function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f2, args);
        return new Ctor();
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react$1 = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$8 = Symbol.for("react.profiler"), t$5 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$4 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$5 = Symbol.iterator;
function A$3(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$5 && a2[z$5] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$2 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$3.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
var H$2 = G$1.prototype = new F$2();
H$2.constructor = G$1;
C$3(H$2, E$3.prototype);
H$2.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$3.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
}
function escape$3(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$4 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$3("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$5:
          case n$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$4, "$&/") + "/"), R$3(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$3(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$4, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$3(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$3(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$3(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$3 };
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$8;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$3.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$5, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$4, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react$1.exports = react_production_min;
}
var reactExports = react$1.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const $2AODx$react = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$5 = reactExports, k$4 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$5 = f$5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$5.call(a2, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$4, type: c2, key: e2, ref: h2, props: d2, _owner: n$5.current };
}
reactJsxRuntime_production_min.Fragment = l$4;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
const _400 = "";
const _300 = "";
const _500 = "";
const _600 = "";
const _700 = "";
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N10 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N10 = false, O2 = null);
      }
    } else
      N10 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N10 || (N10 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$4(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$4(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$4 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$4[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$4[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$4[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$4[b2] = new v$4(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$4.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$4[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$4.hasOwnProperty(b2) ? z$4[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$2 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$4(91));
  return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$4(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$4(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$4(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$4(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$4(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$4(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$4(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$4(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$4(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$4(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$4(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$4(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$4(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$4(190));
  }
  if (3 !== c2.tag)
    throw Error(p$4(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec$1 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$3, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$3, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$3 = null;
function Yc(a2, b2, c2, d2) {
  id$3 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$3 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$4(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$4(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$1);
}
function ag(a2, b2, c2) {
  if (H$1.current !== Vf)
    throw Error(p$4(168));
  G(H$1, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$4(108, Ra(a2) || "Unknown", e2));
  return A$2({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$1.current;
  G(H$1, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$4(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$1), G(H$1, a2)) : E$2(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$4(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$4(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I)
    return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$4(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$4(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$2({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$4(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$2 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$2({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$4(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh$1(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh$1(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$4(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$4(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$4(284));
    if (!c2._owner)
      throw Error(p$4(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$4(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh$1(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh$1(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh$1(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh$1(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$4(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$4(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh$1(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh$1(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$4(174));
  return a2;
}
function Ih(a2, b2) {
  G(Gh, b2);
  G(Fh, a2);
  G(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh$1(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(Fh, a2), G(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O$2 = null, P$3 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$4(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$4(301));
      f2 += 1;
      P$3 = O$2 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$2 && null !== O$2.next;
  Rh = 0;
  P$3 = O$2 = N$1 = null;
  Sh = false;
  if (b2)
    throw Error(p$4(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$3 ? N$1.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  return P$3;
}
function di() {
  if (null === O$2) {
    var a2 = N$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = null === P$3 ? N$1.memoizedState : P$3.next;
  if (null !== b2)
    P$3 = b2, O$2 = a2;
  else {
    if (null === a2)
      throw Error(p$4(310));
    O$2 = a2;
    a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
    null === P$3 ? N$1.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  }
  return P$3;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$1.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$1, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$3 && P$3.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$2)
      throw Error(p$4(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$1, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$1.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$2) {
    var g2 = O$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$1.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$2();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$2(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$1 || null !== b2 && b2 === N$1;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$1, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$1, e2 = ci();
  if (I) {
    if (void 0 === c2)
      throw Error(p$4(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$2)
      throw Error(p$4(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$2.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$2 ? b2.memoizedState = a2 : Di(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$1.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh$1(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G(M$1, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$4(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$4(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$2;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$4(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$4(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh$1(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G(M$1, M$1.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$2({}, e2, { value: void 0 });
        d2 = A$2({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$1);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$4(166));
          S$1(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$1("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$1("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$2({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$4(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E$2(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$4(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$4(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E$2(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S$1(b2), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = M$1.current, G(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$4(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$1), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$4(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$4(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a2, b2, c2), U = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$4(160));
        ak(f2, g2, e2);
        X = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$4(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a2), U = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$4(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$4(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$4(163));
          }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$2 = 0, R$2 = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K$2 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$2 & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$4(185));
  Ac(a2, c2, d2);
  if (0 === (K$2 & 2) || a2 !== R$2)
    a2 === R$2 && (0 === (K$2 & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z)), Ek(a2, d2), 1 === c2 && 0 === K$2 && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$2 ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$2 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$2 & 6))
    throw Error(p$4(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$2 ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$2;
    K$2 |= 2;
    var f2 = Kk();
    if (R$2 !== a2 || Z !== b2)
      vk = null, Hj = B$1() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$2 = e2;
    null !== Y ? b2 = 0 : (R$2 = null, Z = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$4(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$1(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$1() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$4(329));
      }
    }
  }
  Ek(a2, B$1());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$2 & 6))
    throw Error(p$4(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$1()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$1()), c2;
  if (6 === c2)
    throw Error(p$4(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$1());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$2;
  K$2 |= 1;
  try {
    return a2(b2);
  } finally {
    K$2 = c2, 0 === K$2 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$2 & 6) && Ik();
  var b2 = K$2;
  K$2 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$2 = b2, 0 === (K$2 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$1);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$1);
          break;
        case 19:
          E$2(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$2 = a2;
  Y = a2 = wh(a2.current, null);
  Z = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$3 = O$2 = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$4(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$2 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$2, Z);
}
function Jk(a2, b2) {
  var c2 = K$2;
  K$2 |= 2;
  var d2 = Kk();
  if (R$2 !== a2 || Z !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$2 = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$4(261));
  R$2 = null;
  Z = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$2 & 6))
    throw Error(p$4(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$4(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$2 && (Y = R$2 = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$2;
    K$2 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$2 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$1());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$2 & 6))
          throw Error(p$4(331));
        var e2 = K$2;
        K$2 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$2 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$2 === a2 && (Z & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z & 130023424) === Z && 500 > B$1() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$4(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$1.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh$1(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$4(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$4(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$4(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$4(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh$1(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$4(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh$1(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$4(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$4(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$4(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$4(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$2(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$4(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$1()), 0 === (K$2 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$4(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$4(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$4(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$4(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$4(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$4(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$4(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$4(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$4(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$4(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$4(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const $7SXl2$reactdom = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$4 = reactDomExports;
{
  client.createRoot = m$4.createRoot;
  client.hydrateRoot = m$4.hydrateRoot;
}
/**
 * @remix-run/router v1.6.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
function invariant$2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state2, key2) {
  if (state2 === void 0) {
    state2 = null;
  }
  let location = _extends$4({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state: state2,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key2 || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options2;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$4({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state2 = globalHistory.state || {
      idx: null
    };
    return state2.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state2) {
    action = Action.Push;
    let location = createLocation(history.location, to, state2);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state2) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state2);
    if (validateLocation)
      validateLocation(location, to);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base3 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant$2(base3, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base3);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$2(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$2(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end2 = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$4({}, toArg);
    invariant$2(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$2(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$2(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.13.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const START_TRANSITION = "startTransition";
var startTransitionImpl = $2AODx$react[START_TRANSITION];
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$1(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant$2(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$2(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$3({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state2) {
    if (state2.location !== props.location || state2.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state2.error,
      location: state2.location,
      revalidation: props.revalidation || state2.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant$2(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match2.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant$2(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state2 = reactExports.useContext(DataRouterStateContext);
  !state2 ? invariant$2(false) : void 0;
  return state2;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$2(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$2(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state2 = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state2.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$3({
        fromRouteId: id2
      }, options2));
    }
  }, [router, id2]);
  return navigate;
}
function Route(_props) {
  invariant$2(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant$2(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state: state2 = null,
    key: key2 = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state: state2,
        key: key2
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state2, key2, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$2(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$2(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.13.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state2, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state2.location,
    navigationType: state2.action,
    navigator: history
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null);
  this._extensions = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < arguments.length; i2++) {
    this.define(arguments[i2]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t2) {
      return t2.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const ext = extensions[i2];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error(
          'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
        );
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime$1;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
let Mime = Mime_1;
var lite = new Mime(standard);
const mime = /* @__PURE__ */ getDefaultExportFromCjs(lite);
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len = code$3.length; i$3 < len; ++i$3) {
  lookup[i$3] = code$3[i$3];
  revLookup[code$3.charCodeAt(i$3)] = i$3;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base642 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length2);
    }
    var b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(
        value[Symbol.toPrimitive]("string"),
        encodingOrOffset,
        length2
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc2(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer.alloc = function(size2, fill, encoding) {
    return alloc2(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length2 = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length2);
    var actual = buf.write(string2, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length2);
    for (var i2 = 0; i2 < length2; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len2 = checked(obj.length) | 0;
      var buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer.alloc(+length2);
  }
  Buffer.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer.prototype;
  };
  Buffer.compare = function compare2(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer.from(b2, b2.offset, b2.byteLength);
    if (!Buffer.isBuffer(a2) || !Buffer.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat2(list2, length2) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer.alloc(0);
    }
    var i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list2.length; ++i2) {
        length2 += list2[i2].length;
      }
    }
    var buffer2 = Buffer.allocUnsafe(length2);
    var pos = 0;
    for (i2 = 0; i2 < list2.length; ++i2) {
      var buf = list2[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength2;
  function slowToString(encoding, start2, end2) {
    var loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start2 >>>= 0;
    if (end2 <= start2) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end2);
        case "ascii":
          return asciiSlice(this, start2, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end2);
        case "base64":
          return base64Slice(this, start2, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString3() {
    var length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals2(b2) {
    if (!Buffer.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer.compare(this, b2) === 0;
  };
  Buffer.prototype.inspect = function inspect4() {
    var str = "";
    var max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare2(target, start2, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end2) {
      return 1;
    }
    start2 >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end2 - start2;
    var len2 = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start2, end2);
    for (var i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir2) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir2 ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir2)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir2)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir2);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir2) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir2);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir2) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir2) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset2, length2) {
    offset2 = Number(offset2) || 0;
    var remaining = buf.length - offset2;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    var strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    for (var i2 = 0; i2 < length2; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset2 + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset2, length2) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset2), buf, offset2, length2);
  }
  function asciiWrite(buf, string2, offset2, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset2, length2);
  }
  function base64Write(buf, string2, offset2, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset2, length2);
  }
  function ucs2Write(buf, string2, offset2, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length2);
  }
  Buffer.prototype.write = function write2(string2, offset2, length2, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset2 = 0;
    } else if (length2 === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length2 = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset2;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset2, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset2, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset2, length2);
        case "base64":
          return base64Write(this, string2, offset2, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset2, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end2) {
    if (start2 === 0 && end2 === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start2, end2));
    }
  }
  function utf8Slice(buf, start2, end2) {
    end2 = Math.min(buf.length, end2);
    var res = [];
    var i2 = start2;
    while (i2 < end2) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start2, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i2 = start2; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i2 = start2; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end2) {
    var len2 = buf.length;
    if (!start2 || start2 < 0)
      start2 = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    var out = "";
    for (var i2 = start2; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end2) {
    var bytes3 = buf.slice(start2, end2);
    var res = "";
    for (var i2 = 0; i2 < bytes3.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes3[i2] + bytes3[i2 + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice2(start2, end2) {
    var len2 = this.length;
    start2 = ~~start2;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start2 < 0) {
      start2 += len2;
      if (start2 < 0)
        start2 = 0;
    } else if (start2 > len2) {
      start2 = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start2)
      end2 = start2;
    var newBuf = this.subarray(start2, end2);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length2) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    var val = this[offset2];
    var mul3 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset2 + i2] * mul3;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    var val = this[offset2 + --byteLength3];
    var mul3 = 1;
    while (byteLength3 > 0 && (mul3 *= 256)) {
      val += this[offset2 + --byteLength3] * mul3;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    var val = this[offset2];
    var mul3 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      val += this[offset2 + i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    var i2 = byteLength3;
    var mul3 = 1;
    var val = this[offset2 + --i2];
    while (i2 > 0 && (mul3 *= 256)) {
      val += this[offset2 + --i2] * mul3;
    }
    mul3 *= 128;
    if (val >= mul3)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    var val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    var val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    var mul3 = 1;
    var i2 = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      this[offset2 + i2] = value / mul3 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul3 = 1;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      this[offset2 + i2] = value / mul3 & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul3 = 1;
    var sub = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul3 = 1;
    var sub = 0;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul3 *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul3 >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer.prototype.copy = function copy2(target, targetStart, start2, end2) {
    if (!Buffer.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start2)
      start2 = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start2)
      end2 = start2;
    if (end2 === start2)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start2) {
      end2 = target.length - targetStart + start2;
    }
    var len2 = end2 - start2;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start2, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer.prototype.fill = function fill(val, start2, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start2; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes3 = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len2 = bytes3.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start2; ++i2) {
        this[i2 + start2] = bytes3[i2 % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length2 = string2.length;
    var leadSurrogate = null;
    var bytes3 = [];
    for (var i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes3.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes3.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes3.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi2, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset2, length2) {
    for (var i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset2 >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset2] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet2 = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i16 = i2 * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table;
  }();
})(buffer);
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$5() {
}
process.on = noop$5;
process.addListener = noop$5;
process.once = noop$5;
process.off = noop$5;
process.removeListener = noop$5;
process.removeAllListeners = noop$5;
process.emit = noop$5;
process.prependListener = noop$5;
process.prependOnceListener = noop$5;
process.listeners = function(name2) {
  return [];
};
process.binding = function(name2) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir2) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var _globalThis = function(Object2) {
  function get2() {
    var _global3 = this || self;
    delete Object2.prototype.__magic__;
    return _global3;
  }
  if (typeof globalThis === "object") {
    return globalThis;
  }
  if (this) {
    return get2();
  } else {
    Object2.defineProperty(Object2.prototype, "__magic__", {
      configurable: true,
      get: get2
    });
    var _global2 = __magic__;
    return _global2;
  }
}(Object);
var _global$1 = _globalThis;
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView2 = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue2(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name2) {
            this.append(name2, headers[name2]);
          }, this);
        }
      }
      Headers.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue2(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue2(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push(name2);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name2) {
          items.push([name2, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader2) {
        return new Promise(function(resolve, reject) {
          reader2.onload = function() {
            resolve(reader2.result);
          };
          reader2.onerror = function() {
            reject(reader2.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader2 = new FileReader();
        var promise = fileReaderReady(reader2);
        reader2.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader2 = new FileReader();
        var promise = fileReaderReady(reader2);
        reader2.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i2 = 0; i2 < view.length; i2++) {
          chars[i2] = String.fromCharCode(view[i2]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView2(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options2) {
        options2 = options2 || {};
        var body = options2.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options2.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options2.credentials || this.credentials || "same-origin";
        if (options2.headers || !this.headers) {
          this.headers = new Headers(options2.headers);
        }
        this.method = normalizeMethod(options2.method || this.method || "GET");
        this.mode = options2.mode || this.mode || null;
        this.signal = options2.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes3) {
          if (bytes3) {
            var split = bytes3.split("=");
            var name2 = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders2(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
          var parts = line2.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            headers.append(key2, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response2(bodyInit, options2) {
        if (!options2) {
          options2 = {};
        }
        this.type = "default";
        this.status = options2.status === void 0 ? 200 : options2.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options2 ? options2.statusText : "OK";
        this.headers = new Headers(options2.headers);
        this.url = options2.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init3) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init3);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options2 = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders2(xhr.getAllResponseHeaders() || "")
            };
            options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options2));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name2) {
            xhr.setRequestHeader(name2, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response2;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response2;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const fetch$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
var browser = typeof self == "object" ? self.FormData : window.FormData;
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(browser);
async function* batch$1(source, size2 = 1) {
  let things = [];
  if (size2 < 1) {
    size2 = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size2) {
      yield things.slice(0, size2);
      things = things.slice(size2);
    }
  }
  while (things.length) {
    yield things.slice(0, size2);
    things = things.slice(size2);
  }
}
var itBatch = batch$1;
const batch = itBatch;
async function* parallelBatch$1(source, size2 = 1) {
  for await (const tasks of batch(source, size2)) {
    const things = tasks.map(
      /**
       * @param {() => Promise<T>} p
       */
      (p2) => {
        return p2().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
      }
    );
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var itParallelBatch = parallelBatch$1;
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return prototype2 === null || prototype2 === Object.prototype;
};
const isOptionObject = isPlainObj;
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value) => {
  const keys2 = [];
  for (const key2 in value) {
    if (hasOwnProperty$1.call(value, key2)) {
      keys2.push(key2);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol of symbols) {
      if (propertyIsEnumerable.call(value, symbol)) {
        keys2.push(symbol);
      }
    }
  }
  return keys2;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key2) => {
    defineProperty(result, key2, clone(array[key2]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key2) => {
    defineProperty(result, key2, clone(object[key2]));
  });
  return result;
}
const mergeKeys = (merged, source, keys2, config2) => {
  keys2.forEach((key2) => {
    if (typeof source[key2] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key2 in merged && merged[key2] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key2, merge$2(merged[key2], source[key2], config2));
    } else {
      defineProperty(merged, key2, clone(source[key2]));
    }
  });
  return merged;
};
const concatArrays = (merged, source, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array) => {
    const indices = [];
    for (let k2 = 0; k2 < array.length; k2++) {
      if (!hasOwnProperty$1.call(array, k2)) {
        continue;
      }
      indices.push(String(k2));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k2]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k2]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key2) => !indices.includes(key2)), config2);
  });
  return result;
};
function merge$2(merged, source, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config2);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
}
var mergeOptions$1 = function(...options2) {
  const config2 = merge$2(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options2) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge$2(merged, { _: option }, config2);
  }
  return merged._;
};
function assign$1(obj, props) {
  for (const key2 in props) {
    Object.defineProperty(obj, key2, {
      value: props[key2],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign$1(err, props);
  } catch (_) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output = assign$1(new ErrClass(), props);
    return output;
  }
}
var errCode = createError;
var src$d = { exports: {} };
function base$4(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode3,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src$c = base$4;
const textDecoder$1 = new TextDecoder();
const decodeText$1 = (bytes3) => textDecoder$1.decode(bytes3);
const textEncoder$1 = new TextEncoder();
const encodeText$2 = (text) => textEncoder$1.encode(text);
function concat$3(arrs, length2) {
  const output = new Uint8Array(length2);
  let offset2 = 0;
  for (const arr of arrs) {
    output.set(arr, offset2);
    offset2 += arr.length;
  }
  return output;
}
var util$7 = { decodeText: decodeText$1, encodeText: encodeText$2, concat: concat$3 };
const { encodeText: encodeText$1 } = util$7;
let Base$3 = class Base2 {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor(name2, code2, factory2, alphabet2) {
    this.name = name2;
    this.code = code2;
    this.codeBuf = encodeText$1(this.code);
    this.alphabet = alphabet2;
    this.codec = factory2(alphabet2);
  }
  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode(buf) {
    return this.codec.encode(buf);
  }
  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode(string2) {
    for (const char2 of string2) {
      if (this.alphabet && this.alphabet.indexOf(char2) < 0) {
        throw new Error(`invalid character '${char2}' in '${string2}'`);
      }
    }
    return this.codec.decode(string2);
  }
};
var base$3 = Base$3;
const decode$f = (string2, alphabet2, bitsPerChar) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError("Invalid character " + string2[i2]);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$e = (data, alphabet2, bitsPerChar) => {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$2 = (bitsPerChar) => (alphabet2) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode(input) {
      return encode$e(input, alphabet2, bitsPerChar);
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode(input) {
      return decode$f(input, alphabet2, bitsPerChar);
    }
  };
};
var rfc4648_1 = { rfc4648: rfc4648$2 };
const baseX$1 = src$c;
const Base$2 = base$3;
const { rfc4648: rfc4648$1 } = rfc4648_1;
const { decodeText, encodeText } = util$7;
const identity$4 = () => {
  return {
    encode: decodeText,
    decode: encodeText
  };
};
const constants$1 = [
  ["identity", "\0", identity$4, ""],
  ["base2", "0", rfc4648$1(1), "01"],
  ["base8", "7", rfc4648$1(3), "01234567"],
  ["base10", "9", baseX$1, "0123456789"],
  ["base16", "f", rfc4648$1(4), "0123456789abcdef"],
  ["base16upper", "F", rfc4648$1(4), "0123456789ABCDEF"],
  ["base32hex", "v", rfc4648$1(5), "0123456789abcdefghijklmnopqrstuv"],
  ["base32hexupper", "V", rfc4648$1(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
  ["base32hexpad", "t", rfc4648$1(5), "0123456789abcdefghijklmnopqrstuv="],
  ["base32hexpadupper", "T", rfc4648$1(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
  ["base32", "b", rfc4648$1(5), "abcdefghijklmnopqrstuvwxyz234567"],
  ["base32upper", "B", rfc4648$1(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
  ["base32pad", "c", rfc4648$1(5), "abcdefghijklmnopqrstuvwxyz234567="],
  ["base32padupper", "C", rfc4648$1(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
  ["base32z", "h", rfc4648$1(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
  ["base36", "k", baseX$1, "0123456789abcdefghijklmnopqrstuvwxyz"],
  ["base36upper", "K", baseX$1, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
  ["base58btc", "z", baseX$1, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
  ["base58flickr", "Z", baseX$1, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
  ["base64", "m", rfc4648$1(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
  ["base64pad", "M", rfc4648$1(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
  ["base64url", "u", rfc4648$1(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
  ["base64urlpad", "U", rfc4648$1(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
];
const names$3 = constants$1.reduce(
  (prev2, tupple) => {
    prev2[tupple[0]] = new Base$2(tupple[0], tupple[1], tupple[2], tupple[3]);
    return prev2;
  },
  /** @type {Record<BaseName,Base>} */
  {}
);
const codes$1 = constants$1.reduce(
  (prev2, tupple) => {
    prev2[tupple[1]] = names$3[tupple[0]];
    return prev2;
  },
  /** @type {Record<BaseCode,Base>} */
  {}
);
var constants_1 = {
  names: names$3,
  codes: codes$1
};
(function(module, exports) {
  const constants2 = constants_1;
  const { encodeText: encodeText2, decodeText: decodeText2, concat: concat2 } = util$7;
  function multibase2(nameOrCode, buf) {
    if (!buf) {
      throw new Error("requires an encoded Uint8Array");
    }
    const { name: name2, codeBuf } = encoding(nameOrCode);
    validEncode(name2, buf);
    return concat2([codeBuf, buf], codeBuf.length + buf.length);
  }
  function encode3(nameOrCode, buf) {
    const enc = encoding(nameOrCode);
    const data = encodeText2(enc.encode(buf));
    return concat2([enc.codeBuf, data], enc.codeBuf.length + data.length);
  }
  function decode2(data) {
    if (data instanceof Uint8Array) {
      data = decodeText2(data);
    }
    const prefix2 = data[0];
    if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix2)) {
      data = data.toLowerCase();
    }
    const enc = encoding(
      /** @type {BaseCode} */
      data[0]
    );
    return enc.decode(data.substring(1));
  }
  function isEncoded(data) {
    if (data instanceof Uint8Array) {
      data = decodeText2(data);
    }
    if (Object.prototype.toString.call(data) !== "[object String]") {
      return false;
    }
    try {
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.name;
    } catch (err) {
      return false;
    }
  }
  function validEncode(name2, buf) {
    const enc = encoding(name2);
    enc.decode(decodeText2(buf));
  }
  function encoding(nameOrCode) {
    if (Object.prototype.hasOwnProperty.call(
      constants2.names,
      /** @type {BaseName} */
      nameOrCode
    )) {
      return constants2.names[
        /** @type {BaseName} */
        nameOrCode
      ];
    } else if (Object.prototype.hasOwnProperty.call(
      constants2.codes,
      /** @type {BaseCode} */
      nameOrCode
    )) {
      return constants2.codes[
        /** @type {BaseCode} */
        nameOrCode
      ];
    } else {
      throw new Error(`Unsupported encoding: ${nameOrCode}`);
    }
  }
  function encodingFromData(data) {
    if (data instanceof Uint8Array) {
      data = decodeText2(data);
    }
    return encoding(
      /** @type {BaseCode} */
      data[0]
    );
  }
  exports = module.exports = multibase2;
  exports.encode = encode3;
  exports.decode = decode2;
  exports.isEncoded = isEncoded;
  exports.encoding = encoding;
  exports.encodingFromData = encodingFromData;
  const names2 = Object.freeze(constants2.names);
  const codes2 = Object.freeze(constants2.codes);
  exports.names = names2;
  exports.codes = codes2;
})(src$d, src$d.exports);
var srcExports = src$d.exports;
var encode_1$2 = encode$d;
var MSB$3 = 128, REST$3 = 127, MSBALL$1 = ~REST$3, INT$1 = Math.pow(2, 31);
function encode$d(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT$1) {
    out[offset2++] = num & 255 | MSB$3;
    num /= 128;
  }
  while (num & MSBALL$1) {
    out[offset2++] = num & 255 | MSB$3;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode$d.bytes = offset2 - oldOffset + 1;
  return out;
}
var decode$e = read$3;
var MSB$2 = 128, REST$2 = 127;
function read$3(buf, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter2 = offset2, b2, l2 = buf.length;
  do {
    if (counter2 >= l2) {
      read$3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter2++];
    res += shift < 28 ? (b2 & REST$2) << shift : (b2 & REST$2) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$2);
  read$3.bytes = counter2 - offset2;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$3 = function(value) {
  return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
};
var varint$4 = {
  encode: encode_1$2,
  decode: decode$e,
  encodingLength: length$3
};
const names$2 = Object.freeze({
  "identity": 0,
  "sha1": 17,
  "sha2-256": 18,
  "sha2-512": 19,
  "sha3-512": 20,
  "sha3-384": 21,
  "sha3-256": 22,
  "sha3-224": 23,
  "shake-128": 24,
  "shake-256": 25,
  "keccak-224": 26,
  "keccak-256": 27,
  "keccak-384": 28,
  "keccak-512": 29,
  "blake3": 30,
  "murmur3-128": 34,
  "murmur3-32": 35,
  "dbl-sha2-256": 86,
  "md4": 212,
  "md5": 213,
  "bmt": 214,
  "sha2-256-trunc254-padded": 4114,
  "ripemd-128": 4178,
  "ripemd-160": 4179,
  "ripemd-256": 4180,
  "ripemd-320": 4181,
  "x11": 4352,
  "kangarootwelve": 7425,
  "sm3-256": 21325,
  "blake2b-8": 45569,
  "blake2b-16": 45570,
  "blake2b-24": 45571,
  "blake2b-32": 45572,
  "blake2b-40": 45573,
  "blake2b-48": 45574,
  "blake2b-56": 45575,
  "blake2b-64": 45576,
  "blake2b-72": 45577,
  "blake2b-80": 45578,
  "blake2b-88": 45579,
  "blake2b-96": 45580,
  "blake2b-104": 45581,
  "blake2b-112": 45582,
  "blake2b-120": 45583,
  "blake2b-128": 45584,
  "blake2b-136": 45585,
  "blake2b-144": 45586,
  "blake2b-152": 45587,
  "blake2b-160": 45588,
  "blake2b-168": 45589,
  "blake2b-176": 45590,
  "blake2b-184": 45591,
  "blake2b-192": 45592,
  "blake2b-200": 45593,
  "blake2b-208": 45594,
  "blake2b-216": 45595,
  "blake2b-224": 45596,
  "blake2b-232": 45597,
  "blake2b-240": 45598,
  "blake2b-248": 45599,
  "blake2b-256": 45600,
  "blake2b-264": 45601,
  "blake2b-272": 45602,
  "blake2b-280": 45603,
  "blake2b-288": 45604,
  "blake2b-296": 45605,
  "blake2b-304": 45606,
  "blake2b-312": 45607,
  "blake2b-320": 45608,
  "blake2b-328": 45609,
  "blake2b-336": 45610,
  "blake2b-344": 45611,
  "blake2b-352": 45612,
  "blake2b-360": 45613,
  "blake2b-368": 45614,
  "blake2b-376": 45615,
  "blake2b-384": 45616,
  "blake2b-392": 45617,
  "blake2b-400": 45618,
  "blake2b-408": 45619,
  "blake2b-416": 45620,
  "blake2b-424": 45621,
  "blake2b-432": 45622,
  "blake2b-440": 45623,
  "blake2b-448": 45624,
  "blake2b-456": 45625,
  "blake2b-464": 45626,
  "blake2b-472": 45627,
  "blake2b-480": 45628,
  "blake2b-488": 45629,
  "blake2b-496": 45630,
  "blake2b-504": 45631,
  "blake2b-512": 45632,
  "blake2s-8": 45633,
  "blake2s-16": 45634,
  "blake2s-24": 45635,
  "blake2s-32": 45636,
  "blake2s-40": 45637,
  "blake2s-48": 45638,
  "blake2s-56": 45639,
  "blake2s-64": 45640,
  "blake2s-72": 45641,
  "blake2s-80": 45642,
  "blake2s-88": 45643,
  "blake2s-96": 45644,
  "blake2s-104": 45645,
  "blake2s-112": 45646,
  "blake2s-120": 45647,
  "blake2s-128": 45648,
  "blake2s-136": 45649,
  "blake2s-144": 45650,
  "blake2s-152": 45651,
  "blake2s-160": 45652,
  "blake2s-168": 45653,
  "blake2s-176": 45654,
  "blake2s-184": 45655,
  "blake2s-192": 45656,
  "blake2s-200": 45657,
  "blake2s-208": 45658,
  "blake2s-216": 45659,
  "blake2s-224": 45660,
  "blake2s-232": 45661,
  "blake2s-240": 45662,
  "blake2s-248": 45663,
  "blake2s-256": 45664,
  "skein256-8": 45825,
  "skein256-16": 45826,
  "skein256-24": 45827,
  "skein256-32": 45828,
  "skein256-40": 45829,
  "skein256-48": 45830,
  "skein256-56": 45831,
  "skein256-64": 45832,
  "skein256-72": 45833,
  "skein256-80": 45834,
  "skein256-88": 45835,
  "skein256-96": 45836,
  "skein256-104": 45837,
  "skein256-112": 45838,
  "skein256-120": 45839,
  "skein256-128": 45840,
  "skein256-136": 45841,
  "skein256-144": 45842,
  "skein256-152": 45843,
  "skein256-160": 45844,
  "skein256-168": 45845,
  "skein256-176": 45846,
  "skein256-184": 45847,
  "skein256-192": 45848,
  "skein256-200": 45849,
  "skein256-208": 45850,
  "skein256-216": 45851,
  "skein256-224": 45852,
  "skein256-232": 45853,
  "skein256-240": 45854,
  "skein256-248": 45855,
  "skein256-256": 45856,
  "skein512-8": 45857,
  "skein512-16": 45858,
  "skein512-24": 45859,
  "skein512-32": 45860,
  "skein512-40": 45861,
  "skein512-48": 45862,
  "skein512-56": 45863,
  "skein512-64": 45864,
  "skein512-72": 45865,
  "skein512-80": 45866,
  "skein512-88": 45867,
  "skein512-96": 45868,
  "skein512-104": 45869,
  "skein512-112": 45870,
  "skein512-120": 45871,
  "skein512-128": 45872,
  "skein512-136": 45873,
  "skein512-144": 45874,
  "skein512-152": 45875,
  "skein512-160": 45876,
  "skein512-168": 45877,
  "skein512-176": 45878,
  "skein512-184": 45879,
  "skein512-192": 45880,
  "skein512-200": 45881,
  "skein512-208": 45882,
  "skein512-216": 45883,
  "skein512-224": 45884,
  "skein512-232": 45885,
  "skein512-240": 45886,
  "skein512-248": 45887,
  "skein512-256": 45888,
  "skein512-264": 45889,
  "skein512-272": 45890,
  "skein512-280": 45891,
  "skein512-288": 45892,
  "skein512-296": 45893,
  "skein512-304": 45894,
  "skein512-312": 45895,
  "skein512-320": 45896,
  "skein512-328": 45897,
  "skein512-336": 45898,
  "skein512-344": 45899,
  "skein512-352": 45900,
  "skein512-360": 45901,
  "skein512-368": 45902,
  "skein512-376": 45903,
  "skein512-384": 45904,
  "skein512-392": 45905,
  "skein512-400": 45906,
  "skein512-408": 45907,
  "skein512-416": 45908,
  "skein512-424": 45909,
  "skein512-432": 45910,
  "skein512-440": 45911,
  "skein512-448": 45912,
  "skein512-456": 45913,
  "skein512-464": 45914,
  "skein512-472": 45915,
  "skein512-480": 45916,
  "skein512-488": 45917,
  "skein512-496": 45918,
  "skein512-504": 45919,
  "skein512-512": 45920,
  "skein1024-8": 45921,
  "skein1024-16": 45922,
  "skein1024-24": 45923,
  "skein1024-32": 45924,
  "skein1024-40": 45925,
  "skein1024-48": 45926,
  "skein1024-56": 45927,
  "skein1024-64": 45928,
  "skein1024-72": 45929,
  "skein1024-80": 45930,
  "skein1024-88": 45931,
  "skein1024-96": 45932,
  "skein1024-104": 45933,
  "skein1024-112": 45934,
  "skein1024-120": 45935,
  "skein1024-128": 45936,
  "skein1024-136": 45937,
  "skein1024-144": 45938,
  "skein1024-152": 45939,
  "skein1024-160": 45940,
  "skein1024-168": 45941,
  "skein1024-176": 45942,
  "skein1024-184": 45943,
  "skein1024-192": 45944,
  "skein1024-200": 45945,
  "skein1024-208": 45946,
  "skein1024-216": 45947,
  "skein1024-224": 45948,
  "skein1024-232": 45949,
  "skein1024-240": 45950,
  "skein1024-248": 45951,
  "skein1024-256": 45952,
  "skein1024-264": 45953,
  "skein1024-272": 45954,
  "skein1024-280": 45955,
  "skein1024-288": 45956,
  "skein1024-296": 45957,
  "skein1024-304": 45958,
  "skein1024-312": 45959,
  "skein1024-320": 45960,
  "skein1024-328": 45961,
  "skein1024-336": 45962,
  "skein1024-344": 45963,
  "skein1024-352": 45964,
  "skein1024-360": 45965,
  "skein1024-368": 45966,
  "skein1024-376": 45967,
  "skein1024-384": 45968,
  "skein1024-392": 45969,
  "skein1024-400": 45970,
  "skein1024-408": 45971,
  "skein1024-416": 45972,
  "skein1024-424": 45973,
  "skein1024-432": 45974,
  "skein1024-440": 45975,
  "skein1024-448": 45976,
  "skein1024-456": 45977,
  "skein1024-464": 45978,
  "skein1024-472": 45979,
  "skein1024-480": 45980,
  "skein1024-488": 45981,
  "skein1024-496": 45982,
  "skein1024-504": 45983,
  "skein1024-512": 45984,
  "skein1024-520": 45985,
  "skein1024-528": 45986,
  "skein1024-536": 45987,
  "skein1024-544": 45988,
  "skein1024-552": 45989,
  "skein1024-560": 45990,
  "skein1024-568": 45991,
  "skein1024-576": 45992,
  "skein1024-584": 45993,
  "skein1024-592": 45994,
  "skein1024-600": 45995,
  "skein1024-608": 45996,
  "skein1024-616": 45997,
  "skein1024-624": 45998,
  "skein1024-632": 45999,
  "skein1024-640": 46e3,
  "skein1024-648": 46001,
  "skein1024-656": 46002,
  "skein1024-664": 46003,
  "skein1024-672": 46004,
  "skein1024-680": 46005,
  "skein1024-688": 46006,
  "skein1024-696": 46007,
  "skein1024-704": 46008,
  "skein1024-712": 46009,
  "skein1024-720": 46010,
  "skein1024-728": 46011,
  "skein1024-736": 46012,
  "skein1024-744": 46013,
  "skein1024-752": 46014,
  "skein1024-760": 46015,
  "skein1024-768": 46016,
  "skein1024-776": 46017,
  "skein1024-784": 46018,
  "skein1024-792": 46019,
  "skein1024-800": 46020,
  "skein1024-808": 46021,
  "skein1024-816": 46022,
  "skein1024-824": 46023,
  "skein1024-832": 46024,
  "skein1024-840": 46025,
  "skein1024-848": 46026,
  "skein1024-856": 46027,
  "skein1024-864": 46028,
  "skein1024-872": 46029,
  "skein1024-880": 46030,
  "skein1024-888": 46031,
  "skein1024-896": 46032,
  "skein1024-904": 46033,
  "skein1024-912": 46034,
  "skein1024-920": 46035,
  "skein1024-928": 46036,
  "skein1024-936": 46037,
  "skein1024-944": 46038,
  "skein1024-952": 46039,
  "skein1024-960": 46040,
  "skein1024-968": 46041,
  "skein1024-976": 46042,
  "skein1024-984": 46043,
  "skein1024-992": 46044,
  "skein1024-1000": 46045,
  "skein1024-1008": 46046,
  "skein1024-1016": 46047,
  "skein1024-1024": 46048,
  "poseidon-bls12_381-a2-fc1": 46081,
  "poseidon-bls12_381-a2-fc1-sc": 46082
});
var constants = { names: names$2 };
function base$2(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src$b = base$2;
var _brrp__multiformats_scope_baseX = src$b;
const empty = new Uint8Array(0);
const toHex$3 = (d2) => d2.reduce((hex2, byte) => hex2 + byte.toString(16).padStart(2, "0"), "");
const fromHex = (hex2) => {
  const hexes = hex2.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b2) => parseInt(b2, 16))) : empty;
};
const equals$4 = (aa2, bb2) => {
  if (aa2 === bb2)
    return true;
  if (aa2.byteLength !== bb2.byteLength) {
    return false;
  }
  for (let ii2 = 0; ii2 < aa2.byteLength; ii2++) {
    if (aa2[ii2] !== bb2[ii2]) {
      return false;
    }
  }
  return true;
};
const coerce$1 = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const isBinary = (o2) => o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
const fromString$2 = (str) => new TextEncoder().encode(str);
const toString$3 = (b2) => new TextDecoder().decode(b2);
const bytes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  coerce: coerce$1,
  empty,
  equals: equals$4,
  fromHex,
  fromString: fromString$2,
  isBinary,
  toHex: toHex$3,
  toString: toString$3
}, Symbol.toStringTag, { value: "Module" }));
class Encoder {
  constructor(name2, prefix2, baseEncode) {
    this.name = name2;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
let Decoder$1 = class Decoder2 {
  constructor(name2, prefix2, baseDecode) {
    this.name = name2;
    this.prefix = prefix2;
    if (prefix2.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix2.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder2) {
    return or(this, decoder2);
  }
};
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder2) {
    return or(this, decoder2);
  }
  decode(input) {
    const prefix2 = input[0];
    const decoder2 = this.decoders[prefix2];
    if (decoder2) {
      return decoder2.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left2, right2) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right2.decoders || { [right2.prefix]: right2 }
});
class Codec {
  constructor(name2, prefix2, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix2, baseEncode);
    this.decoder = new Decoder$1(name2, prefix2, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$2 = ({ name: name2, prefix: prefix2, encode: encode3, decode: decode2 }) => new Codec(name2, prefix2, encode3, decode2);
const baseX = ({ prefix: prefix2, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode3, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$2({
    prefix: prefix2,
    name: name2,
    encode: encode3,
    decode: (text) => coerce$1(decode2(text))
  });
};
const decode$d = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$c = (data, alphabet2, bitsPerChar) => {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => {
  return from$2({
    prefix: prefix2,
    name: name2,
    encode(input) {
      return encode$c(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$d(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity$3 = from$2({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$3(buf),
  decode: (str) => fromString$2(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$3
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64$1 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$1,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  p2[c2.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$b(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$c(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char2}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$2({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode$b,
  decode: decode$c
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$1 = encode$a;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode$a(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT) {
    out[offset2++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset2++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode$a.bytes = offset2 - oldOffset + 1;
  return out;
}
var decode$b = read$2;
var MSB$1 = 128, REST$1 = 127;
function read$2(buf, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter2 = offset2, b2, l2 = buf.length;
  do {
    if (counter2 >= l2) {
      read$2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter2++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read$2.bytes = counter2 - offset2;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length$2 = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint$3 = {
  encode: encode_1$1,
  decode: decode$b,
  encodingLength: length$2
};
var _brrp_varint = varint$3;
const decode$a = (data, offset2 = 0) => {
  const code2 = _brrp_varint.decode(data, offset2);
  return [
    code2,
    _brrp_varint.decode.bytes
  ];
};
const encodeTo = (int2, target, offset2 = 0) => {
  _brrp_varint.encode(int2, target, offset2);
  return target;
};
const encodingLength = (int2) => {
  return _brrp_varint.encodingLength(int2);
};
const varint$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$a,
  encodeTo,
  encodingLength
}, Symbol.toStringTag, { value: "Module" }));
const create$1 = (code2, digest10) => {
  const size2 = digest10.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes3 = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes3, 0);
  encodeTo(size2, bytes3, sizeOffset);
  bytes3.set(digest10, digestOffset);
  return new Digest(code2, size2, digest10, bytes3);
};
const decode$9 = (multihash2) => {
  const bytes3 = coerce$1(multihash2);
  const [code2, sizeOffset] = decode$a(bytes3);
  const [size2, digestOffset] = decode$a(bytes3.subarray(sizeOffset));
  const digest10 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest10.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size2, digest10, bytes3);
};
const equals$3 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$4(a2.bytes, b2.bytes);
  }
};
class Digest {
  constructor(code2, size2, digest10, bytes3) {
    this.code = code2;
    this.size = size2;
    this.digest = digest10;
    this.bytes = bytes3;
  }
}
const digest$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Digest,
  create: create$1,
  decode: decode$9,
  equals: equals$3
}, Symbol.toStringTag, { value: "Module" }));
const from$1 = ({ name: name2, code: code2, encode: encode3 }) => new Hasher(name2, code2, encode3);
class Hasher {
  constructor(name2, code2, encode3) {
    this.name = name2;
    this.code = code2;
    this.encode = encode3;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$1(this.code, result) : result.then((digest10) => create$1(this.code, digest10));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const hasher = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Hasher,
  from: from$1
}, Symbol.toStringTag, { value: "Module" }));
const sha$2 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$3 = from$1({
  name: "sha2-256",
  code: 18,
  encode: sha$2("SHA-256")
});
const sha512$2 = from$1({
  name: "sha2-512",
  code: 19,
  encode: sha$2("SHA-512")
});
const sha2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$3,
  sha512: sha512$2
}, Symbol.toStringTag, { value: "Module" }));
const code$2 = 0;
const name$2 = "identity";
const encode$9 = coerce$1;
const digest$1 = (input) => create$1(code$2, encode$9(input));
const identity$1 = {
  code: code$2,
  name: name$2,
  encode: encode$9,
  digest: digest$1
};
const identity$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" }));
const name$1 = "raw";
const code$1 = 85;
const encode$8 = (node2) => coerce$1(node2);
const decode$8 = (data) => coerce$1(data);
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$1,
  decode: decode$8,
  encode: encode$8,
  name: name$1
}, Symbol.toStringTag, { value: "Module" }));
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = "json";
const code = 512;
const encode$7 = (node2) => textEncoder.encode(JSON.stringify(node2));
const decode$7 = (data) => JSON.parse(textDecoder.decode(data));
const json = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code,
  decode: decode$7,
  encode: encode$7,
  name
}, Symbol.toStringTag, { value: "Module" }));
class CID {
  constructor(version2, code2, multihash2, bytes3) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash2;
    this.bytes = bytes3;
    this.byteOffset = bytes3.byteOffset;
    this.byteLength = bytes3.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash: multihash2 } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash2.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash2);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest10 } = this.multihash;
        const multihash2 = create$1(code2, digest10);
        return CID.createV1(this.code, multihash2);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$3(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes3, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes3, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes3, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash: multihash2, bytes: bytes3 } = value;
      return new CID(version2, code2, multihash2, bytes3 || encodeCID(version2, code2, multihash2.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash: multihash2, code: code2 } = value;
      const digest10 = decode$9(multihash2);
      return CID.create(version2, code2, digest10);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest10) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code2, digest10, digest10.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID(version2, code2, digest10.bytes);
        return new CID(version2, code2, digest10, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest10) {
    return CID.create(0, DAG_PB_CODE, digest10);
  }
  static createV1(code2, digest10) {
    return CID.create(1, code2, digest10);
  }
  static decode(bytes3) {
    const [cid, remainder] = CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes3) {
    const specs = CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$1(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest10 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest10) : CID.createV1(specs.codec, digest10);
    return [
      cid,
      bytes3.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset2 = 0;
    const next2 = () => {
      const [i2, length2] = decode$a(initialBytes.subarray(offset2));
      offset2 += length2;
      return i2;
    };
    let version2 = next2();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset2 = 0;
    } else if (version2 === 1) {
      codec = next2();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset2;
    const multihashCode = next2();
    const digestSize = next2();
    const size2 = offset2 + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base3) {
    const [prefix2, bytes3] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes3);
    cid._baseCache.set(prefix2, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder2 = base3 || base32;
      return [
        base32.prefix,
        decoder2.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes3, cache, base3) => {
  const { prefix: prefix2 } = base3;
  if (prefix2 !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix2);
  if (cid == null) {
    const cid2 = base3.encode(bytes3).slice(1);
    cache.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes3, cache, base3) => {
  const { prefix: prefix2 } = base3;
  const cid = cache.get(prefix2);
  if (cid == null) {
    const cid2 = base3.encode(bytes3);
    cache.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version2, code2, multihash2) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes3 = new Uint8Array(hashOffset + multihash2.byteLength);
  encodeTo(version2, bytes3, 0);
  encodeTo(code2, bytes3, codeOffset);
  bytes3.set(multihash2, hashOffset);
  return bytes3;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$p = "0.0.0-dev";
const deprecate = (range, message) => {
  if (range.test(version$p)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$2,
  ...base256emoji$1
};
const hashes = {
  ...sha2,
  ...identity$2
};
const codecs = {
  raw,
  json
};
const basics = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID,
  bases,
  bytes,
  codecs,
  digest: digest$2,
  hasher,
  hashes,
  varint: varint$2
}, Symbol.toStringTag, { value: "Module" }));
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function createCodec(name2, prefix2, encode3, decode2) {
  return {
    name: name2,
    prefix: prefix2,
    encoder: {
      name: name2,
      prefix: prefix2,
      encode: encode3
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder2 = new TextDecoder("utf8");
  return "u" + decoder2.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string2 += String.fromCharCode(buf[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString$1(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
const toString$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toString: toString$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(toString$2);
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const fromString$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromString
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(fromString$1);
function concat$1(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset2 = 0;
  for (const arr of arrays) {
    output.set(arr, offset2);
    offset2 += arr.length;
  }
  return asUint8Array(output);
}
const concat$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: concat$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(concat$2);
const multibase = srcExports;
const varint$1 = varint$4;
const { names: names$1 } = constants;
const { toString: uint8ArrayToString } = require$$5$1;
const { fromString: uint8ArrayFromString$1 } = require$$1$3;
const { concat: uint8ArrayConcat } = require$$1$2;
const codes = (
  /** @type {import('./types').CodeNameMap} */
  {}
);
for (const key2 in names$1) {
  const name2 = (
    /** @type {HashName} */
    key2
  );
  codes[names$1[name2]] = name2;
}
Object.freeze(codes);
function toHexString(hash2) {
  if (!(hash2 instanceof Uint8Array)) {
    throw new Error("must be passed a Uint8Array");
  }
  return uint8ArrayToString(hash2, "base16");
}
function fromHexString(hash2) {
  return uint8ArrayFromString$1(hash2, "base16");
}
function toB58String(hash2) {
  if (!(hash2 instanceof Uint8Array)) {
    throw new Error("must be passed a Uint8Array");
  }
  return uint8ArrayToString(multibase.encode("base58btc", hash2)).slice(1);
}
function fromB58String(hash2) {
  const encoded = hash2 instanceof Uint8Array ? uint8ArrayToString(hash2) : hash2;
  return multibase.decode("z" + encoded);
}
function decode$6(bytes3) {
  if (!(bytes3 instanceof Uint8Array)) {
    throw new Error("multihash must be a Uint8Array");
  }
  if (bytes3.length < 2) {
    throw new Error("multihash too short. must be > 2 bytes.");
  }
  const code2 = (
    /** @type {HashCode} */
    varint$1.decode(bytes3)
  );
  if (!isValidCode(code2)) {
    throw new Error(`multihash unknown function code: 0x${code2.toString(16)}`);
  }
  bytes3 = bytes3.slice(varint$1.decode.bytes);
  const len2 = varint$1.decode(bytes3);
  if (len2 < 0) {
    throw new Error(`multihash invalid length: ${len2}`);
  }
  bytes3 = bytes3.slice(varint$1.decode.bytes);
  if (bytes3.length !== len2) {
    throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes3, "base16")}`);
  }
  return {
    code: code2,
    name: codes[code2],
    length: len2,
    digest: bytes3
  };
}
function encode$6(digest10, code2, length2) {
  if (!digest10 || code2 === void 0) {
    throw new Error("multihash encode requires at least two args: digest, code");
  }
  const hashfn = coerceCode(code2);
  if (!(digest10 instanceof Uint8Array)) {
    throw new Error("digest should be a Uint8Array");
  }
  if (length2 == null) {
    length2 = digest10.length;
  }
  if (length2 && digest10.length !== length2) {
    throw new Error("digest length should be equal to specified length.");
  }
  const hash2 = varint$1.encode(hashfn);
  const len2 = varint$1.encode(length2);
  return uint8ArrayConcat([hash2, len2, digest10], hash2.length + len2.length + digest10.length);
}
function coerceCode(name2) {
  let code2 = name2;
  if (typeof name2 === "string") {
    if (names$1[name2] === void 0) {
      throw new Error(`Unrecognized hash function named: ${name2}`);
    }
    code2 = names$1[name2];
  }
  if (typeof code2 !== "number") {
    throw new Error(`Hash function code should be a number. Got: ${code2}`);
  }
  if (codes[code2] === void 0 && !isAppCode(code2)) {
    throw new Error(`Unrecognized function code: ${code2}`);
  }
  return code2;
}
function isAppCode(code2) {
  return code2 > 0 && code2 < 16;
}
function isValidCode(code2) {
  if (isAppCode(code2)) {
    return true;
  }
  if (codes[code2]) {
    return true;
  }
  return false;
}
function validate(multihash2) {
  decode$6(multihash2);
}
function prefix$2(multihash2) {
  validate(multihash2);
  return multihash2.subarray(0, 2);
}
var src$a = {
  names: names$1,
  codes,
  toHexString,
  fromHexString,
  toB58String,
  fromB58String,
  decode: decode$6,
  encode: encode$6,
  coerceCode,
  isAppCode,
  validate,
  prefix: prefix$2,
  isValidCode
};
var sha3$3 = { exports: {} };
(function(module) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process$1 === "object" && process$1.versions && process$1.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding2) {
      for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
        var type = OUTPUT_TYPES[i3];
        method[type] = createMethod2(bits2, padding2, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding2) {
      var method = createOutputMethod(bits2, padding2, "hex");
      method.create = function() {
        return new Keccak(bits2, padding2, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method = createShakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding2, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding2, "hex");
      method.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method.update = function(message, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding2, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method.update = function(key2, message, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm = algorithms[i2];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i3 = 0; i3 < 50; ++i3) {
        this.s[i3] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i3, code2;
      while (index2 < length2) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        if (notString) {
          for (i3 = this.start; index2 < length2 && i3 < byteCount; ++index2) {
            blocks[i3 >> 2] |= message[index2] << SHIFT[i3++ & 3];
          }
        } else {
          for (i3 = this.start; index2 < length2 && i3 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks[i3 >> 2] |= code2 << SHIFT[i3++ & 3];
            } else if (code2 < 2048) {
              blocks[i3 >> 2] |= (192 | code2 >> 6) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i3 >> 2] |= (224 | code2 >> 12) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks[i3 >> 2] |= (240 | code2 >> 18) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i3++ & 3];
              blocks[i3 >> 2] |= (128 | code2 & 63) << SHIFT[i3++ & 3];
            }
          }
        }
        this.lastByteIndex = i3;
        if (i3 >= byteCount) {
          this.start = i3 - byteCount;
          this.block = blocks[blockCount];
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i3;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x2, right2) {
      var o2 = x2 & 255, n2 = 1;
      var bytes3 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes3.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n2;
      }
      if (right2) {
        bytes3.push(n2);
      } else {
        bytes3.unshift(n2);
      }
      this.update(bytes3);
      return bytes3.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes3 = 0, length2 = str.length;
      if (notString) {
        bytes3 = length2;
      } else {
        for (var i3 = 0; i3 < str.length; ++i3) {
          var code2 = str.charCodeAt(i3);
          if (code2 < 128) {
            bytes3 += 1;
          } else if (code2 < 2048) {
            bytes3 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes3 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i3) & 1023);
            bytes3 += 4;
          }
        }
      }
      bytes3 += this.encode(bytes3 * 8);
      this.update(str);
      return bytes3;
    };
    Keccak.prototype.bytepad = function(strs, w2) {
      var bytes3 = this.encode(w2);
      for (var i3 = 0; i3 < strs.length; ++i3) {
        bytes3 += this.encodeString(strs[i3]);
      }
      var paddingBytes = w2 - bytes3 % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i3 >> 2] |= this.padding[i3 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i3 = 1; i3 < blockCount + 1; ++i3) {
          blocks[i3] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i3 = 0; i3 < blockCount; ++i3) {
        s2[i3] ^= blocks[i3];
      }
      f2(s2);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
      var hex2 = "", block;
      while (j2 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
          block = s2[i3];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
          i3 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i3];
        hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex2;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
      var bytes3 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes3);
      }
      var array = new Uint32Array(buffer2);
      while (j2 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
          array[j2] = s2[i3];
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array[i3] = s2[i3];
        buffer2 = buffer2.slice(0, bytes3);
      }
      return buffer2;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j2 = 0;
      var array = [], offset2, block;
      while (j2 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j2 < outputBlocks; ++i3, ++j2) {
          offset2 = j2 << 2;
          block = s2[i3];
          array[offset2] = block & 255;
          array[offset2 + 1] = block >> 8 & 255;
          array[offset2 + 2] = block >> 16 & 255;
          array[offset2 + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset2 = j2 << 2;
        block = s2[i3];
        array[offset2] = block & 255;
        if (extraBytes > 1) {
          array[offset2 + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset2 + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c12, c2, c3, c4, c52, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c12 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c52 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c52 >>> 31);
        l2 = c12 ^ (c52 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c52 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c12 >>> 31);
        l2 = c7 ^ (c12 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3$3);
var sha3Exports = sha3$3.exports;
const sha3$2 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports);
var murmurHash3js = { exports: {} };
(function(module, exports) {
  (function(root, undefined$1) {
    var library = {
      "version": "3.0.0",
      "x86": {},
      "x64": {},
      "inputValidation": true
    };
    function _validBytes(bytes3) {
      if (!Array.isArray(bytes3) && !ArrayBuffer.isView(bytes3)) {
        return false;
      }
      for (var i2 = 0; i2 < bytes3.length; i2++) {
        if (!Number.isInteger(bytes3[i2]) || bytes3[i2] < 0 || bytes3[i2] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m2, n2) {
      return (m2 & 65535) * n2 + (((m2 >>> 16) * n2 & 65535) << 16);
    }
    function _x86Rotl(m2, n2) {
      return m2 << n2 | m2 >>> 32 - n2;
    }
    function _x86Fmix(h2) {
      h2 ^= h2 >>> 16;
      h2 = _x86Multiply(h2, 2246822507);
      h2 ^= h2 >>> 13;
      h2 = _x86Multiply(h2, 3266489909);
      h2 ^= h2 >>> 16;
      return h2;
    }
    function _x64Add(m2, n2) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
      var o2 = [0, 0, 0, 0];
      o2[3] += m2[3] + n2[3];
      o2[2] += o2[3] >>> 16;
      o2[3] &= 65535;
      o2[2] += m2[2] + n2[2];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[1] += m2[1] + n2[1];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[0] += m2[0] + n2[0];
      o2[0] &= 65535;
      return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
    }
    function _x64Multiply(m2, n2) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
      var o2 = [0, 0, 0, 0];
      o2[3] += m2[3] * n2[3];
      o2[2] += o2[3] >>> 16;
      o2[3] &= 65535;
      o2[2] += m2[2] * n2[3];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[2] += m2[3] * n2[2];
      o2[1] += o2[2] >>> 16;
      o2[2] &= 65535;
      o2[1] += m2[1] * n2[3];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[1] += m2[2] * n2[2];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[1] += m2[3] * n2[1];
      o2[0] += o2[1] >>> 16;
      o2[1] &= 65535;
      o2[0] += m2[0] * n2[3] + m2[1] * n2[2] + m2[2] * n2[1] + m2[3] * n2[0];
      o2[0] &= 65535;
      return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
    }
    function _x64Rotl(m2, n2) {
      n2 %= 64;
      if (n2 === 32) {
        return [m2[1], m2[0]];
      } else if (n2 < 32) {
        return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2 | m2[0] >>> 32 - n2];
      } else {
        n2 -= 32;
        return [m2[1] << n2 | m2[0] >>> 32 - n2, m2[0] << n2 | m2[1] >>> 32 - n2];
      }
    }
    function _x64LeftShift(m2, n2) {
      n2 %= 64;
      if (n2 === 0) {
        return m2;
      } else if (n2 < 32) {
        return [m2[0] << n2 | m2[1] >>> 32 - n2, m2[1] << n2];
      } else {
        return [m2[1] << n2 - 32, 0];
      }
    }
    function _x64Xor(m2, n2) {
      return [m2[0] ^ n2[0], m2[1] ^ n2[1]];
    }
    function _x64Fmix(h2) {
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [4283543511, 3981806797]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [3301882366, 444984403]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      return h2;
    }
    library.x86.hash32 = function(bytes3, seed) {
      if (library.inputValidation && !_validBytes(bytes3)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes3.length % 4;
      var blocks = bytes3.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c12 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
        k1 = bytes3[i2] | bytes3[i2 + 1] << 8 | bytes3[i2 + 2] << 16 | bytes3[i2 + 3] << 24;
        k1 = _x86Multiply(k1, c12);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes3[i2 + 2] << 16;
        case 2:
          k1 ^= bytes3[i2 + 1] << 8;
        case 1:
          k1 ^= bytes3[i2];
          k1 = _x86Multiply(k1, c12);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes3.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes3, seed) {
      if (library.inputValidation && !_validBytes(bytes3)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes3.length % 16;
      var blocks = bytes3.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c12 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = bytes3[i2] | bytes3[i2 + 1] << 8 | bytes3[i2 + 2] << 16 | bytes3[i2 + 3] << 24;
        k2 = bytes3[i2 + 4] | bytes3[i2 + 5] << 8 | bytes3[i2 + 6] << 16 | bytes3[i2 + 7] << 24;
        k3 = bytes3[i2 + 8] | bytes3[i2 + 9] << 8 | bytes3[i2 + 10] << 16 | bytes3[i2 + 11] << 24;
        k4 = bytes3[i2 + 12] | bytes3[i2 + 13] << 8 | bytes3[i2 + 14] << 16 | bytes3[i2 + 15] << 24;
        k1 = _x86Multiply(k1, c12);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c12);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes3[i2 + 14] << 16;
        case 14:
          k4 ^= bytes3[i2 + 13] << 8;
        case 13:
          k4 ^= bytes3[i2 + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c12);
          h4 ^= k4;
        case 12:
          k3 ^= bytes3[i2 + 11] << 24;
        case 11:
          k3 ^= bytes3[i2 + 10] << 16;
        case 10:
          k3 ^= bytes3[i2 + 9] << 8;
        case 9:
          k3 ^= bytes3[i2 + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= bytes3[i2 + 7] << 24;
        case 7:
          k2 ^= bytes3[i2 + 6] << 16;
        case 6:
          k2 ^= bytes3[i2 + 5] << 8;
        case 5:
          k2 ^= bytes3[i2 + 4];
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= bytes3[i2 + 3] << 24;
        case 3:
          k1 ^= bytes3[i2 + 2] << 16;
        case 2:
          k1 ^= bytes3[i2 + 1] << 8;
        case 1:
          k1 ^= bytes3[i2];
          k1 = _x86Multiply(k1, c12);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes3.length;
      h2 ^= bytes3.length;
      h3 ^= bytes3.length;
      h4 ^= bytes3.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes3, seed) {
      if (library.inputValidation && !_validBytes(bytes3)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes3.length % 16;
      var blocks = bytes3.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c12 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
        k1 = [bytes3[i2 + 4] | bytes3[i2 + 5] << 8 | bytes3[i2 + 6] << 16 | bytes3[i2 + 7] << 24, bytes3[i2] | bytes3[i2 + 1] << 8 | bytes3[i2 + 2] << 16 | bytes3[i2 + 3] << 24];
        k2 = [bytes3[i2 + 12] | bytes3[i2 + 13] << 8 | bytes3[i2 + 14] << 16 | bytes3[i2 + 15] << 24, bytes3[i2 + 8] | bytes3[i2 + 9] << 8 | bytes3[i2 + 10] << 16 | bytes3[i2 + 11] << 24];
        k1 = _x64Multiply(k1, c12);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c12);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 14]], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 13]], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 12]], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 11]], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 10]], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i2 + 9]], 8));
        case 9:
          k2 = _x64Xor(k2, [0, bytes3[i2 + 8]]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c12);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i2 + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes3[i2]]);
          k1 = _x64Multiply(k1, c12);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes3.length]);
      h2 = _x64Xor(h2, [0, bytes3.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module.exports) {
        exports = module.exports = library;
      }
      exports.murmurHash3 = library;
    }
  })();
})(murmurHash3js, murmurHash3js.exports);
var murmurHash3jsExports = murmurHash3js.exports;
var murmurhash3jsRevisited = murmurHash3jsExports;
const multihash$1 = src$a;
const crypto$4 = self.crypto || /** @type {typeof window.crypto} */
// @ts-ignore - unknown property
self.msCrypto;
const digest = async (data, alg) => {
  if (typeof self === "undefined" || !crypto$4) {
    throw new Error(
      "Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context"
    );
  }
  switch (alg) {
    case "sha1":
      return new Uint8Array(await crypto$4.subtle.digest({ name: "SHA-1" }, data));
    case "sha2-256":
      return new Uint8Array(await crypto$4.subtle.digest({ name: "SHA-256" }, data));
    case "sha2-512":
      return new Uint8Array(await crypto$4.subtle.digest({ name: "SHA-512" }, data));
    case "dbl-sha2-256": {
      const d2 = await crypto$4.subtle.digest({ name: "SHA-256" }, data);
      return new Uint8Array(await crypto$4.subtle.digest({ name: "SHA-256" }, d2));
    }
    default:
      throw new Error(`${alg} is not a supported algorithm`);
  }
};
var sha_browser = {
  /**
   * @param {HashName} alg
   * @returns {Digest}
   */
  factory: (alg) => async (data) => {
    return digest(data, alg);
  },
  digest,
  /**
   * @param {Uint8Array} buf
   * @param {HashName} alg
   * @param {number} [length]
   */
  multihashing: async (buf, alg, length2) => {
    const h2 = await digest(buf, alg);
    return multihash$1.encode(h2, alg, length2);
  }
};
const fromNumberTo32BitBuf$1 = (number2) => {
  const bytes3 = new Uint8Array(4);
  for (let i2 = 0; i2 < 4; i2++) {
    bytes3[i2] = number2 & 255;
    number2 = number2 >> 8;
  }
  return bytes3;
};
var utils$c = {
  fromNumberTo32BitBuf: fromNumberTo32BitBuf$1
};
var util$6;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3)
    return util$6;
  hasRequiredUtil$3 = 1;
  const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (typeof input === "string") {
      const encoder = new TextEncoder();
      ret = encoder.encode(input);
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex2(bytes3) {
    return Array.prototype.map.call(bytes3, function(n2) {
      return (n2 < 16 ? "0" : "") + n2.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size2) {
    let msg = "\n" + label + " = ";
    for (let i2 = 0; i2 < arr.length; i2 += 2) {
      if (size2 === 32) {
        msg += uint32ToHex(arr[i2]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
      } else if (size2 === 64) {
        msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        msg += uint32ToHex(arr[i2]).toUpperCase();
      } else
        throw new Error("Invalid size " + size2);
      if (i2 % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i2 < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N10, M2) {
    let startMs = (/* @__PURE__ */ new Date()).getTime();
    const input = new Uint8Array(N10);
    for (let i2 = 0; i2 < N10; i2++) {
      input[i2] = i2 % 256;
    }
    const genMs = (/* @__PURE__ */ new Date()).getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (let i2 = 0; i2 < M2; i2++) {
      const hashHex = hashFn(input);
      const hashMs = (/* @__PURE__ */ new Date()).getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(
        Math.round(N10 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
      );
    }
  }
  util$6 = {
    normalizeInput,
    toHex: toHex2,
    debugPrint,
    testSpeed
  };
  return util$6;
}
var blake2b_1;
var hasRequiredBlake2b;
function requireBlake2b() {
  if (hasRequiredBlake2b)
    return blake2b_1;
  hasRequiredBlake2b = 1;
  const util2 = requireUtil$3();
  function ADD64AA(v3, a2, b2) {
    const o0 = v3[a2] + v3[b2];
    let o1 = v3[a2 + 1] + v3[b2 + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function ADD64AC(v3, a2, b0, b1) {
    let o0 = v3[a2] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    let o1 = v3[a2 + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function B2B_GET32(arr, i2) {
    return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
  }
  function B2B_G(a2, b2, c2, d2, ix, iy) {
    const x0 = m2[ix];
    const x1 = m2[ix + 1];
    const y0 = m2[iy];
    const y1 = m2[iy + 1];
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, x0, x1);
    let xor0 = v2[d2] ^ v2[a2];
    let xor1 = v2[d2 + 1] ^ v2[a2 + 1];
    v2[d2] = xor1;
    v2[d2 + 1] = xor0;
    ADD64AA(v2, c2, d2);
    xor0 = v2[b2] ^ v2[c2];
    xor1 = v2[b2 + 1] ^ v2[c2 + 1];
    v2[b2] = xor0 >>> 24 ^ xor1 << 8;
    v2[b2 + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, y0, y1);
    xor0 = v2[d2] ^ v2[a2];
    xor1 = v2[d2 + 1] ^ v2[a2 + 1];
    v2[d2] = xor0 >>> 16 ^ xor1 << 16;
    v2[d2 + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v2, c2, d2);
    xor0 = v2[b2] ^ v2[c2];
    xor1 = v2[b2 + 1] ^ v2[c2 + 1];
    v2[b2] = xor1 >>> 31 ^ xor0 << 1;
    v2[b2 + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  const BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function(x2) {
      return x2 * 2;
    })
  );
  const v2 = new Uint32Array(32);
  const m2 = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    let i2 = 0;
    for (i2 = 0; i2 < 16; i2++) {
      v2[i2] = ctx.h[i2];
      v2[i2 + 16] = BLAKE2B_IV32[i2];
    }
    v2[24] = v2[24] ^ ctx.t;
    v2[25] = v2[25] ^ ctx.t / 4294967296;
    if (last) {
      v2[28] = ~v2[28];
      v2[29] = ~v2[29];
    }
    for (i2 = 0; i2 < 32; i2++) {
      m2[i2] = B2B_GET32(ctx.b, 4 * i2);
    }
    for (i2 = 0; i2 < 12; i2++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
    }
    for (i2 = 0; i2 < 16; i2++) {
      ctx.h[i2] = ctx.h[i2] ^ v2[i2] ^ v2[i2 + 16];
    }
  }
  const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
    // 60: personal
  ]);
  function blake2bInit(outlen, key2, salt, personal) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key2 && key2.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    if (salt && salt.length !== 16) {
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    }
    if (personal && personal.length !== 16) {
      throw new Error("Illegal personal, expected Uint8Array with length is 16");
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      // input count
      c: 0,
      // pointer within buffer
      outlen
      // output length in bytes
    };
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key2)
      parameterBlock[1] = key2.length;
    parameterBlock[2] = 1;
    parameterBlock[3] = 1;
    if (salt)
      parameterBlock.set(salt, 32);
    if (personal)
      parameterBlock.set(personal, 48);
    for (let i2 = 0; i2 < 16; i2++) {
      ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
    }
    if (key2) {
      blake2bUpdate(ctx, key2);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (let i2 = 0; i2 < input.length; i2++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i2];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i2 = 0; i2 < ctx.outlen; i2++) {
      out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
    }
    return out;
  }
  function blake2b(input, key2, outlen, salt, personal) {
    outlen = outlen || 64;
    input = util2.normalizeInput(input);
    if (salt) {
      salt = util2.normalizeInput(salt);
    }
    if (personal) {
      personal = util2.normalizeInput(personal);
    }
    const ctx = blake2bInit(outlen, key2, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key2, outlen, salt, personal) {
    const output = blake2b(input, key2, outlen, salt, personal);
    return util2.toHex(output);
  }
  blake2b_1 = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
  return blake2b_1;
}
var blake2s_1;
var hasRequiredBlake2s;
function requireBlake2s() {
  if (hasRequiredBlake2s)
    return blake2s_1;
  hasRequiredBlake2s = 1;
  const util2 = requireUtil$3();
  function B2S_GET32(v3, i2) {
    return v3[i2] ^ v3[i2 + 1] << 8 ^ v3[i2 + 2] << 16 ^ v3[i2 + 3] << 24;
  }
  function B2S_G(a2, b2, c2, d2, x2, y2) {
    v2[a2] = v2[a2] + v2[b2] + x2;
    v2[d2] = ROTR32(v2[d2] ^ v2[a2], 16);
    v2[c2] = v2[c2] + v2[d2];
    v2[b2] = ROTR32(v2[b2] ^ v2[c2], 12);
    v2[a2] = v2[a2] + v2[b2] + y2;
    v2[d2] = ROTR32(v2[d2] ^ v2[a2], 8);
    v2[c2] = v2[c2] + v2[d2];
    v2[b2] = ROTR32(v2[b2] ^ v2[c2], 7);
  }
  function ROTR32(x2, y2) {
    return x2 >>> y2 ^ x2 << 32 - y2;
  }
  const BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v2 = new Uint32Array(16);
  const m2 = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    let i2 = 0;
    for (i2 = 0; i2 < 8; i2++) {
      v2[i2] = ctx.h[i2];
      v2[i2 + 8] = BLAKE2S_IV[i2];
    }
    v2[12] ^= ctx.t;
    v2[13] ^= ctx.t / 4294967296;
    if (last) {
      v2[14] = ~v2[14];
    }
    for (i2 = 0; i2 < 16; i2++) {
      m2[i2] = B2S_GET32(ctx.b, 4 * i2);
    }
    for (i2 = 0; i2 < 10; i2++) {
      B2S_G(0, 4, 8, 12, m2[SIGMA[i2 * 16 + 0]], m2[SIGMA[i2 * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m2[SIGMA[i2 * 16 + 2]], m2[SIGMA[i2 * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m2[SIGMA[i2 * 16 + 4]], m2[SIGMA[i2 * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m2[SIGMA[i2 * 16 + 6]], m2[SIGMA[i2 * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m2[SIGMA[i2 * 16 + 8]], m2[SIGMA[i2 * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m2[SIGMA[i2 * 16 + 10]], m2[SIGMA[i2 * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m2[SIGMA[i2 * 16 + 12]], m2[SIGMA[i2 * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m2[SIGMA[i2 * 16 + 14]], m2[SIGMA[i2 * 16 + 15]]);
    }
    for (i2 = 0; i2 < 8; i2++) {
      ctx.h[i2] ^= v2[i2] ^ v2[i2 + 8];
    }
  }
  function blake2sInit(outlen, key2) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    const keylen = key2 ? key2.length : 0;
    if (key2 && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      // hash state
      b: new Uint8Array(64),
      // input block
      c: 0,
      // pointer within block
      t: 0,
      // input count
      outlen
      // output length in bytes
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key2);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (let i2 = 0; i2 < input.length; i2++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i2];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i2 = 0; i2 < ctx.outlen; i2++) {
      out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key2, outlen) {
    outlen = outlen || 32;
    input = util2.normalizeInput(input);
    const ctx = blake2sInit(outlen, key2);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key2, outlen) {
    const output = blake2s(input, key2, outlen);
    return util2.toHex(output);
  }
  blake2s_1 = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
  return blake2s_1;
}
var blakejs;
var hasRequiredBlakejs;
function requireBlakejs() {
  if (hasRequiredBlakejs)
    return blakejs;
  hasRequiredBlakejs = 1;
  const b2b = requireBlake2b();
  const b2s = requireBlake2s();
  blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  return blakejs;
}
var blake_1;
var hasRequiredBlake;
function requireBlake() {
  if (hasRequiredBlake)
    return blake_1;
  hasRequiredBlake = 1;
  const blake = requireBlakejs();
  const minB = 45569;
  const minS = 45633;
  const blake2b = {
    init: blake.blake2bInit,
    update: blake.blake2bUpdate,
    digest: blake.blake2bFinal
  };
  const blake2s = {
    init: blake.blake2sInit,
    update: blake.blake2sUpdate,
    digest: blake.blake2sFinal
  };
  const makeB2Hash = (size2, hf2) => async (data) => {
    const ctx = hf2.init(size2, null);
    hf2.update(ctx, data);
    return hf2.digest(ctx);
  };
  blake_1 = (table) => {
    for (let i2 = 0; i2 < 64; i2++) {
      table[minB + i2] = makeB2Hash(i2 + 1, blake2b);
    }
    for (let i2 = 0; i2 < 32; i2++) {
      table[minS + i2] = makeB2Hash(i2 + 1, blake2s);
    }
  };
  return blake_1;
}
const sha3$1 = sha3Exports;
const mur = murmurhash3jsRevisited;
const { factory: sha$1 } = sha_browser;
const { fromNumberTo32BitBuf } = utils$c;
const { fromString: uint8ArrayFromString } = require$$1$3;
const hash$6 = (algorithm) => async (data) => {
  switch (algorithm) {
    case "sha3-224":
      return new Uint8Array(sha3$1.sha3_224.arrayBuffer(data));
    case "sha3-256":
      return new Uint8Array(sha3$1.sha3_256.arrayBuffer(data));
    case "sha3-384":
      return new Uint8Array(sha3$1.sha3_384.arrayBuffer(data));
    case "sha3-512":
      return new Uint8Array(sha3$1.sha3_512.arrayBuffer(data));
    case "shake-128":
      return new Uint8Array(sha3$1.shake128.create(128).update(data).arrayBuffer());
    case "shake-256":
      return new Uint8Array(sha3$1.shake256.create(256).update(data).arrayBuffer());
    case "keccak-224":
      return new Uint8Array(sha3$1.keccak224.arrayBuffer(data));
    case "keccak-256":
      return new Uint8Array(sha3$1.keccak256.arrayBuffer(data));
    case "keccak-384":
      return new Uint8Array(sha3$1.keccak384.arrayBuffer(data));
    case "keccak-512":
      return new Uint8Array(sha3$1.keccak512.arrayBuffer(data));
    case "murmur3-128":
      return uint8ArrayFromString(mur.x64.hash128(data), "base16");
    case "murmur3-32":
      return fromNumberTo32BitBuf(mur.x86.hash32(data));
    default:
      throw new TypeError(`${algorithm} is not a supported algorithm`);
  }
};
const identity = (data) => data;
var crypto$3 = {
  identity,
  sha1: sha$1("sha1"),
  sha2256: sha$1("sha2-256"),
  sha2512: sha$1("sha2-512"),
  dblSha2256: sha$1("dbl-sha2-256"),
  sha3224: hash$6("sha3-224"),
  sha3256: hash$6("sha3-256"),
  sha3384: hash$6("sha3-384"),
  sha3512: hash$6("sha3-512"),
  shake128: hash$6("shake-128"),
  shake256: hash$6("shake-256"),
  keccak224: hash$6("keccak-224"),
  keccak256: hash$6("keccak-256"),
  keccak384: hash$6("keccak-384"),
  keccak512: hash$6("keccak-512"),
  murmur3128: hash$6("murmur3-128"),
  murmur332: hash$6("murmur3-32"),
  addBlake: requireBlake()
};
function equals$1(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
const equals$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  equals: equals$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$6$1 = /* @__PURE__ */ getAugmentedNamespace(equals$2);
const errcode = errCode;
const multihash = src$a;
const crypto$2 = crypto$3;
const { equals } = require$$6$1;
async function Multihashing(bytes3, alg, length2) {
  const digest10 = await Multihashing.digest(bytes3, alg, length2);
  return multihash.encode(digest10, alg, length2);
}
Multihashing.multihash = multihash;
Multihashing.digest = async (bytes3, alg, length2) => {
  const hash2 = Multihashing.createHash(alg);
  const digest10 = await hash2(bytes3);
  return length2 ? digest10.slice(0, length2) : digest10;
};
Multihashing.createHash = function(alg) {
  if (!alg) {
    const e2 = errcode(new Error("hash algorithm must be specified"), "ERR_HASH_ALGORITHM_NOT_SPECIFIED");
    throw e2;
  }
  const code2 = multihash.coerceCode(alg);
  if (!Multihashing.functions[code2]) {
    throw errcode(new Error(`multihash function '${alg}' not yet supported`), "ERR_HASH_ALGORITHM_NOT_SUPPORTED");
  }
  return Multihashing.functions[code2];
};
Multihashing.functions = {
  // identity
  0: crypto$2.identity,
  // sha1
  17: crypto$2.sha1,
  // sha2-256
  18: crypto$2.sha2256,
  // sha2-512
  19: crypto$2.sha2512,
  // sha3-512
  20: crypto$2.sha3512,
  // sha3-384
  21: crypto$2.sha3384,
  // sha3-256
  22: crypto$2.sha3256,
  // sha3-224
  23: crypto$2.sha3224,
  // shake-128
  24: crypto$2.shake128,
  // shake-256
  25: crypto$2.shake256,
  // keccak-224
  26: crypto$2.keccak224,
  // keccak-256
  27: crypto$2.keccak256,
  // keccak-384
  28: crypto$2.keccak384,
  // keccak-512
  29: crypto$2.keccak512,
  // murmur3-128
  34: crypto$2.murmur3128,
  // murmur3-32
  35: crypto$2.murmur332,
  // dbl-sha2-256
  86: crypto$2.dblSha2256
};
crypto$2.addBlake(Multihashing.functions);
Multihashing.validate = async (bytes3, hash2) => {
  const newHash = await Multihashing(bytes3, multihash.decode(hash2).name);
  return equals(hash2, newHash);
};
var src$9 = Multihashing;
const mergeOptions = mergeOptions$1.bind({ ignoreUndefined: true });
const multihashing = src$9;
async function hamtHashFn(buf) {
  const hash2 = await multihashing(buf, "murmur3-128");
  const justHash = hash2.slice(2, 10);
  const length2 = justHash.length;
  const result = new Uint8Array(length2);
  for (let i2 = 0; i2 < length2; i2++) {
    result[length2 - i2 - 1] = justHash[i2];
  }
  return result;
}
const defaultOptions$3 = {
  chunker: "fixed",
  strategy: "balanced",
  // 'flat', 'trickle'
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hashAlg: "sha2-256",
  leafType: "file",
  // 'raw'
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  // FIXME: This number is too big for JavaScript
  // https://github.com/ipfs/go-ipfs-chunker/blob/d0125832512163708c0804a3cda060e21acddae4/rabin.go#L11
  polynomial: 17437180132763652,
  // eslint-disable-line no-loss-of-precision
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  pin: false,
  recursive: false,
  hidden: false,
  preload: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options$3 = function(options2 = {}) {
  return mergeOptions(defaultOptions$3, options2);
};
var indexMinimal = {};
var minimal$1 = {};
var aspromise;
var hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise)
    return aspromise;
  hasRequiredAspromise = 1;
  aspromise = asPromise;
  function asPromise(fn2, ctx) {
    var params = new Array(arguments.length - 1), offset2 = 0, index2 = 2, pending = true;
    while (index2 < arguments.length)
      params[offset2++] = arguments[index2++];
    return new Promise(function executor(resolve, reject) {
      params[offset2] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset3 = 0;
            while (offset3 < params2.length)
              params2[offset3++] = arguments[offset3];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn2.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
  return aspromise;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64)
    return base64;
  hasRequiredBase64 = 1;
  (function(exports) {
    var base642 = exports;
    base642.length = function length2(string2) {
      var p2 = string2.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string2.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (var i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    base642.encode = function encode3(buffer2, start2, end2) {
      var parts = null, chunk = [];
      var i3 = 0, j = 0, t2;
      while (start2 < end2) {
        var b2 = buffer2[start2++];
        switch (j) {
          case 0:
            chunk[i3++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b2 >> 6];
            chunk[i3++] = b64[b2 & 63];
            j = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode2(string2, buffer2, offset2) {
      var start2 = offset2;
      var j = 0, t2;
      for (var i3 = 0; i3 < string2.length; ) {
        var c2 = string2.charCodeAt(i3++);
        if (c2 === 61 && j > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c2;
            j = 1;
            break;
          case 1:
            buffer2[offset2++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j = 2;
            break;
          case 2:
            buffer2[offset2++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j = 3;
            break;
          case 3:
            buffer2[offset2++] = (t2 & 3) << 6 | c2;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset2 - start2;
    };
    base642.test = function test2(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  })(base64);
  return base64;
}
var eventemitter;
var hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter)
    return eventemitter;
  hasRequiredEventemitter = 1;
  eventemitter = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn2, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn: fn2,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn2) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn2 === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i2 = 0; i2 < listeners.length; )
          if (listeners[i2].fn === fn2)
            listeners.splice(i2, 1);
          else
            ++i2;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i2 = 1;
      for (; i2 < arguments.length; )
        args.push(arguments[i2++]);
      for (i2 = 0; i2 < listeners.length; )
        listeners[i2].fn.apply(listeners[i2++].ctx, args);
    }
    return this;
  };
  return eventemitter;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat)
    return float;
  hasRequiredFloat = 1;
  float = factory2(factory2);
  function factory2(exports) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
        exports.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign3 = val < 0 ? 1 : 0;
          if (sign3)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign3 << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
        exports.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign3 = val < 0 ? 1 : 0;
          if (sign3)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign3 << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi2 = readUint(buf, pos + off1);
          var sign3 = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
  return float;
}
var inquire_1;
var hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire)
    return inquire_1;
  hasRequiredInquire = 1;
  inquire_1 = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e2) {
    }
    return null;
  }
  return inquire_1;
}
var utf8 = {};
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8)
    return utf8;
  hasRequiredUtf8 = 1;
  (function(exports) {
    var utf82 = exports;
    utf82.length = function utf8_length(string2) {
      var len2 = 0, c2 = 0;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c2 = string2.charCodeAt(i2);
        if (c2 < 128)
          len2 += 1;
        else if (c2 < 2048)
          len2 += 2;
        else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len2 += 4;
        } else
          len2 += 3;
      }
      return len2;
    };
    utf82.read = function utf8_read(buffer2, start2, end2) {
      var len2 = end2 - start2;
      if (len2 < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start2 < end2) {
        t2 = buffer2[start2++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf82.write = function utf8_write(string2, buffer2, offset2) {
      var start2 = offset2, c12, c2;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c12 = string2.charCodeAt(i2);
        if (c12 < 128) {
          buffer2[offset2++] = c12;
        } else if (c12 < 2048) {
          buffer2[offset2++] = c12 >> 6 | 192;
          buffer2[offset2++] = c12 & 63 | 128;
        } else if ((c12 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c12 = 65536 + ((c12 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer2[offset2++] = c12 >> 18 | 240;
          buffer2[offset2++] = c12 >> 12 & 63 | 128;
          buffer2[offset2++] = c12 >> 6 & 63 | 128;
          buffer2[offset2++] = c12 & 63 | 128;
        } else {
          buffer2[offset2++] = c12 >> 12 | 224;
          buffer2[offset2++] = c12 >> 6 & 63 | 128;
          buffer2[offset2++] = c12 & 63 | 128;
        }
      }
      return offset2 - start2;
    };
  })(utf8);
  return utf8;
}
var pool_1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool)
    return pool_1;
  hasRequiredPool = 1;
  pool_1 = pool;
  function pool(alloc2, slice2, size2) {
    var SIZE = size2 || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset2 = SIZE;
    return function pool_alloc(size3) {
      if (size3 < 1 || size3 > MAX)
        return alloc2(size3);
      if (offset2 + size3 > SIZE) {
        slab = alloc2(SIZE);
        offset2 = 0;
      }
      var buf = slice2.call(slab, offset2, offset2 += size3);
      if (offset2 & 7)
        offset2 = (offset2 | 7) + 1;
      return buf;
    };
  }
  return pool_1;
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits;
  var util2 = requireMinimal$1();
  function LongBits(lo, hi2) {
    this.lo = lo >>> 0;
    this.hi = hi2 >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign3 = value < 0;
    if (sign3)
      value = -value;
    var lo = value >>> 0, hi2 = (value - lo) / 4294967296 >>> 0;
    if (sign3) {
      hi2 = ~hi2 >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi2 > 4294967295)
          hi2 = 0;
      }
    }
    return new LongBits(lo, hi2);
  };
  LongBits.from = function from2(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
      if (!lo)
        hi2 = hi2 + 1 >>> 0;
      return -(lo + hi2 * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length2() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal$1;
function requireMinimal$1() {
  if (hasRequiredMinimal$1)
    return minimal$1;
  hasRequiredMinimal$1 = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = requireAspromise();
    util2.base64 = requireBase64();
    util2.EventEmitter = requireEventemitter();
    util2.float = requireFloat();
    util2.inquire = requireInquire();
    util2.utf8 = requireUtf8();
    util2.pool = requirePool();
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
    util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger2(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer = util2.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys2 = Object.keys(src2), i2 = 0; i2 < keys2.length; ++i2)
        if (dst[keys2[i2]] === void 0 || !ifNotSet)
          dst[keys2[i2]] = src2[keys2[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i3 = keys2.length - 1; i3 > -1; --i3)
          if (fieldMap[keys2[i3]] === 1 && this[keys2[i3]] !== void 0 && this[keys2[i3]] !== null)
            return keys2[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer = util2.Buffer;
      if (!Buffer) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size2) {
        return new Buffer(size2);
      };
    };
  })(minimal$1);
  return minimal$1;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter)
    return writer;
  hasRequiredWriter = 1;
  writer = Writer2;
  var util2 = requireMinimal$1();
  var BufferWriter;
  var LongBits = util2.LongBits, base642 = util2.base64, utf82 = util2.utf8;
  function Op(fn2, len2, val) {
    this.fn = fn2;
    this.len = len2;
    this.next = void 0;
    this.val = val;
  }
  function noop2() {
  }
  function State(writer2) {
    this.head = writer2.head;
    this.tail = writer2.tail;
    this.len = writer2.len;
    this.next = writer2.states;
  }
  function Writer2() {
    this.len = 0;
    this.head = new Op(noop2, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create2 = function create3() {
    return util2.Buffer ? function create_buffer_setup() {
      return (Writer2.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer2();
    };
  };
  Writer2.create = create2();
  Writer2.alloc = function alloc2(size2) {
    return new util2.Array(size2);
  };
  if (util2.Array !== Array)
    Writer2.alloc = util2.pool(Writer2.alloc, util2.Array.prototype.subarray);
  Writer2.prototype._push = function push(fn2, len2, val) {
    this.tail = this.tail.next = new Op(fn2, len2, val);
    this.len += len2;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len2, val) {
    this.len = len2;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer2.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
      value
    )).len;
    return this;
  };
  Writer2.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer2.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer2.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer2.prototype.int64 = Writer2.prototype.uint64;
  Writer2.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer2.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer2.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
  Writer2.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
  Writer2.prototype.float = function write_float(value) {
    return this._push(util2.float.writeFloatLE, 4, value);
  };
  Writer2.prototype.double = function write_double(value) {
    return this._push(util2.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i2 = 0; i2 < val.length; ++i2)
      buf[pos + i2] = val[i2];
  };
  Writer2.prototype.bytes = function write_bytes(value) {
    var len2 = value.length >>> 0;
    if (!len2)
      return this._push(writeByte, 1, 0);
    if (util2.isString(value)) {
      var buf = Writer2.alloc(len2 = base642.length(value));
      base642.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len2)._push(writeBytes, len2, value);
  };
  Writer2.prototype.string = function write_string(value) {
    var len2 = utf82.length(value);
    return len2 ? this.uint32(len2)._push(utf82.write, len2, value) : this._push(writeByte, 1, 0);
  };
  Writer2.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop2, 0, 0);
    this.len = 0;
    return this;
  };
  Writer2.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer2.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len2 = this.len;
    this.reset().uint32(len2);
    if (len2) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len2;
    }
    return this;
  };
  Writer2.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer2._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer2.create = create2();
    BufferWriter._configure();
  };
  return writer;
}
var writer_buffer;
var hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer)
    return writer_buffer;
  hasRequiredWriter_buffer = 1;
  writer_buffer = BufferWriter;
  var Writer2 = requireWriter();
  (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
  var util2 = requireMinimal$1();
  function BufferWriter() {
    Writer2.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util2._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i2 = 0; i2 < val.length; )
          buf[pos++] = val[i2++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util2.isString(value))
      value = util2._Buffer_from(value, "base64");
    var len2 = value.length >>> 0;
    this.uint32(len2);
    if (len2)
      this._push(BufferWriter.writeBytesBuffer, len2, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util2.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len2 = util2.Buffer.byteLength(value);
    this.uint32(len2);
    if (len2)
      this._push(writeStringBuffer, len2, value);
    return this;
  };
  BufferWriter._configure();
  return writer_buffer;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader)
    return reader;
  hasRequiredReader = 1;
  reader = Reader2;
  var util2 = requireMinimal$1();
  var BufferReader;
  var LongBits = util2.LongBits, utf82 = util2.utf8;
  function indexOutOfRange(reader2, writeLength) {
    return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
  }
  function Reader2(buffer2) {
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
    if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
      return new Reader2(buffer2);
    throw Error("illegal buffer");
  } : function create_array2(buffer2) {
    if (Array.isArray(buffer2))
      return new Reader2(buffer2);
    throw Error("illegal buffer");
  };
  var create2 = function create3() {
    return util2.Buffer ? function create_buffer_setup(buffer2) {
      return (Reader2.create = function create_buffer(buffer3) {
        return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
      })(buffer2);
    } : create_array;
  };
  Reader2.create = create2();
  Reader2.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
  util2.Array.prototype.slice;
  Reader2.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader2.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader2.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i2 = 0;
    if (this.len - this.pos > 4) {
      for (; i2 < 4; ++i2) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i2 = 0;
    } else {
      for (; i2 < 3; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i2 < 5; ++i2) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i2 < 5; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader2.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end2) {
    return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;
  }
  Reader2.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader2.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader2.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader2.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util2.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader2.prototype.bytes = function read_bytes() {
    var length2 = this.uint32(), start2 = this.pos, end2 = this.pos + length2;
    if (end2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
    if (Array.isArray(this.buf))
      return this.buf.slice(start2, end2);
    return start2 === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end2);
  };
  Reader2.prototype.string = function read_string() {
    var bytes3 = this.bytes();
    return utf82.read(bytes3, 0, bytes3.length);
  };
  Reader2.prototype.skip = function skip(length2) {
    if (typeof length2 === "number") {
      if (this.pos + length2 > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader2.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader2._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader2.create = create2();
    BufferReader._configure();
    var fn2 = util2.Long ? "toLong" : (
      /* istanbul ignore next */
      "toNumber"
    );
    util2.merge(Reader2.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn2](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn2](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn2](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn2](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn2](false);
      }
    });
  };
  return reader;
}
var reader_buffer;
var hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer)
    return reader_buffer;
  hasRequiredReader_buffer = 1;
  reader_buffer = BufferReader;
  var Reader2 = requireReader();
  (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
  var util2 = requireMinimal$1();
  function BufferReader(buffer2) {
    Reader2.call(this, buffer2);
  }
  BufferReader._configure = function() {
    if (util2.Buffer)
      BufferReader.prototype._slice = util2.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len2 = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
  };
  BufferReader._configure();
  return reader_buffer;
}
var rpc = {};
var service;
var hasRequiredService;
function requireService() {
  if (hasRequiredService)
    return service;
  hasRequiredService = 1;
  service = Service;
  var util2 = requireMinimal$1();
  (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util2.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(
        method,
        requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
        function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(
              /* endedByRPC */
              true
            );
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        }
      );
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service.prototype.end = function end2(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
  return service;
}
var hasRequiredRpc;
function requireRpc() {
  if (hasRequiredRpc)
    return rpc;
  hasRequiredRpc = 1;
  (function(exports) {
    var rpc2 = exports;
    rpc2.Service = requireService();
  })(rpc);
  return rpc;
}
var roots;
var hasRequiredRoots;
function requireRoots() {
  if (hasRequiredRoots)
    return roots;
  hasRequiredRoots = 1;
  roots = {};
  return roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  if (hasRequiredIndexMinimal)
    return indexMinimal;
  hasRequiredIndexMinimal = 1;
  (function(exports) {
    var protobuf = exports;
    protobuf.build = "minimal";
    protobuf.Writer = requireWriter();
    protobuf.BufferWriter = requireWriter_buffer();
    protobuf.Reader = requireReader();
    protobuf.BufferReader = requireReader_buffer();
    protobuf.util = requireMinimal$1();
    protobuf.rpc = requireRpc();
    protobuf.roots = requireRoots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  })(indexMinimal);
  return indexMinimal;
}
var minimal;
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal;
  hasRequiredMinimal = 1;
  minimal = requireIndexMinimal();
  return minimal;
}
var unixfs;
var hasRequiredUnixfs;
function requireUnixfs() {
  if (hasRequiredUnixfs)
    return unixfs;
  hasRequiredUnixfs = 1;
  var $protobuf = requireMinimal();
  var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
  var $root = $protobuf.roots["ipfs-unixfs"] || ($protobuf.roots["ipfs-unixfs"] = {});
  $root.Data = function() {
    function Data(p2) {
      this.blocksizes = [];
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    Data.prototype.Type = 0;
    Data.prototype.Data = $util.newBuffer([]);
    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data.prototype.blocksizes = $util.emptyArray;
    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    Data.prototype.mode = 0;
    Data.prototype.mtime = null;
    Data.encode = function encode3(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      w2.uint32(8).int32(m2.Type);
      if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
        w2.uint32(18).bytes(m2.Data);
      if (m2.filesize != null && Object.hasOwnProperty.call(m2, "filesize"))
        w2.uint32(24).uint64(m2.filesize);
      if (m2.blocksizes != null && m2.blocksizes.length) {
        for (var i2 = 0; i2 < m2.blocksizes.length; ++i2)
          w2.uint32(32).uint64(m2.blocksizes[i2]);
      }
      if (m2.hashType != null && Object.hasOwnProperty.call(m2, "hashType"))
        w2.uint32(40).uint64(m2.hashType);
      if (m2.fanout != null && Object.hasOwnProperty.call(m2, "fanout"))
        w2.uint32(48).uint64(m2.fanout);
      if (m2.mode != null && Object.hasOwnProperty.call(m2, "mode"))
        w2.uint32(56).uint32(m2.mode);
      if (m2.mtime != null && Object.hasOwnProperty.call(m2, "mtime"))
        $root.UnixTime.encode(m2.mtime, w2.uint32(66).fork()).ldelim();
      return w2;
    };
    Data.decode = function decode2(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Data();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.Type = r2.int32();
            break;
          case 2:
            m2.Data = r2.bytes();
            break;
          case 3:
            m2.filesize = r2.uint64();
            break;
          case 4:
            if (!(m2.blocksizes && m2.blocksizes.length))
              m2.blocksizes = [];
            if ((t2 & 7) === 2) {
              var c22 = r2.uint32() + r2.pos;
              while (r2.pos < c22)
                m2.blocksizes.push(r2.uint64());
            } else
              m2.blocksizes.push(r2.uint64());
            break;
          case 5:
            m2.hashType = r2.uint64();
            break;
          case 6:
            m2.fanout = r2.uint64();
            break;
          case 7:
            m2.mode = r2.uint32();
            break;
          case 8:
            m2.mtime = $root.UnixTime.decode(r2, r2.uint32());
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      if (!m2.hasOwnProperty("Type"))
        throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
      return m2;
    };
    Data.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.Data)
        return d2;
      var m2 = new $root.Data();
      switch (d2.Type) {
        case "Raw":
        case 0:
          m2.Type = 0;
          break;
        case "Directory":
        case 1:
          m2.Type = 1;
          break;
        case "File":
        case 2:
          m2.Type = 2;
          break;
        case "Metadata":
        case 3:
          m2.Type = 3;
          break;
        case "Symlink":
        case 4:
          m2.Type = 4;
          break;
        case "HAMTShard":
        case 5:
          m2.Type = 5;
          break;
      }
      if (d2.Data != null) {
        if (typeof d2.Data === "string")
          $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
        else if (d2.Data.length)
          m2.Data = d2.Data;
      }
      if (d2.filesize != null) {
        if ($util.Long)
          (m2.filesize = $util.Long.fromValue(d2.filesize)).unsigned = true;
        else if (typeof d2.filesize === "string")
          m2.filesize = parseInt(d2.filesize, 10);
        else if (typeof d2.filesize === "number")
          m2.filesize = d2.filesize;
        else if (typeof d2.filesize === "object")
          m2.filesize = new $util.LongBits(d2.filesize.low >>> 0, d2.filesize.high >>> 0).toNumber(true);
      }
      if (d2.blocksizes) {
        if (!Array.isArray(d2.blocksizes))
          throw TypeError(".Data.blocksizes: array expected");
        m2.blocksizes = [];
        for (var i2 = 0; i2 < d2.blocksizes.length; ++i2) {
          if ($util.Long)
            (m2.blocksizes[i2] = $util.Long.fromValue(d2.blocksizes[i2])).unsigned = true;
          else if (typeof d2.blocksizes[i2] === "string")
            m2.blocksizes[i2] = parseInt(d2.blocksizes[i2], 10);
          else if (typeof d2.blocksizes[i2] === "number")
            m2.blocksizes[i2] = d2.blocksizes[i2];
          else if (typeof d2.blocksizes[i2] === "object")
            m2.blocksizes[i2] = new $util.LongBits(d2.blocksizes[i2].low >>> 0, d2.blocksizes[i2].high >>> 0).toNumber(true);
        }
      }
      if (d2.hashType != null) {
        if ($util.Long)
          (m2.hashType = $util.Long.fromValue(d2.hashType)).unsigned = true;
        else if (typeof d2.hashType === "string")
          m2.hashType = parseInt(d2.hashType, 10);
        else if (typeof d2.hashType === "number")
          m2.hashType = d2.hashType;
        else if (typeof d2.hashType === "object")
          m2.hashType = new $util.LongBits(d2.hashType.low >>> 0, d2.hashType.high >>> 0).toNumber(true);
      }
      if (d2.fanout != null) {
        if ($util.Long)
          (m2.fanout = $util.Long.fromValue(d2.fanout)).unsigned = true;
        else if (typeof d2.fanout === "string")
          m2.fanout = parseInt(d2.fanout, 10);
        else if (typeof d2.fanout === "number")
          m2.fanout = d2.fanout;
        else if (typeof d2.fanout === "object")
          m2.fanout = new $util.LongBits(d2.fanout.low >>> 0, d2.fanout.high >>> 0).toNumber(true);
      }
      if (d2.mode != null) {
        m2.mode = d2.mode >>> 0;
      }
      if (d2.mtime != null) {
        if (typeof d2.mtime !== "object")
          throw TypeError(".Data.mtime: object expected");
        m2.mtime = $root.UnixTime.fromObject(d2.mtime);
      }
      return m2;
    };
    Data.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.arrays || o2.defaults) {
        d2.blocksizes = [];
      }
      if (o2.defaults) {
        d2.Type = o2.enums === String ? "Raw" : 0;
        if (o2.bytes === String)
          d2.Data = "";
        else {
          d2.Data = [];
          if (o2.bytes !== Array)
            d2.Data = $util.newBuffer(d2.Data);
        }
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.filesize = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.filesize = o2.longs === String ? "0" : 0;
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.hashType = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.hashType = o2.longs === String ? "0" : 0;
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.fanout = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.fanout = o2.longs === String ? "0" : 0;
        d2.mode = 0;
        d2.mtime = null;
      }
      if (m2.Type != null && m2.hasOwnProperty("Type")) {
        d2.Type = o2.enums === String ? $root.Data.DataType[m2.Type] : m2.Type;
      }
      if (m2.Data != null && m2.hasOwnProperty("Data")) {
        d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
      }
      if (m2.filesize != null && m2.hasOwnProperty("filesize")) {
        if (typeof m2.filesize === "number")
          d2.filesize = o2.longs === String ? String(m2.filesize) : m2.filesize;
        else
          d2.filesize = o2.longs === String ? $util.Long.prototype.toString.call(m2.filesize) : o2.longs === Number ? new $util.LongBits(m2.filesize.low >>> 0, m2.filesize.high >>> 0).toNumber(true) : m2.filesize;
      }
      if (m2.blocksizes && m2.blocksizes.length) {
        d2.blocksizes = [];
        for (var j = 0; j < m2.blocksizes.length; ++j) {
          if (typeof m2.blocksizes[j] === "number")
            d2.blocksizes[j] = o2.longs === String ? String(m2.blocksizes[j]) : m2.blocksizes[j];
          else
            d2.blocksizes[j] = o2.longs === String ? $util.Long.prototype.toString.call(m2.blocksizes[j]) : o2.longs === Number ? new $util.LongBits(m2.blocksizes[j].low >>> 0, m2.blocksizes[j].high >>> 0).toNumber(true) : m2.blocksizes[j];
        }
      }
      if (m2.hashType != null && m2.hasOwnProperty("hashType")) {
        if (typeof m2.hashType === "number")
          d2.hashType = o2.longs === String ? String(m2.hashType) : m2.hashType;
        else
          d2.hashType = o2.longs === String ? $util.Long.prototype.toString.call(m2.hashType) : o2.longs === Number ? new $util.LongBits(m2.hashType.low >>> 0, m2.hashType.high >>> 0).toNumber(true) : m2.hashType;
      }
      if (m2.fanout != null && m2.hasOwnProperty("fanout")) {
        if (typeof m2.fanout === "number")
          d2.fanout = o2.longs === String ? String(m2.fanout) : m2.fanout;
        else
          d2.fanout = o2.longs === String ? $util.Long.prototype.toString.call(m2.fanout) : o2.longs === Number ? new $util.LongBits(m2.fanout.low >>> 0, m2.fanout.high >>> 0).toNumber(true) : m2.fanout;
      }
      if (m2.mode != null && m2.hasOwnProperty("mode")) {
        d2.mode = m2.mode;
      }
      if (m2.mtime != null && m2.hasOwnProperty("mtime")) {
        d2.mtime = $root.UnixTime.toObject(m2.mtime, o2);
      }
      return d2;
    };
    Data.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Data.DataType = function() {
      var valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "Raw"] = 0;
      values[valuesById[1] = "Directory"] = 1;
      values[valuesById[2] = "File"] = 2;
      values[valuesById[3] = "Metadata"] = 3;
      values[valuesById[4] = "Symlink"] = 4;
      values[valuesById[5] = "HAMTShard"] = 5;
      return values;
    }();
    return Data;
  }();
  $root.UnixTime = function() {
    function UnixTime(p2) {
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    UnixTime.prototype.FractionalNanoseconds = 0;
    UnixTime.encode = function encode3(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      w2.uint32(8).int64(m2.Seconds);
      if (m2.FractionalNanoseconds != null && Object.hasOwnProperty.call(m2, "FractionalNanoseconds"))
        w2.uint32(21).fixed32(m2.FractionalNanoseconds);
      return w2;
    };
    UnixTime.decode = function decode2(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.UnixTime();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.Seconds = r2.int64();
            break;
          case 2:
            m2.FractionalNanoseconds = r2.fixed32();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      if (!m2.hasOwnProperty("Seconds"))
        throw $util.ProtocolError("missing required 'Seconds'", { instance: m2 });
      return m2;
    };
    UnixTime.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.UnixTime)
        return d2;
      var m2 = new $root.UnixTime();
      if (d2.Seconds != null) {
        if ($util.Long)
          (m2.Seconds = $util.Long.fromValue(d2.Seconds)).unsigned = false;
        else if (typeof d2.Seconds === "string")
          m2.Seconds = parseInt(d2.Seconds, 10);
        else if (typeof d2.Seconds === "number")
          m2.Seconds = d2.Seconds;
        else if (typeof d2.Seconds === "object")
          m2.Seconds = new $util.LongBits(d2.Seconds.low >>> 0, d2.Seconds.high >>> 0).toNumber();
      }
      if (d2.FractionalNanoseconds != null) {
        m2.FractionalNanoseconds = d2.FractionalNanoseconds >>> 0;
      }
      return m2;
    };
    UnixTime.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.defaults) {
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, false);
          d2.Seconds = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.Seconds = o2.longs === String ? "0" : 0;
        d2.FractionalNanoseconds = 0;
      }
      if (m2.Seconds != null && m2.hasOwnProperty("Seconds")) {
        if (typeof m2.Seconds === "number")
          d2.Seconds = o2.longs === String ? String(m2.Seconds) : m2.Seconds;
        else
          d2.Seconds = o2.longs === String ? $util.Long.prototype.toString.call(m2.Seconds) : o2.longs === Number ? new $util.LongBits(m2.Seconds.low >>> 0, m2.Seconds.high >>> 0).toNumber() : m2.Seconds;
      }
      if (m2.FractionalNanoseconds != null && m2.hasOwnProperty("FractionalNanoseconds")) {
        d2.FractionalNanoseconds = m2.FractionalNanoseconds;
      }
      return d2;
    };
    UnixTime.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return UnixTime;
  }();
  $root.Metadata = function() {
    function Metadata(p2) {
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    Metadata.prototype.MimeType = "";
    Metadata.encode = function encode3(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      if (m2.MimeType != null && Object.hasOwnProperty.call(m2, "MimeType"))
        w2.uint32(10).string(m2.MimeType);
      return w2;
    };
    Metadata.decode = function decode2(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.Metadata();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.MimeType = r2.string();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      return m2;
    };
    Metadata.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.Metadata)
        return d2;
      var m2 = new $root.Metadata();
      if (d2.MimeType != null) {
        m2.MimeType = String(d2.MimeType);
      }
      return m2;
    };
    Metadata.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.defaults) {
        d2.MimeType = "";
      }
      if (m2.MimeType != null && m2.hasOwnProperty("MimeType")) {
        d2.MimeType = m2.MimeType;
      }
      return d2;
    };
    Metadata.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Metadata;
  }();
  unixfs = $root;
  return unixfs;
}
var src$8;
var hasRequiredSrc$5;
function requireSrc$5() {
  if (hasRequiredSrc$5)
    return src$8;
  hasRequiredSrc$5 = 1;
  const {
    Data: PBData
  } = requireUnixfs();
  const errcode2 = errCode;
  const types2 = [
    "raw",
    "directory",
    "file",
    "metadata",
    "symlink",
    "hamt-sharded-directory"
  ];
  const dirTypes = [
    "directory",
    "hamt-sharded-directory"
  ];
  const DEFAULT_FILE_MODE = parseInt("0644", 8);
  const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  function parseMode(mode2) {
    if (mode2 == null) {
      return void 0;
    }
    if (typeof mode2 === "number") {
      return mode2 & 4095;
    }
    mode2 = mode2.toString();
    if (mode2.substring(0, 1) === "0") {
      return parseInt(mode2, 8) & 4095;
    }
    return parseInt(mode2, 10) & 4095;
  }
  function parseMtime(input) {
    if (input == null) {
      return void 0;
    }
    let mtime;
    if (input.secs != null) {
      mtime = {
        secs: input.secs,
        nsecs: input.nsecs
      };
    }
    if (input.Seconds != null) {
      mtime = {
        secs: input.Seconds,
        nsecs: input.FractionalNanoseconds
      };
    }
    if (Array.isArray(input)) {
      mtime = {
        secs: input[0],
        nsecs: input[1]
      };
    }
    if (input instanceof Date) {
      const ms = input.getTime();
      const secs = Math.floor(ms / 1e3);
      mtime = {
        secs,
        nsecs: (ms - secs * 1e3) * 1e3
      };
    }
    if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
      return void 0;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
      throw errcode2(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
    }
    return mtime;
  }
  class Data {
    /**
     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
     *
     * @param {Uint8Array} marshaled
     */
    static unmarshal(marshaled) {
      const message = PBData.decode(marshaled);
      const decoded = PBData.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      });
      const data = new Data({
        type: types2[decoded.Type],
        data: decoded.Data,
        blockSizes: decoded.blocksizes,
        mode: decoded.mode,
        mtime: decoded.mtime ? {
          secs: decoded.mtime.Seconds,
          nsecs: decoded.mtime.FractionalNanoseconds
        } : void 0
      });
      data._originalMode = decoded.mode || 0;
      return data;
    }
    /**
     * @param {object} [options]
     * @param {string} [options.type='file']
     * @param {Uint8Array} [options.data]
     * @param {number[]} [options.blockSizes]
     * @param {number} [options.hashType]
     * @param {number} [options.fanout]
     * @param {MtimeLike | null} [options.mtime]
     * @param {number | string} [options.mode]
     */
    constructor(options2 = {
      type: "file"
    }) {
      const {
        type,
        data,
        blockSizes,
        hashType,
        fanout,
        mtime,
        mode: mode2
      } = options2;
      if (type && !types2.includes(type)) {
        throw errcode2(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      this.type = type || "file";
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes || [];
      this._originalMode = 0;
      this.mode = parseMode(mode2);
      if (mtime) {
        this.mtime = parseMtime(mtime);
        if (this.mtime && !this.mtime.nsecs) {
          this.mtime.nsecs = 0;
        }
      }
    }
    /**
     * @param {number | undefined} mode
     */
    set mode(mode2) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
      const parsedMode = parseMode(mode2);
      if (parsedMode !== void 0) {
        this._mode = parsedMode;
      }
    }
    /**
     * @returns {number | undefined}
     */
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return Boolean(this.type && dirTypes.includes(this.type));
    }
    /**
     * @param {number} size
     */
    addBlockSize(size2) {
      this.blockSizes.push(size2);
    }
    /**
     * @param {number} index
     */
    removeBlockSize(index2) {
      this.blockSizes.splice(index2, 1);
    }
    /**
     * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else
     */
    fileSize() {
      if (this.isDirectory()) {
        return 0;
      }
      let sum = 0;
      this.blockSizes.forEach((size2) => {
        sum += size2;
      });
      if (this.data) {
        sum += this.data.length;
      }
      return sum;
    }
    /**
     * encode to protobuf Uint8Array
     */
    marshal() {
      let type;
      switch (this.type) {
        case "raw":
          type = PBData.DataType.Raw;
          break;
        case "directory":
          type = PBData.DataType.Directory;
          break;
        case "file":
          type = PBData.DataType.File;
          break;
        case "metadata":
          type = PBData.DataType.Metadata;
          break;
        case "symlink":
          type = PBData.DataType.Symlink;
          break;
        case "hamt-sharded-directory":
          type = PBData.DataType.HAMTShard;
          break;
        default:
          throw errcode2(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      let data = this.data;
      if (!this.data || !this.data.length) {
        data = void 0;
      }
      let mode2;
      if (this.mode != null) {
        mode2 = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
        if (mode2 === DEFAULT_FILE_MODE && !this.isDirectory()) {
          mode2 = void 0;
        }
        if (mode2 === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode2 = void 0;
        }
      }
      let mtime;
      if (this.mtime != null) {
        const parsed = parseMtime(this.mtime);
        if (parsed) {
          mtime = {
            Seconds: parsed.secs,
            FractionalNanoseconds: parsed.nsecs
          };
          if (mtime.FractionalNanoseconds === 0) {
            delete mtime.FractionalNanoseconds;
          }
        }
      }
      const pbData = {
        Type: type,
        Data: data,
        filesize: this.isDirectory() ? void 0 : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode: mode2,
        mtime
      };
      return PBData.encode(pbData).finish();
    }
  }
  src$8 = {
    UnixFS: Data,
    parseMode,
    parseMtime
  };
  return src$8;
}
var encode_1;
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode)
    return encode_1;
  hasRequiredEncode = 1;
  encode_1 = encode3;
  var MSB2 = 128, REST2 = 127, MSBALL2 = ~REST2, INT2 = Math.pow(2, 31);
  function encode3(num, out, offset2) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode3.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset2 = offset2 || 0;
    var oldOffset = offset2;
    while (num >= INT2) {
      out[offset2++] = num & 255 | MSB2;
      num /= 128;
    }
    while (num & MSBALL2) {
      out[offset2++] = num & 255 | MSB2;
      num >>>= 7;
    }
    out[offset2] = num | 0;
    encode3.bytes = offset2 - oldOffset + 1;
    return out;
  }
  return encode_1;
}
var decode$5;
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode)
    return decode$5;
  hasRequiredDecode = 1;
  decode$5 = read2;
  var MSB2 = 128, REST2 = 127;
  function read2(buf, offset2) {
    var res = 0, offset2 = offset2 || 0, shift = 0, counter2 = offset2, b2, l2 = buf.length;
    do {
      if (counter2 >= l2 || shift > 49) {
        read2.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b2 = buf[counter2++];
      res += shift < 28 ? (b2 & REST2) << shift : (b2 & REST2) * Math.pow(2, shift);
      shift += 7;
    } while (b2 >= MSB2);
    read2.bytes = counter2 - offset2;
    return res;
  }
  return decode$5;
}
var length$1;
var hasRequiredLength;
function requireLength() {
  if (hasRequiredLength)
    return length$1;
  hasRequiredLength = 1;
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var N82 = Math.pow(2, 56);
  var N92 = Math.pow(2, 63);
  length$1 = function(value) {
    return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
  };
  return length$1;
}
var varint;
var hasRequiredVarint;
function requireVarint() {
  if (hasRequiredVarint)
    return varint;
  hasRequiredVarint = 1;
  varint = {
    encode: requireEncode(),
    decode: requireDecode(),
    encodingLength: requireLength()
  };
  return varint;
}
var util$5;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2)
    return util$5;
  hasRequiredUtil$2 = 1;
  const varint2 = requireVarint();
  const { toString: uint8ArrayToString2 } = require$$5$1;
  const { fromString: uint8ArrayFromString2 } = require$$1$3;
  util$5 = {
    numberToUint8Array,
    uint8ArrayToNumber,
    varintUint8ArrayEncode,
    varintEncode
  };
  function uint8ArrayToNumber(buf) {
    return parseInt(uint8ArrayToString2(buf, "base16"), 16);
  }
  function numberToUint8Array(num) {
    let hexString = num.toString(16);
    if (hexString.length % 2 === 1) {
      hexString = "0" + hexString;
    }
    return uint8ArrayFromString2(hexString, "base16");
  }
  function varintUint8ArrayEncode(input) {
    return Uint8Array.from(varint2.encode(uint8ArrayToNumber(input)));
  }
  function varintEncode(num) {
    return Uint8Array.from(varint2.encode(num));
  }
  return util$5;
}
var generatedTable;
var hasRequiredGeneratedTable;
function requireGeneratedTable() {
  if (hasRequiredGeneratedTable)
    return generatedTable;
  hasRequiredGeneratedTable = 1;
  const baseTable = Object.freeze({
    "identity": 0,
    "cidv1": 1,
    "cidv2": 2,
    "cidv3": 3,
    "ip4": 4,
    "tcp": 6,
    "sha1": 17,
    "sha2-256": 18,
    "sha2-512": 19,
    "sha3-512": 20,
    "sha3-384": 21,
    "sha3-256": 22,
    "sha3-224": 23,
    "shake-128": 24,
    "shake-256": 25,
    "keccak-224": 26,
    "keccak-256": 27,
    "keccak-384": 28,
    "keccak-512": 29,
    "blake3": 30,
    "dccp": 33,
    "murmur3-128": 34,
    "murmur3-32": 35,
    "ip6": 41,
    "ip6zone": 42,
    "path": 47,
    "multicodec": 48,
    "multihash": 49,
    "multiaddr": 50,
    "multibase": 51,
    "dns": 53,
    "dns4": 54,
    "dns6": 55,
    "dnsaddr": 56,
    "protobuf": 80,
    "cbor": 81,
    "raw": 85,
    "dbl-sha2-256": 86,
    "rlp": 96,
    "bencode": 99,
    "dag-pb": 112,
    "dag-cbor": 113,
    "libp2p-key": 114,
    "git-raw": 120,
    "torrent-info": 123,
    "torrent-file": 124,
    "leofcoin-block": 129,
    "leofcoin-tx": 130,
    "leofcoin-pr": 131,
    "sctp": 132,
    "dag-jose": 133,
    "dag-cose": 134,
    "eth-block": 144,
    "eth-block-list": 145,
    "eth-tx-trie": 146,
    "eth-tx": 147,
    "eth-tx-receipt-trie": 148,
    "eth-tx-receipt": 149,
    "eth-state-trie": 150,
    "eth-account-snapshot": 151,
    "eth-storage-trie": 152,
    "eth-receipt-log-trie": 153,
    "eth-reciept-log": 154,
    "bitcoin-block": 176,
    "bitcoin-tx": 177,
    "bitcoin-witness-commitment": 178,
    "zcash-block": 192,
    "zcash-tx": 193,
    "caip-50": 202,
    "streamid": 206,
    "stellar-block": 208,
    "stellar-tx": 209,
    "md4": 212,
    "md5": 213,
    "bmt": 214,
    "decred-block": 224,
    "decred-tx": 225,
    "ipld-ns": 226,
    "ipfs-ns": 227,
    "swarm-ns": 228,
    "ipns-ns": 229,
    "zeronet": 230,
    "secp256k1-pub": 231,
    "bls12_381-g1-pub": 234,
    "bls12_381-g2-pub": 235,
    "x25519-pub": 236,
    "ed25519-pub": 237,
    "bls12_381-g1g2-pub": 238,
    "dash-block": 240,
    "dash-tx": 241,
    "swarm-manifest": 250,
    "swarm-feed": 251,
    "udp": 273,
    "p2p-webrtc-star": 275,
    "p2p-webrtc-direct": 276,
    "p2p-stardust": 277,
    "p2p-circuit": 290,
    "dag-json": 297,
    "udt": 301,
    "utp": 302,
    "unix": 400,
    "thread": 406,
    "p2p": 421,
    "ipfs": 421,
    "https": 443,
    "onion": 444,
    "onion3": 445,
    "garlic64": 446,
    "garlic32": 447,
    "tls": 448,
    "noise": 454,
    "quic": 460,
    "ws": 477,
    "wss": 478,
    "p2p-websocket-star": 479,
    "http": 480,
    "swhid-1-snp": 496,
    "json": 512,
    "messagepack": 513,
    "libp2p-peer-record": 769,
    "libp2p-relay-rsvp": 770,
    "car-index-sorted": 1024,
    "sha2-256-trunc254-padded": 4114,
    "ripemd-128": 4178,
    "ripemd-160": 4179,
    "ripemd-256": 4180,
    "ripemd-320": 4181,
    "x11": 4352,
    "p256-pub": 4608,
    "p384-pub": 4609,
    "p521-pub": 4610,
    "ed448-pub": 4611,
    "x448-pub": 4612,
    "ed25519-priv": 4864,
    "secp256k1-priv": 4865,
    "x25519-priv": 4866,
    "kangarootwelve": 7425,
    "sm3-256": 21325,
    "blake2b-8": 45569,
    "blake2b-16": 45570,
    "blake2b-24": 45571,
    "blake2b-32": 45572,
    "blake2b-40": 45573,
    "blake2b-48": 45574,
    "blake2b-56": 45575,
    "blake2b-64": 45576,
    "blake2b-72": 45577,
    "blake2b-80": 45578,
    "blake2b-88": 45579,
    "blake2b-96": 45580,
    "blake2b-104": 45581,
    "blake2b-112": 45582,
    "blake2b-120": 45583,
    "blake2b-128": 45584,
    "blake2b-136": 45585,
    "blake2b-144": 45586,
    "blake2b-152": 45587,
    "blake2b-160": 45588,
    "blake2b-168": 45589,
    "blake2b-176": 45590,
    "blake2b-184": 45591,
    "blake2b-192": 45592,
    "blake2b-200": 45593,
    "blake2b-208": 45594,
    "blake2b-216": 45595,
    "blake2b-224": 45596,
    "blake2b-232": 45597,
    "blake2b-240": 45598,
    "blake2b-248": 45599,
    "blake2b-256": 45600,
    "blake2b-264": 45601,
    "blake2b-272": 45602,
    "blake2b-280": 45603,
    "blake2b-288": 45604,
    "blake2b-296": 45605,
    "blake2b-304": 45606,
    "blake2b-312": 45607,
    "blake2b-320": 45608,
    "blake2b-328": 45609,
    "blake2b-336": 45610,
    "blake2b-344": 45611,
    "blake2b-352": 45612,
    "blake2b-360": 45613,
    "blake2b-368": 45614,
    "blake2b-376": 45615,
    "blake2b-384": 45616,
    "blake2b-392": 45617,
    "blake2b-400": 45618,
    "blake2b-408": 45619,
    "blake2b-416": 45620,
    "blake2b-424": 45621,
    "blake2b-432": 45622,
    "blake2b-440": 45623,
    "blake2b-448": 45624,
    "blake2b-456": 45625,
    "blake2b-464": 45626,
    "blake2b-472": 45627,
    "blake2b-480": 45628,
    "blake2b-488": 45629,
    "blake2b-496": 45630,
    "blake2b-504": 45631,
    "blake2b-512": 45632,
    "blake2s-8": 45633,
    "blake2s-16": 45634,
    "blake2s-24": 45635,
    "blake2s-32": 45636,
    "blake2s-40": 45637,
    "blake2s-48": 45638,
    "blake2s-56": 45639,
    "blake2s-64": 45640,
    "blake2s-72": 45641,
    "blake2s-80": 45642,
    "blake2s-88": 45643,
    "blake2s-96": 45644,
    "blake2s-104": 45645,
    "blake2s-112": 45646,
    "blake2s-120": 45647,
    "blake2s-128": 45648,
    "blake2s-136": 45649,
    "blake2s-144": 45650,
    "blake2s-152": 45651,
    "blake2s-160": 45652,
    "blake2s-168": 45653,
    "blake2s-176": 45654,
    "blake2s-184": 45655,
    "blake2s-192": 45656,
    "blake2s-200": 45657,
    "blake2s-208": 45658,
    "blake2s-216": 45659,
    "blake2s-224": 45660,
    "blake2s-232": 45661,
    "blake2s-240": 45662,
    "blake2s-248": 45663,
    "blake2s-256": 45664,
    "skein256-8": 45825,
    "skein256-16": 45826,
    "skein256-24": 45827,
    "skein256-32": 45828,
    "skein256-40": 45829,
    "skein256-48": 45830,
    "skein256-56": 45831,
    "skein256-64": 45832,
    "skein256-72": 45833,
    "skein256-80": 45834,
    "skein256-88": 45835,
    "skein256-96": 45836,
    "skein256-104": 45837,
    "skein256-112": 45838,
    "skein256-120": 45839,
    "skein256-128": 45840,
    "skein256-136": 45841,
    "skein256-144": 45842,
    "skein256-152": 45843,
    "skein256-160": 45844,
    "skein256-168": 45845,
    "skein256-176": 45846,
    "skein256-184": 45847,
    "skein256-192": 45848,
    "skein256-200": 45849,
    "skein256-208": 45850,
    "skein256-216": 45851,
    "skein256-224": 45852,
    "skein256-232": 45853,
    "skein256-240": 45854,
    "skein256-248": 45855,
    "skein256-256": 45856,
    "skein512-8": 45857,
    "skein512-16": 45858,
    "skein512-24": 45859,
    "skein512-32": 45860,
    "skein512-40": 45861,
    "skein512-48": 45862,
    "skein512-56": 45863,
    "skein512-64": 45864,
    "skein512-72": 45865,
    "skein512-80": 45866,
    "skein512-88": 45867,
    "skein512-96": 45868,
    "skein512-104": 45869,
    "skein512-112": 45870,
    "skein512-120": 45871,
    "skein512-128": 45872,
    "skein512-136": 45873,
    "skein512-144": 45874,
    "skein512-152": 45875,
    "skein512-160": 45876,
    "skein512-168": 45877,
    "skein512-176": 45878,
    "skein512-184": 45879,
    "skein512-192": 45880,
    "skein512-200": 45881,
    "skein512-208": 45882,
    "skein512-216": 45883,
    "skein512-224": 45884,
    "skein512-232": 45885,
    "skein512-240": 45886,
    "skein512-248": 45887,
    "skein512-256": 45888,
    "skein512-264": 45889,
    "skein512-272": 45890,
    "skein512-280": 45891,
    "skein512-288": 45892,
    "skein512-296": 45893,
    "skein512-304": 45894,
    "skein512-312": 45895,
    "skein512-320": 45896,
    "skein512-328": 45897,
    "skein512-336": 45898,
    "skein512-344": 45899,
    "skein512-352": 45900,
    "skein512-360": 45901,
    "skein512-368": 45902,
    "skein512-376": 45903,
    "skein512-384": 45904,
    "skein512-392": 45905,
    "skein512-400": 45906,
    "skein512-408": 45907,
    "skein512-416": 45908,
    "skein512-424": 45909,
    "skein512-432": 45910,
    "skein512-440": 45911,
    "skein512-448": 45912,
    "skein512-456": 45913,
    "skein512-464": 45914,
    "skein512-472": 45915,
    "skein512-480": 45916,
    "skein512-488": 45917,
    "skein512-496": 45918,
    "skein512-504": 45919,
    "skein512-512": 45920,
    "skein1024-8": 45921,
    "skein1024-16": 45922,
    "skein1024-24": 45923,
    "skein1024-32": 45924,
    "skein1024-40": 45925,
    "skein1024-48": 45926,
    "skein1024-56": 45927,
    "skein1024-64": 45928,
    "skein1024-72": 45929,
    "skein1024-80": 45930,
    "skein1024-88": 45931,
    "skein1024-96": 45932,
    "skein1024-104": 45933,
    "skein1024-112": 45934,
    "skein1024-120": 45935,
    "skein1024-128": 45936,
    "skein1024-136": 45937,
    "skein1024-144": 45938,
    "skein1024-152": 45939,
    "skein1024-160": 45940,
    "skein1024-168": 45941,
    "skein1024-176": 45942,
    "skein1024-184": 45943,
    "skein1024-192": 45944,
    "skein1024-200": 45945,
    "skein1024-208": 45946,
    "skein1024-216": 45947,
    "skein1024-224": 45948,
    "skein1024-232": 45949,
    "skein1024-240": 45950,
    "skein1024-248": 45951,
    "skein1024-256": 45952,
    "skein1024-264": 45953,
    "skein1024-272": 45954,
    "skein1024-280": 45955,
    "skein1024-288": 45956,
    "skein1024-296": 45957,
    "skein1024-304": 45958,
    "skein1024-312": 45959,
    "skein1024-320": 45960,
    "skein1024-328": 45961,
    "skein1024-336": 45962,
    "skein1024-344": 45963,
    "skein1024-352": 45964,
    "skein1024-360": 45965,
    "skein1024-368": 45966,
    "skein1024-376": 45967,
    "skein1024-384": 45968,
    "skein1024-392": 45969,
    "skein1024-400": 45970,
    "skein1024-408": 45971,
    "skein1024-416": 45972,
    "skein1024-424": 45973,
    "skein1024-432": 45974,
    "skein1024-440": 45975,
    "skein1024-448": 45976,
    "skein1024-456": 45977,
    "skein1024-464": 45978,
    "skein1024-472": 45979,
    "skein1024-480": 45980,
    "skein1024-488": 45981,
    "skein1024-496": 45982,
    "skein1024-504": 45983,
    "skein1024-512": 45984,
    "skein1024-520": 45985,
    "skein1024-528": 45986,
    "skein1024-536": 45987,
    "skein1024-544": 45988,
    "skein1024-552": 45989,
    "skein1024-560": 45990,
    "skein1024-568": 45991,
    "skein1024-576": 45992,
    "skein1024-584": 45993,
    "skein1024-592": 45994,
    "skein1024-600": 45995,
    "skein1024-608": 45996,
    "skein1024-616": 45997,
    "skein1024-624": 45998,
    "skein1024-632": 45999,
    "skein1024-640": 46e3,
    "skein1024-648": 46001,
    "skein1024-656": 46002,
    "skein1024-664": 46003,
    "skein1024-672": 46004,
    "skein1024-680": 46005,
    "skein1024-688": 46006,
    "skein1024-696": 46007,
    "skein1024-704": 46008,
    "skein1024-712": 46009,
    "skein1024-720": 46010,
    "skein1024-728": 46011,
    "skein1024-736": 46012,
    "skein1024-744": 46013,
    "skein1024-752": 46014,
    "skein1024-760": 46015,
    "skein1024-768": 46016,
    "skein1024-776": 46017,
    "skein1024-784": 46018,
    "skein1024-792": 46019,
    "skein1024-800": 46020,
    "skein1024-808": 46021,
    "skein1024-816": 46022,
    "skein1024-824": 46023,
    "skein1024-832": 46024,
    "skein1024-840": 46025,
    "skein1024-848": 46026,
    "skein1024-856": 46027,
    "skein1024-864": 46028,
    "skein1024-872": 46029,
    "skein1024-880": 46030,
    "skein1024-888": 46031,
    "skein1024-896": 46032,
    "skein1024-904": 46033,
    "skein1024-912": 46034,
    "skein1024-920": 46035,
    "skein1024-928": 46036,
    "skein1024-936": 46037,
    "skein1024-944": 46038,
    "skein1024-952": 46039,
    "skein1024-960": 46040,
    "skein1024-968": 46041,
    "skein1024-976": 46042,
    "skein1024-984": 46043,
    "skein1024-992": 46044,
    "skein1024-1000": 46045,
    "skein1024-1008": 46046,
    "skein1024-1016": 46047,
    "skein1024-1024": 46048,
    "poseidon-bls12_381-a2-fc1": 46081,
    "poseidon-bls12_381-a2-fc1-sc": 46082,
    "zeroxcert-imprint-256": 52753,
    "fil-commitment-unsealed": 61697,
    "fil-commitment-sealed": 61698,
    "holochain-adr-v0": 8417572,
    "holochain-adr-v1": 8483108,
    "holochain-key-v0": 9728292,
    "holochain-key-v1": 9793828,
    "holochain-sig-v0": 10645796,
    "holochain-sig-v1": 10711332,
    "skynet-ns": 11639056,
    "arweave-ns": 11704592
  });
  generatedTable = { baseTable };
  return generatedTable;
}
var maps;
var hasRequiredMaps;
function requireMaps() {
  if (hasRequiredMaps)
    return maps;
  hasRequiredMaps = 1;
  const { baseTable } = requireGeneratedTable();
  const varintEncode = requireUtil$2().varintEncode;
  const nameToVarint = (
    /** @type {NameUint8ArrayMap} */
    {}
  );
  const constantToCode = (
    /** @type {ConstantCodeMap} */
    {}
  );
  const codeToName = (
    /** @type {CodeNameMap} */
    {}
  );
  for (const name2 in baseTable) {
    const codecName = (
      /** @type {CodecName} */
      name2
    );
    const code2 = baseTable[codecName];
    nameToVarint[codecName] = varintEncode(code2);
    const constant = (
      /** @type {CodecConstant} */
      codecName.toUpperCase().replace(/-/g, "_")
    );
    constantToCode[constant] = code2;
    if (!codeToName[code2]) {
      codeToName[code2] = codecName;
    }
  }
  Object.freeze(nameToVarint);
  Object.freeze(constantToCode);
  Object.freeze(codeToName);
  const nameToCode = Object.freeze(baseTable);
  maps = {
    nameToVarint,
    constantToCode,
    nameToCode,
    codeToName
  };
  return maps;
}
var src$7;
var hasRequiredSrc$4;
function requireSrc$4() {
  if (hasRequiredSrc$4)
    return src$7;
  hasRequiredSrc$4 = 1;
  const varint2 = requireVarint();
  const { concat: uint8ArrayConcat2 } = require$$1$2;
  const util2 = requireUtil$2();
  const { nameToVarint, constantToCode, nameToCode, codeToName } = requireMaps();
  function addPrefix2(multicodecStrOrCode, data) {
    let prefix2;
    if (multicodecStrOrCode instanceof Uint8Array) {
      prefix2 = util2.varintUint8ArrayEncode(multicodecStrOrCode);
    } else {
      if (nameToVarint[multicodecStrOrCode]) {
        prefix2 = nameToVarint[multicodecStrOrCode];
      } else {
        throw new Error("multicodec not recognized");
      }
    }
    return uint8ArrayConcat2([prefix2, data], prefix2.length + data.length);
  }
  function rmPrefix(data) {
    varint2.decode(
      /** @type {Buffer} */
      data
    );
    return data.slice(varint2.decode.bytes);
  }
  function getNameFromData(prefixedData) {
    const code2 = (
      /** @type {CodecCode} */
      varint2.decode(
        /** @type {Buffer} */
        prefixedData
      )
    );
    const name2 = codeToName[code2];
    if (name2 === void 0) {
      throw new Error(`Code "${code2}" not found`);
    }
    return name2;
  }
  function getNameFromCode(codec) {
    return codeToName[codec];
  }
  function getCodeFromName(name2) {
    const code2 = nameToCode[name2];
    if (code2 === void 0) {
      throw new Error(`Codec "${name2}" not found`);
    }
    return code2;
  }
  function getCodeFromData(prefixedData) {
    return (
      /** @type {CodecCode} */
      varint2.decode(
        /** @type {Buffer} */
        prefixedData
      )
    );
  }
  function getVarintFromName(name2) {
    const code2 = nameToVarint[name2];
    if (code2 === void 0) {
      throw new Error(`Codec "${name2}" not found`);
    }
    return code2;
  }
  function getVarintFromCode(code2) {
    return util2.varintEncode(code2);
  }
  function getCodec(prefixedData) {
    return getNameFromData(prefixedData);
  }
  function getName(codec) {
    return getNameFromCode(codec);
  }
  function getNumber(name2) {
    return getCodeFromName(name2);
  }
  function getCode(prefixedData) {
    return getCodeFromData(prefixedData);
  }
  function getCodeVarint(name2) {
    return getVarintFromName(name2);
  }
  function getVarint(code2) {
    return Array.from(getVarintFromCode(code2));
  }
  src$7 = {
    addPrefix: addPrefix2,
    rmPrefix,
    getNameFromData,
    getNameFromCode,
    getCodeFromName,
    getCodeFromData,
    getVarintFromName,
    getVarintFromCode,
    // Deprecated
    getCodec,
    getName,
    getNumber,
    getCode,
    getCodeVarint,
    getVarint,
    // Make the constants top-level constants
    ...constantToCode,
    // Export the maps
    nameToVarint,
    nameToCode,
    codeToName
  };
  return src$7;
}
var cidUtil;
var hasRequiredCidUtil;
function requireCidUtil() {
  if (hasRequiredCidUtil)
    return cidUtil;
  hasRequiredCidUtil = 1;
  const mh2 = src$a;
  const CIDUtil = {
    /**
     * Test if the given input is a valid CID object.
     * Returns an error message if it is not.
     * Returns undefined if it is a valid CID.
     *
     * @param {any} other
     * @returns {string|undefined}
     */
    checkCIDComponents: function(other) {
      if (other == null) {
        return "null values are not valid CIDs";
      }
      if (!(other.version === 0 || other.version === 1)) {
        return "Invalid version, must be a number equal to 1 or 0";
      }
      if (typeof other.codec !== "string") {
        return "codec must be string";
      }
      if (other.version === 0) {
        if (other.codec !== "dag-pb") {
          return "codec must be 'dag-pb' for CIDv0";
        }
        if (other.multibaseName !== "base58btc") {
          return "multibaseName must be 'base58btc' for CIDv0";
        }
      }
      if (!(other.multihash instanceof Uint8Array)) {
        return "multihash must be a Uint8Array";
      }
      try {
        mh2.validate(other.multihash);
      } catch (err) {
        let errorMsg = err.message;
        if (!errorMsg) {
          errorMsg = "Multihash validation failed";
        }
        return errorMsg;
      }
    }
  };
  cidUtil = CIDUtil;
  return cidUtil;
}
var src$6;
var hasRequiredSrc$3;
function requireSrc$3() {
  if (hasRequiredSrc$3)
    return src$6;
  hasRequiredSrc$3 = 1;
  const mh2 = src$a;
  const multibase2 = srcExports;
  const multicodec = requireSrc$4();
  const CIDUtil = requireCidUtil();
  const { concat: uint8ArrayConcat2 } = require$$1$2;
  const { toString: uint8ArrayToString2 } = require$$5$1;
  const { equals: uint8ArrayEquals } = require$$6$1;
  const codecs2 = multicodec.nameToCode;
  const codecInts = (
    /** @type {CodecName[]} */
    Object.keys(codecs2).reduce(
      (p2, name2) => {
        p2[codecs2[name2]] = name2;
        return p2;
      },
      /** @type {Record<CodecCode, CodecName>} */
      {}
    )
  );
  const symbol = Symbol.for("@ipld/js-cid/CID");
  class CID2 {
    /**
     * Create a new CID.
     *
     * The algorithm for argument input is roughly:
     * ```
     * if (cid)
     *   -> create a copy
     * else if (str)
     *   if (1st char is on multibase table) -> CID String
     *   else -> bs58 encoded multihash
     * else if (Uint8Array)
     *   if (1st byte is 0 or 1) -> CID
     *   else -> multihash
     * else if (Number)
     *   -> construct CID by parts
     * ```
     *
     * @param {CIDVersion | string | Uint8Array | CID} version
     * @param {string|number} [codec]
     * @param {Uint8Array} [multihash]
     * @param {string} [multibaseName]
     *
     * @example
     * new CID(<version>, <codec>, <multihash>, <multibaseName>)
     * new CID(<cidStr>)
     * new CID(<cid.bytes>)
     * new CID(<multihash>)
     * new CID(<bs58 encoded multihash>)
     * new CID(<cid>)
     */
    constructor(version2, codec, multihash2, multibaseName) {
      this.version;
      this.codec;
      this.multihash;
      Object.defineProperty(this, symbol, { value: true });
      if (CID2.isCID(version2)) {
        const cid = (
          /** @type {CID} */
          version2
        );
        this.version = cid.version;
        this.codec = cid.codec;
        this.multihash = cid.multihash;
        this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
        return;
      }
      if (typeof version2 === "string") {
        const baseName = multibase2.isEncoded(version2);
        if (baseName) {
          const cid = multibase2.decode(version2);
          this.version = /** @type {CIDVersion} */
          parseInt(cid[0].toString(), 16);
          this.codec = multicodec.getCodec(cid.slice(1));
          this.multihash = multicodec.rmPrefix(cid.slice(1));
          this.multibaseName = baseName;
        } else {
          this.version = 0;
          this.codec = "dag-pb";
          this.multihash = mh2.fromB58String(version2);
          this.multibaseName = "base58btc";
        }
        CID2.validateCID(this);
        Object.defineProperty(this, "string", { value: version2 });
        return;
      }
      if (version2 instanceof Uint8Array) {
        const v2 = parseInt(version2[0].toString(), 16);
        if (v2 === 1) {
          const cid = version2;
          this.version = v2;
          this.codec = multicodec.getCodec(cid.slice(1));
          this.multihash = multicodec.rmPrefix(cid.slice(1));
          this.multibaseName = "base32";
        } else {
          this.version = 0;
          this.codec = "dag-pb";
          this.multihash = version2;
          this.multibaseName = "base58btc";
        }
        CID2.validateCID(this);
        return;
      }
      this.version = version2;
      if (typeof codec === "number") {
        codec = codecInts[codec];
      }
      this.codec = /** @type {CodecName} */
      codec;
      this.multihash = /** @type {Uint8Array} */
      multihash2;
      this.multibaseName = multibaseName || (version2 === 0 ? "base58btc" : "base32");
      CID2.validateCID(this);
    }
    /**
     * The CID as a `Uint8Array`
     *
     * @returns {Uint8Array}
     *
     */
    get bytes() {
      let bytes3 = this._bytes;
      if (!bytes3) {
        if (this.version === 0) {
          bytes3 = this.multihash;
        } else if (this.version === 1) {
          const codec = multicodec.getCodeVarint(this.codec);
          bytes3 = uint8ArrayConcat2([
            [1],
            codec,
            this.multihash
          ], 1 + codec.byteLength + this.multihash.byteLength);
        } else {
          throw new Error("unsupported version");
        }
        Object.defineProperty(this, "_bytes", { value: bytes3 });
      }
      return bytes3;
    }
    /**
     * The prefix of the CID.
     *
     * @returns {Uint8Array}
     */
    get prefix() {
      const codec = multicodec.getCodeVarint(this.codec);
      const multihash2 = mh2.prefix(this.multihash);
      const prefix2 = uint8ArrayConcat2([
        [this.version],
        codec,
        multihash2
      ], 1 + codec.byteLength + multihash2.byteLength);
      return prefix2;
    }
    /**
     * The codec of the CID in its number form.
     *
     * @returns {CodecCode}
     */
    get code() {
      return codecs2[this.codec];
    }
    /**
     * Convert to a CID of version `0`.
     *
     * @returns {CID}
     */
    toV0() {
      if (this.codec !== "dag-pb") {
        throw new Error("Cannot convert a non dag-pb CID to CIDv0");
      }
      const { name: name2, length: length2 } = mh2.decode(this.multihash);
      if (name2 !== "sha2-256") {
        throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
      }
      if (length2 !== 32) {
        throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
      }
      return new CID2(0, this.codec, this.multihash);
    }
    /**
     * Convert to a CID of version `1`.
     *
     * @returns {CID}
     */
    toV1() {
      return new CID2(1, this.codec, this.multihash, this.multibaseName);
    }
    /**
     * Encode the CID into a string.
     *
     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
     * @returns {string}
     */
    toBaseEncodedString(base3 = this.multibaseName) {
      if (this.string && this.string.length !== 0 && base3 === this.multibaseName) {
        return this.string;
      }
      let str;
      if (this.version === 0) {
        if (base3 !== "base58btc") {
          throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
        }
        str = mh2.toB58String(this.multihash);
      } else if (this.version === 1) {
        str = uint8ArrayToString2(multibase2.encode(base3, this.bytes));
      } else {
        throw new Error("unsupported version");
      }
      if (base3 === this.multibaseName) {
        Object.defineProperty(this, "string", { value: str });
      }
      return str;
    }
    /**
     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
     *
     * @returns {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    /**
     * Encode the CID into a string.
     *
     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
     * @returns {string}
     */
    toString(base3) {
      return this.toBaseEncodedString(base3);
    }
    /**
     * Serialize to a plain object.
     *
     * @returns {SerializedCID}
     */
    toJSON() {
      return {
        codec: this.codec,
        version: this.version,
        hash: this.multihash
      };
    }
    /**
     * Compare equality with another CID.
     *
     * @param {CID} other
     * @returns {boolean}
     */
    equals(other) {
      return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
    }
    /**
     * Test if the given input is a valid CID object.
     * Throws if it is not.
     *
     * @param {any} other - The other CID.
     * @returns {void}
     */
    static validateCID(other) {
      const errorMsg = CIDUtil.checkCIDComponents(other);
      if (errorMsg) {
        throw new Error(errorMsg);
      }
    }
    /**
     * Check if object is a CID instance
     *
     * @param {any} value
     * @returns {value is CID}
     */
    static isCID(value) {
      return value instanceof CID2 || Boolean(value && value[symbol]);
    }
  }
  CID2.codecs = codecs2;
  src$6 = CID2;
  return src$6;
}
var persist_1;
var hasRequiredPersist;
function requirePersist() {
  if (hasRequiredPersist)
    return persist_1;
  hasRequiredPersist = 1;
  const mh2 = src$9;
  const CID2 = requireSrc$3();
  const persist = async (buffer2, block, options2) => {
    if (!options2.codec) {
      options2.codec = "dag-pb";
    }
    if (!options2.cidVersion) {
      options2.cidVersion = 0;
    }
    if (!options2.hashAlg) {
      options2.hashAlg = "sha2-256";
    }
    if (options2.hashAlg !== "sha2-256") {
      options2.cidVersion = 1;
    }
    const multihash2 = await mh2(buffer2, options2.hashAlg);
    const cid = new CID2(options2.cidVersion, options2.codec, multihash2);
    if (!options2.onlyHash) {
      await block.put(buffer2, {
        // @ts-ignore pin option is missing from block api typedefs
        pin: options2.pin,
        preload: options2.preload,
        timeout: options2.timeout,
        cid
      });
    }
    return cid;
  };
  persist_1 = persist;
  return persist_1;
}
var resolver = {};
var dag;
var hasRequiredDag;
function requireDag() {
  if (hasRequiredDag)
    return dag;
  hasRequiredDag = 1;
  var $protobuf = requireMinimal();
  var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
  $root.PBLink = function() {
    function PBLink(p2) {
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    PBLink.prototype.Hash = $util.newBuffer([]);
    PBLink.prototype.Name = "";
    PBLink.prototype.Tsize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    PBLink.encode = function encode3(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      if (m2.Hash != null && Object.hasOwnProperty.call(m2, "Hash"))
        w2.uint32(10).bytes(m2.Hash);
      if (m2.Name != null && Object.hasOwnProperty.call(m2, "Name"))
        w2.uint32(18).string(m2.Name);
      if (m2.Tsize != null && Object.hasOwnProperty.call(m2, "Tsize"))
        w2.uint32(24).uint64(m2.Tsize);
      return w2;
    };
    PBLink.decode = function decode2(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PBLink();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 1:
            m2.Hash = r2.bytes();
            break;
          case 2:
            m2.Name = r2.string();
            break;
          case 3:
            m2.Tsize = r2.uint64();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      return m2;
    };
    PBLink.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.PBLink)
        return d2;
      var m2 = new $root.PBLink();
      if (d2.Hash != null) {
        if (typeof d2.Hash === "string")
          $util.base64.decode(d2.Hash, m2.Hash = $util.newBuffer($util.base64.length(d2.Hash)), 0);
        else if (d2.Hash.length)
          m2.Hash = d2.Hash;
      }
      if (d2.Name != null) {
        m2.Name = String(d2.Name);
      }
      if (d2.Tsize != null) {
        if ($util.Long)
          (m2.Tsize = $util.Long.fromValue(d2.Tsize)).unsigned = true;
        else if (typeof d2.Tsize === "string")
          m2.Tsize = parseInt(d2.Tsize, 10);
        else if (typeof d2.Tsize === "number")
          m2.Tsize = d2.Tsize;
        else if (typeof d2.Tsize === "object")
          m2.Tsize = new $util.LongBits(d2.Tsize.low >>> 0, d2.Tsize.high >>> 0).toNumber(true);
      }
      return m2;
    };
    PBLink.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.defaults) {
        if (o2.bytes === String)
          d2.Hash = "";
        else {
          d2.Hash = [];
          if (o2.bytes !== Array)
            d2.Hash = $util.newBuffer(d2.Hash);
        }
        d2.Name = "";
        if ($util.Long) {
          var n2 = new $util.Long(0, 0, true);
          d2.Tsize = o2.longs === String ? n2.toString() : o2.longs === Number ? n2.toNumber() : n2;
        } else
          d2.Tsize = o2.longs === String ? "0" : 0;
      }
      if (m2.Hash != null && m2.hasOwnProperty("Hash")) {
        d2.Hash = o2.bytes === String ? $util.base64.encode(m2.Hash, 0, m2.Hash.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Hash) : m2.Hash;
      }
      if (m2.Name != null && m2.hasOwnProperty("Name")) {
        d2.Name = m2.Name;
      }
      if (m2.Tsize != null && m2.hasOwnProperty("Tsize")) {
        if (typeof m2.Tsize === "number")
          d2.Tsize = o2.longs === String ? String(m2.Tsize) : m2.Tsize;
        else
          d2.Tsize = o2.longs === String ? $util.Long.prototype.toString.call(m2.Tsize) : o2.longs === Number ? new $util.LongBits(m2.Tsize.low >>> 0, m2.Tsize.high >>> 0).toNumber(true) : m2.Tsize;
      }
      return d2;
    };
    PBLink.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PBLink;
  }();
  $root.PBNode = function() {
    function PBNode(p2) {
      this.Links = [];
      if (p2) {
        for (var ks = Object.keys(p2), i2 = 0; i2 < ks.length; ++i2)
          if (p2[ks[i2]] != null)
            this[ks[i2]] = p2[ks[i2]];
      }
    }
    PBNode.prototype.Links = $util.emptyArray;
    PBNode.prototype.Data = $util.newBuffer([]);
    PBNode.encode = function encode3(m2, w2) {
      if (!w2)
        w2 = $Writer.create();
      if (m2.Data != null && Object.hasOwnProperty.call(m2, "Data"))
        w2.uint32(10).bytes(m2.Data);
      if (m2.Links != null && m2.Links.length) {
        for (var i2 = 0; i2 < m2.Links.length; ++i2)
          $root.PBLink.encode(m2.Links[i2], w2.uint32(18).fork()).ldelim();
      }
      return w2;
    };
    PBNode.decode = function decode2(r2, l2) {
      if (!(r2 instanceof $Reader))
        r2 = $Reader.create(r2);
      var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PBNode();
      while (r2.pos < c2) {
        var t2 = r2.uint32();
        switch (t2 >>> 3) {
          case 2:
            if (!(m2.Links && m2.Links.length))
              m2.Links = [];
            m2.Links.push($root.PBLink.decode(r2, r2.uint32()));
            break;
          case 1:
            m2.Data = r2.bytes();
            break;
          default:
            r2.skipType(t2 & 7);
            break;
        }
      }
      return m2;
    };
    PBNode.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.PBNode)
        return d2;
      var m2 = new $root.PBNode();
      if (d2.Links) {
        if (!Array.isArray(d2.Links))
          throw TypeError(".PBNode.Links: array expected");
        m2.Links = [];
        for (var i2 = 0; i2 < d2.Links.length; ++i2) {
          if (typeof d2.Links[i2] !== "object")
            throw TypeError(".PBNode.Links: object expected");
          m2.Links[i2] = $root.PBLink.fromObject(d2.Links[i2]);
        }
      }
      if (d2.Data != null) {
        if (typeof d2.Data === "string")
          $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
        else if (d2.Data.length)
          m2.Data = d2.Data;
      }
      return m2;
    };
    PBNode.toObject = function toObject(m2, o2) {
      if (!o2)
        o2 = {};
      var d2 = {};
      if (o2.arrays || o2.defaults) {
        d2.Links = [];
      }
      if (o2.defaults) {
        if (o2.bytes === String)
          d2.Data = "";
        else {
          d2.Data = [];
          if (o2.bytes !== Array)
            d2.Data = $util.newBuffer(d2.Data);
        }
      }
      if (m2.Data != null && m2.hasOwnProperty("Data")) {
        d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
      }
      if (m2.Links && m2.Links.length) {
        d2.Links = [];
        for (var j = 0; j < m2.Links.length; ++j) {
          d2.Links[j] = $root.PBLink.toObject(m2.Links[j], o2);
        }
      }
      return d2;
    };
    PBNode.prototype.toJSON = function toJSON3() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PBNode;
  }();
  dag = $root;
  return dag;
}
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(basics);
var bases_1$1;
var hasRequiredBases$1;
function requireBases$1() {
  if (hasRequiredBases$1)
    return bases_1$1;
  hasRequiredBases$1 = 1;
  const { bases: bases2 } = require$$0$3;
  function createCodec2(name2, prefix2, encode3, decode2) {
    return {
      name: name2,
      prefix: prefix2,
      encoder: {
        name: name2,
        prefix: prefix2,
        encode: encode3
      },
      decoder: {
        decode: decode2
      }
    };
  }
  const string2 = createCodec2("utf8", "u", (buf) => {
    const decoder2 = new TextDecoder("utf8");
    return "u" + decoder2.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  const ascii2 = createCodec2("ascii", "a", (buf) => {
    let string3 = "a";
    for (let i2 = 0; i2 < buf.length; i2++) {
      string3 += String.fromCharCode(buf[i2]);
    }
    return string3;
  }, (str) => {
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for (let i2 = 0; i2 < str.length; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  });
  const BASES2 = {
    "utf8": string2,
    "utf-8": string2,
    "hex": bases2.base16,
    "latin1": ascii2,
    "ascii": ascii2,
    "binary": ascii2,
    ...bases2
  };
  bases_1$1 = BASES2;
  return bases_1$1;
}
var fromString_1$1;
var hasRequiredFromString$1;
function requireFromString$1() {
  if (hasRequiredFromString$1)
    return fromString_1$1;
  hasRequiredFromString$1 = 1;
  const bases2 = requireBases$1();
  function fromString2(string2, encoding = "utf8") {
    const base3 = bases2[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }
  fromString_1$1 = fromString2;
  return fromString_1$1;
}
var dagLink;
var hasRequiredDagLink;
function requireDagLink() {
  if (hasRequiredDagLink)
    return dagLink;
  hasRequiredDagLink = 1;
  const CID2 = requireSrc$3();
  const uint8ArrayFromString2 = requireFromString$1();
  class DAGLink {
    /**
     * @param {string | undefined | null} name
     * @param {number} size
     * @param {CID | string | Uint8Array} cid
     */
    constructor(name2, size2, cid) {
      if (!cid) {
        throw new Error("A link requires a cid to point to");
      }
      this.Name = name2 || "";
      this.Tsize = size2;
      this.Hash = new CID2(cid);
      Object.defineProperties(this, {
        _nameBuf: { value: null, writable: true, enumerable: false }
      });
    }
    toString() {
      return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`;
    }
    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          name: this.Name,
          size: this.Tsize,
          cid: this.Hash.toBaseEncodedString()
        });
      }
      return Object.assign({}, this._json);
    }
    // Memoize the Uint8Array representation of name
    // We need this to sort the links, otherwise
    // we will reallocate new Uint8Arrays every time
    get nameAsBuffer() {
      if (this._nameBuf != null) {
        return this._nameBuf;
      }
      this._nameBuf = uint8ArrayFromString2(this.Name);
      return this._nameBuf;
    }
  }
  dagLink = DAGLink;
  return dagLink;
}
var stable = { exports: {} };
var hasRequiredStable;
function requireStable() {
  if (hasRequiredStable)
    return stable.exports;
  hasRequiredStable = 1;
  (function(module, exports) {
    //! stable.js 0.1.8, https://github.com/Two-Screen/stable
    //! © 2018 Angry Bytes and contributors. MIT licensed.
    (function(global2, factory2) {
      module.exports = factory2();
    })(commonjsGlobal, function() {
      var stable2 = function(arr, comp) {
        return exec(arr.slice(), comp);
      };
      stable2.inplace = function(arr, comp) {
        var result = exec(arr, comp);
        if (result !== arr) {
          pass(result, null, arr.length, arr);
        }
        return arr;
      };
      function exec(arr, comp) {
        if (typeof comp !== "function") {
          comp = function(a2, b2) {
            return String(a2).localeCompare(b2);
          };
        }
        var len2 = arr.length;
        if (len2 <= 1) {
          return arr;
        }
        var buffer2 = new Array(len2);
        for (var chk = 1; chk < len2; chk *= 2) {
          pass(arr, comp, chk, buffer2);
          var tmp = arr;
          arr = buffer2;
          buffer2 = tmp;
        }
        return arr;
      }
      var pass = function(arr, comp, chk, result) {
        var len2 = arr.length;
        var i2 = 0;
        var dbl3 = chk * 2;
        var l2, r2, e2;
        var li2, ri2;
        for (l2 = 0; l2 < len2; l2 += dbl3) {
          r2 = l2 + chk;
          e2 = r2 + chk;
          if (r2 > len2)
            r2 = len2;
          if (e2 > len2)
            e2 = len2;
          li2 = l2;
          ri2 = r2;
          while (true) {
            if (li2 < r2 && ri2 < e2) {
              if (comp(arr[li2], arr[ri2]) <= 0) {
                result[i2++] = arr[li2++];
              } else {
                result[i2++] = arr[ri2++];
              }
            } else if (li2 < r2) {
              result[i2++] = arr[li2++];
            } else if (ri2 < e2) {
              result[i2++] = arr[ri2++];
            } else {
              break;
            }
          }
        }
      };
      return stable2;
    });
  })(stable);
  return stable.exports;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare)
    return compare_1;
  hasRequiredCompare = 1;
  function compare2(a2, b2) {
    for (let i2 = 0; i2 < a2.byteLength; i2++) {
      if (a2[i2] < b2[i2]) {
        return -1;
      }
      if (a2[i2] > b2[i2]) {
        return 1;
      }
    }
    if (a2.byteLength > b2.byteLength) {
      return 1;
    }
    if (a2.byteLength < b2.byteLength) {
      return -1;
    }
    return 0;
  }
  compare_1 = compare2;
  return compare_1;
}
var sortLinks_1;
var hasRequiredSortLinks;
function requireSortLinks() {
  if (hasRequiredSortLinks)
    return sortLinks_1;
  hasRequiredSortLinks = 1;
  const sort = requireStable();
  const uint8ArrayCompare = requireCompare();
  const linkSort = (a2, b2) => {
    const buf1 = a2.nameAsBuffer;
    const buf2 = b2.nameAsBuffer;
    return uint8ArrayCompare(buf1, buf2);
  };
  const sortLinks = (links) => {
    sort.inplace(links, linkSort);
  };
  sortLinks_1 = sortLinks;
  return sortLinks_1;
}
var util$4;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1)
    return util$4;
  hasRequiredUtil$1 = 1;
  const DAGLink = requireDagLink();
  function createDagLinkFromB58EncodedHash(link) {
    return new DAGLink(
      link.Name || link.name || "",
      link.Tsize || link.Size || link.size || 0,
      link.Hash || link.hash || link.multihash || link.cid
    );
  }
  util$4 = {
    createDagLinkFromB58EncodedHash
  };
  return util$4;
}
var serialize$4;
var hasRequiredSerialize;
function requireSerialize() {
  if (hasRequiredSerialize)
    return serialize$4;
  hasRequiredSerialize = 1;
  const protobuf = requireMinimal();
  const {
    PBLink
  } = requireDag();
  const {
    createDagLinkFromB58EncodedHash
  } = requireUtil$1();
  const toProtoBuf = (node2) => {
    const pbn = {};
    if (node2.Data && node2.Data.byteLength > 0) {
      pbn.Data = node2.Data;
    } else {
      pbn.Data = null;
    }
    if (node2.Links && node2.Links.length > 0) {
      pbn.Links = node2.Links.map((link) => ({
        Hash: link.Hash.bytes,
        Name: link.Name,
        Tsize: link.Tsize
      }));
    } else {
      pbn.Links = null;
    }
    return pbn;
  };
  const serializeDAGNode = (node2) => {
    return encode3(toProtoBuf(node2));
  };
  const serializeDAGNodeLike = (data, links = []) => {
    const node2 = {
      Data: data,
      Links: links.map((link) => {
        return createDagLinkFromB58EncodedHash(link);
      })
    };
    return encode3(toProtoBuf(node2));
  };
  serialize$4 = {
    serializeDAGNode,
    serializeDAGNodeLike
  };
  function encode3(pbf) {
    const writer2 = protobuf.Writer.create();
    if (pbf.Links != null) {
      for (let i2 = 0; i2 < pbf.Links.length; i2++) {
        PBLink.encode(pbf.Links[i2], writer2.uint32(18).fork()).ldelim();
      }
    }
    if (pbf.Data != null) {
      writer2.uint32(10).bytes(pbf.Data);
    }
    return writer2.finish();
  }
  return serialize$4;
}
var genCid;
var hasRequiredGenCid;
function requireGenCid() {
  if (hasRequiredGenCid)
    return genCid;
  hasRequiredGenCid = 1;
  const CID2 = requireSrc$3();
  const multicodec = requireSrc$4();
  const multihashing2 = src$9;
  const { multihash: multihash2 } = multihashing2;
  const codec = multicodec.DAG_PB;
  const defaultHashAlg = multihash2.names["sha2-256"];
  const cid = async (binaryBlob, userOptions = {}) => {
    const options2 = {
      cidVersion: userOptions.cidVersion == null ? 1 : userOptions.cidVersion,
      hashAlg: userOptions.hashAlg == null ? defaultHashAlg : userOptions.hashAlg
    };
    const hashName = multihash2.codes[options2.hashAlg];
    const hash2 = await multihashing2(binaryBlob, hashName);
    const codecName = multicodec.getNameFromCode(codec);
    const cid2 = new CID2(options2.cidVersion, codecName, hash2);
    return cid2;
  };
  genCid = {
    codec,
    defaultHashAlg,
    cid
  };
  return genCid;
}
var toDagLink;
var hasRequiredToDagLink;
function requireToDagLink() {
  if (hasRequiredToDagLink)
    return toDagLink;
  hasRequiredToDagLink = 1;
  const DAGLink = requireDagLink();
  const genCid2 = requireGenCid();
  const toDAGLink = async (node2, options2 = {}) => {
    const buf = node2.serialize();
    const nodeCid = await genCid2.cid(buf, options2);
    return new DAGLink(options2.name || "", node2.size, nodeCid);
  };
  toDagLink = toDAGLink;
  return toDagLink;
}
var addLink_1;
var hasRequiredAddLink;
function requireAddLink() {
  if (hasRequiredAddLink)
    return addLink_1;
  hasRequiredAddLink = 1;
  const sortLinks = requireSortLinks();
  const DAGLink = requireDagLink();
  const asDAGLink = (link) => {
    if (link instanceof DAGLink) {
      return link;
    }
    if (!("cid" in link || "hash" in link || "Hash" in link || "multihash" in link)) {
      throw new Error("Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.");
    }
    return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid);
  };
  const addLink = (node2, link) => {
    const dagLink2 = asDAGLink(link);
    node2.Links.push(dagLink2);
    sortLinks(node2.Links);
  };
  addLink_1 = addLink;
  return addLink_1;
}
var equals_1;
var hasRequiredEquals;
function requireEquals() {
  if (hasRequiredEquals)
    return equals_1;
  hasRequiredEquals = 1;
  function equals2(a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (a2.byteLength !== b2.byteLength) {
      return false;
    }
    for (let i2 = 0; i2 < a2.byteLength; i2++) {
      if (a2[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  }
  equals_1 = equals2;
  return equals_1;
}
var rmLink_1;
var hasRequiredRmLink;
function requireRmLink() {
  if (hasRequiredRmLink)
    return rmLink_1;
  hasRequiredRmLink = 1;
  const CID2 = requireSrc$3();
  const uint8ArrayEquals = requireEquals();
  const rmLink = (dagNode2, nameOrCid) => {
    let predicate = null;
    if (typeof nameOrCid === "string") {
      predicate = (link) => link.Name === nameOrCid;
    } else if (nameOrCid instanceof Uint8Array) {
      predicate = (link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid);
    } else if (CID2.isCID(nameOrCid)) {
      predicate = (link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes);
    }
    if (predicate) {
      const links = dagNode2.Links;
      let index2 = 0;
      while (index2 < links.length) {
        const link = links[index2];
        if (predicate(link)) {
          links.splice(index2, 1);
        } else {
          index2++;
        }
      }
    } else {
      throw new Error("second arg needs to be a name or CID");
    }
  };
  rmLink_1 = rmLink;
  return rmLink_1;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  const bases2 = requireBases$1();
  function toString3(array, encoding = "utf8") {
    const base3 = bases2[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }
  toString_1 = toString3;
  return toString_1;
}
var dagNode;
var hasRequiredDagNode;
function requireDagNode() {
  if (hasRequiredDagNode)
    return dagNode;
  hasRequiredDagNode = 1;
  const sortLinks = requireSortLinks();
  const DAGLink = requireDagLink();
  const { createDagLinkFromB58EncodedHash } = requireUtil$1();
  const { serializeDAGNode } = requireSerialize();
  const toDAGLink = requireToDagLink();
  const addLink = requireAddLink();
  const rmLink = requireRmLink();
  const uint8ArrayFromString2 = requireFromString$1();
  const uint8ArrayToString2 = requireToString();
  class DAGNode {
    /**
     *@param {Uint8Array | string} [data]
     * @param {(DAGLink | DAGLinkLike)[]} links
     * @param {number | null} [serializedSize]
     */
    constructor(data, links = [], serializedSize = null) {
      if (!data) {
        data = new Uint8Array(0);
      }
      if (typeof data === "string") {
        data = uint8ArrayFromString2(data);
      }
      if (!(data instanceof Uint8Array)) {
        throw new Error("Passed 'data' is not a Uint8Array or a String!");
      }
      if (serializedSize !== null && typeof serializedSize !== "number") {
        throw new Error("Passed 'serializedSize' must be a number!");
      }
      const sortedLinks = links.map((link) => {
        return link instanceof DAGLink ? link : createDagLinkFromB58EncodedHash(link);
      });
      sortLinks(sortedLinks);
      this.Data = data;
      this.Links = sortedLinks;
      Object.defineProperties(this, {
        _serializedSize: { value: serializedSize, writable: true, enumerable: false },
        _size: { value: null, writable: true, enumerable: false }
      });
    }
    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          data: this.Data,
          links: this.Links.map((l2) => l2.toJSON()),
          size: this.size
        });
      }
      return Object.assign({}, this._json);
    }
    toString() {
      return `DAGNode <data: "${uint8ArrayToString2(this.Data, "base64urlpad")}", links: ${this.Links.length}, size: ${this.size}>`;
    }
    _invalidateCached() {
      this._serializedSize = null;
      this._size = null;
    }
    /**
     * @param {DAGLink | import('../types').DAGLinkLike} link
     */
    addLink(link) {
      this._invalidateCached();
      return addLink(this, link);
    }
    /**
     * @param {DAGLink | string | CID} link
     */
    rmLink(link) {
      this._invalidateCached();
      return rmLink(this, link);
    }
    /**
     * @param {import('./toDagLink').ToDagLinkOptions} [options]
     */
    toDAGLink(options2) {
      return toDAGLink(this, options2);
    }
    serialize() {
      const buf = serializeDAGNode(this);
      this._serializedSize = buf.length;
      return buf;
    }
    get size() {
      if (this._size == null) {
        let serializedSize;
        if (serializedSize == null) {
          this._serializedSize = this.serialize().length;
          serializedSize = this._serializedSize;
        }
        this._size = this.Links.reduce((sum, l2) => sum + l2.Tsize, serializedSize);
      }
      return this._size;
    }
    set size(size2) {
      throw new Error("Can't set property: 'size' is immutable");
    }
  }
  dagNode = DAGNode;
  return dagNode;
}
var util$3;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$3;
  hasRequiredUtil = 1;
  const {
    PBNode
  } = requireDag();
  const DAGLink = requireDagLink();
  const DAGNode = requireDagNode();
  const { serializeDAGNode, serializeDAGNodeLike } = requireSerialize();
  const genCid2 = requireGenCid();
  const cid = (binaryBlob, userOptions) => {
    return genCid2.cid(binaryBlob, userOptions);
  };
  const serialize2 = (node2) => {
    if (node2 instanceof DAGNode) {
      return serializeDAGNode(node2);
    } else {
      return serializeDAGNodeLike(node2.Data, node2.Links);
    }
  };
  const deserialize = (buffer2) => {
    const message = PBNode.decode(buffer2);
    const pbn = PBNode.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const links = pbn.Links.map((link) => {
      return new DAGLink(link.Name, link.Tsize, link.Hash);
    });
    const data = pbn.Data == null ? new Uint8Array(0) : pbn.Data;
    return new DAGNode(data, links, buffer2.byteLength);
  };
  util$3 = {
    codec: genCid2.codec,
    defaultHashAlg: genCid2.defaultHashAlg,
    serialize: serialize2,
    deserialize,
    cid
  };
  return util$3;
}
var hasRequiredResolver;
function requireResolver() {
  if (hasRequiredResolver)
    return resolver;
  hasRequiredResolver = 1;
  const CID2 = requireSrc$3();
  const util2 = requireUtil();
  resolver.resolve = (binaryBlob, path = "/") => {
    let node2 = util2.deserialize(binaryBlob);
    const parts = path.split("/").filter(Boolean);
    while (parts.length) {
      const key2 = parts.shift();
      if (node2[key2] === void 0) {
        for (const link of node2.Links) {
          if (link.Name === key2) {
            return {
              value: link.Hash,
              remainderPath: parts.join("/")
            };
          }
        }
        throw new Error(`Object has no property '${key2}'`);
      }
      node2 = node2[key2];
      if (CID2.isCID(node2)) {
        return {
          value: node2,
          remainderPath: parts.join("/")
        };
      }
    }
    return {
      value: node2,
      remainderPath: ""
    };
  };
  resolver.tree = function* (binaryBlob) {
    const node2 = util2.deserialize(binaryBlob);
    yield "Data";
    yield "Links";
    for (let ii2 = 0; ii2 < node2.Links.length; ii2++) {
      yield `Links/${ii2}`;
      yield `Links/${ii2}/Name`;
      yield `Links/${ii2}/Tsize`;
      yield `Links/${ii2}/Hash`;
    }
  };
  return resolver;
}
var src$5;
var hasRequiredSrc$2;
function requireSrc$2() {
  if (hasRequiredSrc$2)
    return src$5;
  hasRequiredSrc$2 = 1;
  const resolver2 = requireResolver();
  const util2 = requireUtil();
  const DAGNodeClass = requireDagNode();
  const DAGLinkClass = requireDagLink();
  const format = {
    DAGNode: DAGNodeClass,
    DAGLink: DAGLinkClass,
    /**
     * Functions to fulfil IPLD Format interface
     * https://github.com/ipld/interface-ipld-format
     */
    resolver: resolver2,
    util: util2,
    codec: util2.codec,
    defaultHashAlg: util2.defaultHashAlg
  };
  src$5 = format;
  return src$5;
}
var dir$1;
var hasRequiredDir$1;
function requireDir$1() {
  if (hasRequiredDir$1)
    return dir$1;
  hasRequiredDir$1 = 1;
  const { UnixFS } = requireSrc$5();
  const persist = requirePersist();
  const {
    DAGNode
  } = requireSrc$2();
  const dirBuilder = async (item, block, options2) => {
    const unixfs2 = new UnixFS({
      type: "directory",
      mtime: item.mtime,
      mode: item.mode
    });
    const buffer2 = new DAGNode(unixfs2.marshal()).serialize();
    const cid = await persist(buffer2, block, options2);
    const path = item.path;
    return {
      cid,
      path,
      unixfs: unixfs2,
      size: buffer2.length
    };
  };
  dir$1 = dirBuilder;
  return dir$1;
}
var itAll;
var hasRequiredItAll;
function requireItAll() {
  if (hasRequiredItAll)
    return itAll;
  hasRequiredItAll = 1;
  const all2 = async (source) => {
    const arr = [];
    for await (const entry of source) {
      arr.push(entry);
    }
    return arr;
  };
  itAll = all2;
  return itAll;
}
var flat$1;
var hasRequiredFlat;
function requireFlat() {
  if (hasRequiredFlat)
    return flat$1;
  hasRequiredFlat = 1;
  const all2 = requireItAll();
  flat$1 = async function(source, reduce) {
    return reduce(await all2(source));
  };
  return flat$1;
}
var balanced_1;
var hasRequiredBalanced;
function requireBalanced() {
  if (hasRequiredBalanced)
    return balanced_1;
  hasRequiredBalanced = 1;
  const batch2 = itBatch;
  function balanced(source, reduce, options2) {
    return reduceToParents(source, reduce, options2);
  }
  async function reduceToParents(source, reduce, options2) {
    const roots2 = [];
    for await (const chunked of batch2(source, options2.maxChildrenPerNode)) {
      roots2.push(await reduce(chunked));
    }
    if (roots2.length > 1) {
      return reduceToParents(roots2, reduce, options2);
    }
    return roots2[0];
  }
  balanced_1 = balanced;
  return balanced_1;
}
var trickle;
var hasRequiredTrickle;
function requireTrickle() {
  if (hasRequiredTrickle)
    return trickle;
  hasRequiredTrickle = 1;
  const batch2 = itBatch;
  trickle = async function trickleStream(source, reduce, options2) {
    const root = new Root(options2.layerRepeat);
    let iteration = 0;
    let maxDepth = 1;
    let subTree = root;
    for await (const layer of batch2(source, options2.maxChildrenPerNode)) {
      if (subTree.isFull()) {
        if (subTree !== root) {
          root.addChild(await subTree.reduce(reduce));
        }
        if (iteration && iteration % options2.layerRepeat === 0) {
          maxDepth++;
        }
        subTree = new SubTree(maxDepth, options2.layerRepeat, iteration);
        iteration++;
      }
      subTree.append(layer);
    }
    if (subTree && subTree !== root) {
      root.addChild(await subTree.reduce(reduce));
    }
    return root.reduce(reduce);
  };
  class SubTree {
    /**
     * @param {number} maxDepth
     * @param {number} layerRepeat
     * @param {number} [iteration=0]
     */
    constructor(maxDepth, layerRepeat, iteration = 0) {
      this.maxDepth = maxDepth;
      this.layerRepeat = layerRepeat;
      this.currentDepth = 1;
      this.iteration = iteration;
      this.root = this.node = this.parent = {
        children: [],
        depth: this.currentDepth,
        maxDepth,
        maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
      };
    }
    isFull() {
      if (!this.root.data) {
        return false;
      }
      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
        this._addNextNodeToParent(this.node);
        return false;
      }
      const distantRelative = this._findParent(this.node, this.currentDepth);
      if (distantRelative) {
        this._addNextNodeToParent(distantRelative);
        return false;
      }
      return true;
    }
    /**
     * @param {TrickleDagNode} parent
     */
    _addNextNodeToParent(parent) {
      this.parent = parent;
      const nextNode = {
        children: [],
        depth: parent.depth + 1,
        parent,
        maxDepth: this.maxDepth,
        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
      };
      parent.children.push(nextNode);
      this.currentDepth = nextNode.depth;
      this.node = nextNode;
    }
    /**
     *
     * @param {InProgressImportResult[]} layer
     */
    append(layer) {
      this.node.data = layer;
    }
    /**
     * @param {Reducer} reduce
     */
    reduce(reduce) {
      return this._reduce(this.root, reduce);
    }
    /**
     * @param {TrickleDagNode} node
     * @param {Reducer} reduce
     * @returns {Promise<InProgressImportResult>}
     */
    async _reduce(node2, reduce) {
      let children = [];
      if (node2.children.length) {
        children = await Promise.all(
          node2.children.filter((child) => child.data).map((child) => this._reduce(child, reduce))
        );
      }
      return reduce((node2.data || []).concat(children));
    }
    /**
     * @param {TrickleDagNode} node
     * @param {number} depth
     * @returns {TrickleDagNode | undefined}
     */
    _findParent(node2, depth) {
      const parent = node2.parent;
      if (!parent || parent.depth === 0) {
        return;
      }
      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
        return this._findParent(parent, depth);
      }
      return parent;
    }
  }
  class Root extends SubTree {
    /**
     * @param {number} layerRepeat
     */
    constructor(layerRepeat) {
      super(0, layerRepeat);
      this.root.depth = 0;
      this.currentDepth = 1;
    }
    /**
     * @param {InProgressImportResult} child
     */
    addChild(child) {
      this.root.children.push(child);
    }
    /**
     * @param {Reducer} reduce
     */
    reduce(reduce) {
      return reduce((this.root.data || []).concat(this.root.children));
    }
  }
  return trickle;
}
var bufferImporter_1;
var hasRequiredBufferImporter;
function requireBufferImporter() {
  if (hasRequiredBufferImporter)
    return bufferImporter_1;
  hasRequiredBufferImporter = 1;
  const { UnixFS } = requireSrc$5();
  const persist = requirePersist();
  const {
    DAGNode
  } = requireSrc$2();
  async function* bufferImporter(file2, block, options2) {
    for await (let buffer2 of file2.content) {
      yield async () => {
        options2.progress(buffer2.length, file2.path);
        let unixfs2;
        const opts = {
          codec: "dag-pb",
          cidVersion: options2.cidVersion,
          hashAlg: options2.hashAlg,
          onlyHash: options2.onlyHash
        };
        if (options2.rawLeaves) {
          opts.codec = "raw";
          opts.cidVersion = 1;
        } else {
          unixfs2 = new UnixFS({
            type: options2.leafType,
            data: buffer2,
            mtime: file2.mtime,
            mode: file2.mode
          });
          buffer2 = new DAGNode(unixfs2.marshal()).serialize();
        }
        return {
          cid: await persist(buffer2, block, opts),
          unixfs: unixfs2,
          size: buffer2.length
        };
      };
    }
  }
  bufferImporter_1 = bufferImporter;
  return bufferImporter_1;
}
var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile)
    return file;
  hasRequiredFile = 1;
  const errCode$1 = errCode;
  const { UnixFS } = requireSrc$5();
  const persist = requirePersist();
  const {
    DAGNode,
    DAGLink
  } = requireSrc$2();
  const parallelBatch2 = itParallelBatch;
  const mh2 = src$9.multihash;
  const dagBuilders = {
    flat: requireFlat(),
    balanced: requireBalanced(),
    trickle: requireTrickle()
  };
  async function* buildFileBatch(file2, block, options2) {
    let count = -1;
    let previous;
    let bufferImporter;
    if (typeof options2.bufferImporter === "function") {
      bufferImporter = options2.bufferImporter;
    } else {
      bufferImporter = requireBufferImporter();
    }
    for await (const entry of parallelBatch2(bufferImporter(file2, block, options2), options2.blockWriteConcurrency)) {
      count++;
      if (count === 0) {
        previous = entry;
        continue;
      } else if (count === 1 && previous) {
        yield previous;
        previous = null;
      }
      yield entry;
    }
    if (previous) {
      previous.single = true;
      yield previous;
    }
  }
  const reduce = (file2, block, options2) => {
    async function reducer(leaves) {
      if (leaves.length === 1 && leaves[0].single && options2.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        if (leaf.cid.codec === "raw" && (file2.mtime !== void 0 || file2.mode !== void 0)) {
          let { data: buffer3 } = await block.get(leaf.cid, options2);
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file2.mtime,
            mode: file2.mode,
            data: buffer3
          });
          const multihash2 = mh2.decode(leaf.cid.multihash);
          buffer3 = new DAGNode(leaf.unixfs.marshal()).serialize();
          leaf.cid = await persist(buffer3, block, {
            ...options2,
            codec: "dag-pb",
            hashAlg: multihash2.name,
            cidVersion: options2.cidVersion
          });
          leaf.size = buffer3.length;
        }
        return {
          cid: leaf.cid,
          path: file2.path,
          unixfs: leaf.unixfs,
          size: leaf.size
        };
      }
      const f2 = new UnixFS({
        type: "file",
        mtime: file2.mtime,
        mode: file2.mode
      });
      const links = leaves.filter((leaf) => {
        if (leaf.cid.codec === "raw" && leaf.size) {
          return true;
        }
        if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true;
        }
        return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
      }).map((leaf) => {
        if (leaf.cid.codec === "raw") {
          f2.addBlockSize(leaf.size);
          return new DAGLink("", leaf.size, leaf.cid);
        }
        if (!leaf.unixfs || !leaf.unixfs.data) {
          f2.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
        } else {
          f2.addBlockSize(leaf.unixfs.data.length);
        }
        return new DAGLink("", leaf.size, leaf.cid);
      });
      const node2 = new DAGNode(f2.marshal(), links);
      const buffer2 = node2.serialize();
      const cid = await persist(buffer2, block, options2);
      return {
        cid,
        path: file2.path,
        unixfs: f2,
        size: buffer2.length + node2.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
      };
    }
    return reducer;
  };
  function fileBuilder(file2, block, options2) {
    const dagBuilder = dagBuilders[options2.strategy];
    if (!dagBuilder) {
      throw errCode$1(new Error(`Unknown importer build strategy name: ${options2.strategy}`), "ERR_BAD_STRATEGY");
    }
    return dagBuilder(buildFileBatch(file2, block, options2), reduce(file2, block, options2), options2);
  }
  file = fileBuilder;
  return file;
}
var BufferList_1;
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList)
    return BufferList_1;
  hasRequiredBufferList = 1;
  const { Buffer } = buffer;
  const symbol = Symbol.for("BufferList");
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
  }
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, { value: true });
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
  };
  BufferList.prototype._offset = function _offset(offset2) {
    if (offset2 === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i2 = 0; i2 < this._bufs.length; i2++) {
      const _t = tot + this._bufs[i2].length;
      if (offset2 < _t || i2 === this._bufs.length - 1) {
        return [i2, offset2 - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset2 = blOffset[1];
    for (let i2 = 0; i2 < bufferId; i2++) {
      offset2 += this._bufs[i2].length;
    }
    return offset2;
  };
  BufferList.prototype.get = function get2(index2) {
    if (index2 > this.length || index2 < 0) {
      return void 0;
    }
    const offset2 = this._offset(index2);
    return this._bufs[offset2[0]][offset2[1]];
  };
  BufferList.prototype.slice = function slice2(start2, end2) {
    if (typeof start2 === "number" && start2 < 0) {
      start2 += this.length;
    }
    if (typeof end2 === "number" && end2 < 0) {
      end2 += this.length;
    }
    return this.copy(null, 0, start2, end2);
  };
  BufferList.prototype.copy = function copy2(dst, dstStart, srcStart, srcEnd2) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd2 !== "number" || srcEnd2 > this.length) {
      srcEnd2 = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer.alloc(0);
    }
    if (srcEnd2 <= 0) {
      return dst || Buffer.alloc(0);
    }
    const copy3 = !!dst;
    const off = this._offset(srcStart);
    const len2 = srcEnd2 - srcStart;
    let bytes3 = len2;
    let bufoff = copy3 && dstStart || 0;
    let start2 = off[1];
    if (srcStart === 0 && srcEnd2 === this.length) {
      if (!copy3) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
      }
      for (let i2 = 0; i2 < this._bufs.length; i2++) {
        this._bufs[i2].copy(dst, bufoff);
        bufoff += this._bufs[i2].length;
      }
      return dst;
    }
    if (bytes3 <= this._bufs[off[0]].length - start2) {
      return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start2, start2 + bytes3) : this._bufs[off[0]].slice(start2, start2 + bytes3);
    }
    if (!copy3) {
      dst = Buffer.allocUnsafe(len2);
    }
    for (let i2 = off[0]; i2 < this._bufs.length; i2++) {
      const l2 = this._bufs[i2].length - start2;
      if (bytes3 > l2) {
        this._bufs[i2].copy(dst, bufoff, start2);
        bufoff += l2;
      } else {
        this._bufs[i2].copy(dst, bufoff, start2, start2 + bytes3);
        bufoff += l2;
        break;
      }
      bytes3 -= l2;
      if (start2) {
        start2 = 0;
      }
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start2, end2) {
    start2 = start2 || 0;
    end2 = typeof end2 !== "number" ? this.length : end2;
    if (start2 < 0) {
      start2 += this.length;
    }
    if (end2 < 0) {
      end2 += this.length;
    }
    if (start2 === end2) {
      return this._new();
    }
    const startOffset = this._offset(start2);
    const endOffset = this._offset(end2);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers.pop();
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
  };
  BufferList.prototype.toString = function toString3(encoding, start2, end2) {
    return this.slice(start2, end2).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes3) {
    bytes3 = Math.trunc(bytes3);
    if (Number.isNaN(bytes3) || bytes3 <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes3 >= this._bufs[0].length) {
        bytes3 -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes3);
        this.length -= bytes3;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    const copy2 = this._new();
    for (let i2 = 0; i2 < this._bufs.length; i2++) {
      copy2.append(this._bufs[i2]);
    }
    return copy2;
  };
  BufferList.prototype.append = function append3(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i2 = 0; i2 < buf.length; i2++) {
        this.append(buf[i2]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i2 = 0; i2 < buf._bufs.length; i2++) {
        this.append(buf._bufs[i2]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype.indexOf = function(search, offset2, encoding) {
    if (encoding === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      offset2 = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer.from([search]);
    } else if (typeof search === "string") {
      search = Buffer.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer.isBuffer(search)) {
      search = Buffer.from(search);
    }
    offset2 = Number(offset2 || 0);
    if (isNaN(offset2)) {
      offset2 = 0;
    }
    if (offset2 < 0) {
      offset2 = this.length + offset2;
    }
    if (offset2 < 0) {
      offset2 = 0;
    }
    if (search.length === 0) {
      return offset2 > this.length ? this.length : offset2;
    }
    const blOffset = this._offset(offset2);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset2, search) {
    if (this.length - offset2 < search.length) {
      return false;
    }
    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset2 + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m2 in methods) {
      (function(m3) {
        if (methods[m3] === null) {
          BufferList.prototype[m3] = function(offset2, byteLength2) {
            return this.slice(offset2, offset2 + byteLength2)[m3](0, byteLength2);
          };
        } else {
          BufferList.prototype[m3] = function(offset2 = 0) {
            return this.slice(offset2, offset2 + methods[m3])[m3](0);
          };
        }
      })(m2);
    }
  })();
  BufferList.prototype._isBufferList = function _isBufferList(b2) {
    return b2 instanceof BufferList || BufferList.isBufferList(b2);
  };
  BufferList.isBufferList = function isBufferList(b2) {
    return b2 != null && b2[symbol];
  };
  BufferList_1 = BufferList;
  return BufferList_1;
}
var rabin;
var hasRequiredRabin$1;
function requireRabin$1() {
  if (hasRequiredRabin$1)
    return rabin;
  hasRequiredRabin$1 = 1;
  class Rabin {
    /**
     * Creates an instance of Rabin.
     * @param { import("./../dist/rabin-wasm") } asModule
     * @param {number} [bits=12]
     * @param {number} [min=8 * 1024]
     * @param {number} [max=32 * 1024]
     * @param {number} polynomial
     * @memberof Rabin
     */
    constructor(asModule, bits = 12, min2 = 8 * 1024, max2 = 32 * 1024, windowSize = 64, polynomial) {
      this.bits = bits;
      this.min = min2;
      this.max = max2;
      this.asModule = asModule;
      this.rabin = new asModule.Rabin(bits, min2, max2, windowSize, polynomial);
      this.polynomial = polynomial;
    }
    /**
     * Fingerprints the buffer
     *
     * @param {Uint8Array} buf
     * @returns {Array<number>}
     * @memberof Rabin
     */
    fingerprint(buf) {
      const {
        __retain,
        __release,
        __allocArray,
        __getInt32Array,
        Int32Array_ID,
        Uint8Array_ID
      } = this.asModule;
      const lengths = new Int32Array(Math.ceil(buf.length / this.min));
      const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
      const pointer = __retain(__allocArray(Uint8Array_ID, buf));
      const out = this.rabin.fingerprint(pointer, lengthsPtr);
      const processed = __getInt32Array(out);
      __release(pointer);
      __release(lengthsPtr);
      const end2 = processed.indexOf(0);
      return end2 >= 0 ? processed.subarray(0, end2) : processed;
    }
  }
  rabin = Rabin;
  return rabin;
}
var loader = {};
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader)
    return loader;
  hasRequiredLoader = 1;
  const ID_OFFSET = -8;
  const SIZE_OFFSET = -4;
  const ARRAYBUFFER_ID = 0;
  const STRING_ID = 1;
  const ARRAYBUFFERVIEW = 1 << 0;
  const ARRAY = 1 << 1;
  const VAL_ALIGN_OFFSET = 5;
  const VAL_SIGNED = 1 << 10;
  const VAL_FLOAT = 1 << 11;
  const VAL_MANAGED = 1 << 13;
  const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
  const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
  const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
  const ARRAYBUFFERVIEW_SIZE = 12;
  const ARRAY_LENGTH_OFFSET = 12;
  const ARRAY_SIZE = 16;
  const BIGINT = typeof BigUint64Array !== "undefined";
  const THIS = Symbol();
  const CHUNKSIZE = 1024;
  function getStringImpl(buffer2, ptr) {
    const U32 = new Uint32Array(buffer2);
    const U16 = new Uint16Array(buffer2);
    var length2 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
    var offset2 = ptr >>> 1;
    if (length2 <= CHUNKSIZE)
      return String.fromCharCode.apply(String, U16.subarray(offset2, offset2 + length2));
    const parts = [];
    do {
      const last = U16[offset2 + CHUNKSIZE - 1];
      const size2 = last >= 55296 && last < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
      parts.push(String.fromCharCode.apply(String, U16.subarray(offset2, offset2 += size2)));
      length2 -= size2;
    } while (length2 > CHUNKSIZE);
    return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset2, offset2 + length2));
  }
  function preInstantiate(imports) {
    const baseModule = {};
    function getString(memory, ptr) {
      if (!memory)
        return "<yet unknown>";
      return getStringImpl(memory.buffer, ptr);
    }
    const env = imports.env = imports.env || {};
    env.abort = env.abort || function abort(mesg, file2, line2, colm) {
      const memory = baseModule.memory || env.memory;
      throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file2) + ":" + line2 + ":" + colm);
    };
    env.trace = env.trace || function trace(mesg, n2) {
      const memory = baseModule.memory || env.memory;
      console.log("trace: " + getString(memory, mesg) + (n2 ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n2).join(", "));
    };
    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return baseModule;
  }
  function postInstantiate(baseModule, instance) {
    const rawExports = instance.exports;
    const memory = rawExports.memory;
    const table = rawExports.table;
    const alloc2 = rawExports["__alloc"];
    const retain = rawExports["__retain"];
    const rttiBase = rawExports["__rtti_base"] || ~0;
    function getInfo(id2) {
      const U32 = new Uint32Array(memory.buffer);
      const count = U32[rttiBase >>> 2];
      if ((id2 >>>= 0) >= count)
        throw Error("invalid id: " + id2);
      return U32[(rttiBase + 4 >>> 2) + id2 * 2];
    }
    function getBase(id2) {
      const U32 = new Uint32Array(memory.buffer);
      const count = U32[rttiBase >>> 2];
      if ((id2 >>>= 0) >= count)
        throw Error("invalid id: " + id2);
      return U32[(rttiBase + 4 >>> 2) + id2 * 2 + 1];
    }
    function getValueAlign(info) {
      return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
    }
    function __allocString(str) {
      const length2 = str.length;
      const ptr = alloc2(length2 << 1, STRING_ID);
      const U16 = new Uint16Array(memory.buffer);
      for (var i2 = 0, p2 = ptr >>> 1; i2 < length2; ++i2)
        U16[p2 + i2] = str.charCodeAt(i2);
      return ptr;
    }
    baseModule.__allocString = __allocString;
    function __getString(ptr) {
      const buffer2 = memory.buffer;
      const id2 = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
      if (id2 !== STRING_ID)
        throw Error("not a string: " + ptr);
      return getStringImpl(buffer2, ptr);
    }
    baseModule.__getString = __getString;
    function getView(alignLog2, signed2, float2) {
      const buffer2 = memory.buffer;
      if (float2) {
        switch (alignLog2) {
          case 2:
            return new Float32Array(buffer2);
          case 3:
            return new Float64Array(buffer2);
        }
      } else {
        switch (alignLog2) {
          case 0:
            return new (signed2 ? Int8Array : Uint8Array)(buffer2);
          case 1:
            return new (signed2 ? Int16Array : Uint16Array)(buffer2);
          case 2:
            return new (signed2 ? Int32Array : Uint32Array)(buffer2);
          case 3:
            return new (signed2 ? BigInt64Array : BigUint64Array)(buffer2);
        }
      }
      throw Error("unsupported align: " + alignLog2);
    }
    function __allocArray(id2, values) {
      const info = getInfo(id2);
      if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
        throw Error("not an array: " + id2 + " @ " + info);
      const align = getValueAlign(info);
      const length2 = values.length;
      const buf = alloc2(length2 << align, ARRAYBUFFER_ID);
      const arr = alloc2(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id2);
      const U32 = new Uint32Array(memory.buffer);
      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);
      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length2 << align;
      if (info & ARRAY)
        U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length2;
      const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
      if (info & VAL_MANAGED) {
        for (let i2 = 0; i2 < length2; ++i2)
          view[(buf >>> align) + i2] = retain(values[i2]);
      } else {
        view.set(values, buf >>> align);
      }
      return arr;
    }
    baseModule.__allocArray = __allocArray;
    function __getArrayView(arr) {
      const U32 = new Uint32Array(memory.buffer);
      const id2 = U32[arr + ID_OFFSET >>> 2];
      const info = getInfo(id2);
      if (!(info & ARRAYBUFFERVIEW))
        throw Error("not an array: " + id2);
      const align = getValueAlign(info);
      var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      const length2 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
      return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length2);
    }
    baseModule.__getArrayView = __getArrayView;
    function __getArray(arr) {
      const input = __getArrayView(arr);
      const len2 = input.length;
      const out = new Array(len2);
      for (let i2 = 0; i2 < len2; i2++)
        out[i2] = input[i2];
      return out;
    }
    baseModule.__getArray = __getArray;
    function __getArrayBuffer(ptr) {
      const buffer2 = memory.buffer;
      const length2 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
      return buffer2.slice(ptr, ptr + length2);
    }
    baseModule.__getArrayBuffer = __getArrayBuffer;
    function getTypedArray(Type, alignLog2, ptr) {
      return new Type(getTypedArrayView(Type, alignLog2, ptr));
    }
    function getTypedArrayView(Type, alignLog2, ptr) {
      const buffer2 = memory.buffer;
      const U32 = new Uint32Array(buffer2);
      const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      return new Type(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
    }
    baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
    baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
    baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
    baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
    baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
    baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
    baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
    baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
    baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
    baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
    baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
    baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
    baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
    baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
    if (BIGINT) {
      baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
      baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
      baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
      baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
    }
    baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
    baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
    baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
    baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
    function __instanceof(ptr, baseId) {
      const U32 = new Uint32Array(memory.buffer);
      var id2 = U32[ptr + ID_OFFSET >>> 2];
      if (id2 <= U32[rttiBase >>> 2]) {
        do
          if (id2 == baseId)
            return true;
        while (id2 = getBase(id2));
      }
      return false;
    }
    baseModule.__instanceof = __instanceof;
    baseModule.memory = baseModule.memory || memory;
    baseModule.table = baseModule.table || table;
    return demangle(rawExports, baseModule);
  }
  function isResponse(o2) {
    return typeof Response !== "undefined" && o2 instanceof Response;
  }
  async function instantiate(source, imports) {
    if (isResponse(source = await source))
      return instantiateStreaming(source, imports);
    return postInstantiate(
      preInstantiate(imports || (imports = {})),
      await WebAssembly.instantiate(
        source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source),
        imports
      )
    );
  }
  loader.instantiate = instantiate;
  function instantiateSync(source, imports) {
    return postInstantiate(
      preInstantiate(imports || (imports = {})),
      new WebAssembly.Instance(
        source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
        imports
      )
    );
  }
  loader.instantiateSync = instantiateSync;
  async function instantiateStreaming(source, imports) {
    if (!WebAssembly.instantiateStreaming) {
      return instantiate(
        isResponse(source = await source) ? source.arrayBuffer() : source,
        imports
      );
    }
    return postInstantiate(
      preInstantiate(imports || (imports = {})),
      (await WebAssembly.instantiateStreaming(source, imports)).instance
    );
  }
  loader.instantiateStreaming = instantiateStreaming;
  function demangle(exports, baseModule) {
    var module = baseModule ? Object.create(baseModule) : {};
    var setArgumentsLength = exports["__argumentsLength"] ? function(length2) {
      exports["__argumentsLength"].value = length2;
    } : exports["__setArgumentsLength"] || exports["__setargc"] || function() {
    };
    for (let internalName in exports) {
      if (!Object.prototype.hasOwnProperty.call(exports, internalName))
        continue;
      const elem = exports[internalName];
      let parts = internalName.split(".");
      let curr = module;
      while (parts.length > 1) {
        let part = parts.shift();
        if (!Object.prototype.hasOwnProperty.call(curr, part))
          curr[part] = {};
        curr = curr[part];
      }
      let name2 = parts[0];
      let hash2 = name2.indexOf("#");
      if (hash2 >= 0) {
        let className = name2.substring(0, hash2);
        let classElem = curr[className];
        if (typeof classElem === "undefined" || !classElem.prototype) {
          let ctor = function(...args) {
            return ctor.wrap(ctor.prototype.constructor(0, ...args));
          };
          ctor.prototype = {
            valueOf: function valueOf() {
              return this[THIS];
            }
          };
          ctor.wrap = function(thisValue) {
            return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
          };
          if (classElem)
            Object.getOwnPropertyNames(classElem).forEach(
              (name3) => Object.defineProperty(ctor, name3, Object.getOwnPropertyDescriptor(classElem, name3))
            );
          curr[className] = ctor;
        }
        name2 = name2.substring(hash2 + 1);
        curr = curr[className].prototype;
        if (/^(get|set):/.test(name2)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
            let getter = exports[internalName.replace("set:", "get:")];
            let setter = exports[internalName.replace("get:", "set:")];
            Object.defineProperty(curr, name2, {
              get: function() {
                return getter(this[THIS]);
              },
              set: function(value) {
                setter(this[THIS], value);
              },
              enumerable: true
            });
          }
        } else {
          if (name2 === "constructor") {
            (curr[name2] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            (curr[name2] = function(...args) {
              setArgumentsLength(args.length);
              return elem(this[THIS], ...args);
            }).original = elem;
          }
        }
      } else {
        if (/^(get|set):/.test(name2)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name2 = name2.substring(4))) {
            Object.defineProperty(curr, name2, {
              get: exports[internalName.replace("set:", "get:")],
              set: exports[internalName.replace("get:", "set:")],
              enumerable: true
            });
          }
        } else if (typeof elem === "function" && elem !== setArgumentsLength) {
          (curr[name2] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          curr[name2] = elem;
        }
      }
    }
    return module;
  }
  loader.demangle = demangle;
  return loader;
}
var rabinWasm;
var hasRequiredRabinWasm;
function requireRabinWasm() {
  if (hasRequiredRabinWasm)
    return rabinWasm;
  hasRequiredRabinWasm = 1;
  const { instantiate } = requireLoader();
  loadWebAssembly.supported = typeof WebAssembly !== "undefined";
  function loadWebAssembly(imp = {}) {
    if (!loadWebAssembly.supported)
      return null;
    var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
    return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
  }
  rabinWasm = loadWebAssembly;
  return rabinWasm;
}
var src$4;
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1)
    return src$4;
  hasRequiredSrc$1 = 1;
  const Rabin = requireRabin$1();
  const getRabin = requireRabinWasm();
  const create2 = async (avg, min2, max2, windowSize, polynomial) => {
    const compiled = await getRabin();
    return new Rabin(compiled, avg, min2, max2, windowSize, polynomial);
  };
  src$4 = {
    Rabin,
    create: create2
  };
  return src$4;
}
var rabin_1;
var hasRequiredRabin;
function requireRabin() {
  if (hasRequiredRabin)
    return rabin_1;
  hasRequiredRabin = 1;
  const BufferList = requireBufferList();
  const { create: create2 } = requireSrc$1();
  const errcode2 = errCode;
  rabin_1 = async function* rabinChunker(source, options2) {
    let min2, max2, avg;
    if (options2.minChunkSize && options2.maxChunkSize && options2.avgChunkSize) {
      avg = options2.avgChunkSize;
      min2 = options2.minChunkSize;
      max2 = options2.maxChunkSize;
    } else if (!options2.avgChunkSize) {
      throw errcode2(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
    } else {
      avg = options2.avgChunkSize;
      min2 = avg / 3;
      max2 = avg + avg / 2;
    }
    if (min2 < 16) {
      throw errcode2(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
    }
    if (max2 < min2) {
      max2 = min2;
    }
    if (avg < min2) {
      avg = min2;
    }
    const sizepow = Math.floor(Math.log2(avg));
    for await (const chunk of rabin2(source, {
      min: min2,
      max: max2,
      bits: sizepow,
      window: options2.window,
      polynomial: options2.polynomial
    })) {
      yield chunk;
    }
  };
  async function* rabin2(source, options2) {
    const r2 = await create2(options2.bits, options2.min, options2.max, options2.window);
    const buffers = new BufferList();
    for await (const chunk of source) {
      buffers.append(chunk);
      const sizes2 = r2.fingerprint(chunk);
      for (let i2 = 0; i2 < sizes2.length; i2++) {
        const size2 = sizes2[i2];
        const buf = buffers.slice(0, size2);
        buffers.consume(size2);
        yield buf;
      }
    }
    if (buffers.length) {
      yield buffers.slice(0);
    }
  }
  return rabin_1;
}
var fixedSize;
var hasRequiredFixedSize;
function requireFixedSize() {
  if (hasRequiredFixedSize)
    return fixedSize;
  hasRequiredFixedSize = 1;
  const BufferList = requireBufferList();
  fixedSize = async function* fixedSizeChunker(source, options2) {
    let bl2 = new BufferList();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options2.maxChunkSize;
    for await (const buffer2 of source) {
      bl2.append(buffer2);
      currentLength += buffer2.length;
      while (currentLength >= maxChunkSize) {
        yield bl2.slice(0, maxChunkSize);
        emitted = true;
        if (maxChunkSize === bl2.length) {
          bl2 = new BufferList();
          currentLength = 0;
        } else {
          const newBl = new BufferList();
          newBl.append(bl2.shallowSlice(maxChunkSize));
          bl2 = newBl;
          currentLength -= maxChunkSize;
        }
      }
    }
    if (!emitted || currentLength) {
      yield bl2.slice(0, currentLength);
    }
  };
  return fixedSize;
}
var bases_1;
var hasRequiredBases;
function requireBases() {
  if (hasRequiredBases)
    return bases_1;
  hasRequiredBases = 1;
  const { bases: bases2 } = require$$0$3;
  function createCodec2(name2, prefix2, encode3, decode2) {
    return {
      name: name2,
      prefix: prefix2,
      encoder: {
        name: name2,
        prefix: prefix2,
        encode: encode3
      },
      decoder: {
        decode: decode2
      }
    };
  }
  const string2 = createCodec2("utf8", "u", (buf) => {
    const decoder2 = new TextDecoder("utf8");
    return "u" + decoder2.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  const ascii2 = createCodec2("ascii", "a", (buf) => {
    let string3 = "a";
    for (let i2 = 0; i2 < buf.length; i2++) {
      string3 += String.fromCharCode(buf[i2]);
    }
    return string3;
  }, (str) => {
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for (let i2 = 0; i2 < str.length; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  });
  const BASES2 = {
    "utf8": string2,
    "utf-8": string2,
    "hex": bases2.base16,
    "latin1": ascii2,
    "ascii": ascii2,
    "binary": ascii2,
    ...bases2
  };
  bases_1 = BASES2;
  return bases_1;
}
var fromString_1;
var hasRequiredFromString;
function requireFromString() {
  if (hasRequiredFromString)
    return fromString_1;
  hasRequiredFromString = 1;
  const bases2 = requireBases();
  function fromString2(string2, encoding = "utf8") {
    const base3 = bases2[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }
  fromString_1 = fromString2;
  return fromString_1;
}
var validateChunks_1;
var hasRequiredValidateChunks;
function requireValidateChunks() {
  if (hasRequiredValidateChunks)
    return validateChunks_1;
  hasRequiredValidateChunks = 1;
  const errCode$1 = errCode;
  const uint8ArrayFromString2 = requireFromString();
  async function* validateChunks(source) {
    for await (const content of source) {
      if (content.length === void 0) {
        throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
      if (typeof content === "string" || content instanceof String) {
        yield uint8ArrayFromString2(content.toString());
      } else if (Array.isArray(content)) {
        yield Uint8Array.from(content);
      } else if (content instanceof Uint8Array) {
        yield content;
      } else {
        throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
    }
  }
  validateChunks_1 = validateChunks;
  return validateChunks_1;
}
var dagBuilder_1;
var hasRequiredDagBuilder;
function requireDagBuilder() {
  if (hasRequiredDagBuilder)
    return dagBuilder_1;
  hasRequiredDagBuilder = 1;
  const dirBuilder = requireDir$1();
  const fileBuilder = requireFile();
  const errCode$1 = errCode;
  function isIterable(thing) {
    return Symbol.iterator in thing;
  }
  function isAsyncIterable(thing) {
    return Symbol.asyncIterator in thing;
  }
  function contentAsAsyncIterable(content) {
    try {
      if (content instanceof Uint8Array) {
        return async function* () {
          yield content;
        }();
      } else if (isIterable(content)) {
        return async function* () {
          yield* content;
        }();
      } else if (isAsyncIterable(content)) {
        return content;
      }
    } catch {
      throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  async function* dagBuilder(source, block, options2) {
    for await (const entry of source) {
      if (entry.path) {
        if (entry.path.substring(0, 2) === "./") {
          options2.wrapWithDirectory = true;
        }
        entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
      }
      if (entry.content) {
        let chunker;
        if (typeof options2.chunker === "function") {
          chunker = options2.chunker;
        } else if (options2.chunker === "rabin") {
          chunker = requireRabin();
        } else {
          chunker = requireFixedSize();
        }
        let chunkValidator;
        if (typeof options2.chunkValidator === "function") {
          chunkValidator = options2.chunkValidator;
        } else {
          chunkValidator = requireValidateChunks();
        }
        const file2 = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options2), options2)
        };
        yield () => fileBuilder(file2, block, options2);
      } else if (entry.path) {
        const dir2 = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode
        };
        yield () => dirBuilder(dir2, block, options2);
      } else {
        throw new Error("Import candidate must have content or path or both");
      }
    }
  }
  dagBuilder_1 = dagBuilder;
  return dagBuilder_1;
}
var dir;
var hasRequiredDir;
function requireDir() {
  if (hasRequiredDir)
    return dir;
  hasRequiredDir = 1;
  class Dir {
    /**
     *
     * @param {DirProps} props
     * @param {ImporterOptions} options
     */
    constructor(props, options2) {
      this.options = options2 || {};
      this.root = props.root;
      this.dir = props.dir;
      this.path = props.path;
      this.dirty = props.dirty;
      this.flat = props.flat;
      this.parent = props.parent;
      this.parentKey = props.parentKey;
      this.unixfs = props.unixfs;
      this.mode = props.mode;
      this.mtime = props.mtime;
      this.cid = void 0;
      this.size = void 0;
    }
    /**
     * @param {string} name
     * @param {InProgressImportResult | Dir} value
     */
    async put(name2, value) {
    }
    /**
     * @param {string} name
     * @returns {Promise<InProgressImportResult | Dir | undefined>}
     */
    get(name2) {
      return Promise.resolve(this);
    }
    /**
     * @returns {AsyncIterable<{ key: string, child: InProgressImportResult | Dir}>}
     */
    async *eachChildSeries() {
    }
    /**
     * @param {BlockAPI} block
     * @returns {AsyncIterable<ImportResult>}
     */
    async *flush(block) {
    }
  }
  dir = Dir;
  return dir;
}
var dirFlat;
var hasRequiredDirFlat;
function requireDirFlat() {
  if (hasRequiredDirFlat)
    return dirFlat;
  hasRequiredDirFlat = 1;
  const {
    DAGLink,
    DAGNode
  } = requireSrc$2();
  const { UnixFS } = requireSrc$5();
  const Dir = requireDir();
  const persist = requirePersist();
  class DirFlat extends Dir {
    /**
     * @param {DirProps} props
     * @param {ImporterOptions} options
     */
    constructor(props, options2) {
      super(props, options2);
      this._children = {};
    }
    /**
     * @param {string} name
     * @param {InProgressImportResult | Dir} value
     */
    async put(name2, value) {
      this.cid = void 0;
      this.size = void 0;
      this._children[name2] = value;
    }
    /**
     * @param {string} name
     */
    get(name2) {
      return Promise.resolve(this._children[name2]);
    }
    childCount() {
      return Object.keys(this._children).length;
    }
    directChildrenCount() {
      return this.childCount();
    }
    onlyChild() {
      return this._children[Object.keys(this._children)[0]];
    }
    async *eachChildSeries() {
      const keys2 = Object.keys(this._children);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const key2 = keys2[i2];
        yield {
          key: key2,
          child: this._children[key2]
        };
      }
    }
    /**
     * @param {BlockAPI} block
     * @returns {AsyncIterable<ImportResult>}
     */
    async *flush(block) {
      const children = Object.keys(this._children);
      const links = [];
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = this._children[children[i2]];
        if (child instanceof Dir) {
          for await (const entry of child.flush(block)) {
            child = entry;
            yield child;
          }
        }
        if (child.size != null && child.cid) {
          links.push(new DAGLink(children[i2], child.size, child.cid));
        }
      }
      const unixfs2 = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node2 = new DAGNode(unixfs2.marshal(), links);
      const buffer2 = node2.serialize();
      const cid = await persist(buffer2, block, this.options);
      const size2 = buffer2.length + node2.Links.reduce(
        /**
         * @param {number} acc
         * @param {DAGLink} curr
         */
        (acc, curr) => acc + curr.Tsize,
        0
      );
      this.cid = cid;
      this.size = size2;
      yield {
        cid,
        unixfs: unixfs2,
        path: this.path,
        size: size2
      };
    }
  }
  dirFlat = DirFlat;
  return dirFlat;
}
var sparseArray;
var hasRequiredSparseArray;
function requireSparseArray() {
  if (hasRequiredSparseArray)
    return sparseArray;
  hasRequiredSparseArray = 1;
  const BITS_PER_BYTE = 7;
  sparseArray = class SparseArray {
    constructor() {
      this._bitArrays = [];
      this._data = [];
      this._length = 0;
      this._changedLength = false;
      this._changedData = false;
    }
    set(index2, value) {
      let pos = this._internalPositionFor(index2, false);
      if (value === void 0) {
        if (pos !== -1) {
          this._unsetInternalPos(pos);
          this._unsetBit(index2);
          this._changedLength = true;
          this._changedData = true;
        }
      } else {
        let needsSort = false;
        if (pos === -1) {
          pos = this._data.length;
          this._setBit(index2);
          this._changedData = true;
        } else {
          needsSort = true;
        }
        this._setInternalPos(pos, index2, value, needsSort);
        this._changedLength = true;
      }
    }
    unset(index2) {
      this.set(index2, void 0);
    }
    get(index2) {
      this._sortData();
      const pos = this._internalPositionFor(index2, true);
      if (pos === -1) {
        return void 0;
      }
      return this._data[pos][1];
    }
    push(value) {
      this.set(this.length, value);
      return this.length;
    }
    get length() {
      this._sortData();
      if (this._changedLength) {
        const last = this._data[this._data.length - 1];
        this._length = last ? last[0] + 1 : 0;
        this._changedLength = false;
      }
      return this._length;
    }
    forEach(iterator) {
      let i2 = 0;
      while (i2 < this.length) {
        iterator(this.get(i2), i2, this);
        i2++;
      }
    }
    map(iterator) {
      let i2 = 0;
      let mapped = new Array(this.length);
      while (i2 < this.length) {
        mapped[i2] = iterator(this.get(i2), i2, this);
        i2++;
      }
      return mapped;
    }
    reduce(reducer, initialValue) {
      let i2 = 0;
      let acc = initialValue;
      while (i2 < this.length) {
        const value = this.get(i2);
        acc = reducer(acc, value, i2);
        i2++;
      }
      return acc;
    }
    find(finder) {
      let i2 = 0, found, last;
      while (i2 < this.length && !found) {
        last = this.get(i2);
        found = finder(last);
        i2++;
      }
      return found ? last : void 0;
    }
    _internalPositionFor(index2, noCreate) {
      const bytePos = this._bytePosFor(index2, noCreate);
      if (bytePos >= this._bitArrays.length) {
        return -1;
      }
      const byte = this._bitArrays[bytePos];
      const bitPos = index2 - bytePos * BITS_PER_BYTE;
      const exists = (byte & 1 << bitPos) > 0;
      if (!exists) {
        return -1;
      }
      const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
      const mask = ~(4294967295 << bitPos + 1);
      const bytePopCount = popCount(byte & mask);
      const arrayPos = previousPopCount + bytePopCount - 1;
      return arrayPos;
    }
    _bytePosFor(index2, noCreate) {
      const bytePos = Math.floor(index2 / BITS_PER_BYTE);
      const targetLength = bytePos + 1;
      while (!noCreate && this._bitArrays.length < targetLength) {
        this._bitArrays.push(0);
      }
      return bytePos;
    }
    _setBit(index2) {
      const bytePos = this._bytePosFor(index2, false);
      this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
    }
    _unsetBit(index2) {
      const bytePos = this._bytePosFor(index2, false);
      this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
    }
    _setInternalPos(pos, index2, value, needsSort) {
      const data = this._data;
      const elem = [index2, value];
      if (needsSort) {
        this._sortData();
        data[pos] = elem;
      } else {
        if (data.length) {
          if (data[data.length - 1][0] >= index2) {
            data.push(elem);
          } else if (data[0][0] <= index2) {
            data.unshift(elem);
          } else {
            const randomIndex = Math.round(data.length / 2);
            this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
          }
        } else {
          this._data.push(elem);
        }
        this._changedData = true;
        this._changedLength = true;
      }
    }
    _unsetInternalPos(pos) {
      this._data.splice(pos, 1);
    }
    _sortData() {
      if (this._changedData) {
        this._data.sort(sortInternal);
      }
      this._changedData = false;
    }
    bitField() {
      const bytes3 = [];
      let pendingBitsForResultingByte = 8;
      let pendingBitsForNewByte = 0;
      let resultingByte = 0;
      let newByte;
      const pending = this._bitArrays.slice();
      while (pending.length || pendingBitsForNewByte) {
        if (pendingBitsForNewByte === 0) {
          newByte = pending.shift();
          pendingBitsForNewByte = 7;
        }
        const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
        const mask = ~(255 << usingBits);
        const masked = newByte & mask;
        resultingByte |= masked << 8 - pendingBitsForResultingByte;
        newByte = newByte >>> usingBits;
        pendingBitsForNewByte -= usingBits;
        pendingBitsForResultingByte -= usingBits;
        if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
          bytes3.push(resultingByte);
          resultingByte = 0;
          pendingBitsForResultingByte = 8;
        }
      }
      for (var i2 = bytes3.length - 1; i2 > 0; i2--) {
        const value = bytes3[i2];
        if (value === 0) {
          bytes3.pop();
        } else {
          break;
        }
      }
      return bytes3;
    }
    compactArray() {
      this._sortData();
      return this._data.map(valueOnly);
    }
  };
  function popCountReduce(count, byte) {
    return count + popCount(byte);
  }
  function popCount(_v) {
    let v2 = _v;
    v2 = v2 - (v2 >> 1 & 1431655765);
    v2 = (v2 & 858993459) + (v2 >> 2 & 858993459);
    return (v2 + (v2 >> 4) & 252645135) * 16843009 >> 24;
  }
  function sortInternal(a2, b2) {
    return a2[0] - b2[0];
  }
  function valueOnly(elem) {
    return elem[1];
  }
  return sparseArray;
}
var bucket;
var hasRequiredBucket;
function requireBucket() {
  if (hasRequiredBucket)
    return bucket;
  hasRequiredBucket = 1;
  const SparseArray = requireSparseArray();
  const { fromString: uint8ArrayFromString2 } = require$$1$3;
  class Bucket {
    /**
     * @param {BucketOptions} options
     * @param {Bucket<T>} [parent]
     * @param {number} [posAtParent=0]
     */
    constructor(options2, parent, posAtParent = 0) {
      this._options = options2;
      this._popCount = 0;
      this._parent = parent;
      this._posAtParent = posAtParent;
      this._children = new SparseArray();
      this.key = null;
    }
    /**
     * @param {string} key
     * @param {T} value
     */
    async put(key2, value) {
      const place = await this._findNewBucketAndPos(key2);
      await place.bucket._putAt(place, key2, value);
    }
    /**
     * @param {string} key
     */
    async get(key2) {
      const child = await this._findChild(key2);
      if (child) {
        return child.value;
      }
    }
    /**
     * @param {string} key
     */
    async del(key2) {
      const place = await this._findPlace(key2);
      const child = place.bucket._at(place.pos);
      if (child && child.key === key2) {
        place.bucket._delAt(place.pos);
      }
    }
    /**
     * @returns {number}
     */
    leafCount() {
      const children = this._children.compactArray();
      return children.reduce((acc, child) => {
        if (child instanceof Bucket) {
          return acc + child.leafCount();
        }
        return acc + 1;
      }, 0);
    }
    childrenCount() {
      return this._children.length;
    }
    onlyChild() {
      return this._children.get(0);
    }
    /**
     * @returns {Iterable<BucketChild<T>>}
     */
    *eachLeafSeries() {
      const children = this._children.compactArray();
      for (const child of children) {
        if (child instanceof Bucket) {
          yield* child.eachLeafSeries();
        } else {
          yield child;
        }
      }
      return [];
    }
    /**
     * @param {(value: BucketChild<T>, index: number) => T} map
     * @param {(reduced: any) => any} reduce
     */
    serialize(map, reduce) {
      const acc = [];
      return reduce(this._children.reduce((acc2, child, index2) => {
        if (child) {
          if (child instanceof Bucket) {
            acc2.push(child.serialize(map, reduce));
          } else {
            acc2.push(map(child, index2));
          }
        }
        return acc2;
      }, acc));
    }
    /**
     * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
     * @param {(reduced: any) => Promise<any>} asyncReduce
     */
    asyncTransform(asyncMap, asyncReduce) {
      return asyncTransformBucket(this, asyncMap, asyncReduce);
    }
    toJSON() {
      return this.serialize(mapNode, reduceNodes);
    }
    prettyPrint() {
      return JSON.stringify(this.toJSON(), null, "  ");
    }
    tableSize() {
      return Math.pow(2, this._options.bits);
    }
    /**
     * @param {string} key
     * @returns {Promise<BucketChild<T> | undefined>}
     */
    async _findChild(key2) {
      const result = await this._findPlace(key2);
      const child = result.bucket._at(result.pos);
      if (child instanceof Bucket) {
        return void 0;
      }
      if (child && child.key === key2) {
        return child;
      }
    }
    /**
     * @param {string | InfiniteHash} key
     * @returns {Promise<BucketPosition<T>>}
     */
    async _findPlace(key2) {
      const hashValue = this._options.hash(typeof key2 === "string" ? uint8ArrayFromString2(key2) : key2);
      const index2 = await hashValue.take(this._options.bits);
      const child = this._children.get(index2);
      if (child instanceof Bucket) {
        return child._findPlace(hashValue);
      }
      return {
        bucket: this,
        pos: index2,
        hash: hashValue,
        existingChild: child
      };
    }
    /**
     * @param {string | InfiniteHash} key
     * @returns {Promise<BucketPosition<T>>}
     */
    async _findNewBucketAndPos(key2) {
      const place = await this._findPlace(key2);
      if (place.existingChild && place.existingChild.key !== key2) {
        const bucket2 = new Bucket(this._options, place.bucket, place.pos);
        place.bucket._putObjectAt(place.pos, bucket2);
        const newPlace = await bucket2._findPlace(place.existingChild.hash);
        newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
        return bucket2._findNewBucketAndPos(place.hash);
      }
      return place;
    }
    /**
     * @param {BucketPosition<T>} place
     * @param {string} key
     * @param {T} value
     */
    _putAt(place, key2, value) {
      this._putObjectAt(place.pos, {
        key: key2,
        value,
        hash: place.hash
      });
    }
    /**
     * @param {number} pos
     * @param {Bucket<T> | BucketChild<T>} object
     */
    _putObjectAt(pos, object) {
      if (!this._children.get(pos)) {
        this._popCount++;
      }
      this._children.set(pos, object);
    }
    /**
     * @param {number} pos
     */
    _delAt(pos) {
      if (pos === -1) {
        throw new Error("Invalid position");
      }
      if (this._children.get(pos)) {
        this._popCount--;
      }
      this._children.unset(pos);
      this._level();
    }
    _level() {
      if (this._parent && this._popCount <= 1) {
        if (this._popCount === 1) {
          const onlyChild = this._children.find(exists);
          if (onlyChild && !(onlyChild instanceof Bucket)) {
            const hash2 = onlyChild.hash;
            hash2.untake(this._options.bits);
            const place = {
              pos: this._posAtParent,
              hash: hash2,
              bucket: this._parent
            };
            this._parent._putAt(place, onlyChild.key, onlyChild.value);
          }
        } else {
          this._parent._delAt(this._posAtParent);
        }
      }
    }
    /**
     * @param {number} index
     * @returns {BucketChild<T> | Bucket<T> | undefined}
     */
    _at(index2) {
      return this._children.get(index2);
    }
  }
  function exists(o2) {
    return Boolean(o2);
  }
  function mapNode(node2, index2) {
    return node2.key;
  }
  function reduceNodes(nodes) {
    return nodes;
  }
  async function asyncTransformBucket(bucket2, asyncMap, asyncReduce) {
    const output = [];
    for (const child of bucket2._children.compactArray()) {
      if (child instanceof Bucket) {
        await asyncTransformBucket(child, asyncMap, asyncReduce);
      } else {
        const mappedChildren = await asyncMap(child);
        output.push({
          bitField: bucket2._children.bitField(),
          children: mappedChildren
        });
      }
    }
    return asyncReduce(output);
  }
  bucket = Bucket;
  return bucket;
}
var consumableHash = { exports: {} };
var consumableBuffer;
var hasRequiredConsumableBuffer;
function requireConsumableBuffer() {
  if (hasRequiredConsumableBuffer)
    return consumableBuffer;
  hasRequiredConsumableBuffer = 1;
  const START_MASKS = [
    255,
    254,
    252,
    248,
    240,
    224,
    192,
    128
  ];
  const STOP_MASKS = [
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255
  ];
  consumableBuffer = class ConsumableBuffer {
    /**
     * @param {Uint8Array} value
     */
    constructor(value) {
      this._value = value;
      this._currentBytePos = value.length - 1;
      this._currentBitPos = 7;
    }
    availableBits() {
      return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
      return this._value.length * 8;
    }
    /**
     * @param {number} bits
     */
    take(bits) {
      let pendingBits = bits;
      let result = 0;
      while (pendingBits && this._haveBits()) {
        const byte = this._value[this._currentBytePos];
        const availableBits = this._currentBitPos + 1;
        const taking = Math.min(availableBits, pendingBits);
        const value = byteBitsToInt(byte, availableBits - taking, taking);
        result = (result << taking) + value;
        pendingBits -= taking;
        this._currentBitPos -= taking;
        if (this._currentBitPos < 0) {
          this._currentBitPos = 7;
          this._currentBytePos--;
        }
      }
      return result;
    }
    /**
     * @param {number} bits
     */
    untake(bits) {
      this._currentBitPos += bits;
      while (this._currentBitPos > 7) {
        this._currentBitPos -= 8;
        this._currentBytePos += 1;
      }
    }
    _haveBits() {
      return this._currentBytePos >= 0;
    }
  };
  function byteBitsToInt(byte, start2, length2) {
    const mask = maskFor(start2, length2);
    return (byte & mask) >>> start2;
  }
  function maskFor(start2, length2) {
    return START_MASKS[start2] & STOP_MASKS[Math.min(length2 + start2 - 1, 7)];
  }
  return consumableBuffer;
}
var hasRequiredConsumableHash;
function requireConsumableHash() {
  if (hasRequiredConsumableHash)
    return consumableHash.exports;
  hasRequiredConsumableHash = 1;
  const ConsumableBuffer = requireConsumableBuffer();
  const { concat: uint8ArrayConcat2 } = require$$1$2;
  function wrapHash(hashFn) {
    function hashing(value) {
      if (value instanceof InfiniteHash) {
        return value;
      } else {
        return new InfiniteHash(value, hashFn);
      }
    }
    return hashing;
  }
  class InfiniteHash {
    /**
     *
     * @param {Uint8Array} value
     * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
     */
    constructor(value, hashFn) {
      if (!(value instanceof Uint8Array)) {
        throw new Error("can only hash Uint8Arrays");
      }
      this._value = value;
      this._hashFn = hashFn;
      this._depth = -1;
      this._availableBits = 0;
      this._currentBufferIndex = 0;
      this._buffers = [];
    }
    /**
     * @param {number} bits
     */
    async take(bits) {
      let pendingBits = bits;
      while (this._availableBits < pendingBits) {
        await this._produceMoreBits();
      }
      let result = 0;
      while (pendingBits > 0) {
        const hash2 = this._buffers[this._currentBufferIndex];
        const available = Math.min(hash2.availableBits(), pendingBits);
        const took = hash2.take(available);
        result = (result << available) + took;
        pendingBits -= available;
        this._availableBits -= available;
        if (hash2.availableBits() === 0) {
          this._currentBufferIndex++;
        }
      }
      return result;
    }
    /**
     * @param {number} bits
     */
    untake(bits) {
      let pendingBits = bits;
      while (pendingBits > 0) {
        const hash2 = this._buffers[this._currentBufferIndex];
        const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
        hash2.untake(availableForUntake);
        pendingBits -= availableForUntake;
        this._availableBits += availableForUntake;
        if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
          this._depth--;
          this._currentBufferIndex--;
        }
      }
    }
    async _produceMoreBits() {
      this._depth++;
      const value = this._depth ? uint8ArrayConcat2([this._value, Uint8Array.from([this._depth])]) : this._value;
      const hashValue = await this._hashFn(value);
      const buffer2 = new ConsumableBuffer(hashValue);
      this._buffers.push(buffer2);
      this._availableBits += buffer2.availableBits();
    }
  }
  consumableHash.exports = wrapHash;
  consumableHash.exports.InfiniteHash = InfiniteHash;
  return consumableHash.exports;
}
var src$3;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src$3;
  hasRequiredSrc = 1;
  const Bucket = requireBucket();
  const wrapHash = requireConsumableHash();
  function createHAMT(options2) {
    if (!options2 || !options2.hashFn) {
      throw new Error("please define an options.hashFn");
    }
    const bucketOptions = {
      bits: options2.bits || 8,
      hash: wrapHash(options2.hashFn)
    };
    return new Bucket(bucketOptions);
  }
  src$3 = {
    createHAMT,
    Bucket
  };
  return src$3;
}
var dirSharded;
var hasRequiredDirSharded;
function requireDirSharded() {
  if (hasRequiredDirSharded)
    return dirSharded;
  hasRequiredDirSharded = 1;
  const {
    DAGLink,
    DAGNode
  } = requireSrc$2();
  const { UnixFS } = requireSrc$5();
  const Dir = requireDir();
  const persist = requirePersist();
  const { createHAMT, Bucket } = requireSrc();
  class DirSharded extends Dir {
    /**
     * @param {DirProps} props
     * @param {ImporterOptions} options
     */
    constructor(props, options2) {
      super(props, options2);
      this._bucket = createHAMT({
        hashFn: options2.hamtHashFn,
        bits: options2.hamtBucketBits
      });
    }
    /**
     * @param {string} name
     * @param {InProgressImportResult | Dir} value
     */
    async put(name2, value) {
      await this._bucket.put(name2, value);
    }
    /**
     * @param {string} name
     */
    get(name2) {
      return this._bucket.get(name2);
    }
    childCount() {
      return this._bucket.leafCount();
    }
    directChildrenCount() {
      return this._bucket.childrenCount();
    }
    onlyChild() {
      return this._bucket.onlyChild();
    }
    async *eachChildSeries() {
      for await (const { key: key2, value } of this._bucket.eachLeafSeries()) {
        yield {
          key: key2,
          child: value
        };
      }
    }
    /**
     * @param {BlockAPI} block
     * @returns {AsyncIterable<ImportResult>}
     */
    async *flush(block) {
      for await (const entry of flush(this._bucket, block, this, this.options)) {
        yield {
          ...entry,
          path: this.path
        };
      }
    }
  }
  dirSharded = DirSharded;
  async function* flush(bucket2, block, shardRoot, options2) {
    const children = bucket2._children;
    const links = [];
    let childrenSize = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children.get(i2);
      if (!child) {
        continue;
      }
      const labelPrefix = i2.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof Bucket) {
        let shard;
        for await (const subShard of await flush(child, block, null, options2)) {
          shard = subShard;
        }
        if (!shard) {
          throw new Error("Could not flush sharded directory, no subshard found");
        }
        links.push(new DAGLink(labelPrefix, shard.size, shard.cid));
        childrenSize += shard.size;
      } else if (typeof child.value.flush === "function") {
        const dir3 = child.value;
        let flushedDir;
        for await (const entry of dir3.flush(block)) {
          flushedDir = entry;
          yield flushedDir;
        }
        const label = labelPrefix + child.key;
        links.push(new DAGLink(label, flushedDir.size, flushedDir.cid));
        childrenSize += flushedDir.size;
      } else {
        const value = child.value;
        if (!value.cid) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size3 = value.size;
        links.push(new DAGLink(label, size3, value.cid));
        childrenSize += size3;
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir2 = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket2.tableSize(),
      hashType: options2.hamtHashCode,
      mtime: shardRoot && shardRoot.mtime,
      mode: shardRoot && shardRoot.mode
    });
    const node2 = new DAGNode(dir2.marshal(), links);
    const buffer2 = node2.serialize();
    const cid = await persist(buffer2, block, options2);
    const size2 = buffer2.length + childrenSize;
    yield {
      cid,
      unixfs: dir2,
      size: size2
    };
  }
  return dirSharded;
}
var flatToShard;
var hasRequiredFlatToShard;
function requireFlatToShard() {
  if (hasRequiredFlatToShard)
    return flatToShard;
  hasRequiredFlatToShard = 1;
  const DirSharded = requireDirSharded();
  const DirFlat = requireDirFlat();
  flatToShard = async function flatToShard2(child, dir2, threshold, options2) {
    let newDir = dir2;
    if (dir2 instanceof DirFlat && dir2.directChildrenCount() >= threshold) {
      newDir = await convertToShard(dir2, options2);
    }
    const parent = newDir.parent;
    if (parent) {
      if (newDir !== dir2) {
        if (child) {
          child.parent = newDir;
        }
        if (!newDir.parentKey) {
          throw new Error("No parent key found");
        }
        await parent.put(newDir.parentKey, newDir);
      }
      return flatToShard2(newDir, parent, threshold, options2);
    }
    return newDir;
  };
  async function convertToShard(oldDir, options2) {
    const newDir = new DirSharded({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options2);
    for await (const { key: key2, child } of oldDir.eachChildSeries()) {
      await newDir.put(key2, child);
    }
    return newDir;
  }
  return flatToShard;
}
var toPathComponents_1;
var hasRequiredToPathComponents;
function requireToPathComponents() {
  if (hasRequiredToPathComponents)
    return toPathComponents_1;
  hasRequiredToPathComponents = 1;
  const toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
  };
  toPathComponents_1 = toPathComponents;
  return toPathComponents_1;
}
var treeBuilder_1;
var hasRequiredTreeBuilder;
function requireTreeBuilder() {
  if (hasRequiredTreeBuilder)
    return treeBuilder_1;
  hasRequiredTreeBuilder = 1;
  const DirFlat = requireDirFlat();
  const flatToShard2 = requireFlatToShard();
  const Dir = requireDir();
  const toPathComponents = requireToPathComponents();
  async function addToTree(elem, tree, options2) {
    const pathElems = toPathComponents(elem.path || "");
    const lastIndex = pathElems.length - 1;
    let parent = tree;
    let currentPath = "";
    for (let i2 = 0; i2 < pathElems.length; i2++) {
      const pathElem = pathElems[i2];
      currentPath += `${currentPath ? "/" : ""}${pathElem}`;
      const last = i2 === lastIndex;
      parent.dirty = true;
      parent.cid = void 0;
      parent.size = void 0;
      if (last) {
        await parent.put(pathElem, elem);
        tree = await flatToShard2(null, parent, options2.shardSplitThreshold, options2);
      } else {
        let dir2 = await parent.get(pathElem);
        if (!dir2 || !(dir2 instanceof Dir)) {
          dir2 = new DirFlat({
            root: false,
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir2 && dir2.unixfs && dir2.unixfs.mtime,
            mode: dir2 && dir2.unixfs && dir2.unixfs.mode
          }, options2);
        }
        await parent.put(pathElem, dir2);
        parent = dir2;
      }
    }
    return tree;
  }
  async function* flushAndYield(tree, block) {
    if (!(tree instanceof Dir)) {
      if (tree && tree.unixfs && tree.unixfs.isDirectory()) {
        yield tree;
      }
      return;
    }
    yield* tree.flush(block);
  }
  async function* treeBuilder(source, block, options2) {
    let tree = new DirFlat({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options2);
    for await (const entry of source) {
      if (!entry) {
        continue;
      }
      tree = await addToTree(entry, tree, options2);
      if (!entry.unixfs || !entry.unixfs.isDirectory()) {
        yield entry;
      }
    }
    if (options2.wrapWithDirectory) {
      yield* flushAndYield(tree, block);
    } else {
      for await (const unwrapped of tree.eachChildSeries()) {
        if (!unwrapped) {
          continue;
        }
        yield* flushAndYield(unwrapped.child, block);
      }
    }
  }
  treeBuilder_1 = treeBuilder;
  return treeBuilder_1;
}
const parallelBatch = itParallelBatch;
const defaultOptions$2 = options$3;
async function* importer(source, block, options2 = {}) {
  const opts = defaultOptions$2(options2);
  let dagBuilder;
  if (typeof options2.dagBuilder === "function") {
    dagBuilder = options2.dagBuilder;
  } else {
    dagBuilder = requireDagBuilder();
  }
  let treeBuilder;
  if (typeof options2.treeBuilder === "function") {
    treeBuilder = options2.treeBuilder;
  } else {
    treeBuilder = requireTreeBuilder();
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder(parallelBatch(dagBuilder(candidates, block, opts), opts.fileImportConcurrency), block, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
var src$2 = {
  importer
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options2, buf, offset2) {
  if (native.randomUUID && !buf && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function _toPrimitive$2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$2(arg) {
  var key2 = _toPrimitive$2(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
function _defineProperty$2(obj, key2, value) {
  key2 = _toPropertyKey$2(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
const DEFAULT_GATEWAY_URLS = {
  // Note: Gateway URLs should have trailing slashes (we clean this on user input)
  "ipfs://": [
    "https://ipfs-2.thirdwebcdn.com/ipfs/",
    "https://ipfs-3.thirdwebcdn.com/ipfs/",
    "https://ipfs-4.thirdwebcdn.com/ipfs/",
    "https://ipfs-5.thirdwebcdn.com/ipfs/",
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/",
    // TODO this one can become the default again once it's stable (no more VT issues)
    "https://ipfs.thirdwebcdn.com/ipfs/"
  ]
};
const TW_IPFS_SERVER_URL = "https://upload.nftlabs.co";
const PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
function parseGatewayUrls(gatewayUrls) {
  if (Array.isArray(gatewayUrls)) {
    return {
      "ipfs://": gatewayUrls
    };
  }
  return gatewayUrls || {};
}
function prepareGatewayUrls(gatewayUrls) {
  const allGatewayUrls = {
    ...gatewayUrls,
    ...DEFAULT_GATEWAY_URLS
  };
  for (const key2 of Object.keys(DEFAULT_GATEWAY_URLS)) {
    if (gatewayUrls && gatewayUrls[key2]) {
      const cleanedGatewayUrls = gatewayUrls[key2].map((url) => url.replace(/\/$/, "") + "/");
      allGatewayUrls[key2] = [...cleanedGatewayUrls, ...DEFAULT_GATEWAY_URLS[key2]];
    }
  }
  return allGatewayUrls;
}
function isFileInstance(data) {
  return _global$1.File && data instanceof File;
}
function isBufferInstance(data) {
  return _global$1.Buffer && data instanceof buffer.Buffer;
}
function isBufferOrStringWithName(data) {
  return !!(data && data.name && data.data && typeof data.name === "string" && (typeof data.data === "string" || isBufferInstance(data.data)));
}
function isFileOrBuffer(data) {
  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);
}
function isFileBufferOrStringEqual(input1, input2) {
  if (isFileInstance(input1) && isFileInstance(input2)) {
    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {
      return true;
    }
  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {
    return input1.equals(input2);
  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {
    if (input1.name === input2.name) {
      if (typeof input1.data === "string" && typeof input2.data === "string") {
        return input1.data === input2.data;
      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {
        return input1.data.equals(input2.data);
      }
    }
  }
  return false;
}
function replaceGatewayUrlWithScheme(uri, gatewayUrls) {
  for (const scheme of Object.keys(gatewayUrls)) {
    for (const url of gatewayUrls[scheme]) {
      if (uri.startsWith(url)) {
        return uri.replace(url, scheme);
      }
    }
  }
  return uri;
}
function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {
  let index2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const scheme = Object.keys(gatewayUrls).find((s2) => uri.startsWith(s2));
  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];
  if (!scheme && index2 > 0 || scheme && index2 >= schemeGatewayUrls.length) {
    return void 0;
  }
  if (!scheme) {
    return uri;
  }
  return uri.replace(scheme, schemeGatewayUrls[index2]);
}
function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceGatewayUrlWithScheme(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref) => {
      let [key2, value] = _ref;
      return [key2, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];
    }));
  }
  return data;
}
function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls) {
  if (typeof data === "string") {
    return replaceSchemeWithGatewayUrl(data, gatewayUrls);
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (isFileOrBuffer(data)) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls));
    }
    return Object.fromEntries(Object.entries(data).map((_ref2) => {
      let [key2, value] = _ref2;
      return [key2, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls)];
    }));
  }
  return data;
}
function extractObjectFiles(data) {
  let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (isFileOrBuffer(data)) {
    files.push(data);
    return files;
  }
  if (typeof data === "object") {
    if (!data) {
      return files;
    }
    if (Array.isArray(data)) {
      data.forEach((entry) => extractObjectFiles(entry, files));
    } else {
      Object.keys(data).map((key2) => extractObjectFiles(data[key2], files));
    }
  }
  return files;
}
function replaceObjectFilesWithUris(data, uris) {
  if (isFileOrBuffer(data)) {
    if (uris.length) {
      data = uris.shift();
      return data;
    } else {
      console.warn("Not enough URIs to replace all files in object.");
    }
  }
  if (typeof data === "object") {
    if (!data) {
      return data;
    }
    if (Array.isArray(data)) {
      return data.map((entry) => replaceObjectFilesWithUris(entry, uris));
    } else {
      return Object.fromEntries(Object.entries(data).map((_ref3) => {
        let [key2, value] = _ref3;
        return [key2, replaceObjectFilesWithUris(value, uris)];
      }));
    }
  }
  return data;
}
async function getCIDForUpload(data, fileNames) {
  let wrapWithDirectory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  let cidVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  const contentWithPath = await Promise.all(data.map(async (file2, i2) => {
    const path = fileNames[i2];
    let content;
    if (typeof file2 === "string") {
      content = new TextEncoder().encode(file2);
    } else if (isBufferOrStringWithName(file2)) {
      if (typeof file2.data === "string") {
        content = new TextEncoder().encode(file2.data);
      } else {
        content = file2.data;
      }
    } else if (buffer.Buffer.isBuffer(file2)) {
      content = file2;
    } else {
      const buffer2 = await file2.arrayBuffer();
      content = new Uint8Array(buffer2);
    }
    return {
      path,
      content
    };
  }));
  return getCID(contentWithPath, wrapWithDirectory, cidVersion);
}
async function getCID(content) {
  let wrapWithDirectory = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  let cidVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const options2 = {
    onlyHash: true,
    wrapWithDirectory,
    cidVersion
  };
  const dummyBlockstore = {
    put: async () => {
    }
  };
  let lastCid;
  for await (const {
    cid
  } of src$2.importer(content, dummyBlockstore, options2)) {
    lastCid = cid;
  }
  return `${lastCid}`;
}
async function isUploaded(cid) {
  const res = await fetch$1(`${DEFAULT_GATEWAY_URLS["ipfs://"][0]}${cid}`, {
    method: "HEAD",
    headers: {
      // tell the gateway to skip fetching from origin in order to fail fast on 404s and just re-upload in those cases
      "x-skip-origin": "true"
    }
  });
  return res.ok;
}
class StorageDownloader {
  async download(uri, gatewayUrls) {
    let attempts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (attempts > 3) {
      throw new Error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.");
    }
    const resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts);
    if (!resolvedUri) {
      throw new Error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.");
    }
    const res = await fetch$1(resolvedUri);
    if (res.status >= 500 || res.status === 403 || res.status === 408) {
      console.warn(`Request to ${resolvedUri} failed with status ${res.status} - ${res.statusText}`);
      return this.download(uri, gatewayUrls, attempts + 1);
    }
    return res;
  }
}
class IpfsUploader {
  constructor(options2) {
    _defineProperty$2(this, "uploadWithGatewayUrl", void 0);
    this.uploadWithGatewayUrl = options2?.uploadWithGatewayUrl || false;
  }
  async uploadBatch(data, options2) {
    if (options2?.uploadWithoutDirectory && data.length > 1) {
      throw new Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
    }
    const formData = new FormData$2();
    const {
      form,
      fileNames
    } = this.buildFormData(formData, data, options2);
    try {
      const cid = await getCIDForUpload(data, fileNames.map((name2) => decodeURIComponent(name2)), !options2?.uploadWithoutDirectory);
      if (await isUploaded(cid) && !options2?.alwaysUpload) {
        if (options2?.onProgress) {
          options2?.onProgress({
            progress: 100,
            total: 100
          });
        }
        if (options2?.uploadWithoutDirectory) {
          return [`ipfs://${cid}`];
        } else {
          return fileNames.map((name2) => `ipfs://${cid}/${name2}`);
        }
      }
    } catch {
    }
    {
      return this.uploadBatchBrowser(form, fileNames, options2);
    }
  }
  /**
   * Fetches a one-time-use upload token that can used to upload
   * a file to storage.
   *
   * @returns - The one time use token that can be passed to the Pinata API.
   */
  async getUploadToken() {
    const res = await fetch$1(`${TW_IPFS_SERVER_URL}/grant`, {
      method: "GET",
      headers: {
        "X-APP-NAME": (
          // eslint-disable-next-line turbo/no-undeclared-env-vars
          !!{ "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.CI ? "Storage SDK CI" : "Storage SDK"
        )
      }
    });
    if (!res.ok) {
      throw new Error(`Failed to get upload token`);
    }
    const body = await res.text();
    return body;
  }
  buildFormData(form, files, options2) {
    const fileNameToFileMap = /* @__PURE__ */ new Map();
    const fileNames = [];
    for (let i2 = 0; i2 < files.length; i2++) {
      const file2 = files[i2];
      let fileName = "";
      let fileData = file2;
      if (isFileInstance(file2)) {
        if (options2?.rewriteFileNames) {
          let extensions = "";
          if (file2.name) {
            const extensionStartIndex = file2.name.lastIndexOf(".");
            if (extensionStartIndex > -1) {
              extensions = file2.name.substring(extensionStartIndex);
            }
          }
          fileName = `${i2 + options2.rewriteFileNames.fileStartNumber}${extensions}`;
        } else {
          fileName = `${file2.name}`;
        }
      } else if (isBufferOrStringWithName(file2)) {
        fileData = file2.data;
        if (options2?.rewriteFileNames) {
          fileName = `${i2 + options2.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${file2.name}`;
        }
      } else {
        if (options2?.rewriteFileNames) {
          fileName = `${i2 + options2.rewriteFileNames.fileStartNumber}`;
        } else {
          fileName = `${i2}`;
        }
      }
      const filepath = options2?.uploadWithoutDirectory ? `files` : `files/${fileName}`;
      if (fileNameToFileMap.has(fileName)) {
        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file2)) {
          fileNames.push(fileName);
          continue;
        }
        throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
      }
      fileNameToFileMap.set(fileName, file2);
      fileNames.push(fileName);
      {
        form.append("file", new Blob([fileData]), filepath);
      }
    }
    const metadata = {
      name: `Storage SDK`,
      keyvalues: {
        ...options2?.metadata
      }
    };
    form.append("pinataMetadata", JSON.stringify(metadata));
    if (options2?.uploadWithoutDirectory) {
      form.append("pinataOptions", JSON.stringify({
        wrapWithDirectory: false
      }));
    }
    return {
      form,
      // encode the file names on the way out (which is what the upload backend expects)
      fileNames: fileNames.map((fName) => encodeURIComponent(fName))
    };
  }
  async uploadBatchBrowser(form, fileNames, options2) {
    const token2 = await this.getUploadToken();
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      let timer2 = setTimeout(() => {
        xhr.abort();
        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
      }, 3e4);
      xhr.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      });
      xhr.upload.addEventListener("progress", (event) => {
        console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
        clearTimeout(timer2);
        if (event.loaded < event.total) {
          timer2 = setTimeout(() => {
            xhr.abort();
            reject(new Error("Request to upload timed out! No upload progress received in 30s"));
          }, 3e4);
        } else {
          console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
        }
        if (event.lengthComputable && options2?.onProgress) {
          options2?.onProgress({
            progress: event.loaded,
            total: event.total
          });
        }
      });
      xhr.addEventListener("load", () => {
        console.log(`[${Date.now()}] [IPFS] Load`);
        clearTimeout(timer2);
        if (xhr.status >= 200 && xhr.status < 300) {
          let body;
          try {
            body = JSON.parse(xhr.responseText);
          } catch (err) {
            return reject(new Error("Failed to parse JSON from upload response"));
          }
          const cid = body.IpfsHash;
          if (!cid) {
            throw new Error("Failed to get IPFS hash from upload response");
          }
          if (options2?.uploadWithoutDirectory) {
            return resolve([`ipfs://${cid}`]);
          } else {
            return resolve(fileNames.map((name2) => `ipfs://${cid}/${name2}`));
          }
        }
        return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
      });
      xhr.addEventListener("error", () => {
        console.log("[IPFS] Load");
        clearTimeout(timer2);
        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {
          return reject(new Error("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."));
        }
        return reject(new Error("Unknown upload error occured"));
      });
      xhr.open("POST", PINATA_IPFS_URL);
      xhr.setRequestHeader("Authorization", `Bearer ${token2}`);
      xhr.send(form);
    });
  }
  async uploadBatchNode(form, fileNames, options2) {
    const token2 = await this.getUploadToken();
    if (options2?.onProgress) {
      console.warn("The onProgress option is only supported in the browser");
    }
    const res = await fetch$1(PINATA_IPFS_URL, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token2}`,
        ...form.getHeaders()
      },
      body: form.getBuffer()
    });
    const body = await res.json();
    if (!res.ok) {
      console.warn(body);
      throw new Error("Failed to upload files to IPFS");
    }
    const cid = body.IpfsHash;
    if (!cid) {
      throw new Error("Failed to upload files to IPFS");
    }
    if (options2?.uploadWithoutDirectory) {
      return [`ipfs://${cid}`];
    } else {
      return fileNames.map((name2) => `ipfs://${cid}/${name2}`);
    }
  }
}
class ThirdwebStorage {
  constructor(options2) {
    _defineProperty$2(this, "uploader", void 0);
    _defineProperty$2(this, "downloader", void 0);
    _defineProperty$2(this, "gatewayUrls", void 0);
    this.uploader = options2?.uploader || new IpfsUploader();
    this.downloader = options2?.downloader || new StorageDownloader();
    this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options2?.gatewayUrls));
  }
  /**
   * Resolve any scheme on a URL to get a retrievable URL for the data
   *
   * @param url - The URL to resolve the scheme of
   * @returns The URL with its scheme resolved
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const url = storage.resolveScheme(uri);
   * console.log(url);
   * ```
   */
  resolveScheme(url) {
    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls);
  }
  /**
   * Downloads arbitrary data from any URL scheme.
   *
   * @param url - The URL of the data to download
   * @returns The response object fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const data = await storage.download(uri);
   * ```
   */
  async download(url) {
    return this.downloader.download(url, this.gatewayUrls);
  }
  /**
   * Downloads JSON data from any URL scheme.
   * Resolves any URLs with schemes to retrievable gateway URLs.
   *
   * @param url - The URL of the JSON data to download
   * @returns The JSON data fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const json = await storage.downloadJSON(uri);
   * ```
   */
  async downloadJSON(url) {
    const res = await this.download(url);
    const json2 = await res.json();
    return replaceObjectSchemesWithGatewayUrls(json2, this.gatewayUrls);
  }
  /**
   * Upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns - The URI of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload file data
   * const file = readFileSync("../file.jpg");
   * const fileUri = await storage.upload(file);
   *
   * // Or upload a JSON object
   * const json = { name: "JSON", image: file };
   * const jsonUri = await storage.upload(json);
   * ```
   */
  async upload(data, options2) {
    const [uri] = await this.uploadBatch([data], options2);
    return uri;
  }
  /**
   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Array of arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns - The URIs of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload an array of file data
   * const files = [
   *  readFileSync("../file1.jpg"),
   *  readFileSync("../file2.jpg"),
   * ];
   * const fileUris = await storage.uploadBatch(files);
   *
   * // Upload an array of JSON objects
   * const objects = [
   *  { name: "JSON 1", image: files[0] },
   *  { name: "JSON 2", image: files[1] },
   * ];
   * const jsonUris = await storage.uploadBatch(objects);
   * ```
   */
  async uploadBatch(data, options2) {
    data = data.filter((item) => item !== void 0);
    if (!data.length) {
      return [];
    }
    const isFileArray = data.map((item) => isFileOrBuffer(item) || typeof item === "string").every((item) => !!item);
    let uris = [];
    if (isFileArray) {
      uris = await this.uploader.uploadBatch(data, options2);
    } else {
      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options2)).map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      });
      uris = await this.uploader.uploadBatch(metadata, options2);
    }
    if (options2?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
      return uris.map((uri) => this.resolveScheme(uri));
    } else {
      return uris;
    }
  }
  async uploadAndReplaceFilesWithHashes(data, options2) {
    let cleaned = data;
    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);
    const files = extractObjectFiles(cleaned);
    if (files.length) {
      const uris = await this.uploader.uploadBatch(files, options2);
      cleaned = replaceObjectFilesWithUris(cleaned, uris);
    }
    if (options2?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls);
    }
    return cleaned;
  }
}
class Subscribable {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    const identity2 = {
      listener
    };
    this.listeners.add(identity2);
    this.onSubscribe();
    return () => {
      this.listeners.delete(identity2);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const isServer = typeof window === "undefined" || "Deno" in window;
function noop$4() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey
  } = filters;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options2) {
  const hashFn = (options2 == null ? void 0 : options2.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_, val) => isPlainObject$1(val) ? Object.keys(val).sort().reduce((result, key2) => {
    result[key2] = val[key2];
    return result;
  }, {}) : val);
}
function partialMatchKey(a2, b2) {
  return partialDeepEqual(a2, b2);
}
function partialDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key2) => !partialDeepEqual(a2[key2], b2[key2]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$1(a2) && isPlainObject$1(b2)) {
    const aSize = array ? a2.length : Object.keys(a2).length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key2 = array ? i2 : bItems[i2];
      copy2[key2] = replaceEqualDeep(a2[key2], b2[key2]);
      if (copy2[key2] === a2[key2]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (a2 && !b2 || b2 && !a2) {
    return false;
  }
  for (const key2 in a2) {
    if (a2[key2] !== b2[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$1(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
  return;
}
function replaceData(prevData, data, options2) {
  if (options2.isDataEqual != null && options2.isDataEqual(prevData, data)) {
    return prevData;
  } else if (typeof options2.structuralSharing === "function") {
    return options2.structuralSharing(prevData, data);
  } else if (options2.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
class FocusManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const focusManager = new FocusManager();
const onlineEvents = ["online", "offline"];
class OnlineManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline();
        onlineEvents.forEach((event) => {
          window.addEventListener(event, listener, false);
        });
        return () => {
          onlineEvents.forEach((event) => {
            window.removeEventListener(event, listener);
          });
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach(({
      listener
    }) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
}
const onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
class CancelledError {
  constructor(options2) {
    this.revert = options2 == null ? void 0 : options2.revert;
    this.silent = options2 == null ? void 0 : options2.silent;
  }
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config2.abort == null ? void 0 : config2.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config2.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onSuccess == null ? void 0 : config2.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onError == null ? void 0 : config2.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        const canContinue = isResolved || !shouldPause();
        if (canContinue) {
          continueResolve(value);
        }
        return canContinue;
      };
      config2.onPause == null ? void 0 : config2.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config2.onContinue == null ? void 0 : config2.onContinue();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry = (_config$retry = config2.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail == null ? void 0 : config2.onFail(failureCount, error);
      sleep(delay2).then(() => {
        if (shouldPause()) {
          return pause();
        }
        return;
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  if (canFetch(config2.networkMode)) {
    run();
  } else {
    pause().then(run);
  }
  return {
    promise,
    cancel,
    continue: () => {
      const didContinue = continueFn == null ? void 0 : continueFn();
      return didContinue ? promise : Promise.resolve();
    },
    cancelRetry,
    continueRetry
  };
}
const defaultLogger = console;
function createNotifyManager() {
  let queue2 = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  const batch2 = (callback) => {
    let result;
    transactions++;
    try {
      result = callback();
    } finally {
      transactions--;
      if (!transactions) {
        flush();
      }
    }
    return result;
  };
  const schedule = (callback) => {
    if (transactions) {
      queue2.push(callback);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback);
      });
    }
  };
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args);
      });
    };
  };
  const flush = () => {
    const originalQueue = queue2;
    queue2 = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn2) => {
    notifyFn = fn2;
  };
  const setBatchNotifyFunction = (fn2) => {
    batchNotifyFn = fn2;
  };
  return {
    batch: batch2,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
const notifyManager = createNotifyManager();
class Removable {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout);
      this.gcTimeout = void 0;
    }
  }
}
class Query extends Removable {
  constructor(config2) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config2.defaultOptions;
    this.setOptions(config2.options);
    this.observers = [];
    this.cache = config2.cache;
    this.logger = config2.logger || defaultLogger;
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    this.initialState = config2.state || getDefaultState$1(this.options);
    this.state = this.initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options2) {
    this.options = {
      ...this.defaultOptions,
      ...options2
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(newData, options2) {
    const data = replaceData(this.state.data, newData, this.options);
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options2 == null ? void 0 : options2.updatedAt,
      manual: options2 == null ? void 0 : options2.manual
    });
    return data;
  }
  setState(state2, setStateOptions) {
    this.dispatch({
      type: "setState",
      state: state2,
      setStateOptions
    });
  }
  cancel(options2) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options2);
    return promise ? promise.then(noop$4).catch(noop$4) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options2, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options2) {
      this.setOptions(options2);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (!Array.isArray(this.options.queryKey))
      ;
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
        if (typeof data === "undefined") {
          onError(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(data);
        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        this.dispatch({
          type: "failed",
          failureCount,
          error
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer = (state2) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state2,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state2,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state2,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state2,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state2.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state2,
            data: action.data,
            dataUpdateCount: state2.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState
            };
          }
          return {
            ...state2,
            error,
            errorUpdateCount: state2.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state2.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state2,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state2,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState$1(options2) {
  const data = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
  const hasData = typeof data !== "undefined";
  const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class QueryCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client2, options2, state2) {
    var _options$queryHash;
    const queryKey = options2.queryKey;
    const queryHash = (_options$queryHash = options2.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options2);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client2.getLogger(),
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options2),
        state: state2,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x2) => x2 !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({
        listener
      }) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
}
class Mutation extends Removable {
  constructor(config2) {
    super();
    this.defaultOptions = config2.defaultOptions;
    this.mutationId = config2.mutationId;
    this.mutationCache = config2.mutationCache;
    this.logger = config2.logger || defaultLogger;
    this.observers = [];
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options2) {
    this.options = {
      ...this.defaultOptions,
      ...options2
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(state2) {
    this.dispatch({
      type: "setState",
      state: state2
    });
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x2) => x2 !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    var _this$retryer$continu, _this$retryer;
    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data = await executeMutation();
      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data
      });
      return data;
    } catch (error) {
      try {
        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
        if (false)
          ;
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer = (state2) => {
      switch (action.type) {
        case "failed":
          return {
            ...state2,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state2,
            isPaused: true
          };
        case "continue":
          return {
            ...state2,
            isPaused: false
          };
        case "loading":
          return {
            ...state2,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state2,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state2,
            data: void 0,
            error: action.error,
            failureCount: state2.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state2,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
class MutationCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client2, options2, state2) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client2.getLogger(),
      mutationId: ++this.mutationId,
      options: client2.defaultMutationOptions(options2),
      state: state2,
      defaultOptions: options2.mutationKey ? client2.getMutationDefaults(options2.mutationKey) : void 0
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x2) => x2 !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({
        listener
      }) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    var _this$resuming;
    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
      const pausedMutations = this.mutations.filter((x2) => x2.state.isPaused);
      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$4)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    });
    return this.resuming;
  }
}
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i2 = 1; i2 < oldPages.length; i2++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options2, pages) {
  return options2.getNextPageParam == null ? void 0 : options2.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options2, pages) {
  return options2.getPreviousPageParam == null ? void 0 : options2.getPreviousPageParam(pages[0], pages);
}
class QueryClient {
  constructor(config2 = {}) {
    this.queryCache = config2.queryCache || new QueryCache();
    this.mutationCache = config2.mutationCache || new MutationCache();
    this.logger = config2.logger || defaultLogger;
    this.defaultOptions = config2.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
    this.mountCount = 0;
  }
  mount() {
    this.mountCount++;
    if (this.mountCount !== 1)
      return;
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    this.mountCount--;
    if (this.mountCount !== 0)
      return;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    this.unsubscribeFocus = void 0;
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
    this.unsubscribeOnline = void 0;
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  ensureQueryData(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const cachedData = this.getQueryData(parsedOptions.queryKey);
    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey,
      state: state2
    }) => {
      const data = state2.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options2) {
    const query = this.queryCache.find(queryKey);
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs(queryKey);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options2,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options2) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options2)]));
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options2);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop$4).catch(noop$4);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options2);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options2,
        cancelRefetch: (_options$cancelRefetc = options2 == null ? void 0 : options2.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop$4);
    if (!(options2 != null && options2.throwOnError)) {
      promise = promise.catch(noop$4);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop$4).catch(noop$4);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$4).catch(noop$4);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options2) {
    this.defaultOptions = options2;
  }
  setQueryDefaults(queryKey, options2) {
    const result = this.queryDefaults.find((x2) => hashQueryKey(queryKey) === hashQueryKey(x2.queryKey));
    if (result) {
      result.defaultOptions = options2;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options2
      });
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x2) => partialMatchKey(queryKey, x2.queryKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey, options2) {
    const result = this.mutationDefaults.find((x2) => hashQueryKey(mutationKey) === hashQueryKey(x2.mutationKey));
    if (result) {
      result.defaultOptions = options2;
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options2
      });
    }
  }
  getMutationDefaults(mutationKey) {
    if (!mutationKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x2) => partialMatchKey(mutationKey, x2.mutationKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options2) {
    if (options2 != null && options2._defaulted) {
      return options2;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options2 == null ? void 0 : options2.queryKey),
      ...options2,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options2) {
    if (options2 != null && options2._defaulted) {
      return options2;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options2 == null ? void 0 : options2.mutationKey),
      ...options2,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
}
class QueryObserver extends Subscribable {
  constructor(client2, options2) {
    super();
    this.client = client2;
    this.options = options2;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options2);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options2, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options2);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      });
    }
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options2) {
    const query = this.client.getQueryCache().build(this.client, options2);
    return this.createResult(query, options2);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key2) => {
      Object.defineProperty(trackedResult, key2, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key2);
          return result[key2];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options2
  } = {}) {
    return this.fetch({
      ...options2,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options2) {
    const defaultedOptions = this.client.defaultQueryOptions(options2);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop$4);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = void 0;
    }
  }
  clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = void 0;
    }
  }
  createResult(query, options2) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state: state2
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state2;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options2._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options2);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options2, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options2._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options2.keepPreviousData && !state2.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options2.select && typeof state2.data !== "undefined") {
      if (prevResult && state2.data === (prevResultState == null ? void 0 : prevResultState.data) && options2.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options2.select;
          data = options2.select(state2.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options2);
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          this.selectError = selectError;
        }
      }
    } else {
      data = state2.data;
    }
    if (typeof options2.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options2.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options2.placeholderData === "function" ? options2.placeholderData() : options2.placeholderData;
        if (options2.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options2.select(placeholderData);
            this.selectError = null;
          } catch (selectError) {
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options2);
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const isLoading = status === "loading";
    const isError = status === "error";
    const result = {
      status,
      fetchStatus,
      isLoading,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading && isFetching,
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state2.fetchFailureCount,
      failureReason: state2.fetchFailureReason,
      errorUpdateCount: state2.errorUpdateCount,
      isFetched: state2.dataUpdateCount > 0 || state2.errorUpdateCount > 0,
      isFetchedAfterMount: state2.dataUpdateCount > queryInitialState.dataUpdateCount || state2.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isLoading,
      isLoadingError: isError && state2.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: isError && state2.dataUpdatedAt !== 0,
      isStale: isStale(query, options2),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key2) => {
        const typedKey = key2;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
}
function shouldLoadOnMount(query, options2) {
  return options2.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options2.retryOnMount === false);
}
function shouldFetchOnMount(query, options2) {
  return shouldLoadOnMount(query, options2) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options2, options2.refetchOnMount);
}
function shouldFetchOn(query, options2, field) {
  if (options2.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options2);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options2, prevOptions) {
  return options2.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options2.suspense || query.state.status !== "error") && isStale(query, options2);
}
function isStale(query, options2) {
  return query.isStaleByTime(options2.staleTime);
}
let MutationObserver$1 = class MutationObserver2 extends Subscribable {
  constructor(client2, options2) {
    super();
    this.client = client2;
    this.setOptions(options2);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options2) {
    var _this$currentMutation;
    const prevOptions = this.options;
    this.options = this.client.defaultMutationOptions(options2);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.currentMutation,
        observer: this
      });
    }
    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$currentMutation2;
      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options2) {
    this.mutateOptions = options2;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state2 = this.currentMutation ? this.currentMutation.state : getDefaultState();
    const result = {
      ...state2,
      isLoading: state2.status === "loading",
      isSuccess: state2.status === "success",
      isError: state2.status === "error",
      isIdle: state2.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options2) {
    notifyManager.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (options2.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options2.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options2.listeners) {
        this.listeners.forEach(({
          listener
        }) => {
          listener(this.currentResult);
        });
      }
    });
  }
};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$2 = reactExports;
function h$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$3 = "function" === typeof Object.is ? Object.is : h$4, l$3 = e$2.useState, m$3 = e$2.useEffect, n$4 = e$2.useLayoutEffect, p$3 = e$2.useDebugValue;
function q$2(a2, b2) {
  var d2 = b2(), f2 = l$3({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$4(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$7(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$3(function() {
    r$7(c2) && g2({ inst: c2 });
    return a2(function() {
      r$7(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$3(d2);
  return d2;
}
function r$7(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$3(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$4(a2, b2) {
  return b2();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$2.useSyncExternalStore ? e$2.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
const useSyncExternalStore = shimExports.useSyncExternalStore;
const defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
const QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
const useQueryClient = ({
  context
} = {}) => {
  const queryClient = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
  if (!queryClient) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient;
};
const QueryClientProvider = ({
  client: client2,
  children,
  context,
  contextSharing = false
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  const Context = getQueryClientContext(context, contextSharing);
  return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
    value: client2
  }, children));
};
const IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
const useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
const QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
const useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
const ensurePreventErrorBoundaryRetry = (options2, errorResetBoundary) => {
  if (options2.suspense || options2.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      options2.retryOnMount = false;
    }
  }
};
const useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
const getHasError = ({
  result,
  errorResetBoundary,
  useErrorBoundary,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
};
const ensureStaleTime = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
};
const willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
const shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
  data
}) => {
  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
}).catch((error) => {
  errorResetBoundary.clearReset();
  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
});
function useBaseQuery(options2, Observer) {
  const queryClient = useQueryClient({
    context: options2.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient.defaultQueryOptions(options2);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(() => new Observer(queryClient, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore(reactExports.useCallback((onStoreChange) => {
    const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
    observer.updateResult();
    return unsubscribe;
  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    useErrorBoundary: defaultedOptions.useErrorBoundary,
    query: observer.getCurrentQuery()
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}
function useMutation(arg1, arg2, arg3) {
  const options2 = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient({
    context: options2.context
  });
  const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient, options2));
  reactExports.useEffect(() => {
    observer.setOptions(options2);
  }, [observer, options2]);
  const result = useSyncExternalStore(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = reactExports.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop$3);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop$3() {
}
var isProduction = true;
var prefix$1 = "Invariant failed";
function invariant$1(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix$1);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix$1, ": ").concat(provided) : prefix$1;
  throw new Error(value);
}
var bn = { exports: {} };
bn.exports;
(function(module) {
  (function(module2, exports) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base3, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number2 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer = window.Buffer;
      } else {
        Buffer = buffer.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left2, right2) {
      if (left2.cmp(right2) > 0)
        return left2;
      return right2;
    };
    BN2.min = function min2(left2, right2) {
      if (left2.cmp(right2) < 0)
        return left2;
      return right2;
    };
    BN2.prototype._init = function init3(number2, base3, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base3, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start2 = 0;
      if (number2[0] === "-") {
        start2++;
        this.negative = 1;
      }
      if (start2 < number2.length) {
        if (base3 === 16) {
          this._parseHex(number2, start2, endian);
        } else {
          this._parseBase(number2, base3, start2);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base3, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
          w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
          w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start2, endian) {
      this.length = Math.ceil((number2.length - start2) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number2.length - 1; i2 >= start2; i2 -= 2) {
          w2 = parseHexByte(number2, start2, i2) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start2;
        for (i2 = parseLength % 2 === 0 ? start2 + 1 : start2; i2 < number2.length; i2 += 2) {
          w2 = parseHexByte(number2, start2, i2) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start2, end2, mul3) {
      var r2 = 0;
      var b2 = 0;
      var len2 = Math.min(str.length, end2);
      for (var i2 = start2; i2 < len2; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul3;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul3, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base3, start2) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number2.length - start2;
      var mod2 = total % limbLen;
      var end2 = Math.min(total, total - mod2) + start2;
      var word = 0;
      for (var i2 = start2; i2 < end2; i2 += limbLen) {
        word = parseBase(number2, i2, i2 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow = 1;
        word = parseBase(number2, i2, number2.length, base3);
        for (i2 = 0; i2 < mod2; i2++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone2() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
      } catch (e2) {
        BN2.prototype.inspect = inspect4;
      }
    } else {
      BN2.prototype.inspect = inspect4;
    }
    function inspect4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString3(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16, 2);
    };
    if (Buffer) {
      BN2.prototype.toBuffer = function toBuffer(endian, length2) {
        return this.toArrayLike(Buffer, endian, length2);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length2) {
      return this.toArrayLike(Array, endian, length2);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length2 || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position2 = 0;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position2++] = word & 255;
        if (position2 < res.length) {
          res[position2++] = word >> 8 & 255;
        }
        if (position2 < res.length) {
          res[position2++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 < res.length) {
            res[position2++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 < res.length) {
        res[position2++] = carry;
        while (position2 < res.length) {
          res[position2++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position2 = res.length - 1;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position2--] = word & 255;
        if (position2 >= 0) {
          res[position2--] = word >> 8 & 255;
        }
        if (position2 >= 0) {
          res[position2--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position2 >= 0) {
            res[position2--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position2 >= 0) {
        res[position2--] = carry;
        while (position2 >= 0) {
          res[position2--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg3() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add4(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len2; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i2 = k2 - j | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi2;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
          var i2 = k2 - j;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul3(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs2() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right2 = (num.words[i2] | 0) * mul3;
        w2 -= right2 & 67108863;
        carry = (w2 >> 26) - (right2 / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j = m2 - 1; j >= 0; j--) {
        var qj2 = (a2.words[b2.length + j] | 0) * 67108864 + (a2.words[b2.length + j - 1] | 0);
        qj2 = Math.min(qj2 / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj2, j);
        while (a2.negative !== 0) {
          qj2--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j] = qj2;
        }
      }
      if (q2) {
        q2._strip();
      }
      a2._strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y2.iushrn(j);
          while (j-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq4(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev2 = input.words[9];
      output.words[output.length++] = prev2 & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next2 = input.words[i2] | 0;
        input.words[i2 - 10] = (next2 & mask) << 4 | prev2 >>> 22;
        prev2 = next2;
      }
      prev2 >>>= 22;
      input.words[i2 - 10] = prev2;
      if (prev2 === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi2 = (num.words[i2] | 0) * 19 + carry;
        var lo = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i2] = lo;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg3(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add4(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul3(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start2 = num.bitLength() % 26;
      if (start2 === 0) {
        start2 = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j = start2 - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start2 = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul3(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
const version$o = "logger/5.7.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex2 = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex2 += HEX[value[i2] >> 4];
            hex2 += HEX[value[i2] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex2 + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$o);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const lib_esm$k = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ErrorCode() {
    return ErrorCode;
  },
  get LogLevel() {
    return LogLevel;
  },
  Logger
}, Symbol.toStringTag, { value: "Module" }));
const version$n = "bytes/5.7.0";
const logger$I = new Logger(version$n);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options2) {
  if (!options2) {
    options2 = {};
  }
  if (typeof value === "number") {
    logger$I.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options2.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex2 = value.substring(2);
    if (hex2.length % 2) {
      if (options2.hexPad === "left") {
        hex2 = "0" + hex2;
      } else if (options2.hexPad === "right") {
        hex2 += "0";
      } else {
        logger$I.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex2.length; i2 += 2) {
      result.push(parseInt(hex2.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger$I.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset2, object) => {
    result.set(object, offset2);
    return offset2 + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start2 = 0;
  while (start2 < result.length && result[start2] === 0) {
    start2++;
  }
  if (start2) {
    result = result.slice(start2);
  }
  return result;
}
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger$I.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options2) {
  if (!options2) {
    options2 = {};
  }
  if (typeof value === "number") {
    logger$I.checkSafeUint53(value, "invalid hexlify value");
    let hex2 = "";
    while (value) {
      hex2 = HexCharacters[value & 15] + hex2;
      value = Math.floor(value / 16);
    }
    if (hex2.length) {
      if (hex2.length % 2) {
        hex2 = "0" + hex2;
      }
      return "0x" + hex2;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options2.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options2.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options2.hexPad === "right") {
        value += "0";
      } else {
        logger$I.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$I.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset2, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger$I.throwArgumentError("invalid hexData", "value", data);
  }
  offset2 = 2 + 2 * offset2;
  if (endOffset != null) {
    return "0x" + data.substring(offset2, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset2);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger$I.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset2 = 0;
  while (offset2 < value.length && value[offset2] === "0") {
    offset2++;
  }
  return "0x" + value.substring(offset2);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger$I.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger$I.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes3 = arrayify(signature2);
    if (bytes3.length === 64) {
      result.v = 27 + (bytes3[32] >> 7);
      bytes3[32] &= 127;
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
    } else if (bytes3.length === 65) {
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
      result.v = bytes3[64];
    } else {
      logger$I.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$I.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes3[32] |= 128;
    }
    result._vs = hexlify(bytes3.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$I.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$I.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$I.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$I.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger$I.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger$I.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$I.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger$I.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$I.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const lib_esm$j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayify,
  concat,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  isBytes,
  isBytesLike,
  isHexString,
  joinSignature,
  splitSignature,
  stripZeros,
  zeroPad
}, Symbol.toStringTag, { value: "Module" }));
const version$m = "bignumber/5.7.0";
var BN = BN$1.BN;
const logger$H = new Logger(version$m);
const _constructorGuard$4 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex2) {
    if (constructorGuard !== _constructorGuard$4) {
      logger$H.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex2;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault$1("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault$1("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault$1("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$H.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$H.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$H.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$H.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$4, toHex$2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$4, toHex$2(new BN(value)));
      }
      return logger$H.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault$1("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex2 = anyValue.toHexString();
        if (typeof hex2 === "string") {
          return BigNumber.from(hex2);
        }
      } else {
        let hex2 = anyValue._hex;
        if (hex2 == null && anyValue.type === "BigNumber") {
          hex2 = anyValue.hex;
        }
        if (typeof hex2 === "string") {
          if (isHexString(hex2) || hex2[0] === "-" && isHexString(hex2.substring(1))) {
            return BigNumber.from(hex2);
          }
        }
      }
    }
    return logger$H.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
function toHex$2(value) {
  if (typeof value !== "string") {
    return toHex$2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger$H.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex$2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex$2(value));
}
function toBN(value) {
  const hex2 = BigNumber.from(value).toHexString();
  if (hex2[0] === "-") {
    return new BN("-" + hex2.substring(3), 16);
  }
  return new BN(hex2.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger$H.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
const logger$G = new Logger(version$m);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger$G.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger$G.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero$2);
  if (negative) {
    value = value.mul(NegativeOne$2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger$G.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger$G.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger$G.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$G.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed")
        ;
      else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match2 = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match2) {
          logger$G.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match2[1] !== "u";
        width = parseInt(match2[2]);
        decimals = parseInt(match2[3]);
      }
    } else if (value) {
      const check = (key2, type, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type) {
          logger$G.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$G.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$G.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$3, signed2, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex2, value, format) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$G.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex2;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$G.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$G.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$G.throwArgumentError("invalid byte width", "width", width);
    }
    const hex2 = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex2, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex2 = null;
    if (fixedFormat.signed) {
      hex2 = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex2 = numeric.toHexString();
      hex2 = hexZeroPad(hex2, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex2, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex2 = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex2, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger$G.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$l = "properties/5.7.0";
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$F = new Logger(version$l);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object) {
  return __awaiter$f(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key2) => {
      const value = object[key2];
      return Promise.resolve(value).then((v2) => ({ key: key2, value: v2 }));
    });
    const results2 = yield Promise.all(promises);
    return results2.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger$F.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key2) => {
    if (!properties[key2]) {
      logger$F.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key2 in object) {
    result[key2] = object[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys2 = Object.keys(object);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      let value = null;
      try {
        value = object[keys2[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger$F.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key2 in object) {
      const value = object[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger$F.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
const lib_esm$i = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Description,
  checkProperties,
  deepCopy,
  defineReadOnly,
  getStatic,
  resolveProperties,
  shallowCopy
}, Symbol.toStringTag, { value: "Module" }));
const version$k = "abi/5.7.0";
const logger$E = new Logger(version$k);
const _constructorGuard$2 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$E.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i2) {
    logger$E.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node3 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node2 = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c2 = param[i2];
    switch (c2) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError(i2);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i2);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError(i2);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError(i2);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError(i2);
              }
              if (node2.indexed) {
                throwError(i2);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError(i2);
        }
        node2.type += c2;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError(i2);
        }
        node2.type += c2;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c2;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c2;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c2;
        } else {
          throwError(i2);
        }
    }
  }
  if (node2.parent) {
    logger$E.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key2 in params) {
    defineReadOnly(object, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$E.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match2 = this.type.match(paramTypeArray);
    if (match2) {
      populate(this, {
        arrayLength: parseInt(match2[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match2[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$E.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard$2, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node2) {
      return ParamType.fromObject({
        name: node2.name,
        type: node2.type,
        indexed: node2.indexed,
        components: node2.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$E.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$E.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger$E.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$E.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger$E.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let match2 = value.match(regexParen);
    if (!match2) {
      logger$E.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match2[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$E.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match2[1].trim(),
      anonymous,
      inputs: parseParams(match2[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$E.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$E.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger$E.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger$E.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger$E.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$E.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger$E.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$E.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger$E.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger$E.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger$E.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$E.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$E.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger$E.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger$E.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$E.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$E.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$E.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger$E.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger$E.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger$E.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger$E.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset2 = 0; offset2 < value.length; offset2++) {
    let c2 = value[offset2];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$E.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$D = new Logger(version$k);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key2 in object) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger$D.throwArgumentError(message, this.localName, value);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer2) {
    return this._writeData(concat(writer2._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes3 = arrayify(value);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value) {
    let bytes3 = arrayify(BigNumber.from(value));
    if (bytes3.length > this.wordSize) {
      logger$D.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset2 = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset2] = this._getValue(value);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match2 = name2.match("^u?int([0-9]+)$");
    if (match2 && parseInt(match2[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset2, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger$D.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset2) {
    return new Reader(this._data.slice(this._offset + offset2), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes3 = this._peekBytes(0, length2, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
function keccak256$1(data) {
  return "0x" + sha3$2.keccak_256(arrayify(data));
}
const lib_esm$h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: keccak256$1
}, Symbol.toStringTag, { value: "Module" }));
const version$j = "rlp/5.7.0";
const logger$C = new Logger(version$j);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset2, length2) {
  let result = 0;
  for (let i2 = 0; i2 < length2; i2++) {
    result = result * 256 + data[offset2 + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger$C.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length2 = arrayifyInteger(data.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data);
}
function encode$5(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset2, childOffset, length2) {
  const result = [];
  while (childOffset < offset2 + 1 + length2) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset2 + 1 + length2) {
      logger$C.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
function _decode(data, offset2) {
  if (data.length === 0) {
    logger$C.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset2] >= 248) {
    const lengthLength = data[offset2] - 247;
    if (offset2 + 1 + lengthLength > data.length) {
      logger$C.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length2 > data.length) {
      logger$C.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1 + lengthLength, lengthLength + length2);
  } else if (data[offset2] >= 192) {
    const length2 = data[offset2] - 192;
    if (offset2 + 1 + length2 > data.length) {
      logger$C.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset2, offset2 + 1, length2);
  } else if (data[offset2] >= 184) {
    const lengthLength = data[offset2] - 183;
    if (offset2 + 1 + lengthLength > data.length) {
      logger$C.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data, offset2 + 1, lengthLength);
    if (offset2 + 1 + lengthLength + length2 > data.length) {
      logger$C.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1 + lengthLength, offset2 + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data[offset2] >= 128) {
    const length2 = data[offset2] - 128;
    if (offset2 + 1 + length2 > data.length) {
      logger$C.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset2 + 1, offset2 + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data[offset2]) };
}
function decode$4(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger$C.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
const lib_esm$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$4,
  encode: encode$5
}, Symbol.toStringTag, { value: "Module" }));
const version$i = "address/5.7.0";
const logger$B = new Logger(version$i);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger$B.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$1(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$B.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$B.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$B.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$B.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base362 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base362.length < 30) {
    base362 = "0" + base362;
  }
  return "XE" + ibanChecksum("XE00" + base362) + base362;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger$B.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$5([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$B.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$B.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256$1(concat(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
const lib_esm$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  isAddress
}, Symbol.toStringTag, { value: "Module" }));
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer2, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer2.writeValue(value);
  }
  decode(reader2) {
    return getAddress(hexZeroPad(reader2.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer2, value) {
    return this.coder.encode(writer2, value);
  }
  decode(reader2) {
    return this.coder.decode(reader2);
  }
}
const logger$A = new Logger(version$k);
function pack$1(writer2, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique2 = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$A.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique2[name2]) {
        logger$A.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique2[name2] = true;
      return values[name2];
    });
  } else {
    logger$A.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$A.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer2.wordSize);
  let dynamicWriter = new Writer(writer2.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length2 = writer2.appendWriter(staticWriter);
  length2 += writer2.appendWriter(dynamicWriter);
  return length2;
}
function unpack(reader2, coders) {
  let values = [];
  let baseReader = reader2.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset2 = reader2.readValue();
      let offsetReader = baseReader.subReader(offset2.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader2);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value = values[i2];
    if (value instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length2, localName) {
    const type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic = length2 === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer2, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer2.writeValue(value.length);
    }
    logger$A.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      coders.push(this.coder);
    }
    return pack$1(writer2, coders, value);
  }
  decode(reader2) {
    let count = this.length;
    if (count === -1) {
      count = reader2.readValue().toNumber();
      if (count * 32 > reader2._data.length) {
        logger$A.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader2._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i2 = 0; i2 < count; i2++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader2.coerce(this.name, unpack(reader2, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer2, value) {
    return writer2.writeValue(value ? 1 : 0);
  }
  decode(reader2) {
    return reader2.coerce(this.type, !reader2.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer2, value) {
    value = arrayify(value);
    let length2 = writer2.writeValue(value.length);
    length2 += writer2.writeBytes(value);
    return length2;
  }
  decode(reader2) {
    return reader2.readBytes(reader2.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(super.decode(reader2)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer2, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer2.writeBytes(data);
  }
  decode(reader2) {
    return reader2.coerce(this.name, hexlify(reader2.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer2, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer2.writeBytes([]);
  }
  decode(reader2) {
    reader2.readBytes(0);
    return reader2.coerce(this.name, null);
  }
}
const AddressZero$1 = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer2, value) {
    let v2 = BigNumber.from(value);
    let maxUintValue = MaxUint256$1.mask(writer2.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer2.wordSize);
    }
    return writer2.writeValue(v2);
  }
  decode(reader2) {
    let value = reader2.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader2.coerce(this.name, value);
  }
}
const version$h = "strings/5.7.0";
const logger$z = new Logger(version$h);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset2, bytes3, output, badCodepoint) {
  return logger$z.throwArgumentError(`invalid codepoint at offset ${offset2}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset2, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o2 = offset2 + 1; o2 < bytes3.length; o2++) {
      if (bytes3[o2] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset2 - 1;
  }
  return 0;
}
function replaceFunc(reason, offset2, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset2, bytes3);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i2 = 0;
  while (i2 < bytes3.length) {
    const c2 = bytes3[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes3, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes3, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes3.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes3, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes3[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes3, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$z.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex2 = "0000" + value.toString(16);
  return "\\u" + hex2.substring(hex2.length - 4);
}
function _toEscapedUtf8String(bytes3, onError) {
  return '"' + getUtf8CodePoints(bytes3, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
function formatBytes32String(text) {
  const bytes3 = toUtf8Bytes(text);
  if (bytes3.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes3, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes3) {
  const data = arrayify(bytes3);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length2 = 31;
  while (data[length2 - 1] === 0) {
    length2--;
  }
  return toUtf8String(data.slice(0, length2));
}
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi2 = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi2 + parseInt(comps[0], 16);
    hi2 = parseInt(comps[1], 16);
    return { l: lo, h: hi2 };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range = ranges[i2];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
const Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes2 = Table_B_2_lut_abs[codepoint];
  if (codes2) {
    return codes2;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex2 = Table_B_2_complex[codepoint];
  if (complex2) {
    return complex2;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes2 = toUtf8CodePoints(value);
  codes2 = flatten(codes2.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes2 = toUtf8CodePoints(_toUtf8String(codes2), UnicodeNormalizationForm.NFKC);
  codes2.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes2.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes2);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name2;
}
const lib_esm$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  _toEscapedUtf8String,
  formatBytes32String,
  nameprep,
  parseBytes32String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String
}, Symbol.toStringTag, { value: "Module" }));
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer2, value) {
    return super.encode(writer2, toUtf8Bytes(value));
  }
  decode(reader2) {
    return toUtf8String(super.decode(reader2));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer2, value) {
    return pack$1(writer2, this.coders, value);
  }
  decode(reader2) {
    return reader2.coerce(this.name, unpack(reader2, this.coders));
  }
}
const logger$y = new Logger(version$k);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match2 = param.type.match(paramTypeNumber);
    if (match2) {
      let size2 = parseInt(match2[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$y.throwArgumentError("invalid " + match2[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match2[1] === "int", param.name);
    }
    match2 = param.type.match(paramTypeBytes);
    if (match2) {
      let size2 = parseInt(match2[1]);
      if (size2 === 0 || size2 > 32) {
        logger$y.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$y.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$y.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values.length },
        value: { types: types2, values }
      });
    }
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer2 = this._getWriter();
    coder.encode(writer2, values);
    return writer2.data;
  }
  decode(types2, data, loose) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id$2(text) {
  return keccak256$1(toUtf8Bytes(text));
}
const version$g = "hash/5.7.0";
function decode$3(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify(data);
}
function encode$4(data) {
  data = arrayify(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}
const lib_esm$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$3,
  encode: encode$4
}, Symbol.toStringTag, { value: "Module" }));
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach2 = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach2.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i2 = 0; i2 < array.length; i2++) {
    const value = array[i2];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N10 = 31;
  const FULL = Math.pow(2, N10);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N10; i2++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start2 = 0;
    let end2 = symbol_count;
    while (end2 - start2 > 1) {
      let mid = start2 + end2 >>> 1;
      if (value < acc[mid]) {
        end2 = mid;
      } else {
        start2 = mid;
      }
    }
    if (start2 == 0)
      break;
    symbols.push(start2);
    let a2 = low + Math.floor(range * acc[start2] / total);
    let b2 = low + Math.floor(range * acc[start2 + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b2 - a2;
  }
  let offset2 = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset2) {
      case 3:
        return offset2 + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset2 + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset2 + bytes3[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_counts(n2, next2) {
  let v2 = Array(n2);
  for (let i2 = 0; i2 < n2; i2++)
    v2[i2] = 1 + next2();
  return v2;
}
function read_ascending(n2, next2) {
  let v2 = Array(n2);
  for (let i2 = 0, x2 = -1; i2 < n2; i2++)
    v2[i2] = x2 += 1 + next2();
  return v2;
}
function read_deltas(n2, next2) {
  let v2 = Array(n2);
  for (let i2 = 0, x2 = 0; i2 < n2; i2++)
    v2[i2] = x2 += signed(next2());
  return v2;
}
function read_member_array(next2, lookup2) {
  let v2 = read_ascending(next2(), next2);
  let n2 = next2();
  let vX = read_ascending(n2, next2);
  let vN = read_counts(n2, next2);
  for (let i2 = 0; i2 < n2; i2++) {
    for (let j = 0; j < vN[i2]; j++) {
      v2.push(vX[i2] + j);
    }
  }
  return lookup2 ? v2.map((x2) => lookup2[x2]) : v2;
}
function read_mapped_map(next2) {
  let ret = [];
  while (true) {
    let w2 = next2();
    if (w2 == 0)
      break;
    ret.push(read_linear_table(w2, next2));
  }
  while (true) {
    let w2 = next2() - 1;
    if (w2 < 0)
      break;
    ret.push(read_replacement_table(w2, next2));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next2) {
  let v2 = [];
  while (true) {
    let i2 = next2();
    if (i2 == 0)
      break;
    v2.push(i2);
  }
  return v2;
}
function read_transposed(n2, w2, next2) {
  let m2 = Array(n2).fill(void 0).map(() => []);
  for (let i2 = 0; i2 < w2; i2++) {
    read_deltas(n2, next2).forEach((x2, j) => m2[j].push(x2));
  }
  return m2;
}
function read_linear_table(w2, next2) {
  let dx = 1 + next2();
  let dy = next2();
  let vN = read_zero_terminated_array(next2);
  let m2 = read_transposed(vN.length, 1 + w2, next2);
  return flat(m2.map((v2, i2) => {
    const x2 = v2[0], ys = v2.slice(1);
    return Array(vN[i2]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x2 + j * dx, ys.map((y2) => y2 + j_dy)];
    });
  }));
}
function read_replacement_table(w2, next2) {
  let n2 = 1 + next2();
  let m2 = read_transposed(n2, 1 + w2, next2);
  return m2.map((v2) => [v2[0], v2.slice(1)]);
}
function read_emoji_trie(next2) {
  let sorted = read_member_array(next2).sort((a2, b2) => a2 - b2);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys2 = read_member_array(next2, sorted);
      if (keys2.length == 0)
        break;
      branches.push({ set: new Set(keys2), node: read2() });
    }
    branches.sort((a2, b2) => b2.set.size - a2.set.size);
    let temp = next2();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}
function getData() {
  return read_compressed_payload(decode$3("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$6 = getData();
const VALID = new Set(read_member_array(r$6));
const IGNORED = new Set(read_member_array(r$6));
const MAPPED = read_mapped_map(r$6);
const EMOJI_ROOT = read_emoji_trie(r$6);
const HYPHEN = 45;
const UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i2 = cps.lastIndexOf(UNDERSCORE) - 1; i2 >= 0; i2--) {
        if (cps[i2] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize$1(name2, filter_fe0f));
}
function normalize$1(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s2) {
  return s2.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a4;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a4 = node2.branches.find((x2) => x2.set.has(cp))) === null || _a4 === void 0 ? void 0 : _a4.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
const logger$x = new Logger(version$g);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes3 = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i2 = 0; i2 < bytes3.length; i2++) {
    const d2 = bytes3[i2];
    if (d2 === 46) {
      comps.push(checkComponent(bytes3.slice(last, i2)));
      last = i2 + 1;
    }
  }
  if (last >= bytes3.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes3.slice(last)));
  return comps;
}
function ensNormalize(name2) {
  return ensNameSplit(name2).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$x.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros$1;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256$1(concat([result, keccak256$1(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes3 = new Uint8Array(comp.length + 1);
    bytes3.set(comp, 1);
    bytes3[0] = bytes3.length - 1;
    return bytes3;
  }))) + "00";
}
const messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$1(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$w = new Logger(version$g);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes3 = arrayify(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return hexConcat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger$w.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger$w.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger$w.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes3 = arrayify(value);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error) {
    }
    return logger$w.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match2 = type.match(/^(u?)int(\d*)$/);
    if (match2) {
      const signed2 = match2[1] === "";
      const width = parseInt(match2[2] || "256");
      if (width % 8 !== 0 || width > 256 || match2[2] && match2[2] !== String(width)) {
        logger$w.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value) {
        const v2 = BigNumber.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$w.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match2 = type.match(/^bytes(\d+)$/);
    if (match2) {
      const width = parseInt(match2[1]);
      if (width === 0 || width > 32 || match2[1] !== String(width)) {
        logger$w.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes3 = arrayify(value);
        if (bytes3.length !== width) {
          logger$w.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$1(value);
      };
    case "string":
      return function(value) {
        return id$2(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$w.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$w.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$w.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$w.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$w.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$w.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types2);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types2[name2]) + st.map((t2) => encodeType(t2, types2[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match2[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger$w.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$1);
        }
        return keccak256$1(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id$2(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak256$1(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$w.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$w.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak256$1(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match2) {
      const subtype = match2[1];
      const length2 = parseInt(match2[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger$w.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger$w.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$w.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types2, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain, types2, value) {
    return keccak256$1(TypedDataEncoder.encode(domain, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types2, value, resolveName2) {
    return __awaiter$e(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types2, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$w.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger$w.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger$w.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
const lib_esm$c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _TypedDataEncoder: TypedDataEncoder,
  dnsEncode,
  ensNormalize,
  hashMessage,
  id: id$2,
  isValidName,
  messagePrefix,
  namehash
}, Symbol.toStringTag, { value: "Module" }));
const logger$v = new Logger(version$k);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket2 = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$v.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket2 = this.functions;
          break;
        case "event":
          bucket2 = this.events;
          break;
        case "error":
          bucket2 = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket2[signature2]) {
        logger$v.warn("duplicate definition - " + signature2);
        return;
      }
      bucket2[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger$v.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    return abi;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id$2(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id$2(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$v.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$v.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$v.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$v.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$v.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$v.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$v.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$v.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger$v.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger$v.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$v.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$v.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$v.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(fragment.inputs, bytes3.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$v.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes3 = arrayify(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes3.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes3);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes3.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes3.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger$v.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$v.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id$2(value);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value != null) {
          logger$v.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$v.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$v.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id$2(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$v.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index2] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index2];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i2 = 0; i2 < result.length; i2++) {
      const value = result[i2];
      if (value instanceof Error) {
        Object.defineProperty(result, i2, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i2}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
}
const lib_esm$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder
}, Symbol.toStringTag, { value: "Module" }));
const version$f = "abstract-provider/5.7.0";
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$u = new Logger(version$f);
class ForkEvent extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
let Provider$1 = class Provider2 {
  constructor() {
    logger$u.checkAbstract(new.target, Provider2);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$d(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};
const version$e = "abstract-signer/5.7.0";
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$t = new Logger(version$e);
const allowedTransactionKeys$3 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$t.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$3.indexOf(key2) === -1) {
        logger$t.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$t.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$c(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$t.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$t.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$t.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$t.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$t.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger$t.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results2) => {
          if (results2[1] !== 0 && results2[0] !== results2[1]) {
            logger$t.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results2[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger$t.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(address, provider2) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider2 || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger$t.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types2, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider2) {
    return new VoidSigner(this.address, provider2);
  }
}
var hash$5 = {};
var utils$b = {};
var minimalisticAssert$1 = assert$b;
function assert$b(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$b.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser$1.exports;
var assert$a = minimalisticAssert$1;
var inherits$1 = inherits_browserExports;
utils$b.inherits = inherits$1;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$b.toArray = toArray$1;
function toHex$1(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$b.toHex = toHex$1;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$b.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$b.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$b.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$b.zero8 = zero8;
function join32(msg, start2, end2, endian) {
  var len2 = end2 - start2;
  assert$a(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i2 = 0, k2 = start2; i2 < res.length; i2++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$b.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$b.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$b.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$b.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$b.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$b.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$b.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$b.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo;
}
utils$b.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2 >>> 0;
  var hi2 = (lo < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$b.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo = al2 + bl2;
  return lo >>> 0;
}
utils$b.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$b.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo = al2 + bl2 + cl2 + dl2;
  return lo >>> 0;
}
utils$b.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo = al2;
  lo = lo + bl2 >>> 0;
  carry += lo < al2 ? 1 : 0;
  lo = lo + cl2 >>> 0;
  carry += lo < cl2 ? 1 : 0;
  lo = lo + dl2 >>> 0;
  carry += lo < dl2 ? 1 : 0;
  lo = lo + el2 >>> 0;
  carry += lo < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$b.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo = al2 + bl2 + cl2 + dl2 + el2;
  return lo >>> 0;
}
utils$b.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$b.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$b.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$b.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$b.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$a = utils$b;
var assert$9 = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$a.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$a.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest2(enc) {
  this.update(this._pad());
  assert$9(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len2 = this.pendingTotal;
  var bytes3 = this._delta8;
  var k2 = bytes3 - (len2 + this.padLength) % bytes3;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k2; i2++)
    res[i2] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 & 255;
  } else {
    res[i2++] = len2 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$9 = utils$b;
var rotr32 = utils$9.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$8 = utils$b;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$8.rotl32;
var sum32$2 = utils$8.sum32;
var sum32_5$1 = utils$8.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$8.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h, "big");
  else
    return utils$8.split32(this.h, "big");
};
var utils$7 = utils$b;
var common$2 = common$5;
var shaCommon = common$4;
var assert$8 = minimalisticAssert$1;
var sum32$1 = utils$7.sum32;
var sum32_4$1 = utils$7.sum32_4;
var sum32_5 = utils$7.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$7.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$8(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$7.toHex32(this.h, "big");
  else
    return utils$7.split32(this.h, "big");
};
var utils$6 = utils$b;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$6.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$6.split32(this.h.slice(0, 7), "big");
};
var utils$5 = utils$b;
var common$1 = common$5;
var assert$7 = minimalisticAssert$1;
var rotr64_hi = utils$5.rotr64_hi;
var rotr64_lo = utils$5.rotr64_lo;
var shr64_hi = utils$5.shr64_hi;
var shr64_lo = utils$5.shr64_lo;
var sum64 = utils$5.sum64;
var sum64_hi = utils$5.sum64_hi;
var sum64_lo = utils$5.sum64_lo;
var sum64_4_hi = utils$5.sum64_4_hi;
var sum64_4_lo = utils$5.sum64_4_lo;
var sum64_5_hi = utils$5.sum64_5_hi;
var sum64_5_lo = utils$5.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$5.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start2) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start2 + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i2 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start2) {
  this._prepareBlock(msg, start2);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$7(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "big");
  else
    return utils$5.split32(this.h, "big");
};
function ch64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl, yh2, yl, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl, yh2, yl, zh2, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 28);
  var c1_hi = rotr64_hi(xl, xh2, 2);
  var c2_hi = rotr64_hi(xl, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 28);
  var c1_lo = rotr64_lo(xl, xh2, 2);
  var c2_lo = rotr64_lo(xl, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 14);
  var c1_hi = rotr64_hi(xh2, xl, 18);
  var c2_hi = rotr64_hi(xl, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 14);
  var c1_lo = rotr64_lo(xh2, xl, 18);
  var c2_lo = rotr64_lo(xl, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 1);
  var c1_hi = rotr64_hi(xh2, xl, 8);
  var c2_hi = shr64_hi(xh2, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 1);
  var c1_lo = rotr64_lo(xh2, xl, 8);
  var c2_lo = shr64_lo(xh2, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl) {
  var c0_hi = rotr64_hi(xh2, xl, 19);
  var c1_hi = rotr64_hi(xl, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl) {
  var c0_lo = rotr64_lo(xh2, xl, 19);
  var c1_lo = rotr64_lo(xl, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$4 = utils$b;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$4.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$4.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$3 = utils$b;
var common = common$5;
var rotl32 = utils$3.rotl32;
var sum32 = utils$3.sum32;
var sum32_3 = utils$3.sum32_3;
var sum32_4 = utils$3.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$3.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start2) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j = 0; j < 80; j++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$4(j, B2, C2, D2), msg[r$5[j] + start2], K$1(j)),
        s$2[j]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f$4(79 - j, Bh2, Ch2, Dh2), msg[rh[j] + start2], Kh(j)),
        sh[j]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest8(enc) {
  if (enc === "hex")
    return utils$3.toHex32(this.h, "little");
  else
    return utils$3.split32(this.h, "little");
};
function f$4(j, x2, y2, z2) {
  if (j <= 15)
    return x2 ^ y2 ^ z2;
  else if (j <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$1(j) {
  if (j <= 15)
    return 0;
  else if (j <= 31)
    return 1518500249;
  else if (j <= 47)
    return 1859775393;
  else if (j <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j) {
  if (j <= 15)
    return 1352829926;
  else if (j <= 31)
    return 1548603684;
  else if (j <= 47)
    return 1836072691;
  else if (j <= 63)
    return 2053994217;
  else
    return 0;
}
var r$5 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$2 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$2 = utils$b;
var assert$6 = minimalisticAssert$1;
function Hmac(hash2, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key2, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$2.toArray(key2, enc));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$6(key2.length <= this.blockSize);
  for (var i2 = key2.length; i2 < this.blockSize; i2++)
    key2.push(0);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest9(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash2 = exports;
  hash2.utils = utils$b;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac$1;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$5);
const hash$4 = /* @__PURE__ */ getDefaultExportFromCjs(hash$5);
function createCommonjsModule(fn2, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base3) {
      return commonjsRequire(path, base3 === void 0 || base3 === null ? module.path : base3);
    }
  }, fn2(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi2 = c2 >> 8;
        var lo = c2 & 255;
        if (hi2)
          res.push(hi2, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex2(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex2;
  utils2.encode = function encode3(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  var utils2 = exports;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1.toArray;
  utils2.zero2 = utils_1.zero2;
  utils2.toHex = utils_1.toHex;
  utils2.encode = utils_1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod2 = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod2;
        else
          z2 = mod2;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty;
  function parseBytes(bytes3) {
    return typeof bytes3 === "string" ? utils2.toArray(bytes3, "hex") : bytes3;
  }
  utils2.parseBytes = parseBytes;
  function intFromLE(bytes3) {
    return new BN$1(bytes3, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$1(conf.p, 16);
  this.red = conf.prime ? BN$1.red(conf.prime) : BN$1.mont(this.p);
  this.zero = new BN$1(0).toRed(this.red);
  this.one = new BN$1(1).toRed(this.red);
  this.two = new BN$1(2).toRed(this.red);
  this.n = conf.n && new BN$1(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate2() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l2 = j + doubles.step - 1; l2 >= j; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j;
  var p2;
  for (i2 = 0; i2 < len2; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b2]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j = 0; j < max2; j++) {
      var ja2 = jsf[0][j] | 0;
      var jb2 = jsf[1][j] | 0;
      naf[a2][j] = index2[(ja2 + 1) * 3 + (jb2 + 1)];
      naf[b2][j] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j = 0; j < len2; j++) {
        tmp[j] = naf[j][i2] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j = 0; j < len2; j++) {
      var z2 = tmp[j];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len2; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate3() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
  bytes3 = utils_1$1.toArray(bytes3, enc);
  var len2 = this.p.byteLength();
  if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len2) {
    if (bytes3[0] === 6)
      assert$1(bytes3[bytes3.length - 1] % 2 === 0);
    else if (bytes3[0] === 7)
      assert$1(bytes3[bytes3.length - 1] % 2 === 1);
    var res = this.point(
      bytes3.slice(1, 1 + len2),
      bytes3.slice(1 + len2, 1 + 2 * len2)
    );
    return res;
  } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len2) {
    return this.pointFromX(bytes3.slice(1, 1 + len2), bytes3[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact2) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact2)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint.prototype.encode = function encode2(enc, compact2) {
  return utils_1$1.encode(this._encode(compact2), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl3 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base$1.call(this, "short", conf);
  this.a = new BN$1(conf.a, 16).toRed(this.red);
  this.b = new BN$1(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base$1);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$1(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$1(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$1(vec.a, 16),
        b: new BN$1(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$1.mont(num);
  var tinv = new BN$1(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$1(1);
  var y1 = new BN$1(0);
  var x2 = new BN$1(0);
  var y2 = new BN$1(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c12 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c12.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c12.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$1(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate4(point3) {
  if (point3.inf)
    return true;
  var x2 = point3.x;
  var y2 = point3.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j = 0; j < i2 * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve, x2, y2, isRed) {
  base$1.BasePoint.call(this, curve, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$1(x2, 16);
    this.y = new BN$1(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base$1.BasePoint);
ShortCurve.prototype.point = function point2(x2, y2, isRed) {
  return new Point(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add2(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k2) {
  k2 = new BN$1(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate2 = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate2)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate2)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y2, z2) {
  base$1.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$1(0);
  } else {
    this.x = new BN$1(x2, 16);
    this.y = new BN$1(y2, 16);
    this.z = new BN$1(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base$1.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add3(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha2 = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha2 = alpha2.redAdd(alpha2).redIAdd(alpha2);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha2.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha2.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee2 = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k2, kbase) {
  k2 = new BN$1(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc2 = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc2.iadd(this.curve.n);
    if (xc2.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  var curve = exports;
  curve.base = base$1;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options2) {
    if (options2.type === "short")
      this.curve = new curve_1.short(options2);
    else if (options2.type === "edwards")
      this.curve = new curve_1.edwards(options2);
    else
      this.curve = new curve_1.mont(options2);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options2.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options2) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options2);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$4.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$4.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$4.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options2) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options2);
  this.hash = options2.hash;
  this.predResist = !!options2.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options2.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options2.entropy, options2.entropyEnc || "hex");
  var nonce = utils_1.toArray(options2.nonce, options2.nonceEnc || "hex");
  var pers = utils_1.toArray(options2.pers, options2.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$4.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add4, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add4;
    add4 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add4 = utils_1.toArray(add4, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add4 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len2, enc, add4, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add4;
    add4 = enc;
    enc = null;
  }
  if (add4) {
    add4 = utils_1.toArray(add4, addEnc || "hex");
    this._update(add4);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add4);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options2) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options2.priv)
    this._importPrivate(options2.priv, options2.privEnc);
  if (options2.pub)
    this._importPublic(options2.pub, options2.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate5() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact2, enc) {
  if (typeof compact2 === "string") {
    enc = compact2;
    compact2 = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact2);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$1(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options2) {
  return this.ec.sign(msg, this, enc, options2);
};
KeyPair.prototype.verify = function verify2(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options2, enc) {
  if (options2 instanceof Signature)
    return options2;
  if (this._importDER(options2, enc))
    return;
  assert$4(options2.r && options2.s, "Signature without r or s");
  this.r = new BN$1(options2.r, 16);
  this.s = new BN$1(options2.s, 16);
  if (options2.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options2.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len2 = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength(data, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$1(r2);
  this.s = new BN$1(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len2) {
  if (len2 < 128) {
    arr.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len2 >>> (octets << 3) & 255);
  }
  arr.push(len2);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options2) {
  if (!(this instanceof EC))
    return new EC(options2);
  if (typeof options2 === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options2),
      "Unknown curve " + options2
    );
    options2 = curves_1[options2];
  }
  if (options2 instanceof curves_1.PresetCurve)
    options2 = { curve: options2 };
  this.curve = options2.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options2.curve.g;
  this.g.precompute(options2.curve.n.bitLength() + 1);
  this.hash = options2.hash || options2.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options2) {
  return new key(this, options2);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options2) {
  if (!options2)
    options2 = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options2.pers,
    persEnc: options2.persEnc || "utf8",
    entropy: options2.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options2.entropy && options2.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes3 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (; ; ) {
    var priv = new BN$1(drbg.generate(bytes3));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options2) {
  if (typeof enc === "object") {
    options2 = enc;
    enc = null;
  }
  if (!options2)
    options2 = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$1(msg, 16));
  var bytes3 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes3);
  var nonce = msg.toArray("be", bytes3);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options2.pers,
    persEnc: options2.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0; ; iter++) {
    var k2 = options2.k ? options2.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options2.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify3(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new BN$1(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n2 = this.n;
  var e2 = new BN$1(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$1, i2);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;
const version$d = "signing-key/5.7.0";
const logger$s = new Logger(version$d);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger$s.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest10) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest10);
    if (digestBytes.length !== 32) {
      logger$s.throwArgumentError("bad digest length", "digest", digest10);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
}
function recoverPublicKey(digest10, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest10), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes3 = arrayify(key2);
  if (bytes3.length === 32) {
    const signingKey = new SigningKey(bytes3);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes3.length === 33) {
    if (compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
  } else if (bytes3.length === 65) {
    if (!compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
  }
  return logger$s.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const lib_esm$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey,
  computePublicKey,
  recoverPublicKey
}, Symbol.toStringTag, { value: "Module" }));
const version$c = "transactions/5.7.0";
const logger$r = new Logger(version$c);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
const allowedTransactionKeys$2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest10, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest10), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger$r.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$r.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index2) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger$r.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$r.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$5(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$5(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys$2);
  const raw2 = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options2 = {};
    if (fieldInfo.numeric) {
      options2.hexPad = "left";
    }
    value = arrayify(hexlify(value, options2));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger$r.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger$r.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw2.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger$r.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw2.push(hexlify(chainId));
    raw2.push("0x");
    raw2.push("0x");
  }
  if (!signature2) {
    return encode$5(raw2);
  }
  const sig = splitSignature(signature2);
  let v2 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw2.pop();
    raw2.pop();
    raw2.pop();
    v2 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v2) {
      logger$r.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v2) {
    logger$r.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw2.push(hexlify(v2));
  raw2.push(stripZeros(arrayify(sig.r)));
  raw2.push(stripZeros(arrayify(sig.s)));
  return encode$5(raw2);
}
function serialize$3(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger$r.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
  }
  return logger$r.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger$r.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest10 = keccak256$1(serialize2(tx));
    tx.from = recoverAddress(digest10, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode$4(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$r.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$4(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$r.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$4(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$r.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw2 = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw2.push(hexlify(tx.chainId));
      raw2.push("0x");
      raw2.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest10 = keccak256$1(encode$5(raw2));
    try {
      tx.from = recoverAddress(digest10, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256$1(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$3(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$r.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
const lib_esm$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return TransactionTypes;
  },
  accessListify,
  computeAddress,
  parse: parse$3,
  recoverAddress,
  serialize: serialize$3
}, Symbol.toStringTag, { value: "Module" }));
const version$b = "contracts/5.7.0";
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$q = new Logger(version$b);
const allowedTransactionKeys$1 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver2, nameOrPromise) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger$q.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver2) {
      logger$q.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver2.resolveName(name2);
    if (address == null) {
      logger$q.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver2, value, paramType) {
  return __awaiter$b(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver2, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver2, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver2, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger$q.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver2, v2, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter$b(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger$q.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter$b(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger$q.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes3 = arrayify(data);
      for (let i2 = 0; i2 < bytes3.length; i2++) {
        intrinsic += 4;
        if (bytes3[i2]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger$q.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger$q.throwError(`cannot override ${leftovers.map((l2) => JSON.stringify(l2)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger$q.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e2) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger$q.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag$1(filter3) {
  if (filter3.address && (filter3.topics == null || filter3.topics.length === 0)) {
    return "*";
  }
  return (filter3.address || "*") + "@" + (filter3.topics ? filter3.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
class RunningEvent {
  constructor(tag, filter3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter3);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i2) => i2.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter3 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger$q.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter3.topics = topics.slice();
    } else {
      filter3.topics = [topic];
    }
    super(getEventTag$1(filter3), filter3);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}
class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider$1.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger$q.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger$q.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger$q.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger$q.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e2) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger$q.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e2) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger$q.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger$q.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger$q.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter3 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(filter3), filter3));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger$q.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter3 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger$q.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter3.blockHash = fromBlockOrBlockhash;
    } else {
      filter3.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter3.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter3).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}
class Contract extends BaseContract {
}
let ContractFactory$1 = class ContractFactory2 {
  constructor(contractInterface, bytecode2, signer) {
    let bytecodeHex = null;
    if (typeof bytecode2 === "string") {
      bytecodeHex = bytecode2;
    } else if (isBytes(bytecode2)) {
      bytecodeHex = hexlify(bytecode2);
    } else if (bytecode2 && typeof bytecode2.object === "string") {
      bytecodeHex = bytecode2.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger$q.throwArgumentError("invalid bytecode", "bytecode", bytecode2);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger$q.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys$1[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger$q.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger$q.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger$q.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger$q.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger$q.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode2 = null;
    if (compilerOutput.bytecode) {
      bytecode2 = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode2 = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode2, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};
class BaseX {
  constructor(alphabet2) {
    defineReadOnly(this, "alphabet", alphabet2);
    defineReadOnly(this, "base", alphabet2.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet2.charAt(0));
    for (let i2 = 0; i2 < alphabet2.length; i2++) {
      this._alphabetMap[alphabet2.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes3 = [];
    if (value.length === 0) {
      return new Uint8Array(bytes3);
    }
    bytes3.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes3.length; ++j) {
        carry += bytes3[j] * this.base;
        bytes3[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes3.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes3.push(0);
    }
    return arrayify(new Uint8Array(bytes3.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
const lib_esm$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Base32,
  Base58,
  BaseX
}, Symbol.toStringTag, { value: "Module" }));
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$a = "sha2/5.7.0";
const logger$p = new Logger(version$a);
function ripemd160$1(data) {
  return "0x" + hash$4.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256$2(data) {
  return "0x" + hash$4.sha256().update(arrayify(data)).digest("hex");
}
function sha512$1(data) {
  return "0x" + hash$4.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm, key2, data) {
  if (!SupportedAlgorithm[algorithm]) {
    logger$p.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + hash$4.hmac(hash$4[algorithm], arrayify(key2)).update(arrayify(data)).digest("hex");
}
const lib_esm$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  },
  computeHmac,
  ripemd160: ripemd160$1,
  sha256: sha256$2,
  sha512: sha512$1
}, Symbol.toStringTag, { value: "Module" }));
function pbkdf2$2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i2 = 1; i2 <= l2; i2++) {
    block1[salt.length] = i2 >> 24 & 255;
    block1[salt.length + 1] = i2 >> 16 & 255;
    block1[salt.length + 2] = i2 >> 8 & 255;
    block1[salt.length + 3] = i2 & 255;
    let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T2 = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T2.set(U2);
    for (let j = 1; j < iterations; j++) {
      U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U2[k2];
    }
    const destPos = (i2 - 1) * hLen;
    const len2 = i2 === l2 ? r2 : hLen;
    DK.set(arrayify(T2).slice(0, len2), destPos);
  }
  return hexlify(DK);
}
const version$9 = "wordlists/5.7.0";
const logger$o = new Logger(version$9);
class Wordlist {
  constructor(locale) {
    logger$o.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  // Subclasses may override this
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i2 = 0; i2 < 2048; i2++) {
      const word = wordlist2.getWord(i2);
      if (i2 !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id$2(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index2) {
    loadWords(this);
    return wordlist[index2];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
};
const version$8 = "hdnode/5.7.0";
const logger$n = new Logger(version$8);
const N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256$2(sha256$2(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger$n.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160$1(sha256$2(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index2);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index2) {
    if (index2 > 4294967295) {
      throw new Error("invalid index - " + String(index2));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index2 & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify(this.publicKey));
    }
    for (let i2 = 24; i2 >= 0; i2 -= 8) {
      data[33 + (i2 >> 3)] = index2 >> 24 - i2 & 255;
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki2 = null;
    let Ki2 = null;
    if (this.privateKey) {
      ki2 = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek2 = new SigningKey(hexlify(IL));
      Ki2 = ek2._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard$1, ki2, Ki2, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components2 = path.split("/");
    if (components2.length === 0 || components2[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components2[0] === "m") {
      components2.shift();
    }
    let result = this;
    for (let i2 = 0; i2 < components2.length; i2++) {
      const component = components2[i2];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index2);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard$1, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes3 = Base58.decode(extendedKey);
    if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
      logger$n.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index2 = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key2 = bytes3.slice(45, 78);
    switch (hexlify(bytes3.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(key2), parentFingerprint, chainCode, index2, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard$1, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
    }
    return logger$n.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger$n.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset2 = 0;
  for (let i2 = 0; i2 < words2.length; i2++) {
    let index2 = wordlist2.getWordIndex(words2[i2].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset2 >> 3] |= 1 << 7 - offset2 % 8;
      }
      offset2++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256$2(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256$2(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index2) {
  if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
    logger$n.throwArgumentError("invalid account index", "index", index2);
  }
  return `m/44'/60'/${index2}'/0/0`;
}
const lib_esm$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HDNode,
  defaultPath,
  entropyToMnemonic,
  getAccountPath,
  isValidMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed
}, Symbol.toStringTag, { value: "Module" }));
const version$7 = "random/5.7.0";
const logger$m = new Logger(version$7);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof _global$1 !== "undefined") {
    return _global$1;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
let crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto$1 || !crypto$1.getRandomValues) {
  logger$m.warn("WARNING: Missing strong random number source");
  crypto$1 = {
    getRandomValues: function(buffer2) {
      return logger$m.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes(length2) {
  if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
    logger$m.throwArgumentError("invalid length", "length", length2);
  }
  const result = new Uint8Array(length2);
  crypto$1.getRandomValues(result);
  return arrayify(result);
}
function shuffled(array) {
  array = array.slice();
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j];
    array[j] = tmp;
  }
  return array;
}
const lib_esm$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes,
  shuffled
}, Symbol.toStringTag, { value: "Module" }));
var aesJs = { exports: {} };
(function(module, exports) {
  (function(root) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i2 = 0; i2 < arrayish.length; i2++) {
        if (!checkInt(arrayish[i2]) || arrayish[i2] < 0 || arrayish[i2] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy2) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy2) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length2) {
      return new Uint8Array(length2);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
      function toBytes(text) {
        var result = [], i2 = 0;
        text = encodeURI(text);
        while (i2 < text.length) {
          var c2 = text.charCodeAt(i2++);
          if (c2 === 37) {
            result.push(parseInt(text.substr(i2, 2), 16));
            i2 += 2;
          } else {
            result.push(c2);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes3) {
        var result = [], i2 = 0;
        while (i2 < bytes3.length) {
          var c2 = bytes3[i2];
          if (c2 < 128) {
            result.push(String.fromCharCode(c2));
            i2++;
          } else if (c2 > 191 && c2 < 224) {
            result.push(String.fromCharCode((c2 & 31) << 6 | bytes3[i2 + 1] & 63));
            i2 += 2;
          } else {
            result.push(String.fromCharCode((c2 & 15) << 12 | (bytes3[i2 + 1] & 63) << 6 | bytes3[i2 + 2] & 63));
            i2 += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var convertHex = function() {
      function toBytes(text) {
        var result = [];
        for (var i2 = 0; i2 < text.length; i2 += 2) {
          result.push(parseInt(text.substr(i2, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes3) {
        var result = [];
        for (var i2 = 0; i2 < bytes3.length; i2++) {
          var v2 = bytes3[i2];
          result.push(Hex[(v2 & 240) >> 4] + Hex[v2 & 15]);
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes3) {
      var result = [];
      for (var i2 = 0; i2 < bytes3.length; i2 += 4) {
        result.push(
          bytes3[i2] << 24 | bytes3[i2 + 1] << 16 | bytes3[i2 + 2] << 8 | bytes3[i2 + 3]
        );
      }
      return result;
    }
    var AES = function(key2) {
      if (!(this instanceof AES)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key2, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i2 = 0; i2 <= rounds; i2++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk2 = convertToInt32(this.key);
      var index2;
      for (var i2 = 0; i2 < KC; i2++) {
        index2 = i2 >> 2;
        this._Ke[index2][i2 % 4] = tk2[i2];
        this._Kd[rounds - index2][i2 % 4] = tk2[i2];
      }
      var rconpointer = 0;
      var t2 = KC, tt;
      while (t2 < roundKeyCount) {
        tt = tk2[KC - 1];
        tk2[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i2 = 1; i2 < KC; i2++) {
            tk2[i2] ^= tk2[i2 - 1];
          }
        } else {
          for (var i2 = 1; i2 < KC / 2; i2++) {
            tk2[i2] ^= tk2[i2 - 1];
          }
          tt = tk2[KC / 2 - 1];
          tk2[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
          for (var i2 = KC / 2 + 1; i2 < KC; i2++) {
            tk2[i2] ^= tk2[i2 - 1];
          }
        }
        var i2 = 0, r2, c2;
        while (i2 < KC && t2 < roundKeyCount) {
          r2 = t2 >> 2;
          c2 = t2 % 4;
          this._Ke[r2][c2] = tk2[i2];
          this._Kd[rounds - r2][c2] = tk2[i2++];
          t2++;
        }
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var c2 = 0; c2 < 4; c2++) {
          tt = this._Kd[r2][c2];
          this._Kd[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(plaintext);
      for (var i2 = 0; i2 < 4; i2++) {
        t2[i2] ^= this._Ke[0][i2];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i2 = 0; i2 < 4; i2++) {
          a2[i2] = T1[t2[i2] >> 24 & 255] ^ T2[t2[(i2 + 1) % 4] >> 16 & 255] ^ T3[t2[(i2 + 2) % 4] >> 8 & 255] ^ T4[t2[(i2 + 3) % 4] & 255] ^ this._Ke[r2][i2];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i2 = 0; i2 < 4; i2++) {
        tt = this._Ke[rounds][i2];
        result[4 * i2] = (S2[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i2 + 1] = (S2[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i2 + 2] = (S2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i2 + 3] = (S2[t2[(i2 + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(ciphertext);
      for (var i2 = 0; i2 < 4; i2++) {
        t2[i2] ^= this._Kd[0][i2];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i2 = 0; i2 < 4; i2++) {
          a2[i2] = T5[t2[i2] >> 24 & 255] ^ T6[t2[(i2 + 3) % 4] >> 16 & 255] ^ T7[t2[(i2 + 2) % 4] >> 8 & 255] ^ T8[t2[(i2 + 1) % 4] & 255] ^ this._Kd[r2][i2];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i2 = 0; i2 < 4; i2++) {
        tt = this._Kd[rounds][i2];
        result[4 * i2] = (Si2[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i2 + 1] = (Si2[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i2 + 2] = (Si2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i2 + 3] = (Si2[t2[(i2 + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key2) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key2);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
        copyArray(plaintext, block, 0, i2, i2 + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i2);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
        copyArray(ciphertext, block, 0, i2, i2 + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i2);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key2, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
        copyArray(plaintext, block, 0, i2, i2 + 16);
        for (var j = 0; j < 16; j++) {
          block[j] ^= this._lastCipherblock[j];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i2);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
        copyArray(ciphertext, block, 0, i2, i2 + 16);
        block = this._aes.decrypt(block);
        for (var j = 0; j < 16; j++) {
          plaintext[i2 + j] = block[j] ^ this._lastCipherblock[j];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i2, i2 + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key2, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i2 = 0; i2 < encrypted.length; i2 += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          encrypted[i2 + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i2 = 0; i2 < plaintext.length; i2 += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0; j < this.segmentSize; j++) {
          plaintext[i2 + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key2, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i2 = 0; i2 < encrypted.length; i2++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i2] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value) {
      if (typeof value !== "number" || parseInt(value) != value) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index2 = 15; index2 >= 0; --index2) {
        this._counter[index2] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes3) {
      bytes3 = coerceArray(bytes3, true);
      if (bytes3.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes3;
    };
    Counter.prototype.increment = function() {
      for (var i2 = 15; i2 >= 0; i2--) {
        if (this._counter[i2] === 255) {
          this._counter[i2] = 0;
        } else {
          this._counter[i2]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key2, counter2) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter2 instanceof Counter)) {
        counter2 = new Counter(counter2);
      }
      this._counter = counter2;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i2 = 0; i2 < encrypted.length; i2++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i2] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i2 = data.length; i2 < result.length; i2++) {
        result[i2] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length2 = data.length - padder;
      for (var i2 = 0; i2 < padder; i2++) {
        if (data[length2 + i2] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length2);
      copyArray(data, result, 0, 0, length2);
      return result;
    }
    var aesjs = {
      AES,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    {
      module.exports = aesjs;
    }
  })();
})(aesJs);
var aesJsExports = aesJs.exports;
const aes$1 = /* @__PURE__ */ getDefaultExportFromCjs(aesJsExports);
const version$6 = "json-wallets/5.7.0";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length2) {
  value = String(value);
  while (value.length < length2) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i2 = 0; i2 < comps.length; i2++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i2]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes3 = arrayify(randomBytes2);
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify(bytes3);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const logger$l = new Logger(version$6);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
}
function decrypt$1(json2, password) {
  const data = JSON.parse(json2);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$l.throwArgumentError("invalid encseed", "json", json2);
  }
  const key2 = arrayify(pbkdf2$2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new aes$1.ModeOfOperation.cbc(key2, iv);
  const seed = aes$1.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$1(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
function isCrowdsaleWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json2) {
  if (isCrowdsaleWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var scrypt$1 = { exports: {} };
(function(module, exports) {
  (function(root) {
    const MAX_VALUE = 2147483647;
    function SHA2562(m2) {
      const K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w2 = new Uint32Array(64);
      function blocks(p3) {
        let off = 0, len2 = p3.length;
        while (len2 >= 64) {
          let a2 = h0, b2 = h1, c2 = h2, d2 = h3, e2 = h4, f2 = h5, g2 = h6, h8 = h7, u2, i3, j, t1, t2;
          for (i3 = 0; i3 < 16; i3++) {
            j = off + i3 * 4;
            w2[i3] = (p3[j] & 255) << 24 | (p3[j + 1] & 255) << 16 | (p3[j + 2] & 255) << 8 | p3[j + 3] & 255;
          }
          for (i3 = 16; i3 < 64; i3++) {
            u2 = w2[i3 - 2];
            t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
            u2 = w2[i3 - 15];
            t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
            w2[i3] = (t1 + w2[i3 - 7] | 0) + (t2 + w2[i3 - 16] | 0) | 0;
          }
          for (i3 = 0; i3 < 64; i3++) {
            t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h8 + (K2[i3] + w2[i3] | 0) | 0) | 0;
            t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
            h8 = g2;
            g2 = f2;
            f2 = e2;
            e2 = d2 + t1 | 0;
            d2 = c2;
            c2 = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          h0 = h0 + a2 | 0;
          h1 = h1 + b2 | 0;
          h2 = h2 + c2 | 0;
          h3 = h3 + d2 | 0;
          h4 = h4 + e2 | 0;
          h5 = h5 + f2 | 0;
          h6 = h6 + g2 | 0;
          h7 = h7 + h8 | 0;
          off += 64;
          len2 -= 64;
        }
      }
      blocks(m2);
      let i2, bytesLeft = m2.length % 64, bitLenHi = m2.length / 536870912 | 0, bitLenLo = m2.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m2.slice(m2.length - bytesLeft, m2.length);
      p2.push(128);
      for (i2 = bytesLeft + 1; i2 < numZeros; i2++) {
        p2.push(0);
      }
      p2.push(bitLenHi >>> 24 & 255);
      p2.push(bitLenHi >>> 16 & 255);
      p2.push(bitLenHi >>> 8 & 255);
      p2.push(bitLenHi >>> 0 & 255);
      p2.push(bitLenLo >>> 24 & 255);
      p2.push(bitLenLo >>> 16 & 255);
      p2.push(bitLenLo >>> 8 & 255);
      p2.push(bitLenLo >>> 0 & 255);
      blocks(p2);
      return [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 >>> 0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 >>> 0 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 >>> 0 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 >>> 0 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 >>> 0 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 >>> 0 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 >>> 0 & 255,
        h7 >>> 24 & 255,
        h7 >>> 16 & 255,
        h7 >>> 8 & 255,
        h7 >>> 0 & 255
      ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA2562(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i2;
      let dk2 = [];
      for (i2 = 0; i2 < 64; i2++) {
        inner[i2] = 54;
      }
      for (i2 = 0; i2 < password.length; i2++) {
        inner[i2] ^= password[i2];
      }
      for (i2 = 0; i2 < salt.length; i2++) {
        inner[64 + i2] = salt[i2];
      }
      for (i2 = innerLen - 4; i2 < innerLen; i2++) {
        inner[i2] = 0;
      }
      for (i2 = 0; i2 < 64; i2++)
        outerKey[i2] = 92;
      for (i2 = 0; i2 < password.length; i2++)
        outerKey[i2] ^= password[i2];
      function incrementCounter() {
        for (let i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
          inner[i3]++;
          if (inner[i3] <= 255)
            return;
          inner[i3] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter();
        dk2 = dk2.concat(SHA2562(outerKey.concat(SHA2562(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk2 = dk2.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
      }
      return dk2;
    }
    function blockmix_salsa8(BY, Yi2, r2, x2, _X) {
      let i2;
      arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
      for (i2 = 0; i2 < 2 * r2; i2++) {
        blockxor(BY, i2 * 16, _X, 16);
        salsa20_8(_X, x2);
        arraycopy(_X, 0, BY, Yi2 + i2 * 16, 16);
      }
      for (i2 = 0; i2 < r2; i2++) {
        arraycopy(BY, Yi2 + i2 * 2 * 16, BY, i2 * 16, 16);
      }
      for (i2 = 0; i2 < r2; i2++) {
        arraycopy(BY, Yi2 + (i2 * 2 + 1) * 16, BY, (i2 + r2) * 16, 16);
      }
    }
    function R2(a2, b2) {
      return a2 << b2 | a2 >>> 32 - b2;
    }
    function salsa20_8(B2, x2) {
      arraycopy(B2, 0, x2, 0, 16);
      for (let i2 = 8; i2 > 0; i2 -= 2) {
        x2[4] ^= R2(x2[0] + x2[12], 7);
        x2[8] ^= R2(x2[4] + x2[0], 9);
        x2[12] ^= R2(x2[8] + x2[4], 13);
        x2[0] ^= R2(x2[12] + x2[8], 18);
        x2[9] ^= R2(x2[5] + x2[1], 7);
        x2[13] ^= R2(x2[9] + x2[5], 9);
        x2[1] ^= R2(x2[13] + x2[9], 13);
        x2[5] ^= R2(x2[1] + x2[13], 18);
        x2[14] ^= R2(x2[10] + x2[6], 7);
        x2[2] ^= R2(x2[14] + x2[10], 9);
        x2[6] ^= R2(x2[2] + x2[14], 13);
        x2[10] ^= R2(x2[6] + x2[2], 18);
        x2[3] ^= R2(x2[15] + x2[11], 7);
        x2[7] ^= R2(x2[3] + x2[15], 9);
        x2[11] ^= R2(x2[7] + x2[3], 13);
        x2[15] ^= R2(x2[11] + x2[7], 18);
        x2[1] ^= R2(x2[0] + x2[3], 7);
        x2[2] ^= R2(x2[1] + x2[0], 9);
        x2[3] ^= R2(x2[2] + x2[1], 13);
        x2[0] ^= R2(x2[3] + x2[2], 18);
        x2[6] ^= R2(x2[5] + x2[4], 7);
        x2[7] ^= R2(x2[6] + x2[5], 9);
        x2[4] ^= R2(x2[7] + x2[6], 13);
        x2[5] ^= R2(x2[4] + x2[7], 18);
        x2[11] ^= R2(x2[10] + x2[9], 7);
        x2[8] ^= R2(x2[11] + x2[10], 9);
        x2[9] ^= R2(x2[8] + x2[11], 13);
        x2[10] ^= R2(x2[9] + x2[8], 18);
        x2[12] ^= R2(x2[15] + x2[14], 7);
        x2[13] ^= R2(x2[12] + x2[15], 9);
        x2[14] ^= R2(x2[13] + x2[12], 13);
        x2[15] ^= R2(x2[14] + x2[13], 18);
      }
      for (let i2 = 0; i2 < 16; ++i2) {
        B2[i2] += x2[i2];
      }
    }
    function blockxor(S2, Si2, D2, len2) {
      for (let i2 = 0; i2 < len2; i2++) {
        D2[i2] ^= S2[Si2 + i2];
      }
    }
    function arraycopy(src2, srcPos, dest, destPos, length2) {
      while (length2--) {
        dest[destPos++] = src2[srcPos++];
      }
    }
    function checkBufferish(o2) {
      if (!o2 || typeof o2.length !== "number") {
        return false;
      }
      for (let i2 = 0; i2 < o2.length; i2++) {
        const v2 = o2[i2];
        if (typeof v2 !== "number" || v2 % 1 || v2 < 0 || v2 >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name2) {
      if (typeof value !== "number" || value % 1) {
        throw new Error("invalid " + name2);
      }
      return value;
    }
    function _scrypt(password, salt, N10, r2, p2, dkLen, callback) {
      N10 = ensureInteger(N10, "N");
      r2 = ensureInteger(r2, "r");
      p2 = ensureInteger(p2, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N10 === 0 || (N10 & N10 - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N10 > MAX_VALUE / 128 / r2) {
        throw new Error("N too large");
      }
      if (r2 > MAX_VALUE / 128 / p2) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p2 * 128 * r2);
      const B2 = new Uint32Array(p2 * 32 * r2);
      for (let i2 = 0; i2 < B2.length; i2++) {
        const j = i2 * 4;
        B2[i2] = (b2[j + 3] & 255) << 24 | (b2[j + 2] & 255) << 16 | (b2[j + 1] & 255) << 8 | (b2[j + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r2);
      const V2 = new Uint32Array(32 * r2 * N10);
      const Yi2 = 32 * r2;
      const x2 = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p2 * N10 * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state2 = 0;
      let i0 = 0, i1;
      let Bi2;
      const limit = callback ? parseInt(1e3 / r2) : 4294967295;
      const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps2;
        switch (state2) {
          case 0:
            Bi2 = i0 * 32 * r2;
            arraycopy(B2, Bi2, XY, 0, Yi2);
            state2 = 1;
            i1 = 0;
          case 1:
            steps2 = N10 - i1;
            if (steps2 > limit) {
              steps2 = limit;
            }
            for (let i2 = 0; i2 < steps2; i2++) {
              arraycopy(XY, 0, V2, (i1 + i2) * Yi2, Yi2);
              blockmix_salsa8(XY, Yi2, r2, x2, _X);
            }
            i1 += steps2;
            currentOp += steps2;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N10) {
              break;
            }
            i1 = 0;
            state2 = 2;
          case 2:
            steps2 = N10 - i1;
            if (steps2 > limit) {
              steps2 = limit;
            }
            for (let i2 = 0; i2 < steps2; i2++) {
              const offset2 = (2 * r2 - 1) * 16;
              const j = XY[offset2] & N10 - 1;
              blockxor(V2, j * Yi2, XY, Yi2);
              blockmix_salsa8(XY, Yi2, r2, x2, _X);
            }
            i1 += steps2;
            currentOp += steps2;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N10) {
              break;
            }
            arraycopy(XY, 0, B2, Bi2, Yi2);
            i0++;
            if (i0 < p2) {
              state2 = 0;
              break;
            }
            b2 = [];
            for (let i2 = 0; i2 < B2.length; i2++) {
              b2.push(B2[i2] >> 0 & 255);
              b2.push(B2[i2] >> 8 & 255);
              b2.push(B2[i2] >> 16 & 255);
              b2.push(B2[i2] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != void 0) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib2 = {
      scrypt: function(password, salt, N10, r2, p2, dkLen, progressCallback) {
        return new Promise(function(resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N10, r2, p2, dkLen, function(error, progress2, key2) {
            if (error) {
              reject(error);
            } else if (key2) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key2));
            } else if (progressCallback && progress2 !== lastProgress) {
              lastProgress = progress2;
              return progressCallback(progress2);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N10, r2, p2, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N10, r2, p2, dkLen));
      }
    };
    {
      module.exports = lib2;
    }
  })();
})(scrypt$1);
var scryptExports = scrypt$1.exports;
const scrypt = /* @__PURE__ */ getDefaultExportFromCjs(scryptExports);
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$k = new Logger(version$6);
function hasMnemonic$1(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter2 = new aes$1.Counter(iv);
    const aesCtr = new aes$1.ModeOfOperation.ctr(key2, counter2);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$1(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$k.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes$1.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes$1.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node2 = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node2.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2$2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2$1(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function(name2, value) {
      return logger$k.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N10 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p2 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N10 || !r2 || !p2) {
        throwError("kdf", kdf);
      }
      if ((N10 & N10 - 1) !== 0) {
        throwError("N", N10);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N10, r2, p2, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger$k.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json2, password) {
  const data = JSON.parse(json2);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt(json2, password, progressCallback) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const data = JSON.parse(json2);
    const key2 = yield _computeKdfKey(data, password, pbkdf2$1, scrypt.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt(account, password, options2, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic$1(account)) {
      const mnemonic = account.mnemonic;
      const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options2 === "function" && !progressCallback) {
    progressCallback = options2;
    options2 = {};
  }
  if (!options2) {
    options2 = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic$1(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client2 = options2.client;
  if (!client2) {
    client2 = "ethers.js";
  }
  let salt = null;
  if (options2.salt) {
    salt = arrayify(options2.salt);
  } else {
    salt = randomBytes(32);
  }
  let iv = null;
  if (options2.iv) {
    iv = arrayify(options2.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options2.uuid) {
    uuidRandom = arrayify(options2.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N10 = 1 << 17, r2 = 8, p2 = 1;
  if (options2.scrypt) {
    if (options2.scrypt.N) {
      N10 = options2.scrypt.N;
    }
    if (options2.scrypt.r) {
      r2 = options2.scrypt.r;
    }
    if (options2.scrypt.p) {
      p2 = options2.scrypt.p;
    }
  }
  return scrypt.scrypt(passwordBytes, salt, N10, r2, p2, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter2 = new aes$1.Counter(iv);
    const aesCtr = new aes$1.ModeOfOperation.ctr(derivedKey, counter2);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256$1(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N10,
          dklen: 32,
          p: p2,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new aes$1.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes$1.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = /* @__PURE__ */ new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client: client2,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
function decryptJsonWallet(json2, password, progressCallback) {
  if (isCrowdsaleWallet(json2)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt$1(json2, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json2)) {
    return decrypt(json2, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json2, password) {
  if (isCrowdsaleWallet(json2)) {
    return decrypt$1(json2, password);
  }
  if (isKeystoreWallet(json2)) {
    return decryptSync(json2, password);
  }
  throw new Error("invalid JSON wallet");
}
const lib_esm$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: decrypt$1,
  decryptJsonWallet,
  decryptJsonWalletSync,
  decryptKeystore: decrypt,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt,
  getJsonWalletAddress,
  isCrowdsaleWallet,
  isKeystoreWallet
}, Symbol.toStringTag, { value: "Module" }));
const version$5 = "wallet/5.7.0";
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$j = new Logger(version$5);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
class Wallet extends Signer {
  constructor(privateKey, provider2) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger$j.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node2.privateKey) !== this.address) {
          logger$j.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger$j.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider2 && !Provider$1.isProvider(provider2)) {
      logger$j.throwArgumentError("invalid provider", "provider", provider2);
    }
    defineReadOnly(this, "provider", provider2 || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider2) {
    return new Wallet(this, provider2);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger$j.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256$1(serialize$3(tx)));
      return serialize$3(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter$9(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        if (this.provider == null) {
          logger$j.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types2, populated.value)));
    });
  }
  encrypt(password, options2, progressCallback) {
    if (typeof options2 === "function" && !progressCallback) {
      progressCallback = options2;
      options2 = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options2) {
      options2 = {};
    }
    return encrypt(this, password, options2, progressCallback);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(options2) {
    let entropy = randomBytes(16);
    if (!options2) {
      options2 = {};
    }
    if (options2.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$1(concat([entropy, options2.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options2.locale);
    return Wallet.fromMnemonic(mnemonic, options2.path, options2.locale);
  }
  static fromEncryptedJson(json2, password, progressCallback) {
    return decryptJsonWallet(json2, password, progressCallback).then((account) => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json2, password) {
    return new Wallet(decryptJsonWalletSync(json2, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types2, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types2, value), signature2);
}
const lib_esm$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet,
  verifyMessage,
  verifyTypedData
}, Symbol.toStringTag, { value: "Module" }));
const version$4 = "networks/5.7.1";
const logger$i = new Logger(version$4);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options2) {
    if (options2 == null) {
      options2 = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options2.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options2.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options2.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options2.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options2.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options2.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options2.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider2 = new providers.PocketProvider(network, options2.pocket);
        if (provider2.network && skip.indexOf(provider2.network.name) === -1) {
          providerList.push(provider2);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options2.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options2.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider2 = new providers.AnkrProvider(network, options2.ankr);
        if (provider2.network && skip.indexOf(provider2.network.name) === -1) {
          providerList.push(provider2);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options2.quorum != null) {
        quorum = options2.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options2) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard3 = networks[name2];
      if (standard3.chainId === network) {
        return {
          name: standard3.name,
          chainId: standard3.chainId,
          ensAddress: standard3.ensAddress || null,
          _defaultProvider: standard3._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard3 = networks[network];
    if (standard3 == null) {
      return null;
    }
    return {
      name: standard3.name,
      chainId: standard3.chainId,
      ensAddress: standard3.ensAddress,
      _defaultProvider: standard3._defaultProvider || null
    };
  }
  const standard2 = networks[network.name];
  if (!standard2) {
    if (typeof network.chainId !== "number") {
      logger$i.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard2.chainId) {
    logger$i.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard2._defaultProvider) {
    if (isRenetworkable(standard2._defaultProvider)) {
      defaultProvider = standard2._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard2._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard2.chainId,
    ensAddress: network.ensAddress || standard2.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
const version$3 = "web/5.7.1";
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options2) {
  return __awaiter$8(this, void 0, void 0, function* () {
    if (options2 == null) {
      options2 = {};
    }
    const request = {
      method: options2.method || "GET",
      headers: options2.headers || {},
      body: options2.body || void 0
    };
    if (options2.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    if (options2.fetchOptions != null) {
      const opts = options2.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$h = new Logger(version$3);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$h.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$h.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options2 = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$h.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options2.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$h.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$4(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options2.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options2.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode$3(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger$h.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options2.method = "POST";
    options2.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options2.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$h.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options2.body, flatHeaders["content-type"]),
            requestMethod: options2.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$7(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options2);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options2.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$h.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options2.body, flatHeaders["content-type"]),
              requestMethod: options2.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger$h.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options2.body, flatHeaders["content-type"]),
            requestMethod: options2.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$h.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options2.body, flatHeaders["content-type"]),
              requestMethod: options2.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$h.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options2.body, flatHeaders["content-type"]),
        requestMethod: options2.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json2, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger$h.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json2 != null) {
    body = toUtf8Bytes(json2);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options2) {
  if (!options2) {
    options2 = {};
  }
  options2 = shallowCopy(options2);
  if (options2.floor == null) {
    options2.floor = 0;
  }
  if (options2.ceiling == null) {
    options2.ceiling = 1e4;
  }
  if (options2.interval == null) {
    options2.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options2.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options2.timeout);
    }
    const retryLimit = options2.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options2.oncePoll) {
          options2.oncePoll.once("poll", check);
        } else if (options2.onceBlock) {
          options2.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options2.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options2.floor) {
            timeout = options2.floor;
          }
          if (timeout > options2.ceiling) {
            timeout = options2.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}
const lib_esm$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData,
  fetchJson,
  poll
}, Symbol.toStringTag, { value: "Module" }));
var ALPHABET$2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z$3 = 0; z$3 < ALPHABET$2.length; z$3++) {
  var x$3 = ALPHABET$2.charAt(z$3);
  if (ALPHABET_MAP[x$3] !== void 0)
    throw new TypeError(x$3 + " is ambiguous");
  ALPHABET_MAP[x$3] = z$3;
}
function polymodStep(pre) {
  var b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix2) {
  var chk = 1;
  for (var i2 = 0; i2 < prefix2.length; ++i2) {
    var c2 = prefix2.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix2 + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i2 = 0; i2 < prefix2.length; ++i2) {
    var v2 = prefix2.charCodeAt(i2);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode$3(prefix2, words2, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix2.length + 7 + words2.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix2 = prefix2.toLowerCase();
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix2 + "1";
  for (var i2 = 0; i2 < words2.length; ++i2) {
    var x2 = words2[i2];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET$2.charAt(x2);
  }
  for (i2 = 0; i2 < 6; ++i2) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i2 = 0; i2 < 6; ++i2) {
    var v2 = chk >> (5 - i2) * 5 & 31;
    result += ALPHABET$2.charAt(v2);
  }
  return result;
}
function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8)
    return str + " too short";
  if (str.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered)
    return "Mixed-case string " + str;
  str = lowered;
  var split = str.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str;
  if (split === 0)
    return "Missing prefix for " + str;
  var prefix2 = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix2);
  if (typeof chk === "string")
    return chk;
  var words2 = [];
  for (var i2 = 0; i2 < wordChars.length; ++i2) {
    var c2 = wordChars.charAt(i2);
    var v2 = ALPHABET_MAP[c2];
    if (v2 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v2;
    if (i2 + 6 >= wordChars.length)
      continue;
    words2.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str;
  return { prefix: prefix2, words: words2 };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode$2(str) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad2) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i2 = 0; i2 < data.length; ++i2) {
    value = value << inBits | data[i2];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode: decode$2,
  encode: encode$3,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs(bech32);
const version$2 = "providers/5.7.2";
const logger$g = new Logger(version$2);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash2 = this.hash.bind(this);
    const hex2 = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash2,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash2, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash2,
      address,
      topics: Formatter.arrayOf(hash2),
      data,
      logIndex: number2,
      blockHash: hash2
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex2),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash2,
      transactionHash: hash2,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash2),
      parentHash: hash2,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex2),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash2)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash2, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash2),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash2),
      transactionHash: hash2,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger$g.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero$1 ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger$g.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse$3(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger$g.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger$g.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$g.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
let throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$f = new Logger(version$2);
const MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$f.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique2 = {};
      topic.forEach((topic2) => {
        unique2[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique2);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$f.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter3 = {};
    if (topics.length > 0) {
      filter3.topics = topics;
    }
    if (address && address !== "*") {
      filter3.address = address;
    }
    return filter3;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256$2(sha256$2(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start2) {
  try {
    return toUtf8String(_parseBytes(result, start2));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start2) {
  if (result === "0x") {
    return null;
  }
  const offset2 = BigNumber.from(hexDataSlice(result, start2, start2 + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset2, offset2 + 32)).toNumber();
  return hexDataSlice(result, offset2 + 32, offset2 + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger$f.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i2 = 0; i2 < datas.length; i2++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i2 = 0; i2 < datas.length; i2++) {
    const data = arrayify(datas[i2]);
    result[i2] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider2, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider2);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider2.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger$f.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$f.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes3 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes3[1];
      let version2 = bytes3[0];
      if (version2 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes3.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words2 = bech32$1.toWords(bytes3.slice(2));
        words2.unshift(version2);
        return bech32$1.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$f.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match2 = avatar.match(matchers[i2]);
          if (match2 == null) {
            continue;
          }
          const scheme = match2[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match2[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = encode$4("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
          return "sia://" + hash2;
        }
      }
      return logger$f.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider$1 {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$f.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$f.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i2 = 0; i2 < urls.length; i2++) {
        const url = urls[i2];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json2 = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json2, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger$f.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger$f.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m2) => JSON.stringify(m2)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$f.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$f.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter3 = event.filter;
              filter3.fromBlock = event._lastBlockNumber + 1;
              filter3.toBlock = blockNumber;
              const minFromBlock = filter3.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter3.fromBlock) {
                filter3.fromBlock = minFromBlock;
              }
              if (filter3.fromBlock < 0) {
                filter3.fromBlock = 0;
              }
              const runner = this.getLogs(filter3).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter3, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return logger$f.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall$1(0);
          return this._network;
        }
        const error = logger$f.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$6(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall$1(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$6(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti2 = 0; ti2 < block.transactions.length; ti2++) {
                    const tx = block.transactions[ti2];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$f.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$f.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position2, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position2).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger$f.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter$6(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$f.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter3) {
    return __awaiter$6(this, void 0, void 0, function* () {
      filter3 = yield filter3;
      const result = {};
      if (filter3.address != null) {
        result.address = this._getAddress(filter3.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter3[key2] == null) {
          return;
        }
        result[key2] = filter3[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter3[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter3[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger$f.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger$f.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u2 = 0; u2 < urlsLength; u2++) {
            const url = _parseString(urlsData, u2 * 32);
            if (url == null) {
              logger$f.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger$f.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger$f.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger$f.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$6(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$f.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$f.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger$f.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$6(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter3) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter3) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$f.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver2 = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver2.supportsWildcard())) {
            return null;
          }
          return resolver2;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$f.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger$f.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver2 = yield this.getResolver(name2);
      if (!resolver2) {
        return null;
      }
      return yield resolver2.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$6(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node2, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node2).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$6(this, void 0, void 0, function* () {
      let resolver2 = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node2, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver2 = new Resolver(this, resolverAddress, node2);
        try {
          const avatar2 = yield resolver2.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node2).substring(2)
          }), 0);
          resolver2 = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver2 = yield this.getResolver(nameOrAddress);
        if (!resolver2) {
          return null;
        }
      }
      const avatar = yield resolver2.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger$f.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$e = new Logger(version$2);
const errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError$1(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger$e.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger$e.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger$e.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger$e.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger$e.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger$e.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger$e.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult$1(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider2, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider2);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$e.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider2) {
    return logger$e.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$e.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$5(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$e.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$e.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash2) => {
        return hash2;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$e.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError$1("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$e.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash2 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter$5(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash2);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash2, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash2;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$e.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$e.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types2, value) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types2, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger$e.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types: types2, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const provider2 = this.provider;
      const address = yield this.getAddress();
      return provider2.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash2) => {
      return {
        hash: hash2,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash2, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$5(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger$e.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger$e.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult$1).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method, params) {
    return __awaiter$5(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger$e.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError$1(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes2) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes2.forEach(function(hash2) {
            self2._emitted["t:" + hash2.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash2).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
let WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger2 = new Logger(version$2);
  WS = function() {
    logger2.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$d = new Logger(version$2);
let NextId = 1;
class WebSocketProvider extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger$d.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger$d.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger$d.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger$d.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash2 = event2.hash;
          this.getTransactionReceipt(hash2).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash2, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e2) => e2.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e2) => e2.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$c = new Logger(version$2);
class StaticJsonRpcProvider extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger$c.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger$c.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger$c.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger$c.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger$c.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}
const logger$b = new Logger(version$2);
const defaultApiKey$2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider2 = new AlchemyProvider(network, apiKey);
    const url = provider2.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider2.network);
    defineReadOnly(this, "apiKey", provider2.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
class AlchemyProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$2;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger$b.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger$b.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey$2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey$2;
  }
}
const logger$a = new Logger(version$2);
const defaultApiKey$1 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name2) {
  switch (name2) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger$a.throwArgumentError("unsupported network", "name", name2);
}
class AnkrProvider extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey$1;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey$1;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey$1;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey$1) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$9 = new Logger(version$2);
class CloudflareProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger$9.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger$9.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$2(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger(version$2);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e2 = error.error;
    if (e2 && (e2.message.match(/reverted/i) || e2.message.match(/VM execution error/i))) {
      let data = e2.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger$8.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger$8.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger$8.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger$8.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger$8.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
class EtherscanProvider extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
    }
    return logger$8.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key2) => {
      const value = params[key2];
      if (value != null) {
        accum += `&${key2}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key2) => {
          return `${key2}=${payload[key2]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter$1(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger$8.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger$8.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i2 = 0; i2 < logs.length; i2++) {
            const log = logs[i2];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
      }
      return _super.perform.call(this, method, params);
    });
  }
  // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key2) {
          if (tx[key2] == "") {
            delete tx[key2];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$7 = new Logger(version$2);
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i2 = 0; i2 < networks2.length; i2++) {
    const network = networks2[i2];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger$7.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a2 - b2) > maxDelta) {
    return null;
  }
  return (a2 + b2) / 2;
}
function serialize$2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i2) => serialize$2(i2)));
  } else if (typeof value === "object") {
    const keys2 = Object.keys(value);
    keys2.sort();
    return "{" + keys2.map((key2) => {
      let v2 = value[key2];
      if (typeof v2 === "function") {
        v2 = "[function]";
      } else {
        v2 = serialize$2(v2);
      }
      return JSON.stringify(key2) + ":" + v2;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
let nextRid = 1;
function stall(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
const ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize3, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize3(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys2 = Object.keys(tally);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const check = tally[keys2[i2]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider2, method, params) {
  let normalize3 = serialize$2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider2._highestBlockNumber) {
          provider2._highestBlockNumber = blockNumber;
        }
        return provider2._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize3 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize$2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize3 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize$2(block);
        };
      } else {
        normalize3 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize$2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize3, provider2.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter(this, void 0, void 0, function* () {
    const provider2 = config2.provider;
    if (provider2.blockNumber != null && provider2.blockNumber >= blockNumber || blockNumber === -1) {
      return provider2;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider2.blockNumber >= blockNumber) {
            return resolve(provider2);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider2 });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter(this, void 0, void 0, function* () {
    let provider2 = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider2[method]();
      case "getEtherPrice":
        if (provider2.getEtherPrice) {
          return provider2.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider2[method](params.transaction, params.blockTag);
        }
        return provider2[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider2[method](params.transactionHash);
      case "getLogs": {
        let filter3 = params.filter;
        if (filter3.fromBlock && isHexString(filter3.fromBlock) || filter3.toBlock && isHexString(filter3.toBlock)) {
          provider2 = yield waitForSync(config2, currentBlockNumber);
        }
        return provider2.getLogs(filter3);
      }
    }
    return logger$7.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
class FallbackProvider extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger$7.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index2) => {
      if (Provider$1.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger$7.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index2}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger$7.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results2 = yield Promise.all(this.providerConfigs.map((c2) => {
          return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i3 = 0; i3 < results2.length; i3++) {
          const result = results2[i3];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results2[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a2, b2) => a2.priority - b2.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i2 = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
        while (inflightWeight < this.quorum && i2 < configs.length) {
          const config2 = configs[i2++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c2) => {
          if (c2.done || !c2.runner) {
            return;
          }
          waiting.push(c2.runner);
          if (c2.staller) {
            waiting.push(c2.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results2 = configs.filter((c2) => c2.done && c2.error == null);
        if (results2.length >= this.quorum) {
          const result = processFunc(results2);
          if (result !== void 0) {
            configs.forEach((c2) => {
              if (c2.staller) {
                c2.staller.cancel();
              }
              c2.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall(100).getPromise();
          }
          first = false;
        }
        const errors = configs.reduce((accum, c2) => {
          if (!c2.done || c2.error == null) {
            return accum;
          }
          const code2 = c2.error.code;
          if (ForwardErrors.indexOf(code2) >= 0) {
            if (!accum[code2]) {
              accum[code2] = { error: c2.error, weight: 0 };
            }
            accum[code2].weight += c2.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          const e2 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e2[name2] == null) {
              return;
            }
            props[name2] = e2[name2];
          });
          logger$7.throwError(e2.reason || e2.message, errorCode, props);
        });
        if (configs.filter((c2) => !c2.done).length === 0) {
          break;
        }
      }
      configs.forEach((c2) => {
        if (c2.staller) {
          c2.staller.cancel();
        }
        c2.cancelled = true;
      });
      return logger$7.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map((c2) => exposeDebugConfig(c2)),
        provider: this
      });
    });
  }
}
const IpcProvider = null;
const logger$6 = new Logger(version$2);
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider2 = new InfuraProvider(network, apiKey);
    const connection = provider2.connection;
    if (connection.password) {
      logger$6.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider2.projectId);
    defineReadOnly(this, "projectId", provider2.projectId);
    defineReadOnly(this, "projectSecret", provider2.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger$6.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger$6.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger$6.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class JsonRpcBatchProvider extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch2 = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch2.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch2.forEach((inflightRequest2, index2) => {
            const payload = result[index2];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch2.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
}
const logger$5 = new Logger(version$2);
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger$5.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey;
  }
  static getUrl(network, apiKey) {
    logger$5.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger$5.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
}
const logger$4 = new Logger(version$2);
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger$4.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger$4.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
const logger$3 = new Logger(version$2);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider2, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider2) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider2.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider2, network) {
    if (provider2 == null) {
      logger$3.throwArgumentError("missing provider", "provider", provider2);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider2 === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider2;
    } else {
      path = provider2.host || provider2.path || "";
      if (!path && provider2.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider2;
      if (provider2.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider2);
      } else if (provider2.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider2, provider2.sendAsync.bind(provider2));
      } else if (provider2.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider2, provider2.send.bind(provider2));
      } else {
        logger$3.throwArgumentError("unsupported provider", "provider", provider2);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}
const logger$2 = new Logger(version$2);
function getDefaultProvider(network, options2) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match2 = network.match(/^(ws|http)s?:/i);
    if (match2) {
      switch (match2[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger$2.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n2 = getNetwork(network);
  if (!n2 || !n2._defaultProvider) {
    logger$2.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n2._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options2);
}
const version$1 = "solidity/5.7.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$1 = new Logger(version$1);
function _pack(type, value, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match2 = type.match(regexNumber);
  if (match2) {
    let size2 = parseInt(match2[2] || "256");
    if (match2[2] && String(size2) !== match2[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger$1.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size2 = 256;
    }
    value = BigNumber.from(value).toTwos(size2);
    return zeroPad(value, size2 / 8);
  }
  match2 = type.match(regexBytes);
  if (match2) {
    const size2 = parseInt(match2[1]);
    if (String(size2) !== match2[1] || size2 === 0 || size2 > 32) {
      logger$1.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size2) {
      logger$1.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match2 = type.match(regexArray);
  if (match2 && Array.isArray(value)) {
    const baseType = match2[1];
    const count = parseInt(match2[2] || String(value.length));
    if (count != value.length) {
      logger$1.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger$1.throwArgumentError("invalid type", "type", type);
}
function pack(types2, values) {
  if (types2.length != values.length) {
    logger$1.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values[index2]));
  });
  return hexlify(concat(tight));
}
function keccak256(types2, values) {
  return keccak256$1(pack(types2, values));
}
function sha256$1(types2, values) {
  return sha256$2(pack(types2, values));
}
const lib_esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256,
  pack,
  sha256: sha256$1
}, Symbol.toStringTag, { value: "Module" }));
const version = "units/5.7.0";
const logger = new Logger(version);
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index2 = whole.length - 3;
      formatted.unshift(whole.substring(index2));
      whole = whole.substring(0, index2);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify,
  formatEther,
  formatUnits,
  parseEther,
  parseUnits
}, Symbol.toStringTag, { value: "Module" }));
var c1 = {
  "name": "Ethereum Mainnet",
  "chain": "ETH",
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "rpc": ["https://ethereum.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://mainnet.infura.io/v3/${INFURA_API_KEY}", "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}", "https://api.mycryptoapi.com/eth", "https://cloudflare-eth.com", "https://ethereum.publicnode.com"],
  "features": [{
    "name": "EIP1559"
  }, {
    "name": "EIP155"
  }],
  "faucets": [],
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "infoURL": "https://ethereum.org",
  "shortName": "eth",
  "chainId": 1,
  "networkId": 1,
  "slip44": 60,
  "ens": {
    "registry": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
  },
  "explorers": [{
    "name": "etherscan",
    "url": "https://etherscan.io",
    "standard": "EIP3091"
  }],
  "testnet": false,
  "slug": "ethereum"
};
var c5 = {
  "name": "Goerli",
  "title": "Ethereum Testnet Goerli",
  "chain": "ETH",
  "rpc": ["https://goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://eth-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://goerli.infura.io/v3/${INFURA_API_KEY}", "wss://goerli.infura.io/v3/${INFURA_API_KEY}", "https://rpc.goerli.mudit.blog/", "https://ethereum-goerli.publicnode.com"],
  "faucets": ["https://faucet.paradigm.xyz/", "http://fauceth.komputing.org?chain=5&address=${ADDRESS}", "https://goerli-faucet.slock.it?address=${ADDRESS}", "https://faucet.goerli.mudit.blog"],
  "nativeCurrency": {
    "name": "Goerli Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "infoURL": "https://goerli.net/#about",
  "shortName": "gor",
  "chainId": 5,
  "networkId": 5,
  "ens": {
    "registry": "0x112234455c3a32fd11230c42e7bccd4a84e02010"
  },
  "explorers": [{
    "name": "etherscan-goerli",
    "url": "https://goerli.etherscan.io",
    "standard": "EIP3091"
  }],
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": true,
  "slug": "goerli"
};
var c10 = {
  "name": "Optimism",
  "chain": "ETH",
  "rpc": ["https://optimism.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}", "https://mainnet.optimism.io/"],
  "faucets": [],
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "infoURL": "https://optimism.io",
  "shortName": "oeth",
  "chainId": 10,
  "networkId": 10,
  "explorers": [{
    "name": "etherscan",
    "url": "https://optimistic.etherscan.io",
    "standard": "EIP3091"
  }],
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": false,
  "slug": "optimism"
};
var c56 = {
  "name": "Binance Smart Chain Mainnet",
  "chain": "BSC",
  "rpc": ["https://binance.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "wss://bsc-ws-node.nariox.org", "https://bsc.publicnode.com", "https://bsc-dataseed4.ninicoin.io", "https://bsc-dataseed3.ninicoin.io", "https://bsc-dataseed2.ninicoin.io", "https://bsc-dataseed1.ninicoin.io", "https://bsc-dataseed4.defibit.io", "https://bsc-dataseed3.defibit.io", "https://bsc-dataseed2.defibit.io", "https://bsc-dataseed1.defibit.io", "https://bsc-dataseed4.binance.org", "https://bsc-dataseed3.binance.org", "https://bsc-dataseed2.binance.org", "https://bsc-dataseed1.binance.org"],
  "faucets": ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
  "nativeCurrency": {
    "name": "Binance Chain Native Token",
    "symbol": "BNB",
    "decimals": 18
  },
  "infoURL": "https://www.binance.org",
  "shortName": "bnb",
  "chainId": 56,
  "networkId": 56,
  "slip44": 714,
  "explorers": [{
    "name": "bscscan",
    "url": "https://bscscan.com",
    "standard": "EIP3091"
  }],
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": false,
  "slug": "binance"
};
var c97 = {
  "name": "Binance Smart Chain Testnet",
  "chain": "BSC",
  "rpc": ["https://binance-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://bsc-testnet.publicnode.com", "https://data-seed-prebsc-2-s3.binance.org:8545", "https://data-seed-prebsc-1-s3.binance.org:8545", "https://data-seed-prebsc-2-s2.binance.org:8545", "https://data-seed-prebsc-1-s2.binance.org:8545", "https://data-seed-prebsc-2-s1.binance.org:8545", "https://data-seed-prebsc-1-s1.binance.org:8545"],
  "faucets": ["https://testnet.binance.org/faucet-smart"],
  "nativeCurrency": {
    "name": "Binance Chain Native Token",
    "symbol": "tBNB",
    "decimals": 18
  },
  "infoURL": "https://testnet.binance.org/",
  "shortName": "bnbt",
  "chainId": 97,
  "networkId": 97,
  "explorers": [{
    "name": "bscscan-testnet",
    "url": "https://testnet.bscscan.com",
    "standard": "EIP3091"
  }],
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": true,
  "slug": "binance-testnet"
};
var c137 = {
  "name": "Polygon Mainnet",
  "chain": "Polygon",
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "rpc": ["https://polygon.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}", "https://polygon-rpc.com/", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com", "https://polygon-bor.publicnode.com"],
  "faucets": [],
  "nativeCurrency": {
    "name": "MATIC",
    "symbol": "MATIC",
    "decimals": 18
  },
  "infoURL": "https://polygon.technology/",
  "shortName": "matic",
  "chainId": 137,
  "networkId": 137,
  "slip44": 966,
  "explorers": [{
    "name": "polygonscan",
    "url": "https://polygonscan.com",
    "standard": "EIP3091"
  }],
  "testnet": false,
  "slug": "polygon"
};
var c250 = {
  "name": "Fantom Opera",
  "chain": "FTM",
  "rpc": ["https://fantom.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://fantom.publicnode.com", "https://rpc.ftm.tools"],
  "faucets": ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
  "nativeCurrency": {
    "name": "Fantom",
    "symbol": "FTM",
    "decimals": 18
  },
  "infoURL": "https://fantom.foundation",
  "shortName": "ftm",
  "chainId": 250,
  "networkId": 250,
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "explorers": [{
    "name": "ftmscan",
    "url": "https://ftmscan.com",
    "icon": {
      "url": "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
      "width": 73,
      "height": 73,
      "format": "png"
    },
    "standard": "EIP3091"
  }],
  "testnet": false,
  "slug": "fantom"
};
var c420 = {
  "name": "Optimism Goerli Testnet",
  "chain": "ETH",
  "rpc": ["https://optimism-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://opt-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://optimism-goerli.infura.io/v3/${INFURA_API_KEY}", "https://goerli.optimism.io/"],
  "faucets": ["https://coinbase.com/faucets/optimism-goerli-faucet"],
  "nativeCurrency": {
    "name": "Goerli Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "infoURL": "https://optimism.io",
  "shortName": "ogor",
  "chainId": 420,
  "networkId": 420,
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": true,
  "slug": "optimism-goerli"
};
var c4002 = {
  "name": "Fantom Testnet",
  "chain": "FTM",
  "rpc": ["https://fantom-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://fantom-testnet.publicnode.com", "https://rpc.testnet.fantom.network"],
  "faucets": ["https://faucet.fantom.network"],
  "nativeCurrency": {
    "name": "Fantom",
    "symbol": "FTM",
    "decimals": 18
  },
  "infoURL": "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet",
  "shortName": "tftm",
  "chainId": 4002,
  "networkId": 4002,
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "explorers": [{
    "name": "ftmscan",
    "url": "https://testnet.ftmscan.com",
    "icon": {
      "url": "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
      "width": 73,
      "height": 73,
      "format": "png"
    },
    "standard": "EIP3091"
  }],
  "testnet": true,
  "slug": "fantom-testnet"
};
var c42161 = {
  "name": "Arbitrum One",
  "chainId": 42161,
  "shortName": "arb1",
  "chain": "ETH",
  "networkId": 42161,
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "rpc": ["https://arbitrum.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}", "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://arb1.arbitrum.io/rpc"],
  "faucets": [],
  "explorers": [{
    "name": "Arbitrum Explorer",
    "url": "https://explorer.arbitrum.io",
    "standard": "EIP3091"
  }, {
    "name": "Arbiscan",
    "url": "https://arbiscan.io",
    "standard": "EIP3091"
  }],
  "infoURL": "https://arbitrum.io",
  "parent": {
    "type": "L2",
    "chain": "eip155-1",
    "bridges": [{
      "url": "https://bridge.arbitrum.io"
    }]
  },
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": false,
  "slug": "arbitrum"
};
var c43113 = {
  "name": "Avalanche Fuji Testnet",
  "chain": "AVAX",
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "rpc": ["https://avalanche-fuji.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}", "https://api.avax-test.network/ext/bc/C/rpc", "https://avalanche-fuji-c-chain.publicnode.com"],
  "faucets": ["https://faucet.avax.network/", "https://faucet.avax-test.network/"],
  "nativeCurrency": {
    "name": "Avalanche",
    "symbol": "AVAX",
    "decimals": 18
  },
  "infoURL": "https://cchain.explorer.avax-test.network",
  "shortName": "Fuji",
  "chainId": 43113,
  "networkId": 1,
  "explorers": [{
    "name": "snowtrace",
    "url": "https://testnet.snowtrace.io",
    "standard": "EIP3091"
  }],
  "testnet": true,
  "slug": "avalanche-fuji"
};
var c43114 = {
  "name": "Avalanche C-Chain",
  "chain": "AVAX",
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "rpc": ["https://avalanche.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}", "https://api.avax.network/ext/bc/C/rpc", "https://avalanche-c-chain.publicnode.com"],
  "features": [{
    "name": "EIP1559"
  }],
  "faucets": ["https://free-online-app.com/faucet-for-eth-evm-chains/"],
  "nativeCurrency": {
    "name": "Avalanche",
    "symbol": "AVAX",
    "decimals": 18
  },
  "infoURL": "https://www.avax.network/",
  "shortName": "avax",
  "chainId": 43114,
  "networkId": 43114,
  "slip44": 9005,
  "explorers": [{
    "name": "snowtrace",
    "url": "https://snowtrace.io",
    "standard": "EIP3091"
  }],
  "testnet": false,
  "slug": "avalanche"
};
var c80001 = {
  "name": "Mumbai",
  "title": "Polygon Testnet Mumbai",
  "chain": "Polygon",
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "rpc": ["https://mumbai.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://polygon-mumbai.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://polygon-mumbai.infura.io/v3/${INFURA_API_KEY}", "https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com", "https://polygon-mumbai-bor.publicnode.com"],
  "faucets": ["https://faucet.polygon.technology/"],
  "nativeCurrency": {
    "name": "MATIC",
    "symbol": "MATIC",
    "decimals": 18
  },
  "infoURL": "https://polygon.technology/",
  "shortName": "maticmum",
  "chainId": 80001,
  "networkId": 80001,
  "explorers": [{
    "name": "polygonscan",
    "url": "https://mumbai.polygonscan.com",
    "standard": "EIP3091"
  }],
  "testnet": true,
  "slug": "mumbai"
};
var c84531 = {
  "name": "Base Goerli Testnet",
  "chain": "ETH",
  "rpc": ["https://base-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://goerli.base.org"],
  "faucets": ["https://www.coinbase.com/faucets/base-ethereum-goerli-faucet"],
  "nativeCurrency": {
    "name": "Goerli Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "infoURL": "https://base.org",
  "shortName": "basegor",
  "chainId": 84531,
  "networkId": 84531,
  "explorers": [{
    "name": "basescout",
    "url": "https://base-goerli.blockscout.com",
    "standard": "none"
  }, {
    "name": "basescan",
    "url": "https://goerli.basescan.org",
    "standard": "none"
  }],
  "testnet": true,
  "icon": {
    "url": "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "slug": "base-goerli"
};
var c421613 = {
  "name": "Arbitrum Goerli",
  "title": "Arbitrum Goerli Rollup Testnet",
  "chainId": 421613,
  "shortName": "arb-goerli",
  "chain": "ETH",
  "networkId": 421613,
  "nativeCurrency": {
    "name": "Arbitrum Goerli Ether",
    "symbol": "AGOR",
    "decimals": 18
  },
  "rpc": ["https://arbitrum-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}", "https://arb-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}", "https://abritrum-goerli.infura.io/v3/${INFURA_API_KEY}", "https://goerli-rollup.arbitrum.io/rpc/"],
  "faucets": [],
  "infoURL": "https://arbitrum.io/",
  "explorers": [{
    "name": "Arbitrum Goerli Rollup Explorer",
    "url": "https://goerli-rollup-explorer.arbitrum.io",
    "standard": "EIP3091"
  }],
  "parent": {
    "type": "L2",
    "chain": "eip155-5",
    "bridges": [{
      "url": "https://bridge.arbitrum.io/"
    }]
  },
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "testnet": true,
  "slug": "arbitrum-goerli"
};
var c1337 = {
  "name": "Localhost",
  "chain": "ETH",
  "rpc": ["http://localhost:8545"],
  "faucets": [],
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "icon": {
    "url": "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
    "height": 512,
    "width": 512,
    "format": "png"
  },
  "shortName": "local",
  "chainId": 1337,
  "networkId": 1337,
  "testnet": true,
  "slug": "localhost"
};
const defaultOptions$1 = {
  mode: "http"
};
function getChainRPCs(chain, options2) {
  const {
    thirdwebApiKey,
    alchemyApiKey,
    infuraApiKey,
    mode: mode2
  } = {
    ...defaultOptions$1,
    ...options2
  };
  const modeChains = chain.rpc.filter((rpc2) => {
    if (rpc2.startsWith("http") && mode2 === "http") {
      return true;
    }
    if (rpc2.startsWith("ws") && mode2 === "ws") {
      return true;
    }
    return false;
  });
  const thirdwebRPC = modeChains.filter((rpc2) => {
    return rpc2.includes("${THIRDWEB_API_KEY}") && thirdwebApiKey;
  }).map((rpc2) => thirdwebApiKey ? rpc2.replace("${THIRDWEB_API_KEY}", thirdwebApiKey) : rpc2);
  const alchemyRPC = modeChains.filter((rpc2) => {
    return rpc2.includes("${ALCHEMY_API_KEY}") && alchemyApiKey;
  }).map((rpc2) => alchemyApiKey ? rpc2.replace("${ALCHEMY_API_KEY}", alchemyApiKey) : rpc2);
  const infuraRPC = modeChains.filter((rpc2) => {
    return rpc2.includes("${INFURA_API_KEY}") && infuraApiKey;
  }).map((rpc2) => infuraApiKey ? rpc2.replace("${INFURA_API_KEY}", infuraApiKey) : rpc2);
  const allOtherRpcs = modeChains.filter((rpc2) => {
    return !rpc2.includes("${");
  });
  const orderedRPCs = [...thirdwebRPC, ...infuraRPC, ...alchemyRPC, ...allOtherRpcs];
  if (orderedRPCs.length === 0) {
    throw new Error(`No RPC available for chainId "${chain.chainId}" with mode ${mode2}`);
  }
  return orderedRPCs;
}
function getChainRPC(chain, options2) {
  return getChainRPCs(chain, options2)[0];
}
const defaultChains = [c1, c5, c84531, c137, c80001, c42161, c421613, c10, c420, c56, c97, c250, c4002, c43114, c43113, c1337];
function _checkPrivateRedeclaration$1(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec$1(obj, privateMap, value) {
  _checkPrivateRedeclaration$1(obj, privateMap);
  privateMap.set(obj, value);
}
function _classApplyDescriptorGet$1(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classExtractFieldDescriptor$1(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet$1(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "get");
  return _classApplyDescriptorGet$1(receiver, descriptor);
}
function _classApplyDescriptorSet$1(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldSet$1(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor$1(receiver, privateMap, "set");
  _classApplyDescriptorSet$1(receiver, descriptor, value);
  return value;
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration$1(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateMethodGet(receiver, privateSet, fn2) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn2;
}
function _toPrimitive$1(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$1(arg) {
  var key2 = _toPrimitive$1(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
function _defineProperty$1(obj, key2, value) {
  key2 = _toPropertyKey$1(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn2, context, once) {
    this.fn = fn2;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn2, context, once) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names2 = [], events, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events = this._events) {
      if (has.call(events, name2))
        names2.push(prefix2 ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn2, context) {
    return addListener(this, event, fn2, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn2, context) {
    return addListener(this, event, fn2, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn2, context, once) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
        if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix2;
  EventEmitter.EventEmitter = EventEmitter;
  {
    module.exports = EventEmitter;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
function chainIdToThirdwebRpc(chainId) {
  return `https://${chainId}.rpc.thirdweb.com`;
}
const EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
const EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature2, address, chainId) {
  const provider2 = new JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider2);
  const _hashMessage = hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature2);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
class AbstractWallet extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    _defineProperty$1(this, "type", "evm");
  }
  /**
   * @returns the account address from connected wallet
   */
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  /**
   * @returns the chain id from connected wallet
   */
  async getChainId() {
    const signer = await this.getSigner();
    return signer.getChainId();
  }
  /**
   * @returns the signature of the message
   */
  async signMessage(message) {
    const signer = await this.getSigner();
    return await signer.signMessage(message);
  }
  /**
   * verify the signature of a message
   * @returns `true` if the signature is valid, `false` otherwise
   */
  async verifySignature(message, signature2, address, chainId) {
    try {
      const messageHash = hashMessage(message);
      const messageHashBytes = arrayify(messageHash);
      const recoveredAddress = recoverAddress(messageHashBytes, signature2);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        const isValid2 = await checkContractWalletSignature(message, signature2, address, chainId || 1);
        return isValid2;
      } catch {
      }
    }
    return false;
  }
}
const PREFIX = "__TW__";
class AsyncLocalStorage {
  constructor(name2) {
    _defineProperty$1(this, "name", void 0);
    this.name = name2;
  }
  getItem(key2) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key2}`));
    });
  }
  setItem(key2, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key2}`, value);
        res();
      } catch (e2) {
        rej(e2);
      }
    });
  }
  removeItem(key2) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key2}`);
      res();
    });
  }
}
function createAsyncLocalStorage(name2) {
  return new AsyncLocalStorage(name2);
}
const DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connectParams = /* @__PURE__ */ new WeakMap();
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
class AbstractClientWallet extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options2) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _defineProperty$1(this, "walletId", void 0);
    _defineProperty$1(this, "walletStorage", void 0);
    _defineProperty$1(this, "chains", void 0);
    _defineProperty$1(this, "dappMetadata", void 0);
    _defineProperty$1(this, "options", void 0);
    _classPrivateFieldInitSpec$1(this, _connectParams, {
      writable: true,
      value: void 0
    });
    this.walletId = walletId;
    this.options = options2;
    this.chains = options2?.chains || defaultChains;
    this.dappMetadata = options2?.dappMetadata || DEFAULT_DAPP_META;
    this.walletStorage = options2?.walletStorage || createAsyncLocalStorage(this.walletId);
  }
  /**
   * tries to auto connect to the wallet
   */
  async autoConnect(connectOptions) {
    const options2 = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options2);
  }
  /**
   * connect to the wallet
   */
  async connect(connectOptions) {
    _classPrivateFieldSet$1(this, _connectParams, connectOptions);
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return _classPrivateFieldGet$1(this, _connectParams);
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains;
    const connector = await this.getConnector();
    connector.updateChains(chains);
  }
  /**
   * If the wallet uses a personal wallet under the hood, return it
   */
  getPersonalWallet() {
    return void 0;
  }
}
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address2 = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions?.chainId) {
      await connector.switchChain(connectOptions?.chainId);
    }
    this.emit("connect", {
      address: address2,
      chainId: await this.getChainId()
    });
    return address2;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  const address = await connector.connect(connectOptions);
  return address;
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    this.emit("connect", {
      address: data.account,
      chainId: data.chain?.id
    });
  });
  connector.on("change", (data) => {
    this.emit("change", {
      address: data.account,
      chainId: data.chain?.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}
_defineProperty$1(AbstractClientWallet, "meta", void 0);
const walletIds = {
  coinbase: "coinbase",
  metamask: "metamask",
  localWallet: "localWallet",
  smartWallet: "smartWallet",
  safe: "safe",
  walletConnectV1: "walletConnectV1",
  walletConnect: "walletConnect",
  magicLink: "magicLink",
  paper: "paper"
};
var __spreadArray$3 = globalThis && globalThis.__spreadArray || function(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name2, version2, os) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process$1.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name2, version2, os, bot) {
      this.name = name2;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a4) {
    var browser2 = _a4[0], regex = _a4[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match2 = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray$3(__spreadArray$3([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS$1(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os);
}
function detectOS$1(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a4 = operatingSystemRules[ii2], os = _a4[0], regex = _a4[1];
    var match2 = regex.exec(ua2);
    if (match2) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process$1 !== "undefined" && process$1.version;
  return isNode2 ? new NodeInfo(process$1.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output.push("0");
  }
  return output;
}
var util$2;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys2.push(key2);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$2 || (util$2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el2 = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$2.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps2 = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps2) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results2) {
    const arrayValue = [];
    for (const s2 of results2) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a4;
    const ctx = {
      common: {
        issues: [],
        async: (_a4 = params === null || params === void 0 ? void 0 : params.async) !== null && _a4 !== void 0 ? _a4 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a4) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    var _a4;
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      offset: (_a4 = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a4 !== void 0 ? _a4 : false,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 === null || options2 === void 0 ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len2, message) {
    return this._addCheck({
      kind: "length",
      value: len2,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a4;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util$2.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a4;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a4 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a4 !== void 0 ? _a4 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len2, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len2, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util$2.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a4, _b3, _c2, _d2;
          const defaultError = (_c2 = (_b3 = (_a4 = this._def).errorMap) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util$2.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$2.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results2) {
      for (const result of results2) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results2) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results2.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$2.objectKeys(b2);
    const sharedKeys = util$2.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left2, right2]) => handleParsed(left2, right2));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left2, right2, params) => {
  return new ZodIntersection({
    left: left2,
    right: right2,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results2) => {
        return ParseStatus.mergeArray(status, results2);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await fn2(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn2(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect2 = this._def.effect || null;
    if (effect2.type === "preprocess") {
      const processed = effect2.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect2.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect2.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect2.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect2.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect2.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$2.assertNever(effect2);
  }
}
ZodEffects.create = (schema, effect2, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect2,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a4, _b3;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b3 = (_a4 = p2.fatal) !== null && _a4 !== void 0 ? _a4 : fatal) !== null && _b3 !== void 0 ? _b3 : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$2;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const IBurnableERC20Abi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burnFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IDrop = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const DropERC20_V2Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IDropSinglePhase = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IDropSinglePhaseV1 = [
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ERC20Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "who",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IERC20PermitAbi = [
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IMintableERC20Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const MulticallAbi = [
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ISignatureMintERC20Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC20.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IBurnableERC721Abi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IClaimableERC721 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];
const DelayedRevealAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const DropERC721_V3Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "NFTRevealed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const Erc721Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const Erc721EnumerableAbi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "tokenOfOwnerByIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const Erc721SupplyAbi = [
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const ILazyMintAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "extraData",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IMintableERC721Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "mintTo",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const SignatureMintERC721Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC721.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const SignatureMintERC721_V1Abi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ITokenERC721.MintRequest",
        name: "_req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const TieredDropAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "tier",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "encryptedBaseURI",
        type: "bytes"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    inputs: [],
    name: "getBaseURICount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_index",
        type: "uint256"
      }
    ],
    name: "getBatchIdAtIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMetadataForAllTiers",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "tier",
            type: "string"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "startIdInclusive",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "endIdNonInclusive",
                type: "uint256"
              }
            ],
            internalType: "struct LazyMintWithTier.TokenRange[]",
            name: "ranges",
            type: "tuple[]"
          },
          {
            internalType: "string[]",
            name: "baseURIs",
            type: "string[]"
          }
        ],
        internalType: "struct LazyMintWithTier.TierMetadata[]",
        name: "metadataForAllTiers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "_baseURIForTokens",
        type: "string"
      },
      {
        internalType: "string",
        name: "_tier",
        type: "string"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "lazyMint",
    outputs: [
      {
        internalType: "uint256",
        name: "batchId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IBurnableERC1155Abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "burnBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IClaimableERC1155 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      }
    ],
    name: "verifyClaim",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];
const IDropMultiPhase1155 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDrop1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const DropERC1155_V2Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "claimConditions",
        type: "tuple[]"
      }
    ],
    name: "ClaimConditionsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxTotalSupply",
        type: "uint256"
      }
    ],
    name: "MaxTotalSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "MaxWalletClaimCountUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "saleRecipient",
        type: "address"
      }
    ],
    name: "SaleRecipientForTokenUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "claimConditionIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "baseURI",
        type: "string"
      }
    ],
    name: "TokensLazyMinted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "wallet",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    name: "WalletClaimCountUpdated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proofs",
        type: "bytes32[]"
      },
      {
        internalType: "uint256",
        name: "proofMaxQuantityPerTransaction",
        type: "uint256"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "baseURIForTokens",
        type: "string"
      }
    ],
    name: "lazyMint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
        name: "phases",
        type: "tuple[]"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IDropSinglePhase1155 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IDropSinglePhase1155.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerWallet",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "string",
            name: "metadata",
            type: "string"
          }
        ],
        internalType: "struct IClaimCondition.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IDropSinglePhase1155_V1 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "condition",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "resetEligibility",
        type: "bool"
      }
    ],
    name: "ClaimConditionUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "claimer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityClaimed",
        type: "uint256"
      }
    ],
    name: "TokensClaimed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "bytes32[]",
            name: "proof",
            type: "bytes32[]"
          },
          {
            internalType: "uint256",
            name: "maxQuantityInAllowlist",
            type: "uint256"
          }
        ],
        internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
        name: "allowlistProof",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "startTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxClaimableSupply",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyClaimed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantityLimitPerTransaction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "waitTimeInSecondsBetweenClaims",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "merkleRoot",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          }
        ],
        internalType: "struct IClaimCondition_V1.ClaimCondition",
        name: "phase",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "resetClaimEligibility",
        type: "bool"
      }
    ],
    name: "setClaimConditions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const Erc1155Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "_value",
        type: "string"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_owners",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "_ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "_values",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const Erc1155EnumerableAbi = [
  {
    inputs: [],
    name: "nextTokenIdToMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IMintableERC1155Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityMinted",
        type: "uint256"
      }
    ],
    name: "TokensMinted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mintTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ISignatureMintERC1155Abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "mintedTo",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenIdMinted",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        indexed: false,
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "mintRequest",
        type: "tuple"
      }
    ],
    name: "TokensMintedWithSignature",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "mintWithSignature",
    outputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "royaltyRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "royaltyBps",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "primarySaleRecipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "uri",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "validityStartTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "validityEndTimestamp",
            type: "uint128"
          },
          {
            internalType: "bytes32",
            name: "uid",
            type: "bytes32"
          }
        ],
        internalType: "struct ISignatureMintERC1155.MintRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IERC2771ContextAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IAppURI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "AppURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "appURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setAppURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IContractMetadataAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "ContractURIUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IDirectListingsAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "BuyerApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    name: "CancelledListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "pricePerToken",
        type: "uint256"
      }
    ],
    name: "CurrencyApprovedForListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "NewListing",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "NewSale",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "listingCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    name: "UpdatedListing",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveBuyerForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_pricePerTokenInCurrency",
        type: "uint256"
      }
    ],
    name: "approveCurrencyForListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_buyFor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_quantity",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_expectedTotalPrice",
        type: "uint256"
      }
    ],
    name: "buyFromListing",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createListing",
    outputs: [
      {
        internalType: "uint256",
        name: "listingId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidListings",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing[]",
        name: "listings",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      }
    ],
    name: "getListing",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "listingId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "listingCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          },
          {
            internalType: "enum IDirectListings.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IDirectListings.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IDirectListings.Listing",
        name: "listing",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalListings",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_listingId",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pricePerToken",
            type: "uint256"
          },
          {
            internalType: "uint128",
            name: "startTimestamp",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "endTimestamp",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "reserved",
            type: "bool"
          }
        ],
        internalType: "struct IDirectListings.ListingParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "updateListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IEnglishAuctionsAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "closer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "winningBidder",
        type: "address"
      }
    ],
    name: "AuctionClosed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    name: "CancelledAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "auctionCreator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewAuction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    name: "NewBid",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "bidInAuction",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "cancelAuction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionPayout",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "collectAuctionTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          }
        ],
        internalType: "struct IEnglishAuctions.AuctionParameters",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "createAuction",
    outputs: [
      {
        internalType: "uint256",
        name: "auctionId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidAuctions",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction[]",
        name: "auctions",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getAuction",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "auctionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "auctionCreator",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minimumBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "buyoutBidAmount",
            type: "uint256"
          },
          {
            internalType: "uint64",
            name: "timeBufferInSeconds",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "bidBufferBps",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "startTimestamp",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endTimestamp",
            type: "uint64"
          },
          {
            internalType: "enum IEnglishAuctions.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IEnglishAuctions.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IEnglishAuctions.Auction",
        name: "auction",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "getWinningBid",
    outputs: [
      {
        internalType: "address",
        name: "bidder",
        type: "address"
      },
      {
        internalType: "address",
        name: "currency",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bidAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      }
    ],
    name: "isAuctionExpired",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_auctionId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_bidAmount",
        type: "uint256"
      }
    ],
    name: "isNewWinningBid",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IOffersAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "quantityBought",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPricePaid",
        type: "uint256"
      }
    ],
    name: "AcceptedOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    name: "CancelledOffer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "offeror",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetContract",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    name: "NewOffer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "acceptOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "cancelOffer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endId",
        type: "uint256"
      }
    ],
    name: "getAllValidOffers",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer[]",
        name: "offers",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_offerId",
        type: "uint256"
      }
    ],
    name: "getOffer",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "offerId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "offeror",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          },
          {
            internalType: "enum IOffers.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "enum IOffers.Status",
            name: "status",
            type: "uint8"
          }
        ],
        internalType: "struct IOffers.Offer",
        name: "offer",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "currency",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expirationTimestamp",
            type: "uint256"
          }
        ],
        internalType: "struct IOffers.OfferParams",
        name: "_params",
        type: "tuple"
      }
    ],
    name: "makeOffer",
    outputs: [
      {
        internalType: "uint256",
        name: "offerId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IPackVRFAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalPacksCreated",
        type: "uint256"
      }
    ],
    name: "PackCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackOpenRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "opener",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "numOfPacksOpened",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        indexed: false,
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnitsDistributed",
        type: "tuple[]"
      }
    ],
    name: "PackOpened",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    name: "PackRandomnessFulfilled",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_opener",
        type: "address"
      }
    ],
    name: "canClaimRewards",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "claimRewards",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "rewardUnits",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "assetContract",
            type: "address"
          },
          {
            internalType: "enum ITokenBundle.TokenType",
            name: "tokenType",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          }
        ],
        internalType: "struct ITokenBundle.Token[]",
        name: "contents",
        type: "tuple[]"
      },
      {
        internalType: "uint256[]",
        name: "numOfRewardUnits",
        type: "uint256[]"
      },
      {
        internalType: "string",
        name: "packUri",
        type: "string"
      },
      {
        internalType: "uint128",
        name: "openStartTimestamp",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "amountDistributedPerOpen",
        type: "uint128"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "createPack",
    outputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "packTotalSupply",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amountToOpen",
        type: "uint256"
      }
    ],
    name: "openPack",
    outputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_packId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_amountToOpen",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "_callBackGasLimit",
        type: "uint32"
      }
    ],
    name: "openPackAndClaimRewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IPermissionsAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IPermissionsEnumerableAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IThirdwebPlatformFeeAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "flatFee",
        type: "uint256"
      }
    ],
    name: "FlatPlatformFeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "platformFeeRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "platformFeeBps",
        type: "uint256"
      }
    ],
    name: "PlatformFeeInfoUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum IPlatformFee.PlatformFeeType",
        name: "feeType",
        type: "uint8"
      }
    ],
    name: "PlatformFeeTypeUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "getPlatformFeeInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_platformFeeRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_platformFeeBps",
        type: "uint256"
      }
    ],
    name: "setPlatformFeeInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IThirdwebPrimarySaleAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "PrimarySaleRecipientUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "primarySaleRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_saleRecipient",
        type: "address"
      }
    ],
    name: "setPrimarySaleRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IThirdwebRoyaltyAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRoyaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRoyaltyBps",
        type: "uint256"
      }
    ],
    name: "DefaultRoyalty",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "royaltyRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "royaltyBps",
        type: "uint256"
      }
    ],
    name: "RoyaltyForToken",
    type: "event"
  },
  {
    inputs: [],
    name: "getDefaultRoyaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getRoyaltyInfoForToken",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "",
        type: "uint16"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salePrice",
        type: "uint256"
      }
    ],
    name: "royaltyInfo",
    outputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "royaltyAmount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_royaltyRecipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_royaltyBps",
        type: "uint256"
      }
    ],
    name: "setDefaultRoyaltyInfo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "bps",
        type: "uint256"
      }
    ],
    name: "setRoyaltyInfoForToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IOwnableAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "prevOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnerUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newOwner",
        type: "address"
      }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IAccountFactory = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "accountAdmin",
        type: "address"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "SignerRemoved",
    type: "event"
  },
  {
    inputs: [],
    name: "accountImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "getAccountsOfSigner",
    outputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "adminSigner",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "getAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "getSignersOfAccount",
    outputs: [
      {
        internalType: "address[]",
        name: "signers",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "onSignerAdded",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "onSignerRemoved",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const IAccount = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "initCode",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "callGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxFeePerGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct UserOperation",
        name: "userOp",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "missingAccountFunds",
        type: "uint256"
      }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "uint256",
        name: "validationData",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ContractPublisherAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "contract IContractPublisher",
        name: "_prevPublisher",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        indexed: false,
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "publishedContract",
        type: "tuple"
      }
    ],
    name: "ContractPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: true,
        internalType: "string",
        name: "contractId",
        type: "string"
      }
    ],
    name: "ContractUnpublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "prevURI",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "newURI",
        type: "string"
      }
    ],
    name: "PublisherProfileUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      }
    ],
    name: "getAllPublishedContracts",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContract",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance",
        name: "published",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "getPublishedContractVersions",
    outputs: [
      {
        components: [
          {
            internalType: "string",
            name: "contractId",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "publishTimestamp",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "publishMetadataUri",
            type: "string"
          },
          {
            internalType: "bytes32",
            name: "bytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "implementation",
            type: "address"
          }
        ],
        internalType: "struct IContractPublisher.CustomContractInstance[]",
        name: "published",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "compilerMetadataUri",
        type: "string"
      }
    ],
    name: "getPublishedUriFromCompilerUri",
    outputs: [
      {
        internalType: "string[]",
        name: "publishedMetadataUris",
        type: "string[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      }
    ],
    name: "getPublisherProfileUri",
    outputs: [
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "prevPublisher",
    outputs: [
      {
        internalType: "contract IContractPublisher",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      },
      {
        internalType: "string",
        name: "_publishMetadataUri",
        type: "string"
      },
      {
        internalType: "string",
        name: "_compilerMetadataUri",
        type: "string"
      },
      {
        internalType: "bytes32",
        name: "_bytecodeHash",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "publishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "_pause",
        type: "bool"
      }
    ],
    name: "setPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "setPublisherProfileUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_publisher",
        type: "address"
      },
      {
        internalType: "string",
        name: "_contractId",
        type: "string"
      }
    ],
    name: "unpublishContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const ForwarderABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      }
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const IThirdwebContractABI = [
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_uri",
        type: "string"
      }
    ],
    name: "setContractURI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var utils$1 = {};
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b);
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8);
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7);
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5);
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i);
const require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g);
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a);
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e);
const require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9);
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
const require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3);
const require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
  exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
  var abi_1 = require$$0$2;
  Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
    return abi_1.AbiCoder;
  } });
  Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
    return abi_1.checkResultErrors;
  } });
  Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
    return abi_1.ConstructorFragment;
  } });
  Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
    return abi_1.defaultAbiCoder;
  } });
  Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
    return abi_1.ErrorFragment;
  } });
  Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
    return abi_1.EventFragment;
  } });
  Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
    return abi_1.FormatTypes;
  } });
  Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
    return abi_1.Fragment;
  } });
  Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
    return abi_1.FunctionFragment;
  } });
  Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
    return abi_1.Indexed;
  } });
  Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
    return abi_1.Interface;
  } });
  Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
    return abi_1.LogDescription;
  } });
  Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
    return abi_1.ParamType;
  } });
  Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
    return abi_1.TransactionDescription;
  } });
  var address_1 = require$$1$1;
  Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
    return address_1.getAddress;
  } });
  Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
    return address_1.getCreate2Address;
  } });
  Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
    return address_1.getContractAddress;
  } });
  Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
    return address_1.getIcapAddress;
  } });
  Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
    return address_1.isAddress;
  } });
  var base642 = __importStar(require$$2);
  exports.base64 = base642;
  var basex_1 = require$$3;
  Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
    return basex_1.Base58;
  } });
  var bytes_1 = require$$0$1;
  Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
    return bytes_1.arrayify;
  } });
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return bytes_1.concat;
  } });
  Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
    return bytes_1.hexConcat;
  } });
  Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
    return bytes_1.hexDataSlice;
  } });
  Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
    return bytes_1.hexDataLength;
  } });
  Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
    return bytes_1.hexlify;
  } });
  Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
    return bytes_1.hexStripZeros;
  } });
  Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
    return bytes_1.hexValue;
  } });
  Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
    return bytes_1.hexZeroPad;
  } });
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return bytes_1.isBytes;
  } });
  Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
    return bytes_1.isBytesLike;
  } });
  Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
    return bytes_1.isHexString;
  } });
  Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
    return bytes_1.joinSignature;
  } });
  Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
    return bytes_1.zeroPad;
  } });
  Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
    return bytes_1.splitSignature;
  } });
  Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
    return bytes_1.stripZeros;
  } });
  var hash_1 = require$$5;
  Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
    return hash_1._TypedDataEncoder;
  } });
  Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
    return hash_1.dnsEncode;
  } });
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return hash_1.hashMessage;
  } });
  Object.defineProperty(exports, "id", { enumerable: true, get: function() {
    return hash_1.id;
  } });
  Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
    return hash_1.isValidName;
  } });
  Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
    return hash_1.namehash;
  } });
  var hdnode_1 = require$$6;
  Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
    return hdnode_1.defaultPath;
  } });
  Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
    return hdnode_1.entropyToMnemonic;
  } });
  Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
    return hdnode_1.getAccountPath;
  } });
  Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
    return hdnode_1.HDNode;
  } });
  Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
    return hdnode_1.isValidMnemonic;
  } });
  Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToEntropy;
  } });
  Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToSeed;
  } });
  var json_wallets_1 = require$$7;
  Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
    return json_wallets_1.getJsonWalletAddress;
  } });
  var keccak256_1 = require$$8;
  Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
    return keccak256_1.keccak256;
  } });
  var logger_1 = require$$9;
  Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
    return logger_1.Logger;
  } });
  var sha2_1 = require$$10;
  Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
    return sha2_1.computeHmac;
  } });
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return sha2_1.ripemd160;
  } });
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha2_1.sha256;
  } });
  Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
    return sha2_1.sha512;
  } });
  var solidity_1 = require$$1;
  Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
    return solidity_1.keccak256;
  } });
  Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
    return solidity_1.pack;
  } });
  Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
    return solidity_1.sha256;
  } });
  var random_1 = require$$12;
  Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
    return random_1.randomBytes;
  } });
  Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
    return random_1.shuffled;
  } });
  var properties_1 = require$$0;
  Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
    return properties_1.checkProperties;
  } });
  Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
    return properties_1.deepCopy;
  } });
  Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
    return properties_1.defineReadOnly;
  } });
  Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
    return properties_1.getStatic;
  } });
  Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
    return properties_1.resolveProperties;
  } });
  Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
    return properties_1.shallowCopy;
  } });
  var RLP = __importStar(require$$14);
  exports.RLP = RLP;
  var signing_key_1 = require$$15;
  Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
    return signing_key_1.computePublicKey;
  } });
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
    return signing_key_1.recoverPublicKey;
  } });
  Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
    return signing_key_1.SigningKey;
  } });
  var strings_1 = require$$16;
  Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
    return strings_1.formatBytes32String;
  } });
  Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
    return strings_1.nameprep;
  } });
  Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
    return strings_1.parseBytes32String;
  } });
  Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
    return strings_1._toEscapedUtf8String;
  } });
  Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
    return strings_1.toUtf8Bytes;
  } });
  Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
    return strings_1.toUtf8CodePoints;
  } });
  Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
    return strings_1.toUtf8String;
  } });
  Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
    return strings_1.Utf8ErrorFuncs;
  } });
  var transactions_1 = require$$17;
  Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
    return transactions_1.accessListify;
  } });
  Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
    return transactions_1.computeAddress;
  } });
  Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
    return transactions_1.parse;
  } });
  Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
    return transactions_1.recoverAddress;
  } });
  Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
    return transactions_1.serialize;
  } });
  Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
    return transactions_1.TransactionTypes;
  } });
  var units_1 = require$$18;
  Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
    return units_1.commify;
  } });
  Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
    return units_1.formatEther;
  } });
  Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
    return units_1.parseEther;
  } });
  Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
    return units_1.formatUnits;
  } });
  Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
    return units_1.parseUnits;
  } });
  var wallet_1 = require$$19;
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return wallet_1.verifyMessage;
  } });
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return wallet_1.verifyTypedData;
  } });
  var web_1 = require$$20;
  Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
    return web_1._fetchData;
  } });
  Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
    return web_1.fetchJson;
  } });
  Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
    return web_1.poll;
  } });
  var sha2_2 = require$$10;
  Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
    return sha2_2.SupportedAlgorithm;
  } });
  var strings_2 = require$$16;
  Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
    return strings_2.UnicodeNormalizationForm;
  } });
  Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
    return strings_2.Utf8ErrorReason;
  } });
})(utils$1);
const ERC20MetadataAbi = [
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var dist = {};
var MerkleTree$1 = {};
var bufferReverse = function reverse(src2) {
  var buffer$1 = new buffer.Buffer(src2.length);
  for (var i2 = 0, j = src2.length - 1; i2 <= j; ++i2, --j) {
    buffer$1[i2] = src2[j];
    buffer$1[j] = src2[i2];
  }
  return buffer$1;
};
var sha256 = { exports: {} };
var core = { exports: {} };
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var create2 = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base3 = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base3.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var i2 = 0; i2 < thatSigBytes; i2 += 4) {
                thisWords[thisSigBytes + i2 >>> 2] = thatWords[i2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words2 = this.words;
            var sigBytes = this.sigBytes;
            words2[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words2.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base3.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words2 = [];
            var r2 = function(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
                m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += 0.5;
                return result * (Math2.random() > 0.5 ? 1 : -1);
              };
            };
            for (var i2 = 0, rcache; i2 < nBytes; i2 += 4) {
              var _r = r2((rcache || Math2.random()) * 4294967296);
              rcache = _r() * 987654071;
              words2.push(_r() * 4294967296 | 0);
            }
            return new WordArray.init(words2, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words2 = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words2[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words2, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words2 = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words2[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words2, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base3.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base3.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base3.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher2) {
            return function(message, cfg) {
              return new hasher2.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher2) {
            return function(message, key2) {
              return new C_algo.HMAC.init(hasher2, key2).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core);
  return core.exports;
}
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2(requireCore());
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C2 = CryptoJS;
      var C_lib = C2.lib;
      var WordArray = C_lib.WordArray;
      var Hasher2 = C_lib.Hasher;
      var C_algo = C2.algo;
      var H2 = [];
      var K2 = [];
      (function() {
        function isPrime(n3) {
          var sqrtN = Math2.sqrt(n3);
          for (var factor = 2; factor <= sqrtN; factor++) {
            if (!(n3 % factor)) {
              return false;
            }
          }
          return true;
        }
        function getFractionalBits(n3) {
          return (n3 - (n3 | 0)) * 4294967296 | 0;
        }
        var n2 = 2;
        var nPrime = 0;
        while (nPrime < 64) {
          if (isPrime(n2)) {
            if (nPrime < 8) {
              H2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
            }
            K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
            nPrime++;
          }
          n2++;
        }
      })();
      var W2 = [];
      var SHA2562 = C_algo.SHA256 = Hasher2.extend({
        _doReset: function() {
          this._hash = new WordArray.init(H2.slice(0));
        },
        _doProcessBlock: function(M2, offset2) {
          var H3 = this._hash.words;
          var a2 = H3[0];
          var b2 = H3[1];
          var c2 = H3[2];
          var d2 = H3[3];
          var e2 = H3[4];
          var f2 = H3[5];
          var g2 = H3[6];
          var h2 = H3[7];
          for (var i2 = 0; i2 < 64; i2++) {
            if (i2 < 16) {
              W2[i2] = M2[offset2 + i2] | 0;
            } else {
              var gamma0x = W2[i2 - 15];
              var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
              var gamma1x = W2[i2 - 2];
              var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
              W2[i2] = gamma0 + W2[i2 - 7] + gamma1 + W2[i2 - 16];
            }
            var ch2 = e2 & f2 ^ ~e2 & g2;
            var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
            var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
            var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
            var t1 = h2 + sigma1 + ch2 + K2[i2] + W2[i2];
            var t2 = sigma0 + maj;
            h2 = g2;
            g2 = f2;
            f2 = e2;
            e2 = d2 + t1 | 0;
            d2 = c2;
            c2 = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          H3[0] = H3[0] + a2 | 0;
          H3[1] = H3[1] + b2 | 0;
          H3[2] = H3[2] + c2 | 0;
          H3[3] = H3[3] + d2 | 0;
          H3[4] = H3[4] + e2 | 0;
          H3[5] = H3[5] + f2 | 0;
          H3[6] = H3[6] + g2 | 0;
          H3[7] = H3[7] + h2 | 0;
        },
        _doFinalize: function() {
          var data = this._data;
          var dataWords = data.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
          data.sigBytes = dataWords.length * 4;
          this._process();
          return this._hash;
        },
        clone: function() {
          var clone2 = Hasher2.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        }
      });
      C2.SHA256 = Hasher2._createHelper(SHA2562);
      C2.HmacSHA256 = Hasher2._createHmacHelper(SHA2562);
    })(Math);
    return CryptoJS.SHA256;
  });
})(sha256);
var sha256Exports = sha256.exports;
var treeify = { exports: {} };
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2();
    }
  })(commonjsGlobal, function() {
    function makePrefix(key2, last) {
      var str = last ? "└" : "├";
      if (key2) {
        str += "─ ";
      } else {
        str += "──┐";
      }
      return str;
    }
    function filterKeys(obj, hideFunctions) {
      var keys2 = [];
      for (var branch in obj) {
        if (!obj.hasOwnProperty(branch)) {
          continue;
        }
        if (hideFunctions && typeof obj[branch] === "function") {
          continue;
        }
        keys2.push(branch);
      }
      return keys2;
    }
    function growBranch(key2, root, last, lastStates, showValues, hideFunctions, callback) {
      var line2 = "", index2 = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
      if (lastStatesCopy.push([root, last]) && lastStates.length > 0) {
        lastStates.forEach(function(lastState, idx) {
          if (idx > 0) {
            line2 += (lastState[1] ? " " : "│") + "  ";
          }
          if (!circular && lastState[0] === root) {
            circular = true;
          }
        });
        line2 += makePrefix(key2, last) + key2;
        showValues && (typeof root !== "object" || root instanceof Date) && (line2 += ": " + root);
        circular && (line2 += " (circular ref.)");
        callback(line2);
      }
      if (!circular && typeof root === "object") {
        var keys2 = filterKeys(root, hideFunctions);
        keys2.forEach(function(branch) {
          lastKey = ++index2 === keys2.length;
          growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
        });
      }
    }
    var Treeify = {};
    Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
      var hideFunctionsArg = typeof hideFunctions !== "function" ? hideFunctions : false;
      growBranch(".", obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
    };
    Treeify.asTree = function(obj, showValues, hideFunctions) {
      var tree = "";
      growBranch(".", obj, false, [], showValues, hideFunctions, function(line2) {
        tree += line2 + "\n";
      });
      return tree;
    };
    return Treeify;
  });
})(treeify);
var treeifyExports = treeify.exports;
var Base$1 = {};
var cryptoJs = { exports: {} };
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core)
    return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base3 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C2.x64 = {};
        C_x64.Word = Base3.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base3.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone2 = Base3.clone.call(this);
            var words2 = clone2.words = this.words.slice(0);
            var wordsLength = words2.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words2[i2] = words2[i2].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays)
    return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words2 = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words2[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words2, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16)
    return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words2[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words2[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words2[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words2[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64)
    return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words2[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words2[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words2[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words2 = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              words2[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words2, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5.exports;
  hasRequiredMd5 = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher2.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset2 + 0];
            var M_offset_1 = M2[offset2 + 1];
            var M_offset_2 = M2[offset2 + 2];
            var M_offset_3 = M2[offset2 + 3];
            var M_offset_4 = M2[offset2 + 4];
            var M_offset_5 = M2[offset2 + 5];
            var M_offset_6 = M2[offset2 + 6];
            var M_offset_7 = M2[offset2 + 7];
            var M_offset_8 = M2[offset2 + 8];
            var M_offset_9 = M2[offset2 + 9];
            var M_offset_10 = M2[offset2 + 10];
            var M_offset_11 = M2[offset2 + 11];
            var M_offset_12 = M2[offset2 + 12];
            var M_offset_13 = M2[offset2 + 13];
            var M_offset_14 = M2[offset2 + 14];
            var M_offset_15 = M2[offset2 + 15];
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
            d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
            c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
            b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
            a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
            d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
            c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
            b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
            a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
            d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
            c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
            b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
            a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
            d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
            c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
            b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
            a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
            d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
            b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
            a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
            d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
            b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
            a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
            d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
            b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
            a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
            d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
            b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
            a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
            d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
            b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
            a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
            d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
            b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
            a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
            d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
            b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
            a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
            d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
            b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
            a2 = II(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
            d2 = II(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
            c2 = II(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
            b2 = II(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
            a2 = II(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
            d2 = II(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
            c2 = II(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
            b2 = II(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
            a2 = II(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
            d2 = II(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
            c2 = II(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
            b2 = II(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
            a2 = II(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
            d2 = II(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
            c2 = II(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
            b2 = II(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H2 = hash2.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher2.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & c2 | ~b2 & d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function GG(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 & d2 | c2 & ~d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function HH(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (b2 ^ c2 ^ d2) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        function II(a2, b2, c2, d2, x2, s2, t2) {
          var n2 = a2 + (c2 ^ (b2 | ~d2)) + x2 + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b2;
        }
        C2.MD5 = Hasher2._createHelper(MD5);
        C2.HmacMD5 = Hasher2._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C2.algo;
        var W2 = [];
        var SHA12 = C_algo.SHA1 = Hasher2.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset2) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e2 = H2[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W2[i2] = M2[offset2 + i2] | 0;
              } else {
                var n2 = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
                W2[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e2 + W2[i2];
              if (i2 < 20) {
                t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b2 ^ c2 ^ d2) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
              } else {
                t2 += (b2 ^ c2 ^ d2) - 899497514;
              }
              e2 = d2;
              d2 = c2;
              c2 = b2 << 30 | b2 >>> 2;
              b2 = a2;
              a2 = t2;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher2.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C2.SHA1 = Hasher2._createHelper(SHA12);
        C2.HmacSHA1 = Hasher2._createHmacHelper(SHA12);
      })();
      return CryptoJS.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), sha256Exports);
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA2562 = C_algo.SHA256;
        var SHA2242 = C_algo.SHA224 = SHA2562.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA2562._doFinalize.call(this);
            hash2.sigBytes -= 4;
            return hash2;
          }
        });
        C2.SHA224 = SHA2562._createHelper(SHA2242);
        C2.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
      })();
      return CryptoJS.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Hasher2 = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K2 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W2[i2] = X64Word_create();
          }
        })();
        var SHA5122 = C_algo.SHA512 = Hasher2.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M2, offset2) {
            var H2 = this._hash.words;
            var H0 = H2[0];
            var H1 = H2[1];
            var H22 = H2[2];
            var H3 = H2[3];
            var H4 = H2[4];
            var H5 = H2[5];
            var H6 = H2[6];
            var H7 = H2[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah2 = H0h;
            var al2 = H0l;
            var bh2 = H1h;
            var bl2 = H1l;
            var ch2 = H2h;
            var cl2 = H2l;
            var dh2 = H3h;
            var dl2 = H3l;
            var eh2 = H4h;
            var el2 = H4l;
            var fh2 = H5h;
            var fl2 = H5l;
            var gh2 = H6h;
            var gl2 = H6l;
            var hh2 = H7h;
            var hl2 = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wi2 = W2[i2];
              if (i2 < 16) {
                var Wih = Wi2.high = M2[offset2 + i2 * 2] | 0;
                var Wil = Wi2.low = M2[offset2 + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi2.high = Wih;
                Wi2.low = Wil;
              }
              var chh = eh2 & fh2 ^ ~eh2 & gh2;
              var chl = el2 & fl2 ^ ~el2 & gl2;
              var majh = ah2 & bh2 ^ ah2 & ch2 ^ bh2 & ch2;
              var majl = al2 & bl2 ^ al2 & cl2 ^ bl2 & cl2;
              var sigma0h = (ah2 >>> 28 | al2 << 4) ^ (ah2 << 30 | al2 >>> 2) ^ (ah2 << 25 | al2 >>> 7);
              var sigma0l = (al2 >>> 28 | ah2 << 4) ^ (al2 << 30 | ah2 >>> 2) ^ (al2 << 25 | ah2 >>> 7);
              var sigma1h = (eh2 >>> 14 | el2 << 18) ^ (eh2 >>> 18 | el2 << 14) ^ (eh2 << 23 | el2 >>> 9);
              var sigma1l = (el2 >>> 14 | eh2 << 18) ^ (el2 >>> 18 | eh2 << 14) ^ (el2 << 23 | eh2 >>> 9);
              var Ki2 = K2[i2];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl2 + sigma1l;
              var t1h = hh2 + sigma1h + (t1l >>> 0 < hl2 >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh2 = gh2;
              hl2 = gl2;
              gh2 = fh2;
              gl2 = fl2;
              fh2 = eh2;
              fl2 = el2;
              el2 = dl2 + t1l | 0;
              eh2 = dh2 + t1h + (el2 >>> 0 < dl2 >>> 0 ? 1 : 0) | 0;
              dh2 = ch2;
              dl2 = cl2;
              ch2 = bh2;
              cl2 = bl2;
              bh2 = ah2;
              bl2 = al2;
              al2 = t1l + t2l | 0;
              ah2 = t1h + t2h + (al2 >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al2;
            H0.high = H0h + ah2 + (H0l >>> 0 < al2 >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl2;
            H1.high = H1h + bh2 + (H1l >>> 0 < bl2 >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl2;
            H22.high = H2h + ch2 + (H2l >>> 0 < cl2 >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl2;
            H3.high = H3h + dh2 + (H3l >>> 0 < dl2 >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el2;
            H4.high = H4h + eh2 + (H4l >>> 0 < el2 >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl2;
            H5.high = H5h + fh2 + (H5l >>> 0 < fl2 >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl2;
            H6.high = H6h + gh2 + (H6l >>> 0 < gl2 >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl2;
            H7.high = H7h + hh2 + (H7l >>> 0 < hl2 >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash2 = this._hash.toX32();
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher2.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C2.SHA512 = Hasher2._createHelper(SHA5122);
        C2.HmacSHA512 = Hasher2._createHmacHelper(SHA5122);
      })();
      return CryptoJS.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        var SHA5122 = C_algo.SHA512;
        var SHA3842 = C_algo.SHA384 = SHA5122.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA5122._doFinalize.call(this);
            hash2.sigBytes -= 16;
            return hash2;
          }
        });
        C2.SHA384 = SHA5122._createHelper(SHA3842);
        C2.HmacSHA384 = SHA5122._createHmacHelper(SHA3842);
      })();
      return CryptoJS.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3)
    return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var C_algo = C2.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x2 = 1, y2 = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x2 + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x2 + 3 * y2) % 5;
            x2 = newX;
            y2 = newY;
          }
          for (var x2 = 0; x2 < 5; x2++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x2 + 5 * y2] = y2 + (2 * x2 + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T2[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher2.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher2.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state2 = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M2, offset2) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M2[offset2 + 2 * i2];
              var M2i1 = M2[offset2 + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round2 = 0; round2 < 24; round2++) {
              for (var x2 = 0; x2 < 5; x2++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x2 + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T2[x2];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                var Tx4 = T2[(x2 + 4) % 5];
                var Tx1 = T2[(x2 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x2 + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T2[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T2[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x2 + 5 * y2;
                  var lane = state2[laneIndex];
                  var TLane = T2[laneIndex];
                  var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y2];
                  var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round2];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state2[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher2.clone.call(this);
            var state2 = clone2._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = state2[i2].clone();
            }
            return clone2;
          }
        });
        C2.SHA3 = Hasher2._createHelper(SHA3);
        C2.HmacSHA3 = Hasher2._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C2.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD1602 = C_algo.RIPEMD160 = Hasher2.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M2, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var hl2 = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl2 = _sl.words;
            var sr = _sr.words;
            var al2, bl2, cl2, dl2, el2;
            var ar, br, cr, dr, er;
            ar = al2 = H2[0];
            br = bl2 = H2[1];
            cr = cl2 = H2[2];
            dr = dl2 = H2[3];
            er = el2 = H2[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al2 + M2[offset2 + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl2, cl2, dl2) + hl2[0];
              } else if (i2 < 32) {
                t2 += f2(bl2, cl2, dl2) + hl2[1];
              } else if (i2 < 48) {
                t2 += f3(bl2, cl2, dl2) + hl2[2];
              } else if (i2 < 64) {
                t2 += f4(bl2, cl2, dl2) + hl2[3];
              } else {
                t2 += f5(bl2, cl2, dl2) + hl2[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl2[i2]);
              t2 = t2 + el2 | 0;
              al2 = el2;
              el2 = dl2;
              dl2 = rotl(cl2, 10);
              cl2 = bl2;
              bl2 = t2;
              t2 = ar + M2[offset2 + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H2[1] + cl2 + dr | 0;
            H2[1] = H2[2] + dl2 + er | 0;
            H2[2] = H2[3] + el2 + ar | 0;
            H2[3] = H2[4] + al2 + br | 0;
            H2[4] = H2[0] + bl2 + cr | 0;
            H2[0] = t2;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H2 = hash2.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher2.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x2, y2, z2) {
          return x2 ^ y2 ^ z2;
        }
        function f2(x2, y2, z2) {
          return x2 & y2 | ~x2 & z2;
        }
        function f3(x2, y2, z2) {
          return (x2 | ~y2) ^ z2;
        }
        function f4(x2, y2, z2) {
          return x2 & z2 | y2 & ~z2;
        }
        function f5(x2, y2, z2) {
          return x2 ^ (y2 | ~z2);
        }
        function rotl(x2, n2) {
          return x2 << n2 | x2 >>> 32 - n2;
        }
        C2.RIPEMD160 = Hasher2._createHelper(RIPEMD1602);
        C2.HmacRIPEMD160 = Hasher2._createHmacHelper(RIPEMD1602);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac.exports;
  hasRequiredHmac = 1;
  (function(module, exports) {
    (function(root, factory2) {
      {
        module.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base3 = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        C_algo.HMAC = Base3.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher2, key2) {
            hasher2 = this._hasher = new hasher2.init();
            if (typeof key2 == "string") {
              key2 = Utf8.parse(key2);
            }
            var hasherBlockSize = hasher2.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key2.sigBytes > hasherBlockSizeBytes) {
              key2 = hasher2.finalize(key2);
            }
            key2.clamp();
            var oKey = this._oKey = key2.clone();
            var iKey = this._iKey = key2.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher2 = this._hasher;
            hasher2.reset();
            hasher2.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher2 = this._hasher;
            var innerHash = hasher2.finalize(messageUpdate);
            hasher2.reset();
            var hmac3 = hasher2.finalize(this._oKey.clone().concat(innerHash));
            return hmac3;
          }
        });
      })();
    });
  })(hmac);
  return hmac.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2)
    return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base3 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA12 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base3.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base3.extend({
            keySize: 128 / 32,
            hasher: SHA12,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac3 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac3.update(salt).finalize(blockIndex);
              hmac3.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac3.finalize(intermediate);
                hmac3.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf)
    return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base3 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base3.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base3.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hasher2 = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher2.update(block);
              }
              var block = hasher2.update(password).finalize(salt);
              hasher2.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher2.finalize(block);
                hasher2.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore)
    return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base3 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C2.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C2.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base3.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key2, cfg) {
            return this.create(this._ENC_XFORM_MODE, key2, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key2, cfg) {
            return this.create(this._DEC_XFORM_MODE, key2, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key2, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key2;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function selectCipherStrategy(key2) {
              if (typeof key2 == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key2, cfg) {
                  return selectCipherStrategy(key2).encrypt(cipher, message, key2, cfg);
                },
                decrypt: function(ciphertext, key2, cfg) {
                  return selectCipherStrategy(key2).decrypt(cipher, ciphertext, key2, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C2.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base3.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words2, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words2, offset2, blockSize);
              cipher.encryptBlock(words2, offset2);
              this._prevBlock = words2.slice(offset2, offset2 + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words2, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words2.slice(offset2, offset2 + blockSize);
              cipher.decryptBlock(words2, offset2);
              xorBlock.call(this, words2, offset2, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words2, offset2, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined$1;
            } else {
              var block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words2[offset2 + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C2.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding2 = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding2);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode2 = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              var modeCreator = mode2.createEncryptor;
            } else {
              var modeCreator = mode2.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode2, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words2, offset2) {
            this._mode.processBlock(words2, offset2);
          },
          _doFinalize: function() {
            var padding2 = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding2.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding2.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base3.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C2.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              var wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base3.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base3.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key2, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key: key2,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key2, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C2.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key2 = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key2.words.slice(keySize), ivSize * 4);
            key2.sigBytes = keySize * 4;
            return CipherParams.create({ key: key2, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb)
    return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words2, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words2, offset2, blockSize, cipher);
            this._prevBlock = words2.slice(offset2, offset2 + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words2, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words2.slice(offset2, offset2 + blockSize);
            generateKeystreamAndEncrypt.call(this, words2, offset2, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words2, offset2, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            var keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words2[offset2 + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr)
    return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words2, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter2 = this._counter;
            if (iv) {
              counter2 = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter2.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter2[blockSize - 1] = counter2[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words2[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman)
    return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter2) {
          if ((counter2[0] = incWord(counter2[0])) === 0) {
            counter2[1] = incWord(counter2[1]);
          }
          return counter2;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words2, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter2 = this._counter;
            if (iv) {
              counter2 = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter2);
            var keystream = counter2.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words2[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb)
    return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words2, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words2[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb)
    return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words2, offset2) {
            this._cipher.encryptBlock(words2, offset2);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words2, offset2) {
            this._cipher.decryptBlock(words2, offset2);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923)
    return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126)
    return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971)
    return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding)
    return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i2 = data.sigBytes - 1;
          while (!(dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255)) {
            i2--;
          }
          data.sigBytes = i2 + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding)
    return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex)
    return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C2.enc;
        var Hex = C_enc.Hex;
        var C_format = C2.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes.exports;
  hasRequiredAes = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d2[i2] = i2 << 1;
            } else {
              d2[i2] = i2 << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi2 = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d2[x2];
            var x4 = d2[x22];
            var x8 = d2[x4];
            var t2 = d2[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x2] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x2] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x2] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x2) {
              x2 = xi2 = 1;
            } else {
              x2 = x22 ^ d2[d2[d2[x8 ^ x22]]];
              xi2 ^= d2[d2[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key2 = this._keyPriorReset = this._key;
            var keyWords = key2.words;
            var keySize = key2.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset2) {
            this._doCryptBlock(M2, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset2) {
            var t2 = M2[offset2 + 1];
            M2[offset2 + 1] = M2[offset2 + 3];
            M2[offset2 + 3] = t2;
            this._doCryptBlock(M2, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M2[offset2 + 1];
            M2[offset2 + 1] = M2[offset2 + 3];
            M2[offset2 + 3] = t2;
          },
          _doCryptBlock: function(M2, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset2] ^ keySchedule[0];
            var s1 = M2[offset2 + 1] ^ keySchedule[1];
            var s2 = M2[offset2 + 2] ^ keySchedule[2];
            var s3 = M2[offset2 + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round2 = 1; round2 < nRounds; round2++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset2] = t0;
            M2[offset2 + 1] = t1;
            M2[offset2 + 2] = t2;
            M2[offset2 + 3] = t3;
          },
          keySize: 256 / 32
        });
        C2.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes)
    return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M2, offset2) {
            this._doCryptBlock(M2, offset2, this._subKeys);
          },
          decryptBlock: function(M2, offset2) {
            this._doCryptBlock(M2, offset2, this._invSubKeys);
          },
          _doCryptBlock: function(M2, offset2, subKeys) {
            this._lBlock = M2[offset2];
            this._rBlock = M2[offset2 + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round2 = 0; round2 < 16; round2++) {
              var subKey = subKeys[round2];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M2[offset2] = this._lBlock;
            M2[offset2 + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset2, mask) {
          var t2 = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset2;
        }
        function exchangeRL(offset2, mask) {
          var t2 = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset2;
        }
        C2.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function(M2, offset2) {
            this._des1.encryptBlock(M2, offset2);
            this._des2.decryptBlock(M2, offset2);
            this._des3.encryptBlock(M2, offset2);
          },
          decryptBlock: function(M2, offset2) {
            this._des3.decryptBlock(M2, offset2);
            this._des2.encryptBlock(M2, offset2);
            this._des1.decryptBlock(M2, offset2);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C2.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4)
    return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keySigBytes = key2.sigBytes;
            var S2 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S2[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S2[i2] + keyByte) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j];
              S2[j] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M2, offset2) {
            M2[offset2] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i2 = (i2 + 1) % 256;
            j = (j + S2[i2]) % 256;
            var t2 = S2[i2];
            S2[i2] = S2[j];
            S2[j] = t2;
            keystreamWord |= S2[(S2[i2] + S2[j]) % 256] << 24 - n2 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        C2.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit)
    return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K2[i2] = (K2[i2] << 8 | K2[i2] >>> 24) & 16711935 | (K2[i2] << 24 | K2[i2] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X2[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset2) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M2[offset2 + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X2[i2] + C3[i2];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy)
    return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module, exports) {
    (function(root, factory2, undef) {
      {
        module.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X2[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset2) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M2[offset2 + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X2[i2] + C3[i2];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
(function(module, exports) {
  (function(root, factory2, undef) {
    {
      module.exports = factory2(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireMd5(), requireSha1(), sha256Exports, requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy());
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(Base$1, "__esModule", { value: true });
Base$1.Base = void 0;
const buffer_1$2 = buffer;
const crypto_js_1 = __importDefault$2(cryptoJsExports);
class Base {
  /**
   * print
   * @desc Prints out a visual representation of the merkle tree.
   * @example
   *```js
   *tree.print()
   *```
   */
  print() {
    Base.print(this);
  }
  /**
   * bufferIndexOf
   * @desc Returns the first index of which given buffer is found in array.
   * @param {Buffer[]} haystack - Array of buffers.
   * @param {Buffer} needle - Buffer to find.
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.bufferIndexOf(haystack, needle)
   *```
   */
  _bufferIndexOf(array, element) {
    for (let i2 = 0; i2 < array.length; i2++) {
      if (element.equals(array[i2])) {
        return i2;
      }
    }
    return -1;
  }
  /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer|ArrayBuffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = MerkleTree.bufferify('0x1234')
   *```
   */
  static bufferify(value) {
    if (!buffer_1$2.Buffer.isBuffer(value)) {
      if (typeof value === "object" && value.words) {
        return buffer_1$2.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), "hex");
      } else if (Base.isHexString(value)) {
        return buffer_1$2.Buffer.from(value.replace(/^0x/, ""), "hex");
      } else if (typeof value === "string") {
        return buffer_1$2.Buffer.from(value);
      } else if (typeof value === "number") {
        let s2 = value.toString();
        if (s2.length % 2) {
          s2 = `0${s2}`;
        }
        return buffer_1$2.Buffer.from(s2, "hex");
      } else if (ArrayBuffer.isView(value)) {
        return buffer_1$2.Buffer.from(value.buffer, value.byteOffset, value.byteLength);
      }
    }
    return value;
  }
  /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */
  static isHexString(v2) {
    return typeof v2 === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v2);
  }
  /**
   * print
   * @desc Prints out a visual representation of the given merkle tree.
   * @param {Object} tree - Merkle tree instance.
   * @return {String}
   * @example
   *```js
   *MerkleTree.print(tree)
   *```
   */
  static print(tree) {
    console.log(tree.toString());
  }
  /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = tree.bufferToHex(Buffer.from('A'))
   *```
   */
  bufferToHex(value, withPrefix = true) {
    return Base.bufferToHex(value, withPrefix);
  }
  /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))
   *```
   */
  static bufferToHex(value, withPrefix = true) {
    return `${withPrefix ? "0x" : ""}${(value || buffer_1$2.Buffer.alloc(0)).toString("hex")}`;
  }
  /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = tree.bufferify('0x1234')
   *```
   */
  bufferify(value) {
    return Base.bufferify(value);
  }
  /**
   * bufferifyFn
   * @desc Returns a function that will bufferify the return value.
   * @param {Function}
   * @return {Function}
   *
   * @example
   * ```js
   *const fn = tree.bufferifyFn((value) => sha256(value))
   *```
   */
  bufferifyFn(f2) {
    return (value) => {
      const v2 = f2(value);
      if (buffer_1$2.Buffer.isBuffer(v2)) {
        return v2;
      }
      if (this._isHexString(v2)) {
        return buffer_1$2.Buffer.from(v2.replace("0x", ""), "hex");
      }
      if (typeof v2 === "string") {
        return buffer_1$2.Buffer.from(v2);
      }
      if (ArrayBuffer.isView(v2)) {
        return buffer_1$2.Buffer.from(v2.buffer, v2.byteOffset, v2.byteLength);
      }
      return buffer_1$2.Buffer.from(f2(crypto_js_1.default.enc.Hex.parse(value.toString("hex"))).toString(crypto_js_1.default.enc.Hex), "hex");
    };
  }
  /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */
  _isHexString(value) {
    return Base.isHexString(value);
  }
  /**
   * log2
   * @desc Returns the log2 of number.
   * @param {Number} value
   * @return {Number}
   */
  _log2(n2) {
    return n2 === 1 ? 0 : 1 + this._log2(n2 / 2 | 0);
  }
  /**
   * zip
   * @desc Returns true if value is a hex string.
   * @param {String[]|Number[]|Buffer[]} a - first array
   * @param {String[]|Number[]|Buffer[]} b -  second array
   * @return {String[][]|Number[][]|Buffer[][]}
   *
   * @example
   * ```js
   *const zipped = tree.zip(['a', 'b'],['A', 'B'])
   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]
   *```
   */
  _zip(a2, b2) {
    return a2.map((e2, i2) => [e2, b2[i2]]);
  }
}
Base$1.Base = Base;
Base$1.default = Base;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(MerkleTree$1, "__esModule", { value: true });
MerkleTree$1.MerkleTree = void 0;
const buffer_1$1 = buffer;
const buffer_reverse_1 = __importDefault$1(bufferReverse);
const sha256_1$1 = __importDefault$1(sha256Exports);
const treeify_1 = __importDefault$1(treeifyExports);
const Base_1$1 = __importDefault$1(Base$1);
class MerkleTree extends Base_1$1.default {
  /**
   * @desc Constructs a Merkle Tree.
   * All nodes and leaves are stored as Buffers.
   * Lonely leaf nodes are promoted to the next level up without being hashed again.
   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.
   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes
   * @param {Object} options - Additional options
   * @example
   *```js
   *const MerkleTree = require('merkletreejs')
   *const crypto = require('crypto')
   *
   *function sha256(data) {
   *  // returns Buffer
   *  return crypto.createHash('sha256').update(data).digest()
   *}
   *
   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))
   *
   *const tree = new MerkleTree(leaves, sha256)
   *```
   */
  constructor(leaves, hashFn = sha256_1$1.default, options2 = {}) {
    super();
    this.duplicateOdd = false;
    this.hashLeaves = false;
    this.isBitcoinTree = false;
    this.leaves = [];
    this.layers = [];
    this.sortLeaves = false;
    this.sortPairs = false;
    this.sort = false;
    this.fillDefaultHash = null;
    this.isBitcoinTree = !!options2.isBitcoinTree;
    this.hashLeaves = !!options2.hashLeaves;
    this.sortLeaves = !!options2.sortLeaves;
    this.sortPairs = !!options2.sortPairs;
    if (options2.fillDefaultHash) {
      if (typeof options2.fillDefaultHash === "function") {
        this.fillDefaultHash = options2.fillDefaultHash;
      } else if (buffer_1$1.Buffer.isBuffer(options2.fillDefaultHash) || typeof options2.fillDefaultHash === "string") {
        this.fillDefaultHash = (idx, hashFn2) => options2.fillDefaultHash;
      } else {
        throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
      }
    }
    this.sort = !!options2.sort;
    if (this.sort) {
      this.sortLeaves = true;
      this.sortPairs = true;
    }
    this.duplicateOdd = !!options2.duplicateOdd;
    this.hashFn = this.bufferifyFn(hashFn);
    this.processLeaves(leaves);
  }
  processLeaves(leaves) {
    if (this.hashLeaves) {
      leaves = leaves.map(this.hashFn);
    }
    this.leaves = leaves.map(this.bufferify);
    if (this.sortLeaves) {
      this.leaves = this.leaves.sort(buffer_1$1.Buffer.compare);
    }
    if (this.fillDefaultHash) {
      for (let i2 = 0; i2 < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i2++) {
        if (i2 >= this.leaves.length) {
          this.leaves.push(this.bufferify(this.fillDefaultHash(i2, this.hashFn)));
        }
      }
    }
    this.layers = [this.leaves];
    this._createHashes(this.leaves);
  }
  _createHashes(nodes) {
    while (nodes.length > 1) {
      const layerIndex = this.layers.length;
      this.layers.push([]);
      for (let i2 = 0; i2 < nodes.length; i2 += 2) {
        if (i2 + 1 === nodes.length) {
          if (nodes.length % 2 === 1) {
            let data2 = nodes[nodes.length - 1];
            let hash3 = data2;
            if (this.isBitcoinTree) {
              data2 = buffer_1$1.Buffer.concat([buffer_reverse_1.default(data2), buffer_reverse_1.default(data2)]);
              hash3 = this.hashFn(data2);
              hash3 = buffer_reverse_1.default(this.hashFn(hash3));
              this.layers[layerIndex].push(hash3);
              continue;
            } else {
              if (this.duplicateOdd)
                ;
              else {
                this.layers[layerIndex].push(nodes[i2]);
                continue;
              }
            }
          }
        }
        const left2 = nodes[i2];
        const right2 = i2 + 1 === nodes.length ? left2 : nodes[i2 + 1];
        let data = null;
        let combined = null;
        if (this.isBitcoinTree) {
          combined = [buffer_reverse_1.default(left2), buffer_reverse_1.default(right2)];
        } else {
          combined = [left2, right2];
        }
        if (this.sortPairs) {
          combined.sort(buffer_1$1.Buffer.compare);
        }
        data = buffer_1$1.Buffer.concat(combined);
        let hash2 = this.hashFn(data);
        if (this.isBitcoinTree) {
          hash2 = buffer_reverse_1.default(this.hashFn(hash2));
        }
        this.layers[layerIndex].push(hash2);
      }
      nodes = this.layers[layerIndex];
    }
  }
  /**
   * addLeaf
   * @desc Adds a leaf to the tree and re-calculates layers.
   * @param {String|Buffer} - Leaf
   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaf(newLeaf)
   *```
   */
  addLeaf(leaf, shouldHash = false) {
    if (shouldHash) {
      leaf = this.hashFn(leaf);
    }
    this.processLeaves(this.leaves.concat(leaf));
  }
  /**
   * addLeaves
   * @desc Adds multiple leaves to the tree and re-calculates layers.
   * @param {String[]|Buffer[]} - Array of leaves
   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaves(newLeaves)
   *```
   */
  addLeaves(leaves, shouldHash = false) {
    if (shouldHash) {
      leaves = leaves.map(this.hashFn);
    }
    this.processLeaves(this.leaves.concat(leaves));
  }
  /**
   * getLeaves
   * @desc Returns array of leaves of Merkle Tree.
   * @return {Buffer[]}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *```
   */
  getLeaves(values) {
    if (Array.isArray(values)) {
      if (this.hashLeaves) {
        values = values.map(this.hashFn);
        if (this.sortLeaves) {
          values = values.sort(buffer_1$1.Buffer.compare);
        }
      }
      return this.leaves.filter((leaf) => this._bufferIndexOf(values, leaf) !== -1);
    }
    return this.leaves;
  }
  /**
   * getLeaf
   * @desc Returns the leaf at the given index.
   * @param {Number} - Index number
   * @return {Buffer}
   * @example
   *```js
   *const leaf = tree.getLeaf(1)
   *```
   */
  getLeaf(index2) {
    if (index2 < 0 || index2 > this.leaves.length - 1) {
      return buffer_1$1.Buffer.from([]);
    }
    return this.leaves[index2];
  }
  /**
   * getLeafIndex
   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.
   * @param {String|Buffer} - Target leaf
   * @return {number}
   * @example
   *```js
   *const leaf = Buffer.from('abc')
   *const index = tree.getLeafIndex(leaf)
   *```
   */
  getLeafIndex(target) {
    target = this.bufferify(target);
    const leaves = this.getLeaves();
    for (let i2 = 0; i2 < leaves.length; i2++) {
      const leaf = leaves[i2];
      if (leaf.equals(target)) {
        return i2;
      }
    }
    return -1;
  }
  /**
   * getLeafCount
   * @desc Returns the total number of leaves.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLeafCount()
   *```
   */
  getLeafCount() {
    return this.leaves.length;
  }
  /**
   * getHexLeaves
   * @desc Returns array of leaves of Merkle Tree as hex strings.
   * @return {String[]}
   * @example
   *```js
   *const leaves = tree.getHexLeaves()
   *```
   */
  getHexLeaves() {
    return this.leaves.map((leaf) => this.bufferToHex(leaf));
  }
  /**
   * marshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a JSON string.
   * @param {String[]|Buffer[]} - Merkle tree leaves
   * @return {String} - List of leaves as JSON string
   * @example
   *```js
   *const jsonStr = MerkleTree.marshalLeaves(leaves)
   *```
   */
  static marshalLeaves(leaves) {
    return JSON.stringify(leaves.map((leaf) => MerkleTree.bufferToHex(leaf)), null, 2);
  }
  /**
   * unmarshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a Buffers.
   * @param {String|Object} - JSON stringified leaves
   * @return {Buffer[]} - Unmarshalled list of leaves
   * @example
   *```js
   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)
   *```
   */
  static unmarshalLeaves(jsonStr) {
    let parsed = null;
    if (typeof jsonStr === "string") {
      parsed = JSON.parse(jsonStr);
    } else if (jsonStr instanceof Object) {
      parsed = jsonStr;
    } else {
      throw new Error("Expected type of string or object");
    }
    if (!parsed) {
      return [];
    }
    if (!Array.isArray(parsed)) {
      throw new Error("Expected JSON string to be array");
    }
    return parsed.map(MerkleTree.bufferify);
  }
  /**
   * getLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[]}
   * @example
   *```js
   *const layers = tree.getLayers()
   *```
   */
  getLayers() {
    return this.layers;
  }
  /**
   * getHexLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.
   * @return {String[]}
   * @example
   *```js
   *const layers = tree.getHexLayers()
   *```
   */
  getHexLayers() {
    return this.layers.reduce((acc, item) => {
      if (Array.isArray(item)) {
        acc.push(item.map((layer) => this.bufferToHex(layer)));
      } else {
        acc.push(item);
      }
      return acc;
    }, []);
  }
  /**
   * getLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[]}
   * @example
   *```js
   *const layers = tree.getLayersFlat()
   *```
   */
  getLayersFlat() {
    const layers = this.layers.reduce((acc, item) => {
      if (Array.isArray(item)) {
        acc.unshift(...item);
      } else {
        acc.unshift(item);
      }
      return acc;
    }, []);
    layers.unshift(buffer_1$1.Buffer.from([0]));
    return layers;
  }
  /**
   * getHexLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.
   * @return {String[]}
   * @example
   *```js
   *const layers = tree.getHexLayersFlat()
   *```
   */
  getHexLayersFlat() {
    return this.getLayersFlat().map((layer) => this.bufferToHex(layer));
  }
  /**
   * getLayerCount
   * @desc Returns the total number of layers.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLayerCount()
   *```
   */
  getLayerCount() {
    return this.getLayers().length;
  }
  /**
   * getRoot
   * @desc Returns the Merkle root hash as a Buffer.
   * @return {Buffer}
   * @example
   *```js
   *const root = tree.getRoot()
   *```
   */
  getRoot() {
    if (this.layers.length === 0) {
      return buffer_1$1.Buffer.from([]);
    }
    return this.layers[this.layers.length - 1][0] || buffer_1$1.Buffer.from([]);
  }
  /**
   * getHexRoot
   * @desc Returns the Merkle root hash as a hex string.
   * @return {String}
   * @example
   *```js
   *const root = tree.getHexRoot()
   *```
   */
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  /**
   * getProof
   * @desc Returns the proof for a target leaf.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {Object[]} - Array of objects containing a position property of type string
   * with values of 'left' or 'right' and a data property of type Buffer.
   * @example
   * ```js
   *const proof = tree.getProof(leaves[2])
   *```
   *
   * @example
   *```js
   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
   *const tree = new MerkleTree(leaves, keccak)
   *const proof = tree.getProof(leaves[2], 2)
   *```
   */
  getProof(leaf, index2) {
    if (typeof leaf === "undefined") {
      throw new Error("leaf is required");
    }
    leaf = this.bufferify(leaf);
    const proof = [];
    if (!Number.isInteger(index2)) {
      index2 = -1;
      for (let i2 = 0; i2 < this.leaves.length; i2++) {
        if (buffer_1$1.Buffer.compare(leaf, this.leaves[i2]) === 0) {
          index2 = i2;
        }
      }
    }
    if (index2 <= -1) {
      return [];
    }
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      const layer = this.layers[i2];
      const isRightNode = index2 % 2;
      const pairIndex = isRightNode ? index2 - 1 : this.isBitcoinTree && index2 === layer.length - 1 && i2 < this.layers.length - 1 ? index2 : index2 + 1;
      if (pairIndex < layer.length) {
        proof.push({
          position: isRightNode ? "left" : "right",
          data: layer[pairIndex]
        });
      }
      index2 = index2 / 2 | 0;
    }
    return proof;
  }
  /**
   * getHexProof
   * @desc Returns the proof for a target leaf as hex strings.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {String[]} - Proof array as hex strings.
   * @example
   * ```js
   *const proof = tree.getHexProof(leaves[2])
   *```
   */
  getHexProof(leaf, index2) {
    return this.getProof(leaf, index2).map((item) => this.bufferToHex(item.data));
  }
  /**
  * getPositionalHexProof
  * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).
  * @param {Buffer} leaf - Target leaf
  * @param {Number} [index] - Target leaf index in leaves array.
  * Use if there are leaves containing duplicate data in order to distinguish it.
  * @return {(string | number)[][]} - Proof array as hex strings. position at index 0
  * @example
  * ```js
  *const proof = tree.getPositionalHexProof(leaves[2])
  *```
  */
  getPositionalHexProof(leaf, index2) {
    return this.getProof(leaf, index2).map((item) => {
      return [
        item.position === "left" ? 0 : 1,
        this.bufferToHex(item.data)
      ];
    });
  }
  /**
   * marshalProof
   * @desc Returns proof array as JSON string.
   * @param {String[]|Object[]} proof - Merkle tree proof array
   * @return {String} - Proof array as JSON string.
   * @example
   * ```js
   *const jsonStr = MerkleTree.marshalProof(proof)
   *```
   */
  static marshalProof(proof) {
    const json2 = proof.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      if (buffer_1$1.Buffer.isBuffer(item)) {
        return MerkleTree.bufferToHex(item);
      }
      return {
        position: item.position,
        data: MerkleTree.bufferToHex(item.data)
      };
    });
    return JSON.stringify(json2, null, 2);
  }
  /**
   * unmarshalProof
   * @desc Returns the proof for a target leaf as a list of Buffers.
   * @param {String|Object} - Merkle tree leaves
   * @return {String|Object} - Marshalled proof
   * @example
   * ```js
   *const proof = MerkleTree.unmarshalProof(jsonStr)
   *```
   */
  static unmarshalProof(jsonStr) {
    let parsed = null;
    if (typeof jsonStr === "string") {
      parsed = JSON.parse(jsonStr);
    } else if (jsonStr instanceof Object) {
      parsed = jsonStr;
    } else {
      throw new Error("Expected type of string or object");
    }
    if (!parsed) {
      return [];
    }
    if (!Array.isArray(parsed)) {
      throw new Error("Expected JSON string to be array");
    }
    return parsed.map((item) => {
      if (typeof item === "string") {
        return MerkleTree.bufferify(item);
      } else if (item instanceof Object) {
        return {
          position: item.position,
          data: MerkleTree.bufferify(item.data)
        };
      } else {
        throw new Error("Expected item to be of type string or object");
      }
    });
  }
  /**
   * getProofIndices
   * @desc Returns the proof indices for given tree indices.
   * @param {Number[]} treeIndices - Tree indices
   * @param {Number} depth - Tree depth; number of layers.
   * @return {Number[]} - Proof indices
   * @example
   * ```js
   *const proofIndices = tree.getProofIndices([2,5,6], 4)
   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]
   *```
   */
  getProofIndices(treeIndices, depth) {
    const leafCount = Math.pow(2, depth);
    let maximalIndices = /* @__PURE__ */ new Set();
    for (const index2 of treeIndices) {
      let x2 = leafCount + index2;
      while (x2 > 1) {
        maximalIndices.add(x2 ^ 1);
        x2 = x2 / 2 | 0;
      }
    }
    const a2 = treeIndices.map((index2) => leafCount + index2);
    const b2 = Array.from(maximalIndices).sort((a3, b3) => a3 - b3).reverse();
    maximalIndices = a2.concat(b2);
    const redundantIndices = /* @__PURE__ */ new Set();
    const proof = [];
    for (let index2 of maximalIndices) {
      if (!redundantIndices.has(index2)) {
        proof.push(index2);
        while (index2 > 1) {
          redundantIndices.add(index2);
          if (!redundantIndices.has(index2 ^ 1))
            break;
          index2 = index2 / 2 | 0;
        }
      }
    }
    return proof.filter((index2) => {
      return !treeIndices.includes(index2 - leafCount);
    });
  }
  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
    const depth = Math.ceil(Math.log2(leavesCount));
    const unevenLayers = [];
    for (let index2 = 0; index2 < depth; index2++) {
      const unevenLayer = leavesCount % 2 !== 0;
      if (unevenLayer) {
        unevenLayers.push({ index: index2, leavesCount });
      }
      leavesCount = Math.ceil(leavesCount / 2);
    }
    const proofIndices = [];
    let layerNodes = sortedLeafIndices;
    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {
      const siblingIndices = layerNodes.map((index2) => {
        if (index2 % 2 === 0) {
          return index2 + 1;
        }
        return index2 - 1;
      });
      let proofNodeIndices = siblingIndices.filter((index2) => !layerNodes.includes(index2));
      const unevenLayer = unevenLayers.find(({ index: index2 }) => index2 === layerIndex);
      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
        proofNodeIndices = proofNodeIndices.slice(0, -1);
      }
      proofIndices.push(proofNodeIndices);
      layerNodes = [...new Set(layerNodes.map((index2) => {
        if (index2 % 2 === 0) {
          return index2 / 2;
        }
        if (index2 % 2 === 0) {
          return (index2 + 1) / 2;
        }
        return (index2 - 1) / 2;
      }))];
    }
    return proofIndices;
  }
  /**
   * getMultiProof
   * @desc Returns the multiproof for given tree indices.
   * @param {Number[]} indices - Tree indices.
   * @return {Buffer[]} - Multiproofs
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *```
   */
  getMultiProof(tree, indices) {
    if (!indices) {
      indices = tree;
      tree = this.getLayersFlat();
    }
    const isUneven = this.isUnevenTree();
    if (isUneven) {
      if (indices.every(Number.isInteger)) {
        return this.getMultiProofForUnevenTree(indices);
      }
    }
    if (!indices.every(Number.isInteger)) {
      let els = indices;
      if (this.sortPairs) {
        els = els.sort(buffer_1$1.Buffer.compare);
      }
      let ids = els.map((el2) => this._bufferIndexOf(this.leaves, el2)).sort((a2, b2) => a2 === b2 ? 0 : a2 > b2 ? 1 : -1);
      if (!ids.every((idx) => idx !== -1)) {
        throw new Error("Element does not exist in Merkle tree");
      }
      const hashes2 = [];
      const proof = [];
      let nextIds = [];
      for (let i2 = 0; i2 < this.layers.length; i2++) {
        const layer = this.layers[i2];
        for (let j = 0; j < ids.length; j++) {
          const idx = ids[j];
          const pairElement = this._getPairNode(layer, idx);
          hashes2.push(layer[idx]);
          if (pairElement) {
            proof.push(pairElement);
          }
          nextIds.push(idx / 2 | 0);
        }
        ids = nextIds.filter((value, i3, self2) => self2.indexOf(value) === i3);
        nextIds = [];
      }
      return proof.filter((value) => !hashes2.includes(value));
    }
    return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map((index2) => tree[index2]);
  }
  getMultiProofForUnevenTree(tree, indices) {
    if (!indices) {
      indices = tree;
      tree = this.getLayers();
    }
    let proofHashes = [];
    let currentLayerIndices = indices;
    for (const treeLayer of tree) {
      const siblings = [];
      for (const index2 of currentLayerIndices) {
        if (index2 % 2 === 0) {
          const idx2 = index2 + 1;
          if (!currentLayerIndices.includes(idx2)) {
            if (treeLayer[idx2]) {
              siblings.push(treeLayer[idx2]);
              continue;
            }
          }
        }
        const idx = index2 - 1;
        if (!currentLayerIndices.includes(idx)) {
          if (treeLayer[idx]) {
            siblings.push(treeLayer[idx]);
            continue;
          }
        }
      }
      proofHashes = proofHashes.concat(siblings);
      const uniqueIndices = /* @__PURE__ */ new Set();
      for (const index2 of currentLayerIndices) {
        if (index2 % 2 === 0) {
          uniqueIndices.add(index2 / 2);
          continue;
        }
        if (index2 % 2 === 0) {
          uniqueIndices.add((index2 + 1) / 2);
          continue;
        }
        uniqueIndices.add((index2 - 1) / 2);
      }
      currentLayerIndices = Array.from(uniqueIndices);
    }
    return proofHashes;
  }
  /**
   * getHexMultiProof
   * @desc Returns the multiproof for given tree indices as hex strings.
   * @param {Number[]} indices - Tree indices.
   * @return {String[]} - Multiproofs as hex strings.
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getHexMultiProof(indices)
   *```
   */
  getHexMultiProof(tree, indices) {
    return this.getMultiProof(tree, indices).map((x2) => this.bufferToHex(x2));
  }
  /**
   * getProofFlags
   * @desc Returns list of booleans where proofs should be used instead of hashing.
   * Proof flags are used in the Solidity multiproof verifiers.
   * @param {Number[]|Buffer[]} leaves
   * @param {Buffer[]} proofs
   * @return {Boolean[]} - Boolean flags
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *const proofFlags = tree.getProofFlags(leaves, proof)
   *```
   */
  getProofFlags(leaves, proofs) {
    if (!Array.isArray(leaves) || leaves.length <= 0) {
      throw new Error("Invalid Inputs!");
    }
    let ids;
    if (leaves.every(Number.isInteger)) {
      ids = leaves.sort((a2, b2) => a2 === b2 ? 0 : a2 > b2 ? 1 : -1);
    } else {
      ids = leaves.map((el2) => this._bufferIndexOf(this.leaves, el2)).sort((a2, b2) => a2 === b2 ? 0 : a2 > b2 ? 1 : -1);
    }
    if (!ids.every((idx) => idx !== -1)) {
      throw new Error("Element does not exist in Merkle tree");
    }
    const _proofs = proofs.map((item) => this.bufferify(item));
    const tested = [];
    const flags = [];
    for (let index2 = 0; index2 < this.layers.length; index2++) {
      const layer = this.layers[index2];
      ids = ids.reduce((ids2, idx) => {
        const skipped = tested.includes(layer[idx]);
        if (!skipped) {
          const pairElement = this._getPairNode(layer, idx);
          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
          pairElement && flags.push(!proofUsed);
          tested.push(layer[idx]);
          tested.push(pairElement);
        }
        ids2.push(idx / 2 | 0);
        return ids2;
      }, []);
    }
    return flags;
  }
  /**
   * verify
   * @desc Returns true if the proof path (array of hashes) can connect the target node
   * to the Merkle root.
   * @param {Object[]} proof - Array of proof objects that should connect
   * target node to Merkle root.
   * @param {Buffer} targetNode - Target node Buffer
   * @param {Buffer} root - Merkle root Buffer
   * @return {Boolean}
   * @example
   *```js
   *const root = tree.getRoot()
   *const proof = tree.getProof(leaves[2])
   *const verified = tree.verify(proof, leaves[2], root)
   *```
   */
  verify(proof, targetNode, root) {
    let hash2 = this.bufferify(targetNode);
    root = this.bufferify(root);
    if (!Array.isArray(proof) || !targetNode || !root) {
      return false;
    }
    for (let i2 = 0; i2 < proof.length; i2++) {
      const node2 = proof[i2];
      let data = null;
      let isLeftNode = null;
      if (typeof node2 === "string") {
        data = this.bufferify(node2);
        isLeftNode = true;
      } else if (Array.isArray(node2)) {
        isLeftNode = node2[0] === 0;
        data = this.bufferify(node2[1]);
      } else if (buffer_1$1.Buffer.isBuffer(node2)) {
        data = node2;
        isLeftNode = true;
      } else if (node2 instanceof Object) {
        data = this.bufferify(node2.data);
        isLeftNode = node2.position === "left";
      } else {
        throw new Error("Expected node to be of type string or object");
      }
      const buffers = [];
      if (this.isBitcoinTree) {
        buffers.push(buffer_reverse_1.default(hash2));
        buffers[isLeftNode ? "unshift" : "push"](buffer_reverse_1.default(data));
        hash2 = this.hashFn(buffer_1$1.Buffer.concat(buffers));
        hash2 = buffer_reverse_1.default(this.hashFn(hash2));
      } else {
        if (this.sortPairs) {
          if (buffer_1$1.Buffer.compare(hash2, data) === -1) {
            buffers.push(hash2, data);
            hash2 = this.hashFn(buffer_1$1.Buffer.concat(buffers));
          } else {
            buffers.push(data, hash2);
            hash2 = this.hashFn(buffer_1$1.Buffer.concat(buffers));
          }
        } else {
          buffers.push(hash2);
          buffers[isLeftNode ? "unshift" : "push"](data);
          hash2 = this.hashFn(buffer_1$1.Buffer.concat(buffers));
        }
      }
    }
    return buffer_1$1.Buffer.compare(hash2, root) === 0;
  }
  /**
   * verifyMultiProof
   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.
   * @param {Buffer} root - Merkle tree root
   * @param {Number[]} proofIndices - Leave indices for proof
   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof
   * @param {Number} leavesCount - Count of original leaves
   * @param {Buffer[]} proof - Multiproofs given indices
   * @return {Boolean}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *const root = tree.getRoot()
   *const treeFlat = tree.getLayersFlat()
   *const leavesCount = leaves.length
   *const proofIndices = [2, 5, 6]
   *const proofLeaves = proofIndices.map(i => leaves[i])
   *const proof = tree.getMultiProof(treeFlat, indices)
   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)
   *```
   */
  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
    const isUneven = this.isUnevenTree();
    if (isUneven) {
      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
    }
    const depth = Math.ceil(Math.log2(leavesCount));
    root = this.bufferify(root);
    proofLeaves = proofLeaves.map((leaf) => this.bufferify(leaf));
    proof = proof.map((leaf) => this.bufferify(leaf));
    const tree = {};
    for (const [index2, leaf] of this._zip(proofIndices, proofLeaves)) {
      tree[Math.pow(2, depth) + index2] = leaf;
    }
    for (const [index2, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {
      tree[index2] = proofitem;
    }
    let indexqueue = Object.keys(tree).map((value) => +value).sort((a2, b2) => a2 - b2);
    indexqueue = indexqueue.slice(0, indexqueue.length - 1);
    let i2 = 0;
    while (i2 < indexqueue.length) {
      const index2 = indexqueue[i2];
      if (index2 >= 2 && {}.hasOwnProperty.call(tree, index2 ^ 1)) {
        let pair = [tree[index2 - index2 % 2], tree[index2 - index2 % 2 + 1]];
        if (this.sortPairs) {
          pair = pair.sort(buffer_1$1.Buffer.compare);
        }
        const hash2 = pair[1] ? this.hashFn(buffer_1$1.Buffer.concat(pair)) : pair[0];
        tree[index2 / 2 | 0] = hash2;
        indexqueue.push(index2 / 2 | 0);
      }
      i2 += 1;
    }
    return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);
  }
  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
    root = this.bufferify(root);
    leaves = leaves.map(this.bufferify);
    proofs = proofs.map(this.bufferify);
    const leavesLen = leaves.length;
    const totalHashes = proofFlag.length;
    const hashes2 = [];
    let leafPos = 0;
    let hashPos = 0;
    let proofPos = 0;
    for (let i2 = 0; i2 < totalHashes; i2++) {
      const bufA = proofFlag[i2] ? leafPos < leavesLen ? leaves[leafPos++] : hashes2[hashPos++] : proofs[proofPos++];
      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes2[hashPos++];
      const buffers = [bufA, bufB].sort(buffer_1$1.Buffer.compare);
      hashes2[i2] = this.hashFn(buffer_1$1.Buffer.concat(buffers));
    }
    return buffer_1$1.Buffer.compare(hashes2[totalHashes - 1], root) === 0;
  }
  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
    root = this.bufferify(root);
    leaves = leaves.map((leaf) => this.bufferify(leaf));
    proof = proof.map((leaf) => this.bufferify(leaf));
    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
    return root.equals(computedRoot);
  }
  /**
   * getDepth
   * @desc Returns the tree depth (number of layers)
   * @return {Number}
   * @example
   *```js
   *const depth = tree.getDepth()
   *```
   */
  getDepth() {
    return this.getLayers().length - 1;
  }
  /**
   * getLayersAsObject
   * @desc Returns the layers as nested objects instead of an array.
   * @example
   *```js
   *const layersObj = tree.getLayersAsObject()
   *```
   */
  getLayersAsObject() {
    const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));
    const objs = [];
    for (let i2 = 0; i2 < layers.length; i2++) {
      const arr = [];
      for (let j = 0; j < layers[i2].length; j++) {
        const obj = { [layers[i2][j]]: null };
        if (objs.length) {
          obj[layers[i2][j]] = {};
          const a2 = objs.shift();
          const akey = Object.keys(a2)[0];
          obj[layers[i2][j]][akey] = a2[akey];
          if (objs.length) {
            const b2 = objs.shift();
            const bkey = Object.keys(b2)[0];
            obj[layers[i2][j]][bkey] = b2[bkey];
          }
        }
        arr.push(obj);
      }
      objs.push(...arr);
    }
    return objs[0];
  }
  /**
   * verify
   * @desc Returns true if the proof path (array of hashes) can connect the target node
   * to the Merkle root.
   * @param {Object[]} proof - Array of proof objects that should connect
   * target node to Merkle root.
   * @param {Buffer} targetNode - Target node Buffer
   * @param {Buffer} root - Merkle root Buffer
   * @param {Function} hashFunction - Hash function for hashing leaves and nodes
   * @param {Object} options - Additional options
   * @return {Boolean}
   * @example
   *```js
   *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)
   *```
   */
  static verify(proof, targetNode, root, hashFn = sha256_1$1.default, options2 = {}) {
    const tree = new MerkleTree([], hashFn, options2);
    return tree.verify(proof, targetNode, root);
  }
  /**
   * getMultiProof
   * @desc Returns the multiproof for given tree indices.
   * @param {Buffer[]} tree - Tree as a flat array.
   * @param {Number[]} indices - Tree indices.
   * @return {Buffer[]} - Multiproofs
   *
   *@example
   * ```js
   *const flatTree = tree.getLayersFlat()
   *const indices = [2, 5, 6]
   *const proof = MerkleTree.getMultiProof(flatTree, indices)
   *```
   */
  static getMultiProof(tree, indices) {
    const t2 = new MerkleTree([]);
    return t2.getMultiProof(tree, indices);
  }
  /**
   * resetTree
   * @desc Resets the tree by clearing the leaves and layers.
   * @example
   *```js
   *tree.resetTree()
   *```
   */
  resetTree() {
    this.leaves = [];
    this.layers = [];
  }
  /**
   * getPairNode
   * @desc Returns the node at the index for given layer.
   * @param {Buffer[]} layer - Tree layer
   * @param {Number} index - Index at layer.
   * @return {Buffer} - Node
   *
   *@example
   * ```js
   *const node = tree.getPairNode(layer, index)
   *```
   */
  _getPairNode(layer, idx) {
    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
    if (pairIdx < layer.length) {
      return layer[pairIdx];
    } else {
      return null;
    }
  }
  /**
   * toTreeString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @return {String}
   * @example
   *```js
   *console.log(tree.toTreeString())
   *```
   */
  _toTreeString() {
    const obj = this.getLayersAsObject();
    return treeify_1.default.asTree(obj, true);
  }
  /**
   * toString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @example
   *```js
   *console.log(tree.toString())
   *```
   */
  toString() {
    return this._toTreeString();
  }
  isUnevenTree(treeLayers) {
    const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
    return !this.isPowOf2(depth);
  }
  isPowOf2(v2) {
    return v2 && !(v2 & v2 - 1);
  }
  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
    const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);
    const leafTupleIndices = leafTuples.map(([index2]) => index2);
    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
    let nextSliceStart = 0;
    const proofTuplesByLayers = [];
    for (let i2 = 0; i2 < proofIndices.length; i2++) {
      const indices = proofIndices[i2];
      const sliceStart = nextSliceStart;
      nextSliceStart += indices.length;
      proofTuplesByLayers[i2] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
    }
    const tree = [leafTuples];
    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {
      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB).map(([, hash2]) => hash2);
      const s2 = tree[layerIndex].map(([layerIndex2]) => layerIndex2);
      const parentIndices = [...new Set(s2.map((index2) => {
        if (index2 % 2 === 0) {
          return index2 / 2;
        }
        if (index2 % 2 === 0) {
          return (index2 + 1) / 2;
        }
        return (index2 - 1) / 2;
      }))];
      const parentLayer = [];
      for (let i2 = 0; i2 < parentIndices.length; i2++) {
        const parentNodeTreeIndex = parentIndices[i2];
        const bufA = currentLayer[i2 * 2];
        const bufB = currentLayer[i2 * 2 + 1];
        const hash2 = bufB ? this.hashFn(buffer_1$1.Buffer.concat([bufA, bufB])) : bufA;
        parentLayer.push([parentNodeTreeIndex, hash2]);
      }
      tree.push(parentLayer);
    }
    return tree[tree.length - 1][0][1];
  }
}
MerkleTree$1.MerkleTree = MerkleTree;
if (typeof window !== "undefined") {
  window.MerkleTree = MerkleTree;
}
MerkleTree$1.default = MerkleTree;
var MerkleMountainRange$1 = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
};
Object.defineProperty(MerkleMountainRange$1, "__esModule", { value: true });
MerkleMountainRange$1.MerkleMountainRange = void 0;
const buffer_1 = buffer;
const sha256_1 = __importDefault(sha256Exports);
const Base_1 = __importDefault(Base$1);
class MerkleMountainRange extends Base_1.default {
  constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {
    super();
    this.root = buffer_1.Buffer.alloc(0);
    this.size = 0;
    this.width = 0;
    this.hashes = {};
    this.data = {};
    leaves = leaves.map(this.bufferify);
    this.hashFn = this.bufferifyFn(hashFn);
    this.hashLeafFn = hashLeafFn;
    this.peakBaggingFn = peakBaggingFn;
    this.hashBranchFn = hashBranchFn;
    for (const leaf of leaves) {
      this.append(leaf);
    }
  }
  /**
   * @desc This only stores the hashed value of the leaf.
   * If you need to retrieve the detail data later, use a map to store them.
   */
  append(data) {
    data = this.bufferify(data);
    const dataHash = this.hashFn(data);
    const dataHashHex = this.bufferToHex(dataHash);
    if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
      this.data[dataHashHex] = data;
    }
    const leaf = this.hashLeaf(this.size + 1, dataHash);
    this.hashes[this.size + 1] = leaf;
    this.width += 1;
    const peakIndexes = this.getPeakIndexes(this.width);
    this.size = this.getSize(this.width);
    const peaks = [];
    for (let i2 = 0; i2 < peakIndexes.length; i2++) {
      peaks[i2] = this._getOrCreateNode(peakIndexes[i2]);
    }
    this.root = this.peakBagging(this.width, peaks);
  }
  /**
   * @desc It returns the hash of a leaf node with hash(M | DATA )
   *       M is the index of the node.
   */
  hashLeaf(index2, dataHash) {
    dataHash = this.bufferify(dataHash);
    if (this.hashLeafFn) {
      return this.bufferify(this.hashLeafFn(index2, dataHash));
    }
    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index2), dataHash]));
  }
  /**
   * @desc It returns the hash a parent node with hash(M | Left child | Right child)
   *       M is the index of the node.
   */
  hashBranch(index2, left2, right2) {
    if (this.hashBranchFn) {
      return this.bufferify(this.hashBranchFn(index2, left2, right2));
    }
    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index2), this.bufferify(left2), this.bufferify(right2)]));
  }
  getPeaks() {
    const peakIndexes = this.getPeakIndexes(this.width);
    const peaks = [];
    for (let i2 = 0; i2 < peakIndexes.length; i2++) {
      peaks[i2] = this.hashes[peakIndexes[i2]];
    }
    return peaks;
  }
  getLeafIndex(width) {
    if (width % 2 === 1) {
      return this.getSize(width);
    }
    return this.getSize(width - 1) + 1;
  }
  /**
   * @desc It returns all peaks of the smallest merkle mountain range tree which includes
   *       the given index(size).
   */
  getPeakIndexes(width) {
    const numPeaks = this.numOfPeaks(width);
    const peakIndexes = [];
    let count = 0;
    let size2 = 0;
    for (let i2 = 255; i2 > 0; i2--) {
      if ((width & 1 << i2 - 1) !== 0) {
        size2 = size2 + (1 << i2) - 1;
        peakIndexes[count++] = size2;
        if (peakIndexes.length >= numPeaks) {
          break;
        }
      }
    }
    if (count !== peakIndexes.length) {
      throw new Error("invalid bit calculation");
    }
    return peakIndexes;
  }
  numOfPeaks(width) {
    let bits = width;
    let num = 0;
    while (bits > 0) {
      if (bits % 2 === 1) {
        num++;
      }
      bits = bits >> 1;
    }
    return num;
  }
  peakBagging(width, peaks) {
    const size2 = this.getSize(width);
    if (this.numOfPeaks(width) !== peaks.length) {
      throw new Error("received invalid number of peaks");
    }
    if (width === 0 && !peaks.length) {
      return buffer_1.Buffer.alloc(0);
    }
    if (this.peakBaggingFn) {
      return this.bufferify(this.peakBaggingFn(size2, peaks));
    }
    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size2), ...peaks.map(this.bufferify)]));
  }
  /**
   * @desc It returns the size of the tree.
   */
  getSize(width) {
    return (width << 1) - this.numOfPeaks(width);
  }
  /**
   * @desc It returns the root value of the tree.
   */
  getRoot() {
    return this.root;
  }
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  /**
   * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.
   */
  getNode(index2) {
    return this.hashes[index2];
  }
  /**
   * @desc It returns the height of the highest peak.
   */
  mountainHeight(size2) {
    let height = 1;
    while (1 << height <= size2 + height) {
      height++;
    }
    return height - 1;
  }
  /**
   * @desc It returns the height of the index.
   */
  heightAt(index2) {
    let reducedIndex = index2;
    let peakIndex = 0;
    let height = 0;
    while (reducedIndex > peakIndex) {
      reducedIndex -= (1 << height) - 1;
      height = this.mountainHeight(reducedIndex);
      peakIndex = (1 << height) - 1;
    }
    return height - (peakIndex - reducedIndex);
  }
  /**
   * @desc It returns whether the index is the leaf node or not
   */
  isLeaf(index2) {
    return this.heightAt(index2) === 1;
  }
  /**
   * @desc It returns the children when it is a parent node.
   */
  getChildren(index2) {
    const left2 = index2 - (1 << this.heightAt(index2) - 1);
    const right2 = index2 - 1;
    if (left2 === right2) {
      throw new Error("not a parent");
    }
    return [left2, right2];
  }
  /**
   * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.
   */
  getMerkleProof(index2) {
    if (index2 > this.size) {
      throw new Error("out of range");
    }
    if (!this.isLeaf(index2)) {
      throw new Error("not a leaf");
    }
    const root = this.root;
    const width = this.width;
    const peaks = this.getPeakIndexes(this.width);
    const peakBagging = [];
    let cursor2 = 0;
    for (let i2 = 0; i2 < peaks.length; i2++) {
      peakBagging[i2] = this.hashes[peaks[i2]];
      if (peaks[i2] >= index2 && cursor2 === 0) {
        cursor2 = peaks[i2];
      }
    }
    let left2 = 0;
    let right2 = 0;
    let height = this.heightAt(cursor2);
    const siblings = [];
    while (cursor2 !== index2) {
      height--;
      [left2, right2] = this.getChildren(cursor2);
      cursor2 = index2 <= left2 ? left2 : right2;
      siblings[height - 1] = this.hashes[index2 <= left2 ? right2 : left2];
    }
    return {
      root,
      width,
      peakBagging,
      siblings
    };
  }
  /**
   * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.
   */
  verify(root, width, index2, value, peaks, siblings) {
    value = this.bufferify(value);
    const size2 = this.getSize(width);
    if (size2 < index2) {
      throw new Error("index is out of range");
    }
    if (!root.equals(this.peakBagging(width, peaks))) {
      throw new Error("invalid root hash from the peaks");
    }
    let cursor2 = 0;
    let targetPeak;
    const peakIndexes = this.getPeakIndexes(width);
    for (let i2 = 0; i2 < peakIndexes.length; i2++) {
      if (peakIndexes[i2] >= index2) {
        targetPeak = peaks[i2];
        cursor2 = peakIndexes[i2];
        break;
      }
    }
    if (!targetPeak) {
      throw new Error("target not found");
    }
    let height = siblings.length + 1;
    const path = new Array(height);
    let left2 = 0;
    let right2 = 0;
    while (height > 0) {
      path[--height] = cursor2;
      if (cursor2 === index2) {
        break;
      } else {
        [left2, right2] = this.getChildren(cursor2);
        cursor2 = index2 > left2 ? right2 : left2;
        continue;
      }
    }
    let node2;
    while (height < path.length) {
      cursor2 = path[height];
      if (height === 0) {
        node2 = this.hashLeaf(cursor2, this.hashFn(value));
      } else if (cursor2 - 1 === path[height - 1]) {
        node2 = this.hashBranch(cursor2, siblings[height - 1], node2);
      } else {
        node2 = this.hashBranch(cursor2, node2, siblings[height - 1]);
      }
      height++;
    }
    if (!node2.equals(targetPeak)) {
      throw new Error("hashed peak is invalid");
    }
    return true;
  }
  peaksToPeakMap(width, peaks) {
    const peakMap = {};
    let bitIndex = 0;
    let peakRef = 0;
    let count = peaks.length;
    for (let height = 1; height <= 32; height++) {
      bitIndex = 32 - height;
      peakRef = 1 << height - 1;
      if ((width & peakRef) !== 0) {
        peakMap[bitIndex] = peaks[--count];
      } else {
        peakMap[bitIndex] = 0;
      }
    }
    if (count !== 0) {
      throw new Error("invalid number of peaks");
    }
    return peakMap;
  }
  peakMapToPeaks(width, peakMap) {
    const arrLength = this.numOfPeaks(width);
    const peaks = new Array(arrLength);
    let count = 0;
    for (let i2 = 0; i2 < 32; i2++) {
      if (peakMap[i2] !== 0) {
        peaks[count++] = peakMap[i2];
      }
    }
    if (count !== arrLength) {
      throw new Error("invalid number of peaks");
    }
    return peaks;
  }
  peakUpdate(width, prevPeakMap, itemHash) {
    const nextPeakMap = {};
    const newWidth = width + 1;
    let cursorIndex = this.getLeafIndex(newWidth);
    let cursorNode = this.hashLeaf(cursorIndex, itemHash);
    let bitIndex = 0;
    let peakRef = 0;
    let prevPeakExist = false;
    let nextPeakExist = false;
    let obtained = false;
    for (let height = 1; height <= 32; height++) {
      bitIndex = 32 - height;
      if (obtained) {
        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
      } else {
        peakRef = 1 << height - 1;
        prevPeakExist = (width & peakRef) !== 0;
        nextPeakExist = (newWidth & peakRef) !== 0;
        cursorIndex++;
        if (prevPeakExist) {
          cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
        }
        if (nextPeakExist) {
          if (prevPeakExist) {
            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
          } else {
            nextPeakMap[bitIndex] = cursorNode;
          }
          obtained = true;
        } else {
          nextPeakMap[bitIndex] = 0;
        }
      }
    }
    return nextPeakMap;
  }
  rollUp(root, width, peaks, itemHashes) {
    if (!root.equals(this.peakBagging(width, peaks))) {
      throw new Error("invalid root hash from the peaks");
    }
    let tmpWidth = width;
    let tmpPeakMap = this.peaksToPeakMap(width, peaks);
    for (let i2 = 0; i2 < itemHashes.length; i2++) {
      tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i2]);
      tmpWidth++;
    }
    return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
  }
  /**
   * @desc It returns the hash value of the node for the index.
   *      If the hash already exists it simply returns the stored value. On the other hand,
   *      it computes hashes recursively downward.
   *      Only appending an item calls this function.
   */
  _getOrCreateNode(index2) {
    if (index2 > this.size) {
      throw new Error("out of range");
    }
    if (!this.hashes[index2]) {
      const [leftIndex, rightIndex] = this.getChildren(index2);
      const leftHash = this._getOrCreateNode(leftIndex);
      const rightHash = this._getOrCreateNode(rightIndex);
      this.hashes[index2] = this.hashBranch(index2, leftHash, rightHash);
    }
    return this.hashes[index2];
  }
}
MerkleMountainRange$1.MerkleMountainRange = MerkleMountainRange;
MerkleMountainRange$1.default = MerkleMountainRange;
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MerkleTree = void 0;
  const MerkleTree_1 = __importDefault2(MerkleTree$1);
  exports.MerkleTree = MerkleTree_1.default;
  var MerkleMountainRange_1 = MerkleMountainRange$1;
  Object.defineProperty(exports, "MerkleMountainRange", { enumerable: true, get: function() {
    return MerkleMountainRange_1.MerkleMountainRange;
  } });
  exports.default = MerkleTree_1.default;
})(dist);
var fastDeepEqual = function equal2(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal2(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      var key2 = keys2[i2];
      if (!equal2(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
const deepEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqual);
const ERC165Abi = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const ERC721MetadataAbi = [
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const ERC1155MetadataAbi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_id",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const DeprecatedAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    name: "TokenURIRevealed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "encryptDecrypt",
    outputs: [
      {
        internalType: "bytes",
        name: "result",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      }
    ],
    name: "encryptedBaseURI",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "identifier",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "reveal",
    outputs: [
      {
        internalType: "string",
        name: "revealedURI",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x2 = ALPHABET2.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe2(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode3,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var src$1 = base;
const basex = src$1;
const ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs(bs58);
const TWRegistryABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_msgData",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_msgSender",
    outputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "contractType",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "contractVersion",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "deploymentCount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "deploymentAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "metadataURI",
            type: "string"
          }
        ],
        internalType: "struct ITWMultichainRegistry.Deployment[]",
        name: "allDeployments",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "getMetadataUri",
    outputs: [
      {
        internalType: "string",
        name: "metadataUri",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_chainId",
        type: "uint256"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const TWRegistryRouterABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginMap",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "_trustedForwarders",
        type: "address[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "string",
        name: "functionSignature",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "pluginAddress",
        type: "address"
      }
    ],
    name: "PluginSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldPluginAddress",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newPluginAddress",
        type: "address"
      }
    ],
    name: "PluginUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    stateMutability: "payable",
    type: "fallback"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "_getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "addPlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_pluginAddress",
        type: "address"
      }
    ],
    name: "getAllFunctionsOfPlugin",
    outputs: [
      {
        internalType: "bytes4[]",
        name: "registered",
        type: "bytes4[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAllPlugins",
    outputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin[]",
        name: "registered",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "getPluginForFunction",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "count",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRoleWithSwitch",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginMap",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_selector",
        type: "bytes4"
      }
    ],
    name: "removePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes4",
            name: "functionSelector",
            type: "bytes4"
          },
          {
            internalType: "string",
            name: "functionSignature",
            type: "string"
          },
          {
            internalType: "address",
            name: "pluginAddress",
            type: "address"
          }
        ],
        internalType: "struct IPluginMap.Plugin",
        name: "_plugin",
        type: "tuple"
      }
    ],
    name: "updatePlugin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
const GENERATED_ABI = {};
const TWFactoryAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      },
      {
        internalType: "address",
        name: "_registry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "contractType",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "version",
        type: "uint256"
      }
    ],
    name: "ImplementationAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      }
    ],
    name: "ImplementationApproved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proxy",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      }
    ],
    name: "ProxyDeployed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      }
    ],
    name: "addImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "approval",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_toApprove",
        type: "bool"
      }
    ],
    name: "approveImplementation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "currentVersion",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      }
    ],
    name: "deployProxy",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_implementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyByImplementation",
    outputs: [
      {
        internalType: "address",
        name: "deployedProxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_data",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "_salt",
        type: "bytes32"
      }
    ],
    name: "deployProxyDeterministic",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "deployer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "_version",
        type: "uint256"
      }
    ],
    name: "getImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "_type",
        type: "bytes32"
      }
    ],
    name: "getLatestImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "registry",
    outputs: [
      {
        internalType: "contract TWRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const TWRegistryABI$1 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_trustedForwarder",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Added",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "deployer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "deployment",
        type: "address"
      }
    ],
    name: "Deleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "count",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      }
    ],
    name: "getAll",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "forwarder",
        type: "address"
      }
    ],
    name: "isTrustedForwarder",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_deployer",
        type: "address"
      },
      {
        internalType: "address",
        name: "_deployment",
        type: "address"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
class Connector extends EventEmitter$1 {
}
class WagmiAdapter extends Connector {
  constructor(wagmiConnector) {
    super();
    _defineProperty$1(this, "wagmiConnector", void 0);
    this.wagmiConnector = wagmiConnector;
  }
  async connect(args) {
    this.setupConnectorListeners();
    const result = await this.wagmiConnector.connect(args);
    return result.account;
  }
  disconnect() {
    this.wagmiConnector.removeAllListeners("connect");
    this.wagmiConnector.removeAllListeners("change");
    return this.wagmiConnector.disconnect();
  }
  isConnected() {
    return this.wagmiConnector.isAuthorized();
  }
  getAddress() {
    return this.wagmiConnector.getAccount();
  }
  getSigner() {
    return this.wagmiConnector.getSigner();
  }
  getProvider() {
    return this.wagmiConnector.getProvider();
  }
  async switchChain(chainId) {
    if (!this.wagmiConnector.switchChain) {
      throw new Error("Switch chain not supported");
    }
    await this.wagmiConnector.switchChain(chainId);
  }
  setupConnectorListeners() {
    this.wagmiConnector.addListener("connect", (data) => {
      this.emit("connect", data);
    });
    this.wagmiConnector.addListener("change", (data) => {
      this.emit("change", data);
    });
    this.wagmiConnector.addListener("disconnect", () => {
      this.emit("disconnect");
    });
  }
  async setupListeners() {
    this.setupConnectorListeners();
    await this.wagmiConnector.setupListeners();
  }
  updateChains(chains) {
    this.wagmiConnector.updateChains(chains);
  }
}
function assertWindowEthereum(w2) {
  return typeof w2 !== "undefined" && "ethereum" in w2;
}
{
  window.Buffer = buffer.Buffer;
}
class CoinbaseWallet extends AbstractClientWallet {
  // TODO: remove this
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options2) {
    super(CoinbaseWallet.id, options2);
    _defineProperty$1(this, "connector", void 0);
    _defineProperty$1(this, "coinbaseConnector", void 0);
    _defineProperty$1(this, "headlessMode", void 0);
    this.headlessMode = options2?.headlessMode || false;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await __vitePreload(() => import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-2cd9c21c.js"), true ? ["creator/assets/thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-2cd9c21c.js","creator/assets/errors-105ad187.browser.esm-5668634f.js","creator/assets/normalizeChainId-e4cc0175.browser.esm-64657a5e.js"] : void 0);
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.dappMetadata.isDarkMode,
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
}
_defineProperty$1(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty$1(CoinbaseWallet, "id", walletIds.coinbase);
class MetaMaskWallet extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options2) {
    super(MetaMaskWallet.id, options2);
    _defineProperty$1(this, "connector", void 0);
    _defineProperty$1(this, "walletConnectConnector", void 0);
    _defineProperty$1(this, "metamaskConnector", void 0);
    _defineProperty$1(this, "isInjected", void 0);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!globalThis.window.ethereum?.isMetaMask;
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await __vitePreload(() => import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-4fafdab3.js"), true ? ["creator/assets/thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-4fafdab3.js","creator/assets/errors-105ad187.browser.esm-5668634f.js","creator/assets/normalizeChainId-e4cc0175.browser.esm-64657a5e.js"] : void 0);
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectV1Connector
        } = await __vitePreload(() => import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-925fa8cc.js"), true ? ["creator/assets/thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-925fa8cc.js","creator/assets/errors-105ad187.browser.esm-5668634f.js","creator/assets/normalizeChainId-e4cc0175.browser.esm-64657a5e.js"] : void 0);
        const walletConnectConnector = new WalletConnectV1Connector({
          chains: this.chains,
          storage: this.walletStorage,
          options: {
            clientMeta: {
              name: this.dappMetadata.name,
              description: this.dappMetadata.description || "",
              url: this.dappMetadata.url,
              icons: [this.dappMetadata.logoUrl || ""]
            },
            qrcode: this.options?.qrcode
          }
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options2) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.connector.on("display_uri", (error, payload) => {
      options2.onQrCodeUri(payload.params[0]);
    });
    await wcProvider.enable();
    this.connect({
      chainId: options2.chainId
    }).then(options2.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
}
_defineProperty$1(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty$1(MetaMaskWallet, "id", walletIds.metamask);
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
class WalletConnectV1 extends AbstractClientWallet {
  get walletName() {
    return _classPrivateFieldGet$1(this, _walletConnectConnector)?.walletName || "WalletConnect";
  }
  constructor(options2) {
    super(options2?.walletId || WalletConnectV1.id, options2);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec$1(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty$1(this, "connector", void 0);
    _defineProperty$1(this, "qrcode", void 0);
    _classPrivateFieldInitSpec$1(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet$1(this, _provider, data.provider);
        if (!_classPrivateFieldGet$1(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec$1(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec$1(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec$1(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "request":
          case "add_chain":
          case "switch_chain":
            this.emit("open_wallet");
            break;
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    this.qrcode = options2?.qrcode === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectV1Connector
      } = await __vitePreload(() => import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-925fa8cc.js"), true ? ["creator/assets/thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-925fa8cc.js","creator/assets/errors-105ad187.browser.esm-5668634f.js","creator/assets/normalizeChainId-e4cc0175.browser.esm-64657a5e.js"] : void 0);
      _classPrivateFieldSet$1(this, _walletConnectConnector, new WalletConnectV1Connector({
        chains: this.chains,
        storage: this.walletStorage,
        options: {
          qrcode: this.qrcode,
          clientMeta: {
            description: this.dappMetadata.description || "",
            url: this.dappMetadata.url,
            icons: [this.dappMetadata.logoUrl || ""],
            name: this.dappMetadata.name
          }
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet$1(this, _walletConnectConnector));
      _classPrivateFieldSet$1(this, _provider, await _classPrivateFieldGet$1(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
}
function _setupListeners2() {
  if (!_classPrivateFieldGet$1(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet$1(this, _walletConnectConnector).on("connect", _classPrivateFieldGet$1(this, _onConnect));
  _classPrivateFieldGet$1(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet$1(this, _onDisconnect));
  _classPrivateFieldGet$1(this, _walletConnectConnector).on("change", _classPrivateFieldGet$1(this, _onChange));
  _classPrivateFieldGet$1(this, _walletConnectConnector).on("message", _classPrivateFieldGet$1(this, _onMessage));
}
function _removeListeners2() {
  if (!_classPrivateFieldGet$1(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet$1(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet$1(this, _onConnect));
  _classPrivateFieldGet$1(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet$1(this, _onDisconnect));
  _classPrivateFieldGet$1(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet$1(this, _onChange));
  _classPrivateFieldGet$1(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet$1(this, _onMessage));
}
_defineProperty$1(WalletConnectV1, "id", walletIds.walletConnectV1);
_defineProperty$1(WalletConnectV1, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});
const QueryClientProviderWithDefault = (_ref) => {
  let {
    queryClient,
    children
  } = _ref;
  const queryClientWithDefault = reactExports.useMemo(() => {
    return queryClient ? queryClient : new QueryClient();
  }, [queryClient]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, {
    client: queryClientWithDefault,
    children
  });
};
const NEVER_PERSIST_QUERY_POSTFIX = {
  persist: false
};
function neverPersist(key2) {
  return [...key2, NEVER_PERSIST_QUERY_POSTFIX];
}
function requiredParamInvariant(condition, message) {
  invariant$1(condition !== null || condition !== void 0, message);
}
const DEFAULT_API_KEY$2 = "c6634ad2d97b74baf15ff556016830c251050e6c36b9da508ce3ec80095d3dc1";
const FileOrBufferUnionSchema = z$2.instanceof(File);
const FileOrBufferSchema = z$2.union([FileOrBufferUnionSchema, z$2.object({
  data: z$2.union([FileOrBufferUnionSchema, z$2.string()]),
  name: z$2.string()
})]);
const FileOrBufferOrStringSchema = z$2.union([FileOrBufferSchema, z$2.string()]);
const MAX_BPS = 1e4;
const BytesLikeSchema = z$2.union([z$2.array(z$2.number()), z$2.string()]);
const BigNumberSchema$1 = z$2.union([z$2.string(), z$2.number(), z$2.bigint(), z$2.custom((data) => {
  return BigNumber.isBigNumber(data);
}), z$2.custom((data) => {
  return BN$1.isBN(data);
})]).transform((arg) => {
  let str = BN$1.isBN(arg) ? new BN$1(arg).toString() : BigNumber.from(arg).toString();
  return BigNumber.from(str);
});
BigNumberSchema$1.transform((arg) => arg.toString());
const BigNumberTransformSchema$1 = z$2.union([z$2.bigint(), z$2.custom((data) => {
  return BigNumber.isBigNumber(data);
}), z$2.custom((data) => {
  return BN$1.isBN(data);
})]).transform((arg) => {
  if (BN$1.isBN(arg)) {
    return new BN$1(arg).toString();
  }
  return BigNumber.from(arg).toString();
});
const BasisPointsSchema = z$2.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%");
const PercentSchema = z$2.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%");
const HexColor = z$2.union([z$2.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), z$2.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform((val) => val.replace("#", "")), z$2.string().length(0)]);
const AmountSchema = z$2.union([z$2.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), z$2.number().min(0, "Amount cannot be negative")]).transform((arg) => typeof arg === "number" ? arg.toString() : arg);
const QuantitySchema = z$2.union([AmountSchema, z$2.literal("unlimited")]).default("unlimited");
const RawDateSchema$1 = z$2.date().transform((i2) => {
  return BigNumber.from(Math.floor(i2.getTime() / 1e3));
});
RawDateSchema$1.default(/* @__PURE__ */ new Date(0));
RawDateSchema$1.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return typeof key2 === "symbol" ? key2 : String(key2);
}
function _defineProperty(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
const PropertiesInput$1 = z$2.object({}).catchall(z$2.union([BigNumberTransformSchema$1, z$2.unknown()]));
const OptionalPropertiesInput = z$2.union([z$2.array(PropertiesInput$1), PropertiesInput$1]).optional().nullable();
const CommonNFTInput = z$2.object({
  name: z$2.union([z$2.string(), z$2.number()]).optional().nullable(),
  description: z$2.string().nullable().optional().nullable(),
  image: FileOrBufferOrStringSchema.nullable().optional(),
  external_url: FileOrBufferOrStringSchema.nullable().optional(),
  animation_url: FileOrBufferOrStringSchema.optional().nullable(),
  background_color: HexColor.optional().nullable(),
  properties: OptionalPropertiesInput,
  attributes: OptionalPropertiesInput
}).catchall(z$2.union([BigNumberTransformSchema$1, z$2.unknown()]));
const NFTInputOrUriSchema = z$2.union([CommonNFTInput, z$2.string()]);
const CommonNFTOutput = CommonNFTInput.extend({
  id: z$2.string(),
  uri: z$2.string(),
  image: z$2.string().nullable().optional(),
  external_url: z$2.string().nullable().optional(),
  animation_url: z$2.string().nullable().optional()
});
const DEFAULT_QUERY_ALL_COUNT = 100;
z$2.object({
  start: z$2.number().default(0),
  count: z$2.number().default(DEFAULT_QUERY_ALL_COUNT)
}).default({
  start: 0,
  count: DEFAULT_QUERY_ALL_COUNT
});
const MAX_LENGTH = 256;
const NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
const MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
const REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);
function toSemver(version2) {
  if (version2.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version2.trim().match(REGEX_MAIN_VERSION);
  if (!matches || matches?.length !== 4) {
    throw new Error(`${version2} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}
function isIncrementalVersion(current, next2) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next2);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}
const BigNumberSchema = z$2.union([z$2.string(), z$2.number(), z$2.bigint(), z$2.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => BigNumber.from(arg));
const BigNumberishSchema = BigNumberSchema.transform((arg) => arg.toString());
const BigNumberTransformSchema = z$2.union([z$2.bigint(), z$2.custom((data) => {
  return BigNumber.isBigNumber(data);
})]).transform((arg) => {
  return BigNumber.from(arg).toString();
});
function isSigner(value) {
  return !!(value && value._isSigner);
}
function isProvider(value) {
  return !!(value && value._isProvider);
}
const DEFAULT_BATCH_TIME_LIMIT_MS = 50;
const DEFAULT_BATCH_SIZE_LIMIT = 250;
const DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
class StaticJsonRpcBatchProvider extends StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    _defineProperty(this, "_timeLimitMs", void 0);
    _defineProperty(this, "_sizeLimit", void 0);
    _defineProperty(this, "_pendingBatchAggregator", void 0);
    _defineProperty(this, "_pendingBatch", void 0);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    const batch2 = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;
    const request_ = batch2.map((inflight) => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: deepCopy(request),
      provider: this
    });
    return fetchJson(this.connection, JSON.stringify(request_)).then((result) => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });
      batch2.forEach((inflightRequest_, index2) => {
        const payload = result[index2];
        if (payload) {
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest_.reject(error);
          } else {
            inflightRequest_.resolve(payload.result);
          }
        } else {
          inflightRequest_.reject(new Error("No response for request"));
        }
      });
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request: request_,
        provider: this
      });
      batch2.forEach((inflightRequest_) => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
}
const ChainInfoInputSchema = z$2.object({
  rpc: z$2.array(z$2.string().url()),
  chainId: z$2.number(),
  nativeCurrency: z$2.object({
    name: z$2.string(),
    symbol: z$2.string(),
    decimals: z$2.number()
  }),
  slug: z$2.string()
});
const SDKOptionsSchema = z$2.object({
  // @ts-expect-error - zod doesn't know anything about readonly
  supportedChains: z$2.array(ChainInfoInputSchema).default(defaultChains),
  thirdwebApiKey: z$2.string().default(DEFAULT_API_KEY$2),
  alchemyApiKey: z$2.string().optional(),
  infuraApiKey: z$2.string().optional(),
  readonlySettings: z$2.object({
    rpcUrl: z$2.string().url(),
    chainId: z$2.number().optional()
  }).optional(),
  gasSettings: z$2.object({
    maxPriceInGwei: z$2.number().min(1, "gas price cannot be less than 1").default(300),
    speed: z$2.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: z$2.union([z$2.object({
    openzeppelin: z$2.object({
      relayerUrl: z$2.string().url(),
      relayerForwarderAddress: z$2.string().optional(),
      useEOAForwarder: z$2.boolean().default(false),
      domainName: z$2.string().default("GSNv2 Forwarder"),
      domainVersion: z$2.string().default("0.0.1")
    }),
    experimentalChainlessSupport: z$2.boolean().default(false)
  }), z$2.object({
    biconomy: z$2.object({
      apiId: z$2.string(),
      apiKey: z$2.string(),
      deadlineSeconds: z$2.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  })]).optional(),
  gatewayUrls: z$2.array(z$2.string()).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
});
function buildDefaultMap(options2) {
  return options2.supportedChains.reduce((previousValue, currentValue) => {
    previousValue[currentValue.chainId] = currentValue;
    return previousValue;
  }, {});
}
function getChainProvider(network, sdkOptions) {
  if (typeof network === "string" && isRpcUrl(network)) {
    return getProviderFromRpcUrl(network);
  }
  const options2 = SDKOptionsSchema.parse(sdkOptions);
  if (isChainConfig(network)) {
    options2.supportedChains = [network, ...options2.supportedChains];
  }
  const rpcMap = buildDefaultMap(options2);
  let rpcUrl = "";
  let chainId;
  try {
    chainId = getChainIdFromNetwork(network, options2);
    rpcUrl = getChainRPC(rpcMap[chainId], {
      thirdwebApiKey: options2.thirdwebApiKey || DEFAULT_API_KEY$2,
      infuraApiKey: options2.infuraApiKey,
      alchemyApiKey: options2.alchemyApiKey
    });
  } catch (e2) {
  }
  if (!rpcUrl) {
    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options2.thirdwebApiKey || DEFAULT_API_KEY$2}`;
  }
  if (!rpcUrl) {
    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
  }
  return getProviderFromRpcUrl(rpcUrl, chainId);
}
function getChainIdFromNetwork(network, options2) {
  if (isChainConfig(network)) {
    return network.chainId;
  } else if (typeof network === "number") {
    return network;
  } else {
    const chainNameToId = options2.supportedChains.reduce((acc, curr) => {
      acc[curr.slug] = curr.chainId;
      return acc;
    }, {});
    if (network in chainNameToId) {
      return chainNameToId[network];
    }
  }
  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);
}
function isChainConfig(network) {
  return typeof network !== "string" && typeof network !== "number" && !isSigner(network) && !isProvider(network);
}
function isRpcUrl(url) {
  const match2 = url.match(/^(ws|http)s?:/i);
  if (match2) {
    switch (match2[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return true;
    }
  }
  return false;
}
const RPC_PROVIDER_MAP = /* @__PURE__ */ new Map();
function getProviderFromRpcUrl(rpcUrl, chainId) {
  try {
    const match2 = rpcUrl.match(/^(ws|http)s?:/i);
    if (match2) {
      switch (match2[1].toLowerCase()) {
        case "http":
        case "https":
          const seralizedOpts = `${rpcUrl}-${chainId || -1}`;
          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }
          const newProvider = chainId ? (
            // If we know the chainId we should use the StaticJsonRpcBatchProvider
            new StaticJsonRpcBatchProvider(rpcUrl, chainId)
          ) : (
            // Otherwise fall back to the built in json rpc batch provider
            new JsonRpcBatchProvider(rpcUrl)
          );
          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
        case "wss":
          return new WebSocketProvider(rpcUrl, chainId);
      }
    }
  } catch (e2) {
  }
  return getDefaultProvider(rpcUrl);
}
function getSignerAndProvider(network, options2) {
  let signer;
  let provider2;
  if (isSigner(network)) {
    signer = network;
    if (network.provider) {
      provider2 = network.provider;
    }
  } else if (isProvider(network)) {
    provider2 = network;
  } else {
    provider2 = getChainProvider(network, options2);
  }
  if (options2?.readonlySettings) {
    provider2 = getProviderFromRpcUrl(options2.readonlySettings.rpcUrl, options2.readonlySettings.chainId);
  }
  if (!provider2) {
    if (signer) {
      throw new Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
    }
    throw new Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!");
  }
  return [signer, provider2];
}
let provider;
const ENS_CACHE = /* @__PURE__ */ new Map();
async function resolveEns(ens) {
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!provider) {
    provider = getSignerAndProvider("ethereum")[1];
  }
  let ensPromise;
  if (ENS_CACHE.has(ens)) {
    ensPromise = ENS_CACHE.get(ens);
  } else {
    ensPromise = provider.resolveName(ens).then((address) => {
      if (!address) {
        return {
          address: null,
          expirationTime: new Date(Date.now() + 1e3 * 30)
        };
      }
      return {
        address,
        expirationTime: new Date(Date.now() + 1e3 * 60 * 5)
      };
    });
  }
  const resolvedPromise = await ensPromise;
  if (resolvedPromise.expirationTime < /* @__PURE__ */ new Date()) {
    ENS_CACHE.delete(ens);
    if (depth === 0) {
      resolveEns(ens, depth + 1);
    }
  }
  return resolvedPromise.address;
}
const EnsSchema = z$2.custom((ens) => typeof ens === "string" && (ens.endsWith(".eth") || ens.endsWith(".cb.id"))).transform(async (ens) => resolveEns(ens)).refine((address) => !!address && isAddress(address), {
  message: "Provided value was not a valid ENS name"
});
const AddressSchema = z$2.custom((address) => typeof address === "string" && isAddress(address), (out) => {
  return {
    message: `${out} is not a valid address`
  };
});
const AddressOrEnsSchema = z$2.union([AddressSchema, EnsSchema], {
  invalid_type_error: "Provided value was not a valid address or ENS name"
});
let ChainId = /* @__PURE__ */ function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
  ChainId2[ChainId2["Mumbai"] = 80001] = "Mumbai";
  ChainId2[ChainId2["Localhost"] = 1337] = "Localhost";
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Fantom"] = 250] = "Fantom";
  ChainId2[ChainId2["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId2[ChainId2["Avalanche"] = 43114] = "Avalanche";
  ChainId2[ChainId2["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId2[ChainId2["Optimism"] = 10] = "Optimism";
  ChainId2[ChainId2["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId2[ChainId2["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId2[ChainId2["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
  return ChainId2;
}({});
let supportedChains = defaultChains;
function setSupportedChains(chains) {
  if (chains && chains.length > 0) {
    supportedChains = chains;
  } else {
    supportedChains = defaultChains;
  }
}
function getSupportedChains() {
  return supportedChains;
}
const NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
const NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "Görli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  11155111: {
    name: "Sepolia Ether",
    symbol: "SEP",
    decimals: 18,
    wrapped: {
      address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Localhost]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  84531: {
    name: "Base Goerli Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  // eslint-disable-next-line no-useless-computed-key
  [280]: {
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};
function getNativeTokenByChainId(chainId) {
  const chain = getSupportedChains().find((c2) => c2.chainId === chainId);
  if (chain && chain.nativeCurrency) {
    return {
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: 18,
      wrapped: {
        address: AddressZero$1,
        name: `Wrapped ${chain.nativeCurrency.name}`,
        symbol: `W${chain.nativeCurrency.symbol}`
      }
    };
  }
  return NATIVE_TOKENS[chainId] || {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: AddressZero$1,
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  };
}
const LINK_TOKEN_ADDRESS = {
  [ChainId.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
  [ChainId.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
  [ChainId.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
  [ChainId.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
  [ChainId.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
  [ChainId.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
  [ChainId.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
};
const RawDateSchema = z$2.union([z$2.date().transform((i2) => {
  return BigNumber.from(Math.floor(i2.getTime() / 1e3));
}), z$2.number().transform((i2) => {
  return BigNumber.from(i2);
})]);
const StartDateSchema = RawDateSchema.default(/* @__PURE__ */ new Date(0));
const EndDateSchema = RawDateSchema.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10));
const CurrencySchema = z$2.object({
  name: z$2.string(),
  symbol: z$2.string(),
  decimals: z$2.number()
});
const CurrencyValueSchema = CurrencySchema.extend({
  value: BigNumberSchema,
  displayValue: z$2.string()
});
const MerkleSchema = z$2.object({
  merkle: z$2.record(z$2.string()).default({})
});
const SnapshotEntryInput = z$2.object({
  address: AddressOrEnsSchema,
  maxClaimable: QuantitySchema.default(0),
  // defaults to 0
  price: QuantitySchema.optional(),
  // defaults to unlimited, but can be undefined in old snapshots
  currencyAddress: AddressOrEnsSchema.default(AddressZero$1).optional()
  // defaults to AddressZero, but can be undefined for old snapshots
});
const SnapshotInputSchema = z$2.union([z$2.array(z$2.string()).transform(async (strings) => await Promise.all(strings.map((address) => SnapshotEntryInput.parseAsync({
  address
})))), z$2.array(SnapshotEntryInput)]);
const SnapshotEntryWithProofSchema = SnapshotEntryInput.extend({
  proof: z$2.array(z$2.string())
});
const SnapshotSchema = z$2.object({
  /**
   * The merkle root
   */
  merkleRoot: z$2.string(),
  claims: z$2.array(SnapshotEntryWithProofSchema)
});
z$2.object({
  merkleRoot: z$2.string(),
  snapshotUri: z$2.string()
});
const ClaimConditionMetadataSchema = z$2.object({
  name: z$2.string().optional()
}).catchall(z$2.unknown());
const ClaimConditionInputSchema = z$2.object({
  startTime: StartDateSchema,
  currencyAddress: z$2.string().default(NATIVE_TOKEN_ADDRESS),
  price: AmountSchema.default(0),
  maxClaimableSupply: QuantitySchema,
  maxClaimablePerWallet: QuantitySchema,
  waitInSeconds: BigNumberishSchema.default(0),
  merkleRootHash: BytesLikeSchema.default(hexZeroPad([0], 32)),
  snapshot: z$2.optional(SnapshotInputSchema).nullable(),
  metadata: ClaimConditionMetadataSchema.optional()
});
const ClaimConditionInputArray = z$2.array(ClaimConditionInputSchema);
ClaimConditionInputSchema.partial();
const ClaimConditionOutputSchema = ClaimConditionInputSchema.extend({
  availableSupply: QuantitySchema,
  currentMintSupply: QuantitySchema,
  currencyMetadata: CurrencyValueSchema.default({
    value: BigNumber.from("0"),
    displayValue: "0",
    symbol: "",
    decimals: 18,
    name: ""
  }),
  price: BigNumberSchema,
  waitInSeconds: BigNumberSchema,
  startTime: BigNumberSchema.transform((n2) => new Date(n2.toNumber() * 1e3)),
  snapshot: SnapshotInputSchema.optional().nullable()
});
function resolveOrGenerateId(requestUId) {
  if (requestUId === void 0) {
    const buffer$1 = buffer.Buffer.alloc(16);
    v4({}, buffer$1);
    return hexlify(toUtf8Bytes(buffer$1.toString("hex")));
  } else {
    return hexlify(requestUId);
  }
}
const BaseSignaturePayloadInput = z$2.object({
  to: AddressOrEnsSchema.refine((address) => address.toLowerCase() !== AddressZero$1, {
    message: "Cannot create payload to mint to zero address"
  }),
  price: AmountSchema.default(0),
  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),
  mintStartTime: StartDateSchema,
  mintEndTime: EndDateSchema,
  uid: z$2.string().optional().transform((arg) => resolveOrGenerateId(arg)),
  primarySaleRecipient: AddressOrEnsSchema.default(AddressZero$1)
});
const Signature20PayloadInput = BaseSignaturePayloadInput.extend({
  quantity: AmountSchema
});
const Signature20PayloadOutput = Signature20PayloadInput.extend({
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
});
const Signature721PayloadInput = BaseSignaturePayloadInput.extend({
  metadata: NFTInputOrUriSchema,
  royaltyRecipient: z$2.string().default(AddressZero$1),
  royaltyBps: BasisPointsSchema.default(0)
});
const Signature721PayloadOutput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  uri: z$2.string(),
  royaltyBps: BigNumberSchema,
  mintStartTime: BigNumberSchema,
  mintEndTime: BigNumberSchema
});
const Signature1155PayloadInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberishSchema
});
const Signature1155PayloadInputWithTokenId = Signature1155PayloadInput.extend({
  tokenId: BigNumberishSchema
});
const Signature1155PayloadOutput = Signature721PayloadOutput.extend({
  tokenId: BigNumberSchema,
  quantity: BigNumberSchema
});
const Signature721WithQuantityInput = Signature721PayloadInput.extend({
  metadata: NFTInputOrUriSchema.default(""),
  quantity: BigNumberSchema.default(1)
});
const Signature721WithQuantityOutput = Signature721PayloadOutput.extend({
  quantity: BigNumberSchema.default(1)
});
const MintRequest20 = [{
  name: "to",
  type: "address"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
const MintRequest721 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "price",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
const MintRequest1155 = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "tokenId",
  type: "uint256"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
const MintRequest721withQuantity = [{
  name: "to",
  type: "address"
}, {
  name: "royaltyRecipient",
  type: "address"
}, {
  name: "royaltyBps",
  type: "uint256"
}, {
  name: "primarySaleRecipient",
  type: "address"
}, {
  name: "uri",
  type: "string"
}, {
  name: "quantity",
  type: "uint256"
}, {
  name: "pricePerToken",
  type: "uint256"
}, {
  name: "currency",
  type: "address"
}, {
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}];
const GenericRequest = [{
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}, {
  name: "data",
  type: "bytes"
}];
const CommonContractSchema = z$2.object({
  name: z$2.string(),
  description: z$2.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: z$2.string().optional(),
  app_uri: z$2.string().optional()
});
const CommonContractOutputSchema = CommonContractSchema.extend({
  image: z$2.string().optional()
}).catchall(z$2.unknown());
const CommonRoyaltySchema = z$2.object({
  /**
   * The amount of royalty collected on all royalties represented as basis points.
   * The default is 0 (no royalties).
   *
   * 1 basis point = 0.01%
   *
   * For example: if this value is 100, then the royalty is 1% of the total sales.
   *
   *  @internalremarks used by OpenSea "seller_fee_basis_points"
   */
  seller_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * The address of the royalty recipient. All royalties will be sent
   * to this address.
   * @internalremarks used by OpenSea "fee_recipient"
   */
  fee_recipient: AddressOrEnsSchema.default(AddressZero$1)
});
const CommonPrimarySaleSchema = z$2.object({
  /**
   * primary sale recipient address
   */
  primary_sale_recipient: AddressOrEnsSchema
});
const CommonPlatformFeeSchema = z$2.object({
  /**
   * platform fee basis points
   */
  platform_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * platform fee recipient address
   */
  platform_fee_recipient: AddressOrEnsSchema.default(AddressZero$1)
});
const CommonTrustedForwarderSchema = z$2.object({
  trusted_forwarders: z$2.array(AddressOrEnsSchema).default([])
});
const CommonSymbolSchema = z$2.object({
  symbol: z$2.string().default("")
});
const BYOCContractMetadataSchema = CommonContractSchema.catchall(z$2.union([BigNumberTransformSchema, z$2.unknown()]));
const CustomContractInput = BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
const CustomContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial());
const CustomContractDeploy = CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial());
const CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};
const AbiTypeBaseSchema = z$2.object({
  type: z$2.string(),
  name: z$2.string().default("")
}).catchall(z$2.any());
const AbiTypeSchema = AbiTypeBaseSchema.extend({
  stateMutability: z$2.string().optional(),
  components: z$2.array(AbiTypeBaseSchema).optional()
}).catchall(z$2.any());
const AbiObjectSchema = z$2.object({
  type: z$2.string(),
  name: z$2.string().default(""),
  inputs: z$2.array(AbiTypeSchema).default([]),
  outputs: z$2.array(AbiTypeSchema).default([])
}).catchall(z$2.any());
const AbiSchema = z$2.array(AbiObjectSchema);
const PreDeployMetadata = z$2.object({
  name: z$2.string(),
  metadataUri: z$2.string(),
  bytecodeUri: z$2.string(),
  analytics: z$2.any().optional()
}).catchall(z$2.any());
const ChainIdToAddressSchema = z$2.record(z$2.string(), z$2.string());
const CustomFactoryInput = z$2.object({
  factoryFunction: z$2.string(),
  params: z$2.array(z$2.object({
    name: z$2.string(),
    type: z$2.string()
  })).default([]),
  customFactoryAddresses: ChainIdToAddressSchema
});
const FactoryDeploymentSchema = z$2.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: z$2.string().default("initialize"),
  customFactoryInput: CustomFactoryInput.optional(),
  factoryAddresses: ChainIdToAddressSchema.optional()
});
const DeployTypeInput = z$2.union([z$2.literal("standard"), z$2.literal("autoFactory"), z$2.literal("customFactory")]);
const DeploymentNetworkInput = z$2.object({
  allNetworks: z$2.boolean().optional(),
  networksEnabled: z$2.array(z$2.number()).default([])
});
const ExtraPublishMetadataSchemaInput = z$2.object({
  version: z$2.string().refine((v2) => {
    try {
      toSemver(v2);
      return true;
    } catch (e2) {
      return false;
    }
  }, (out) => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: z$2.string().optional(),
  description: z$2.string().optional(),
  readme: z$2.string().optional(),
  license: z$2.string().optional(),
  changelog: z$2.string().optional(),
  tags: z$2.array(z$2.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: z$2.boolean().optional(),
  isDeployableViaProxy: z$2.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  deployType: DeployTypeInput.optional(),
  networksForDeployment: DeploymentNetworkInput.optional(),
  constructorParams: z$2.record(z$2.string(), z$2.object({
    displayName: z$2.string().optional(),
    description: z$2.string().optional(),
    defaultValue: z$2.string().optional(),
    hidden: z$2.boolean().optional()
  }).catchall(z$2.any())).optional(),
  compositeAbi: AbiSchema.optional()
}).catchall(z$2.any());
const ExtraPublishMetadataSchemaOutput = ExtraPublishMetadataSchemaInput.extend({
  audit: z$2.string().nullable().optional(),
  logo: z$2.string().nullable().optional()
});
const FullPublishMetadataSchemaInput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressOrEnsSchema.optional()
});
const FullPublishMetadataSchemaOutput = PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressOrEnsSchema.optional()
});
const ProfileSchemaInput = z$2.object({
  name: z$2.string().optional(),
  bio: z$2.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: z$2.string().optional(),
  twitter: z$2.string().optional(),
  telegram: z$2.string().optional(),
  facebook: z$2.string().optional(),
  github: z$2.string().optional(),
  medium: z$2.string().optional(),
  linkedin: z$2.string().optional(),
  reddit: z$2.string().optional(),
  discord: z$2.string().optional()
});
const ProfileSchemaOutput = ProfileSchemaInput.extend({
  avatar: z$2.string().nullable().optional()
});
const PublishedContractSchema = z$2.object({
  id: z$2.string(),
  timestamp: BigNumberishSchema,
  metadataUri: z$2.string()
});
const ContractInfoSchema = z$2.object({
  title: z$2.string().optional(),
  author: z$2.string().optional(),
  details: z$2.string().optional(),
  notice: z$2.string().optional()
});
const CompilerMetadataFetchedSchema = z$2.object({
  name: z$2.string(),
  abi: AbiSchema,
  metadata: z$2.record(z$2.string(), z$2.any()),
  info: ContractInfoSchema,
  licenses: z$2.array(z$2.string().optional()).default([]).transform((v2) => {
    return v2.filter((license) => license !== void 0);
  })
});
const PreDeployMetadataFetchedSchema = PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: z$2.string()
});
const CallOverrideSchema = z$2.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: z$2.union([z$2.string(), z$2.number()]).optional(),
  from: AddressOrEnsSchema.optional(),
  type: z$2.number().optional()
}).strict();
class ContractEncoder {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  /**
   * Encodes the given contract function with argument
   * @returns the encoded data
   */
  encode(fn2, args) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(fn2, args);
  }
  /**
   * Decode encoded call data for a given function
   * @param fn - the function to decode
   * @param encodedArgs - the encoded arguments
   */
  decode(fn2, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(fn2, encodedArgs);
  }
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
class NotFoundError extends Error {
  /** @internal */
  constructor(identifier2) {
    super(identifier2 ? `Object with id ${identifier2} NOT FOUND` : "NOT_FOUND");
  }
}
class MissingRoleError extends Error {
  /** @internal */
  /** @internal */
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
}
class DuplicateLeafsError extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
}
class AuctionAlreadyStartedError extends Error {
  constructor(id2) {
    super(`Auction already started with existing bid${id2 ? `, id: ${id2}` : ""}`);
  }
}
class ListingNotFoundError extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
}
class WrongListingTypeError extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
}
class AuctionHasNotEndedError extends Error {
  constructor(id2, endTime) {
    super(`Auction has not ended yet${id2 ? `, id: ${id2}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
}
class ExtensionNotImplementedError extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.docLinks.contracts}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);
  }
}
var _reason = /* @__PURE__ */ new WeakMap();
var _info = /* @__PURE__ */ new WeakMap();
var _raw = /* @__PURE__ */ new WeakMap();
class TransactionError extends Error {
  constructor(info, raw2) {
    let errorMessage = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
    errorMessage += `Reason: ${info.reason}`;
    errorMessage += `


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`;
    errorMessage += withSpaces("from", info.from);
    if (info.to) {
      errorMessage += withSpaces("to", info.contractName ? `${info.to} (${info.contractName})` : info.to);
    }
    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);
    if (info.rpcUrl) {
      try {
        const url = new URL(info.rpcUrl);
        errorMessage += withSpaces(`rpc`, url.hostname);
      } catch (e2) {
      }
    }
    if (info.hash) {
      errorMessage += withSpaces(`tx hash`, info.hash);
    }
    if (info.value && info.value.gt(0)) {
      errorMessage += withSpaces("value", `${formatEther(info.value)} ${NATIVE_TOKENS[info.network.chainId]?.symbol || ""}`);
    }
    errorMessage += withSpaces(`data`, `${info.data}`);
    if (info.method) {
      errorMessage += withSpaces("method", info.method);
    }
    if (info.sources) {
      const revertFile = info.sources.find((file2) => file2.source.includes(info.reason));
      if (revertFile) {
        const lines = revertFile.source.split("\n").map((line2, index2) => `${index2 + 1}  ${line2}`);
        const revertLine = lines.findIndex((line2) => line2.includes(info.reason));
        lines[revertLine] += "   <-- REVERT";
        const errorLines = lines.slice(revertLine - 8, revertLine + 4);
        errorMessage += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`;
        errorMessage += `File: ${revertFile.filename.replace("node_modules/", "")}

`;
        errorMessage += errorLines.join("\n");
      }
    }
    errorMessage += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`;
    errorMessage += `Need helping debugging? Join our Discord: https://discord.gg/thirdweb`;
    errorMessage += `

`;
    super(errorMessage);
    _classPrivateFieldInitSpec(this, _reason, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _info, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _raw, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _reason, info.reason);
    _classPrivateFieldSet(this, _info, info);
    _classPrivateFieldSet(this, _raw, raw2);
  }
  // Keep reason here for backwards compatibility
  get reason() {
    return _classPrivateFieldGet(this, _reason);
  }
  get raw() {
    return _classPrivateFieldGet(this, _raw);
  }
  get info() {
    return _classPrivateFieldGet(this, _info);
  }
}
function parseRevertReason(error) {
  if (error.reason && !error.reason.includes("cannot estimate gas")) {
    return error.reason;
  }
  if (error.error) {
    return error.error;
  }
  let errorString = error;
  if (typeof error === "object") {
    errorString = JSON.stringify(error);
  } else if (typeof error !== "string") {
    errorString = error.toString();
  }
  return parseMessageParts(/.*?"message":"([^"\\]*).*?/, errorString) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, errorString) || error.message || "";
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  if (content.includes("\n")) {
    content = "\n\n  " + content.split("\n").join(`
  `);
  } else {
    content = `${spaces}${content}`;
  }
  return `
${label}:${content}`;
}
function parseMessageParts(regex, raw2) {
  const msgMatches = raw2.match(regex) || [];
  let extracted = "";
  if (msgMatches?.length > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}
const FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi, IDropSinglePhaseV1],
  features: {}
};
const FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi, IDropSinglePhase],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [ERC20Abi, IDrop],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [DropERC20_V2Abi],
  features: {}
};
const FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "erc20burnable"
  },
  abis: [ERC20Abi, IBurnableERC20Abi],
  features: {}
};
const FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "erc20signaturemint"
  },
  abis: [ERC20Abi, ISignatureMintERC20Abi],
  features: {}
};
const FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "erc20batchmintable"
  },
  abis: [ERC20Abi, IMintableERC20Abi, MulticallAbi],
  features: {}
};
const FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "erc20mintable"
  },
  abis: [ERC20Abi, IMintableERC20Abi],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
const FEATURE_TOKEN_PERMIT = {
  name: "ERC20Permit",
  namespace: "token.permit",
  docLinks: {
    sdk: "sdk.erc20permit",
    contracts: "erc20permit"
  },
  abis: [ERC20Abi, IERC20PermitAbi],
  features: {}
};
const FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "erc20"
  },
  abis: [ERC20Abi],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,
    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT
  }
};
const FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "erc721burnable"
  },
  abis: [Erc721Abi, IBurnableERC721Abi],
  features: {}
};
const FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "erc721revealable"
  },
  abis: [Erc721Abi, ILazyMintAbi, DelayedRevealAbi],
  features: {}
};
const FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    //TODO
    contracts: ""
  },
  abis: [Erc721Abi, TieredDropAbi],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi, IDropSinglePhaseV1],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi, IDropSinglePhase],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [DropERC721_V3Abi],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [Erc721Abi, IDrop],
  features: {}
};
const FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimcustom"
  },
  abis: [Erc721Abi, IClaimableERC721],
  features: {}
};
const FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "lazymint"
  },
  abis: [Erc721Abi, ILazyMintAbi],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE
  }
};
const FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "erc721batchmintable"
  },
  abis: [Erc721Abi, IMintableERC721Abi, MulticallAbi],
  features: {}
};
const FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "erc721mintable"
  },
  abis: [Erc721Abi, IMintableERC721Abi],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [Erc721Abi, SignatureMintERC721Abi],
  features: {}
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [SignatureMintERC721_V1Abi],
  features: {}
};
const FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "erc721enumerable"
  },
  abis: [Erc721Abi, Erc721EnumerableAbi],
  features: {}
};
const FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "erc721supply"
  },
  abis: [Erc721Abi, Erc721SupplyAbi],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE
  }
};
const FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "erc721"
  },
  abis: [Erc721Abi],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2
  }
};
const FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "erc1155burnable"
  },
  abis: [Erc1155Abi, IBurnableERC1155Abi],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155dropsinglephase"
  },
  abis: [Erc1155Abi, IDropSinglePhase1155_V1],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimconditions"
  },
  abis: [Erc1155Abi, IDropSinglePhase1155],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [Erc1155Abi, IDropMultiPhase1155],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [DropERC1155_V2Abi],
  features: {}
};
const FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimcustom"
  },
  abis: [Erc1155Abi, IClaimableERC1155],
  features: {}
};
const FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "erc1155revealable"
  },
  abis: [Erc1155Abi, ILazyMintAbi, DelayedRevealAbi],
  features: {}
};
const FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [Erc1155Abi, ILazyMintAbi],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE
  }
};
const FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [DropERC1155_V2Abi],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
const FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "erc1155signaturemint"
  },
  abis: [Erc1155Abi, ISignatureMintERC1155Abi],
  features: {}
};
const FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "erc1155batchmintable"
  },
  abis: [Erc1155Abi, IMintableERC1155Abi, MulticallAbi],
  features: {}
};
const FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "erc1155mintable"
  },
  abis: [Erc1155Abi, IMintableERC1155Abi],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
const FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "erc1155enumerable"
  },
  abis: [Erc1155Abi, Erc1155EnumerableAbi],
  features: {}
};
const FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "erc1155"
  },
  abis: [Erc1155Abi],
  features: {
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2
  }
};
const getAllPluginsAbi = [{
  inputs: [],
  name: "getAllPlugins",
  outputs: [{
    components: [{
      internalType: "bytes4",
      name: "functionSelector",
      type: "bytes4"
    }, {
      internalType: "string",
      name: "functionSignature",
      type: "string"
    }, {
      internalType: "address",
      name: "pluginAddress",
      type: "address"
    }],
    internalType: "struct IPluginMap.Plugin[]",
    name: "registered",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const getAllExtensionsAbi = [{
  inputs: [],
  name: "getAllExtensions",
  outputs: [{
    components: [{
      components: [{
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "metadataURI",
        type: "string"
      }, {
        internalType: "address",
        name: "implementation",
        type: "address"
      }],
      internalType: "struct IExtension.ExtensionMetadata",
      name: "metadata",
      type: "tuple"
    }, {
      components: [{
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      }, {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      }],
      internalType: "struct IExtension.ExtensionFunction[]",
      name: "functions",
      type: "tuple[]"
    }],
    internalType: "struct IExtension.Extension[]",
    name: "allExtensions",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "royalty"
  },
  abis: [IThirdwebRoyaltyAbi],
  features: {}
};
const FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "primarysale"
  },
  abis: [IThirdwebPrimarySaleAbi],
  features: {}
};
const FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFee",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "platformfee"
  },
  abis: [IThirdwebPlatformFeeAbi],
  features: {}
};
const FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissionsenumerable"
  },
  abis: [IPermissionsEnumerableAbi],
  features: {}
};
const FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissions"
  },
  abis: [IPermissionsAbi],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
const FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "contractmetadata"
  },
  abis: [IContractMetadataAbi],
  features: {}
};
const FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    //TODO
    contracts: ""
  },
  abis: [IAppURI],
  features: {}
};
const FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "ownable"
  },
  abis: [IOwnableAbi],
  features: {}
};
const FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    // TODO add the correct name for this once it's added to portal
    contracts: ""
  },
  abis: [IERC2771ContextAbi],
  features: {}
};
const FEATURE_PACK_VRF = {
  name: "PackVRF",
  namespace: "pack.vrf",
  docLinks: {
    sdk: "sdk.packvrf",
    //TODO
    contracts: ""
  },
  abis: [IPackVRFAbi],
  features: {}
};
const FEATURE_PLUGIN_ROUTER = {
  name: "PluginRouter",
  namespace: "plugin.router",
  docLinks: {
    sdk: "sdk.pluginrouter",
    //TODO
    contracts: ""
  },
  abis: [getAllPluginsAbi],
  features: {}
};
const FEATURE_EXTENSION_ROUTER = {
  name: "ExtensionRouter",
  namespace: "extension.router",
  docLinks: {
    sdk: "",
    //TODO
    contracts: ""
  },
  abis: [getAllExtensionsAbi],
  features: {}
};
const FEATURE_DIRECT_LISTINGS = {
  name: "DirectListings",
  namespace: "direct.listings",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IDirectListingsAbi],
  features: {}
};
const FEATURE_ENGLISH_AUCTIONS = {
  name: "EnglishAuctions",
  namespace: "english.auctions",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IEnglishAuctionsAbi],
  features: {}
};
const FEATURE_OFFERS = {
  name: "Offers",
  namespace: "offers",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IOffersAbi],
  features: {}
};
const FEATURE_SMART_WALLET_FACTORY = {
  name: "SmartWalletFactory",
  namespace: "smartwallet.factory",
  docLinks: {
    // TODO
    sdk: "sdk.smartWalletFactory",
    contracts: "smartWalletFactory"
  },
  abis: [IAccountFactory],
  features: {}
};
const FEATURE_SMART_WALLET = {
  name: "SmartWallet",
  namespace: "smartwallet",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [IAccount],
  features: {}
};
const SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS,
  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,
  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,
  [FEATURE_EXTENSION_ROUTER.name]: FEATURE_EXTENSION_ROUTER,
  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,
  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,
  [FEATURE_OFFERS.name]: FEATURE_OFFERS,
  [FEATURE_SMART_WALLET_FACTORY.name]: FEATURE_SMART_WALLET_FACTORY,
  [FEATURE_SMART_WALLET.name]: FEATURE_SMART_WALLET
};
function toJSType(contractType2) {
  let isReturnType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let jsType = contractType2.type;
  let isArray2 = false;
  if (jsType.endsWith("[]")) {
    isArray2 = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType2.components) {
      jsType = `{ ${contractType2.components.map((a2) => toJSType(a2, false, true)).join(", ")} }`;
    }
  }
  if (isArray2) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType2.name}: ${jsType}`;
  }
  return jsType;
}
function extractCommentFromMetadata(name2, metadata, type) {
  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find((fn2) => fn2.includes(name2 || "unknown")) || ""]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find((fn2) => fn2.includes(name2 || "unknown")) || ""]?.details;
}
function extractFunctionsFromAbi(abi, metadata) {
  const functions = (abi || []).filter((el2) => el2.type === "function");
  const parsed = [];
  for (const f2 of functions) {
    const doc = extractCommentFromMetadata(f2.name, metadata, "methods");
    const args = f2.inputs?.map((i2) => `${i2.name || "key"}: ${toJSType(i2)}`)?.join(", ") || "";
    const fargs = args ? `, [${args}]` : "";
    const out = f2.outputs?.map((o2) => toJSType(o2, true))?.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature2 = `contract.call("${f2.name}"${fargs})${promise}`;
    parsed.push({
      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      inputs: f2.inputs || [],
      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      outputs: f2.outputs || [],
      name: f2.name || "unknown",
      signature: signature2,
      stateMutability: f2.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap((i2) => extractFunctionsFromAbi(i2));
  const intersection = contractFn.filter((fn2) => {
    const match2 = interfaceFn.find((iFn) => iFn.name === fn2.name && iFn.inputs.length === fn2.inputs.length && iFn.inputs.every((i2, index2) => {
      if (i2.type === "tuple" || i2.type === "tuple[]") {
        return i2.type === fn2.inputs[index2].type && i2.components?.every((c2, cIndex) => {
          return c2.type === fn2.inputs[index2].components?.[cIndex]?.type;
        });
      }
      return i2.type === fn2.inputs[index2].type;
    }));
    return match2 !== void 0;
  });
  return intersection.length === interfaceFn.length;
}
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SUPPORTED_FEATURES;
  const results2 = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeatures(abi, feature.features);
    results2[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results2;
}
function matchesAbiInterface(abi, feature) {
  return hasMatchingAbi(abi, feature.abis);
}
function isFeatureEnabled(abi, featureName) {
  const features = detectFeatures(abi);
  return _featureEnabled(features, featureName);
}
function _featureEnabled(features, featureName) {
  const keys2 = Object.keys(features);
  if (!keys2.includes(featureName)) {
    let found = false;
    for (const key2 of keys2) {
      const f2 = features[key2];
      found = _featureEnabled(f2.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}
function detectContractFeature(contractWrapper, featureName) {
  return isFeatureEnabled(AbiSchema.parse(contractWrapper.abi), featureName);
}
function hasFunction(functionName, contractWrapper) {
  return functionName in contractWrapper.readContract.functions;
}
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    extractFeatures(extension.features, enabledExtensions);
  }
}
function getAllDetectedFeatureNames(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features.map((f2) => f2.name);
}
async function resolveAddress(addressOrEns) {
  return AddressOrEnsSchema.parseAsync(addressOrEns);
}
const ERROR_SUBSTRINGS = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support"];
const ERROR_SUBSTRINGS_COMPOSITE = [["account", "not found"], ["wrong", "chainid"]];
const CUSTOM_GAS_FOR_CHAIN = {
  [5001]: {
    name: "Mantle Testnet",
    gasPrice: 1
  },
  [71402]: {
    name: "Godwoken Mainnet",
    gasPrice: 4e4 * 10 ** 9
  },
  [1351057110]: {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 1e5
  },
  [361]: {
    name: "Theta Mainnet",
    gasPrice: 4e3 * 10 ** 9
  },
  [365]: {
    name: "Theta Testnet",
    gasPrice: 4e3 * 10 ** 9
  }
};
function matchError(error) {
  const errorIndex = ERROR_SUBSTRINGS.findIndex((substring) => error.includes(substring));
  const compositeErrorIndex = ERROR_SUBSTRINGS_COMPOSITE.findIndex((arr) => {
    let foundError = true;
    arr.forEach((substring) => {
      foundError && (foundError = error.includes(substring));
    });
    return foundError;
  });
  return errorIndex !== -1 || compositeErrorIndex !== -1;
}
const CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
const SIGNATURE = {
  v: 27,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
const COMMON_FACTORY = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
const GAS_LIMIT_FOR_DEPLOYER = 5e6;
const DEPLOYER_BYTECODE = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033";
const DEPLOYER_ABI = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "predictedAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "to",
      type: "address"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IDeployer.Transaction[]",
    name: "transactions",
    type: "tuple[]"
  }],
  stateMutability: "payable",
  type: "constructor"
}];
async function isContractDeployed(address, provider2) {
  const code2 = await provider2.getCode(address);
  return code2 !== "0x" && code2 !== "0x0";
}
async function isEIP155Enforced(provider2) {
  try {
    await provider2.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e2) {
    const errorMsg = e2.toString().toLowerCase();
    const errorJson = JSON.stringify(e2).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      return true;
    }
    return false;
  }
  return false;
}
function getKeylessTxn(transaction, signature2) {
  const digest10 = arrayify(keccak256$1(serialize$3(transaction)));
  const signer = recoverAddress(digest10, signature2);
  const signedSerializedTx = serialize$3(transaction, signature2);
  return {
    signer,
    transaction: signedSerializedTx
  };
}
function getCreate2FactoryDeploymentInfo(chainId, gasPrice) {
  const signature2 = joinSignature(SIGNATURE);
  const deploymentTransaction = getKeylessTxn({
    gasPrice: gasPrice ? gasPrice : 100 * 10 ** 9,
    gasLimit: 1e5,
    nonce: 0,
    data: CREATE2_FACTORY_BYTECODE,
    chainId
  }, signature2);
  const create2FactoryAddress = getContractAddress({
    from: deploymentTransaction.signer,
    nonce: 0
  });
  return {
    ...deploymentTransaction,
    deployment: create2FactoryAddress
  };
}
async function getCreate2FactoryAddress(provider2) {
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, provider2);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(provider2);
  const networkId = (await provider2.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);
  return deploymentInfo.deployment;
}
const bytecode = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";
const ContractPublisher_address = "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7";
function getContractPublisherAddress() {
  if ({ "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.contractPublisherAddress) {
    return { "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.contractPublisherAddress;
  } else {
    return ContractPublisher_address;
  }
}
const uriCache = {};
const THIRDWEB_DEPLOYER$1 = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
async function fetchAndCachePublishedContractURI(contractName) {
  if (uriCache[contractName]) {
    return uriCache[contractName];
  }
  const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider("polygon", {}));
  const model = await contract.getPublishedContract(THIRDWEB_DEPLOYER$1, contractName);
  if (!model) {
    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER$1}'`);
  }
  const uri = model.publishMetadataUri;
  uriCache[contractName] = uri;
  return uri;
}
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}
async function fetchContractMetadata(compilerMetadataUri, storage) {
  const metadata = await storage.downloadJSON(compilerMetadataUri);
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name2 = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map((_ref) => {
    let [, src2] = _ref;
    return src2.license;
  }))];
  return {
    name: name2,
    abi,
    metadata,
    info,
    licenses
  };
}
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}
async function fetchPreDeployMetadata(publishMetadataUri, storage) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();
  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: deployBytecode
  });
}
const deployMetadataCache = {};
async function fetchAndCacheDeployMetadata(publishMetadataUri, storage) {
  if (deployMetadataCache[publishMetadataUri]) {
    return deployMetadataCache[publishMetadataUri];
  }
  const compilerMetadata2 = await fetchPreDeployMetadata(publishMetadataUri, storage);
  let extendedMetadata;
  try {
    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);
  } catch (e2) {
  }
  const data = {
    compilerMetadata: compilerMetadata2,
    extendedMetadata
  };
  deployMetadataCache[publishMetadataUri] = data;
  return data;
}
function getSaltHash(bytecode2) {
  const bytecodeHash = id$2(bytecode2);
  const salt = `tw.${bytecodeHash}`;
  const saltHash = id$2(salt);
  return saltHash;
}
function getInitBytecodeWithSalt(bytecode2, encodedArgs) {
  const saltHash = getSaltHash(bytecode2);
  const initBytecodeWithSalt = pack(["bytes32", "bytes", "bytes"], [saltHash, bytecode2, encodedArgs]);
  return initBytecodeWithSalt;
}
function computeDeploymentAddress(bytecode2, encodedArgs, create2FactoryAddress) {
  const saltHash = getSaltHash(bytecode2);
  const initBytecode = pack(["bytes", "bytes"], [bytecode2, encodedArgs]);
  const deployInfoPacked = pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", create2FactoryAddress, saltHash, keccak256(["bytes"], [initBytecode])]);
  const hashedDeployInfo = keccak256(["bytes"], [deployInfoPacked]);
  return `0x${hashedDeployInfo.slice(26)}`;
}
function extractConstructorParamsFromAbi(abi) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}
const caches = {
  deploymentPresets: {}
};
async function computeDeploymentInfo(contractType2, provider2, storage, create2Factory, contractOptions) {
  let contractName = contractOptions && contractOptions.contractName;
  let metadata = contractOptions && contractOptions.metadata;
  invariant$1(contractName || metadata, "Require contract name or metadata");
  if (contractName && caches.deploymentPresets[contractName]) {
    return caches.deploymentPresets[contractName];
  }
  if (contractName === "WETH9") {
    const address2 = computeDeploymentAddress(bytecode, [], create2Factory);
    const contractDeployed2 = await isContractDeployed(address2, provider2);
    let initBytecodeWithSalt2 = "";
    if (!contractDeployed2) {
      initBytecodeWithSalt2 = getInitBytecodeWithSalt(bytecode, []);
    }
    return {
      name: contractName,
      type: contractType2,
      transaction: {
        predictedAddress: address2,
        to: create2Factory,
        data: initBytecodeWithSalt2
      }
    };
  }
  if (!metadata) {
    invariant$1(contractName, "Require contract name");
    const uri = await fetchAndCachePublishedContractURI(contractName);
    metadata = (await fetchAndCacheDeployMetadata(uri, storage)).compilerMetadata;
  }
  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider2, storage, create2Factory, contractOptions?.constructorParams);
  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);
  const contractDeployed = await isContractDeployed(address, provider2);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);
  }
  return {
    name: contractName,
    type: contractType2,
    transaction: {
      predictedAddress: address,
      to: create2Factory,
      data: initBytecodeWithSalt
    },
    encodedArgs
  };
}
async function encodeConstructorParamsForImplementation(compilerMetadata2, provider2, storage, create2Factory, constructorParamMap) {
  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata2.abi);
  let constructorParamTypes = constructorParams.map((p2) => {
    if (p2.type === "tuple[]") {
      return ParamType.from(p2);
    } else {
      return p2.type;
    }
  });
  const constructorParamValues = await Promise.all(constructorParams.map(async (p2) => {
    if (constructorParamMap && constructorParamMap[p2.name]) {
      if (constructorParamMap[p2.name].type) {
        invariant$1(constructorParamMap[p2.name].type === p2.type, `Provided type ${constructorParamMap[p2.name].type} doesn't match the actual type ${p2.type} from Abi`);
      }
      return constructorParamMap[p2.name].value;
    }
    if (p2.name && p2.name.includes("nativeTokenWrapper")) {
      const chainId = (await provider2.getNetwork()).chainId;
      let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;
      if (nativeTokenWrapperAddress === AddressZero$1) {
        const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
          contractName: "WETH9"
        });
        if (!caches.deploymentPresets["WETH9"]) {
          caches.deploymentPresets["WETH9"] = deploymentInfo;
        }
        nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;
      }
      return nativeTokenWrapperAddress;
    } else if (p2.name && p2.name.includes("trustedForwarder")) {
      if (compilerMetadata2.name === "Pack") {
        const deploymentInfo2 = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
          contractName: "ForwarderEOAOnly"
        });
        if (!caches.deploymentPresets["ForwarderEOAOnly"]) {
          caches.deploymentPresets["ForwarderEOAOnly"] = deploymentInfo2;
        }
        return deploymentInfo2.transaction.predictedAddress;
      }
      const deploymentInfo = await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
        contractName: "Forwarder"
      });
      if (!caches.deploymentPresets["Forwarder"]) {
        caches.deploymentPresets["Forwarder"] = deploymentInfo;
      }
      return deploymentInfo.transaction.predictedAddress;
    } else {
      throw new Error("Can't resolve constructor arguments");
    }
  }));
  const encodedArgs = defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);
  return encodedArgs;
}
async function computeEOAForwarderAddress(provider2, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "ForwarderEOAOnly"
  })).transaction.predictedAddress;
}
async function computeForwarderAddress(provider2, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "Forwarder"
  })).transaction.predictedAddress;
}
async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async (_ref) => {
    let [path, info] = _ref;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find((url) => url.includes("ipfs")) : void 0;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 3e3));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}
const ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
const ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];
const BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
const _nonces = {};
const _noncesSyncTimestamp = {};
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  const shouldSync = Date.now() - timestamp >= 2e3;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}
async function signTypedDataInternal(signer, domain, types2, message) {
  const provider2 = signer?.provider;
  if (!provider2) {
    throw new Error("missing provider");
  }
  const payload = TypedDataEncoder.getPayload(domain, types2, message);
  let signature2 = "";
  const signerAddress = (await signer.getAddress()).toLowerCase();
  if (provider2?.provider?.isWalletConnect) {
    signature2 = await provider2.send("eth_signTypedData", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);
  } else {
    try {
      signature2 = await signer._signTypedData(domain, types2, message);
    } catch (err) {
      if (err?.message?.includes("Method eth_signTypedData_v4 not supported")) {
        signature2 = await provider2.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
      } else {
        try {
          await provider2.send("eth_signTypedData_v4", [signerAddress, JSON.stringify(payload)]);
        } catch (finalErr) {
          throw finalErr;
        }
      }
    }
  }
  return {
    payload,
    signature: joinSignature(splitSignature(signature2))
  };
}
const NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
const NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    try {
      return await contract.getDomainSeperator();
    } catch (err2) {
      console.error("Error getting domain separator", err2);
    }
  }
}
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {
  const domain = await getChainDomainSeperator(signer, {
    name: await getTokenName(signer, currencyAddress),
    version: "1",
    chainId: await signer.getChainId(),
    verifyingContract: currencyAddress
  });
  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();
  deadline = deadline || MaxUint256$1;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types2 = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature: signature2
  } = await signTypedDataInternal(signer, domain, types2, message);
  return {
    message,
    signature: signature2
  };
}
const isBrowser$3 = () => true;
const isNode = () => !isBrowser$3();
function unique(a2, fn2) {
  if (a2.length === 0 || a2.length === 1) {
    return a2;
  }
  if (!fn2) {
    return a2;
  }
  for (let i2 = 0; i2 < a2.length; i2++) {
    for (let j = i2 + 1; j < a2.length; j++) {
      if (fn2(a2[i2], a2[j])) {
        a2.splice(j, 1);
      }
    }
  }
  return a2;
}
let EventType = /* @__PURE__ */ function(EventType2) {
  EventType2["Transaction"] = "transaction";
  EventType2["Signature"] = "signature";
  return EventType2;
}({});
class RPCConnectionHandler extends EventEmitter$1 {
  constructor(network, options2) {
    super();
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "signer", void 0);
    _defineProperty(this, "options", void 0);
    try {
      this.options = SDKOptionsSchema.parse(options2);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.
   *
   * @param network - a network, signer or provider that ethers js can interpret
   */
  updateSignerOrProvider(network) {
    const [signer, provider2] = getSignerAndProvider(network, this.options);
    this.signer = signer;
    this.provider = provider2;
  }
  /**
   *
   * @returns whether or not a signer is set, `true` if there is no signer so the class is in "read only" mode
   */
  isReadOnly() {
    return !isSigner(this.signer);
  }
  /**
   * Explicitly get the active signer.
   * @returns the active signer, if there is one
   */
  getSigner() {
    return this.signer;
  }
  /**
   * Explicitly get the active provider.
   * @returns the active provider
   */
  getProvider() {
    return this.provider;
  }
  /**
   *
   * @returns the current signer if there is one, otherwise the active provider
   */
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
const TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";
const OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";
const CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
    twBYOCRegistry: AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd"
  },
  [ChainId.Hardhat]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Localhost]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  }
};
function getContractAddressByChainId(chainId, contractName) {
  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {
    if (contractName === "twFactory") {
      return { "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.factoryAddress;
    } else if (contractName === "twRegistry") {
      return { "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.registryAddress;
    } else {
      return AddressZero;
    }
  }
  return CONTRACT_ADDRESSES[chainId]?.[contractName];
}
var _storage = /* @__PURE__ */ new WeakMap();
class ContractWrapper extends RPCConnectionHandler {
  // TODO: In another PR, make this storage private, and have extending classes pass
  // down storage to be stored in contract wrapper.
  /**
   * @internal
   */
  constructor(network, contractAddress, contractAbi, options2) {
    super(network, options2);
    _classPrivateFieldInitSpec(this, _storage, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "isValidContract", false);
    _defineProperty(this, "customOverrides", () => ({}));
    _defineProperty(this, "writeContract", void 0);
    _defineProperty(this, "readContract", void 0);
    _defineProperty(this, "abi", void 0);
    this.abi = contractAbi;
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
    _classPrivateFieldSet(this, _storage, new ThirdwebStorage());
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  /**
   * @internal
   */
  async getChainID() {
    const provider2 = this.getProvider();
    const {
      chainId
    } = await provider2.getNetwork();
    return chainId;
  }
  /**
   * @internal
   */
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }
  /**
   * @internal
   */
  callStatic() {
    return this.writeContract.callStatic;
  }
  /**
   * @internal
   */
  async getCallOverrides() {
    {
      return {};
    }
  }
  /**
   * Calculates the priority fee per gas according to user preferences
   * @param defaultPriorityFeePerGas - the base priority fee
   */
  getPreferredPriorityFee(defaultPriorityFeePerGas) {
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(0);
        break;
      case "fast":
        extraTip = defaultPriorityFeePerGas.div(100).mul(5);
        break;
      case "fastest":
        extraTip = defaultPriorityFeePerGas.div(100).mul(10);
        break;
    }
    let txGasPrice = defaultPriorityFeePerGas.add(extraTip);
    const max2 = parseUnits(maxGasPrice.toString(), "gwei");
    const min2 = parseUnits("2.5", "gwei");
    if (txGasPrice.gt(max2)) {
      txGasPrice = max2;
    }
    if (txGasPrice.lt(min2)) {
      txGasPrice = min2;
    }
    return txGasPrice;
  }
  /**
   * Calculates the gas price for transactions according to user preferences
   */
  async getPreferredGasPrice() {
    const gasPrice = await this.getProvider().getGasPrice();
    const speed = this.options.gasSettings.speed;
    const maxGasPrice = this.options.gasSettings.maxPriceInGwei;
    let txGasPrice = gasPrice;
    let extraTip;
    switch (speed) {
      case "standard":
        extraTip = BigNumber.from(1);
        break;
      case "fast":
        extraTip = gasPrice.div(100).mul(5);
        break;
      case "fastest":
        extraTip = gasPrice.div(100).mul(10);
        break;
    }
    txGasPrice = txGasPrice.add(extraTip);
    const max2 = parseUnits(maxGasPrice.toString(), "gwei");
    if (txGasPrice.gt(max2)) {
      txGasPrice = max2;
    }
    return txGasPrice;
  }
  /**
   * @internal
   */
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }
  /**
   * @internal
   */
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }
  /**
   * @internal
   */
  async estimateGas(fn2, args) {
    return this.writeContract.estimateGas[fn2](...args);
  }
  /**
   * @internal
   */
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }
  /**
   * @internal
   */
  async call(functionName) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let overrides = arguments.length > 2 ? arguments[2] : void 0;
    let txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : void 0;
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter((f2) => f2.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn2 = functions.find((f2) => f2.name === functionName && f2.inputs.length === args.length);
    if (!fn2) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.
Expected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn2.inputs.map((i2) => i2.type).join()})`;
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn2.stateMutability === "view" || fn2.stateMutability === "pure") {
      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);
    } else {
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }
  /**
   * @internal
   */
  async sendTransaction(fn2, args, callOverrides) {
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    this.customOverrides = () => ({});
    if (this.options?.gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
      if (fn2 === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from2 = await this.getSignerAddress();
        args[0] = args[0].map((tx) => pack(["bytes", "address"], [tx, from2]));
      }
      const provider2 = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn2, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider2.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      if (!this.isValidContract) {
        const code2 = await this.getProvider().getCode(this.readContract.address);
        this.isValidContract = code2 !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn2, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);
      let receipt;
      try {
        receipt = await tx.wait();
      } catch (err) {
        try {
          await this.writeContract.callStatic[fn2](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (staticErr) {
          throw await this.formatError(staticErr, fn2, args, callOverrides);
        }
        throw await this.formatError(err, fn2, args, callOverrides);
      }
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }
  /**
   * @internal
   */
  async sendTransactionByFunction(fn2, args, callOverrides) {
    const func = this.writeContract.functions[fn2];
    if (!func) {
      throw new Error(`invalid function: "${fn2.toString()}"`);
    }
    if (!callOverrides.gasLimit) {
      try {
        callOverrides.gasLimit = await this.writeContract.estimateGas[fn2](...args, callOverrides);
      } catch (e2) {
        try {
          await this.writeContract.callStatic[fn2](...args, ...callOverrides.value ? [{
            value: callOverrides.value
          }] : []);
        } catch (err) {
          throw await this.formatError(err, fn2, args, callOverrides);
        }
      }
    }
    try {
      return await func(...args, callOverrides);
    } catch (err) {
      const from2 = await (callOverrides.from || this.getSignerAddress());
      const value = await (callOverrides.value ? callOverrides.value : 0);
      const balance = await this.getProvider().getBalance(from2);
      if (balance.eq(0) || value && balance.lt(value)) {
        throw await this.formatError(new Error("You have insufficient funds in your account to execute this transaction."), fn2, args, callOverrides);
      }
      throw await this.formatError(err, fn2, args, callOverrides);
    }
  }
  async formatError(error, fn2, args, callOverrides) {
    const provider2 = this.getProvider();
    const network = await provider2.getNetwork();
    const from2 = await (callOverrides.from || this.getSignerAddress());
    const to = this.readContract.address;
    const data = this.readContract.interface.encodeFunctionData(fn2, args);
    const value = BigNumber.from(callOverrides.value || 0);
    const rpcUrl = provider2.connection?.url;
    const functionSignature = this.readContract.interface.getFunction(fn2);
    const methodArgs = args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash2 = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.readContract.address, this.getProvider(), _classPrivateFieldGet(this, _storage));
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, _classPrivateFieldGet(this, _storage));
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from: from2,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash: hash2,
      contractName,
      sources
    }, error);
  }
  /**
   * @internal
   */
  async sendGaslessTransaction(fn2) {
    let args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : void 0;
    const signer = this.getSigner();
    invariant$1(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from2 = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = callOverrides?.value || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn2, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn2](...args);
      gas = gasEstimate.mul(2);
    } catch (e2) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from: from2,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn2.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types2, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types2, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter((x2) => x2.topics.indexOf(topic) >= 0);
    return parsedLogs.map((l2) => this.writeContract.interface.parseLog(l2));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    }
    return this.defenderSendFunction(transaction);
  }
  async biconomySendFunction(transaction) {
    invariant$1(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant$1(signer && provider2, "signer and provider must be set");
    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: AddressZero$1,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1e3 + (this.options?.gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),
      data: transaction.data
    };
    const hashToSign = arrayify(keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, keccak256$1(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature2 = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature: signature2
    });
    const response = await fetch$1("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature2],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant$1(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider2 = this.getProvider();
    invariant$1(signer, "provider is not set");
    invariant$1(provider2, "provider is not set");
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(this.getProvider(), _classPrivateFieldGet(this, _storage)) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || await computeForwarderAddress(this.getProvider(), _classPrivateFieldGet(this, _storage)));
    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types2;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types2 = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: this.options.gasless.openzeppelin.domainName,
        version: this.options.gasless.openzeppelin.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types2 = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature2;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);
      const {
        r: r2,
        s: s2,
        v: v2
      } = splitSignature(sig);
      message = {
        to: this.readContract.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r: r2,
        s: s2,
        v: v2
      };
      signature2 = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types2, message);
      signature2 = sig;
    }
    let messageType = "forward";
    if (message?.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature: signature2,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: signature2
    });
    const response = await fetch$1(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
}
function joinABIs(abis) {
  const parsedABIs = abis.map((abi) => AbiSchema.parse(abi)).flat();
  const filteredABIs = unique(parsedABIs, (a2, b2) => {
    return a2.name === b2.name && a2.type === b2.type && a2.inputs.length === b2.inputs.length;
  });
  const finalABIs = filteredABIs.filter((item) => item.type !== "constructor");
  return AbiSchema.parse(finalABIs);
}
async function getPluginABI(addresses, provider2, storage) {
  return (await Promise.all(addresses.map((address) => fetchContractMetadataFromAddress(address, provider2, storage).catch((err) => {
    console.error(`Failed to fetch plug-in for ${address}`, err);
    return {
      abi: []
    };
  })))).map((metadata) => metadata.abi);
}
async function getCompositePluginABI(address, abi, provider2, options2, storage) {
  let pluginABIs = [];
  try {
    const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), "PluginRouter");
    const isExtensionRouter = isFeatureEnabled(AbiSchema.parse(abi), "ExtensionRouter");
    if (isExtensionRouter) {
      const contract = new ContractWrapper(provider2, address, getAllExtensionsAbi, options2);
      const plugins = await contract.call("getAllExtensions");
      const pluginAddresses = plugins.map((item) => item.metadata.implementation);
      pluginABIs = await getPluginABI(pluginAddresses, provider2, storage);
    } else if (isPluginRouter) {
      const contract = new ContractWrapper(provider2, address, getAllPluginsAbi, options2);
      const pluginMap = await contract.call("getAllPlugins");
      const allPlugins = pluginMap.map((item) => item.pluginAddress);
      const plugins = Array.from(new Set(allPlugins));
      pluginABIs = await getPluginABI(plugins, provider2, storage);
    }
  } catch (err) {
  }
  return pluginABIs.length > 0 ? joinABIs([abi, ...pluginABIs]) : abi;
}
function createStorage(storage, options2) {
  if (storage) {
    return storage;
  } else if (options2?.gatewayUrls) {
    return new ThirdwebStorage({
      gatewayUrls: options2.gatewayUrls
    });
  } else {
    return new ThirdwebStorage();
  }
}
async function getPrebuiltInfo(address, provider2) {
  try {
    const contract = new Contract(address, IThirdwebContractABI, provider2);
    const [type, version2] = await Promise.all([toUtf8String(await contract.contractType()).replace(/\x00/g, ""), await contract.contractVersion()]);
    return {
      type,
      version: version2
    };
  } catch (e2) {
    return void 0;
  }
}
const roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE",
  signer: "SIGNER_ROLE"
};
const ALL_ROLES = Object.keys(roleMap);
function getRoleHash(role) {
  if (role === "admin") {
    return hexZeroPad([0], 32);
  }
  return id$2(roleMap[role]);
}
const DropErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc1155ContractDeploy = DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};
const DropErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc721ContractDeploy = DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};
const MarketplaceContractInput = CommonContractSchema;
const MarketplaceContractOutput = CommonContractOutputSchema;
const MarketplaceContractDeploy = MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
const MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};
const SplitRecipientInputSchema = z$2.object({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
});
const SplitRecipientOuputSchema = SplitRecipientInputSchema.extend({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema
});
const SplitsContractInput = CommonContractSchema.extend({
  recipients: z$2.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index2 = 0; index2 < val.length; index2++) {
      const entry = val[index2];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: z$2.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index2, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 1e4) {
        context.addIssue({
          code: z$2.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index2, `sharesBps`]
        });
      }
    }
    if (totalShares !== 1e4) {
      context.addIssue({
        code: z$2.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
});
const SplitsContractOutput = CommonContractOutputSchema.extend({
  recipients: z$2.array(SplitRecipientOuputSchema)
});
const SplitsContractDeploy = SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);
const SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};
const TokenErc1155ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const TokenErc1155ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const TokenErc1155ContractDeploy = TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};
const TokenErc20ContractInput = CommonContractSchema.merge(CommonSymbolSchema);
const TokenErc20ContractOutput = CommonContractOutputSchema.merge(CommonSymbolSchema);
const TokenErc20ContractDeploy = TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};
const TokenErc721ContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const TokenErc721ContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const TokenErc721ContractDeploy = TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};
const PackContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const PackContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const PackContractDeploy = PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);
const PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};
const VoteSettingsInputSchema = z$2.object({
  voting_delay_in_blocks: z$2.number().min(0).default(0),
  voting_period_in_blocks: z$2.number().min(1).default(1),
  voting_token_address: AddressOrEnsSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
});
const VoteSettingsOuputSchema = VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
});
const VoteContractInput = CommonContractSchema.merge(VoteSettingsInputSchema);
const VoteContractOutput = CommonContractOutputSchema.merge(VoteSettingsOuputSchema);
const VoteContractDeploy = VoteContractInput.merge(CommonTrustedForwarderSchema);
const VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
z$2.object({
  proposalId: BigNumberSchema,
  proposer: z$2.string(),
  targets: z$2.array(z$2.string()),
  values: z$2.array(BigNumberSchema),
  signatures: z$2.array(z$2.string()),
  calldatas: z$2.array(z$2.string()),
  startBlock: BigNumberSchema,
  endBlock: BigNumberSchema,
  description: z$2.string()
});
const DropErc20ContractInput = CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc20ContractOutput = CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);
const DropErc20ContractDeploy = DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);
const DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};
const MultiwrapContractInput = CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const MultiwrapContractOutput = CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);
const MultiwrapContractDeploy = MultiwrapContractInput.merge(CommonTrustedForwarderSchema);
const MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};
async function getCompositeABIfromRelease(publishMetadataUri, storage) {
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  const compositeAbi = extendedMetadata?.compositeAbi || [];
  return compositeAbi;
}
const EditionDropInitializer = {
  name: "DropERC1155",
  contractType: "edition-drop",
  schema: DropErc1155ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options2] = _ref;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([await EditionDropInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./edition-drop-9d7634c8.browser.esm-2472a631.js"), true ? ["creator/assets/edition-drop-9d7634c8.browser.esm-2472a631.js","creator/assets/erc-1155-standard-607e2724.browser.esm-5f46bd34.js","creator/assets/thirdweb-checkout-7100edf9.browser.esm-420c3924.js"] : void 0), provider2.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await __vitePreload(() => import("./DropERC1155-135dd1ec.js"), true ? [] : void 0)).default : (await __vitePreload(() => import("./DropERC1155_V2-6df808c8.js"), true ? [] : void 0)).default;
  }
};
const EditionInitializer = {
  name: "TokenERC1155",
  contractType: "edition",
  schema: TokenErc1155ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options2] = _ref2;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./edition-b8532b34.browser.esm-0f32f392.js"), true ? ["creator/assets/edition-b8532b34.browser.esm-0f32f392.js","creator/assets/erc-1155-standard-607e2724.browser.esm-5f46bd34.js"] : void 0), provider2.getNetwork()]);
    return new contract.Edition(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./TokenERC1155-d755c64c.js"), true ? [] : void 0)).default;
  }
};
const MarketplaceInitializer = {
  name: "Marketplace",
  contractType: "marketplace",
  schema: MarketplaceContractSchema,
  roles: ["admin", "lister", "asset"],
  initialize: async function() {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options2] = _ref3;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./marketplace-4eba5a7b.browser.esm-608d7ac8.js"), true ? [] : void 0), provider2.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./Marketplace-d298f9d1.js"), true ? [] : void 0)).default;
  }
};
const MarketplaceV3Initializer = {
  name: "MarketplaceV3",
  contractType: "marketplace-v3",
  schema: MarketplaceContractSchema,
  roles: ["admin", "lister", "asset"],
  initialize: async function() {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options2] = _ref4;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider2, storage), __vitePreload(() => import("./marketplacev3-de83f4c2.browser.esm-f955b252.js"), true ? [] : void 0), provider2.getNetwork()]);
    return new contract.MarketplaceV3(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const chainId = (await provider2.getNetwork()).chainId;
    const isZkSync = chainId === 280 || chainId === 324;
    if (isZkSync) {
      const uri = await fetchAndCachePublishedContractURI("MarketplaceV3");
      const compositeAbi = await getCompositeABIfromRelease(uri, storage);
      return compositeAbi;
    }
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return await getCompositePluginABI(address, abi, provider2, {}, storage);
    }
    const localAbi = (await __vitePreload(() => import("./MarketplaceV3-6fce34be.js"), true ? [] : void 0)).default;
    return await getCompositePluginABI(address, AbiSchema.parse(localAbi || []), provider2, {}, storage);
  }
};
const MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: "multiwrap",
  schema: MultiwrapContractSchema,
  roles: ["admin", "transfer", "minter", "unwrap", "asset"],
  initialize: async function() {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options2] = _ref5;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./multiwrap-cd0c9c88.browser.esm-b7195788.js"), true ? ["creator/assets/multiwrap-cd0c9c88.browser.esm-b7195788.js","creator/assets/erc-721-standard-b90faf4d.browser.esm-d2de6de7.js","creator/assets/hasERC20Allowance-59b9da80.browser.esm-ad7dc89a.js"] : void 0), provider2.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./Multiwrap-d97c968b.js"), true ? [] : void 0)).default;
  }
};
const NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: "nft-collection",
  schema: TokenErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options2] = _ref6;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./nft-collection-d29b0868.browser.esm-b260a47c.js"), true ? ["creator/assets/nft-collection-d29b0868.browser.esm-b260a47c.js","creator/assets/erc-721-standard-b90faf4d.browser.esm-d2de6de7.js"] : void 0), provider2.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./TokenERC721-1f8140f5.js"), true ? [] : void 0)).default;
  }
};
const NFTDropInitializer = {
  name: "DropERC721",
  contractType: "nft-drop",
  schema: DropErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options2] = _ref7;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./nft-drop-42222a2b.browser.esm-33ec77ae.js"), true ? ["creator/assets/nft-drop-42222a2b.browser.esm-33ec77ae.js","creator/assets/erc-721-standard-b90faf4d.browser.esm-d2de6de7.js","creator/assets/thirdweb-checkout-7100edf9.browser.esm-420c3924.js"] : void 0), provider2.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 3 ? (await __vitePreload(() => import("./DropERC721-04aee3c3.js"), true ? [] : void 0)).default : (await __vitePreload(() => import("./DropERC721_V3-c54f9ec0.js"), true ? [] : void 0)).default;
  }
};
const PackInitializer = {
  name: "Pack",
  contractType: "pack",
  schema: PackContractSchema,
  roles: ["admin", "minter", "asset", "transfer"],
  initialize: async function() {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options2] = _ref8;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./pack-0281a7de.browser.esm-c96199cd.js"), true ? ["creator/assets/pack-0281a7de.browser.esm-c96199cd.js","creator/assets/erc-1155-standard-607e2724.browser.esm-5f46bd34.js","creator/assets/hasERC20Allowance-59b9da80.browser.esm-ad7dc89a.js"] : void 0), provider2.getNetwork()]);
    return new contract.Pack(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return AbiSchema.parse((await __vitePreload(() => import("./Pack-bcbe123f.js"), true ? [] : void 0)).default || []);
  }
};
const SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: "signature-drop",
  schema: DropErc721ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options2] = _ref9;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./signature-drop-dfc8c43c.browser.esm-31818ed9.js"), true ? ["creator/assets/signature-drop-dfc8c43c.browser.esm-31818ed9.js","creator/assets/erc-721-standard-b90faf4d.browser.esm-d2de6de7.js","creator/assets/thirdweb-checkout-7100edf9.browser.esm-420c3924.js"] : void 0), provider2.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 4 ? (await __vitePreload(() => import("./SignatureDrop-4e9dda93.js"), true ? [] : void 0)).default : (await __vitePreload(() => import("./SignatureDrop_V4-9382e8cd.js"), true ? [] : void 0)).default;
  }
};
const SplitInitializer = {
  name: "Split",
  contractType: "split",
  schema: SplitsContractSchema,
  roles: ["admin"],
  initialize: async function() {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options2] = _ref10;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./split-5845ed11.browser.esm-3cacc628.js"), true ? [] : void 0), provider2.getNetwork()]);
    return new contract.Split(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./Split-635bb05c.js"), true ? [] : void 0)).default;
  }
};
const TokenDropInitializer = {
  name: "DropERC20",
  contractType: "token-drop",
  schema: DropErc20ContractSchema,
  roles: ["admin", "transfer"],
  initialize: async function() {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options2] = _ref11;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./token-drop-dc105915.browser.esm-5ed5556a.js"), true ? ["creator/assets/token-drop-dc105915.browser.esm-5ed5556a.js","creator/assets/erc-20-standard-03737e96.browser.esm-e3c39fad.js"] : void 0), provider2.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    const contractInfo = await getContractInfo(address, provider2);
    return !contractInfo || contractInfo.version > 2 ? (await __vitePreload(() => import("./DropERC20-bbeb92bd.js"), true ? [] : void 0)).default : (await __vitePreload(() => import("./DropERC20_V2-e4c5e163.js"), true ? [] : void 0)).default;
  }
};
const TokenInitializer = {
  name: "TokenERC20",
  contractType: "token",
  schema: TokenErc20ContractSchema,
  roles: ["admin", "minter", "transfer"],
  initialize: async function() {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options2] = _ref12;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./token-c250d37c.browser.esm-e76aebc7.js"), true ? ["creator/assets/token-c250d37c.browser.esm-e76aebc7.js","creator/assets/erc-20-standard-03737e96.browser.esm-e3c39fad.js"] : void 0), provider2.getNetwork()]);
    return new contract.Token(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./TokenERC20-54b2fcb1.js"), true ? [] : void 0)).default;
  }
};
const VoteInitializer = {
  name: "VoteERC20",
  contractType: "vote",
  schema: VoteContractSchema,
  roles: [],
  initialize: async function() {
    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      _ref13[_key13] = arguments[_key13];
    }
    let [network, address, storage, options2] = _ref13;
    const [, provider2] = getSignerAndProvider(network, options2);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider2, storage), __vitePreload(() => import("./vote-eabc46cc.browser.esm-6c17bda2.js"), true ? [] : void 0), provider2.getNetwork()]);
    return new contract.Vote(network, address, storage, options2, abi, _network.chainId);
  },
  getAbi: async (address, provider2, storage) => {
    const abi = await fetchAbiFromAddress(address, provider2, storage);
    if (abi) {
      return abi;
    }
    return (await __vitePreload(() => import("./VoteERC20-9d9f4457.js"), true ? [] : void 0)).default;
  }
};
async function getContractInfo(address, provider2) {
  try {
    return await getPrebuiltInfo(address, provider2);
  } catch (e2) {
    return void 0;
  }
}
const PREBUILT_CONTRACTS_MAP = {
  [EditionDropInitializer.contractType]: EditionDropInitializer,
  [EditionInitializer.contractType]: EditionInitializer,
  [MarketplaceInitializer.contractType]: MarketplaceInitializer,
  [MarketplaceV3Initializer.contractType]: MarketplaceV3Initializer,
  [MultiwrapInitializer.contractType]: MultiwrapInitializer,
  [NFTCollectionInitializer.contractType]: NFTCollectionInitializer,
  [NFTDropInitializer.contractType]: NFTDropInitializer,
  [PackInitializer.contractType]: PackInitializer,
  [SignatureDropInitializer.contractType]: SignatureDropInitializer,
  [SplitInitializer.contractType]: SplitInitializer,
  [TokenDropInitializer.contractType]: TokenDropInitializer,
  [TokenInitializer.contractType]: TokenInitializer,
  [VoteInitializer.contractType]: VoteInitializer
};
const PREBUILT_CONTRACTS_APPURI_MAP = {
  [EditionDropInitializer.contractType]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
  [EditionInitializer.contractType]: "",
  [MarketplaceInitializer.contractType]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
  [MarketplaceV3Initializer.contractType]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
  [MultiwrapInitializer.contractType]: "",
  [NFTCollectionInitializer.contractType]: "",
  [NFTDropInitializer.contractType]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [PackInitializer.contractType]: "",
  [SignatureDropInitializer.contractType]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [SplitInitializer.contractType]: "",
  [TokenDropInitializer.contractType]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
  [TokenInitializer.contractType]: "",
  [VoteInitializer.contractType]: ""
};
const SmartContract$1 = {
  name: "SmartContract",
  contractType: "custom",
  schema: {},
  roles: ALL_ROLES
};
const CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract$1.contractType]: SmartContract$1
};
function getContractTypeForRemoteName(name2) {
  return Object.values(CONTRACTS_MAP).find((contract) => contract.name === name2)?.contractType || "custom";
}
function getContractName(type) {
  return Object.values(CONTRACTS_MAP).find((contract) => contract.contractType === type)?.name;
}
function assertEnabled(namespace, feature) {
  if (!namespace) {
    throw new ExtensionNotImplementedError(feature);
  }
  return namespace;
}
function isRouterContract(abi) {
  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), "PluginRouter");
  const isExtensionRouter = isFeatureEnabled(AbiSchema.parse(abi), "ExtensionRouter");
  return isExtensionRouter || isPluginRouter;
}
class TransactionContext {
  constructor(options2) {
    _defineProperty(this, "args", void 0);
    _defineProperty(this, "overrides", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "signer", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "gasMultiple", void 0);
    this.args = options2.args;
    this.overrides = options2.overrides || {};
    this.provider = options2.provider;
    this.signer = options2.signer;
    this.storage = options2.storage || new ThirdwebStorage();
    if (!this.signer.provider) {
      this.signer = this.signer.connect(this.provider);
    }
  }
  getArgs() {
    return this.args;
  }
  getOverrides() {
    return this.overrides;
  }
  getValue() {
    return this.overrides.value || 0;
  }
  setArgs(args) {
    this.args = args;
    return this;
  }
  setOverrides(overrides) {
    this.overrides = overrides;
    return this;
  }
  updateOverrides(overrides) {
    this.overrides = {
      ...this.overrides,
      ...overrides
    };
    return this;
  }
  setValue(value) {
    this.updateOverrides({
      value
    });
    return this;
  }
  setGasLimit(gasLimit) {
    this.updateOverrides({
      gasLimit
    });
    return this;
  }
  setGasPrice(gasPrice) {
    this.updateOverrides({
      gasPrice
    });
    return this;
  }
  setNonce(nonce) {
    this.updateOverrides({
      nonce
    });
    return this;
  }
  setMaxFeePerGas(maxFeePerGas) {
    this.updateOverrides({
      maxFeePerGas
    });
    return this;
  }
  setMaxPriorityFeePerGas(maxPriorityFeePerGas) {
    this.updateOverrides({
      maxPriorityFeePerGas
    });
    return this;
  }
  setType(type) {
    this.updateOverrides({
      type
    });
    return this;
  }
  setAccessList(accessList) {
    this.updateOverrides({
      accessList
    });
    return this;
  }
  setCustomData(customData) {
    this.updateOverrides({
      customData
    });
    return this;
  }
  setCcipReadEnabled(ccipReadEnabled) {
    this.updateOverrides({
      ccipReadEnabled
    });
    return this;
  }
  /**
   * Set a multiple to multiply the gas limit by
   *
   * @example
   * ```js
   * // Set the gas limit multiple to 1.2 (increase by 20%)
   * tx.setGasLimitMultiple(1.2)
   * ```
   */
  setGasLimitMultiple(factor) {
    if (BigNumber.isBigNumber(this.overrides.gasLimit)) {
      this.overrides.gasLimit = BigNumber.from(Math.floor(BigNumber.from(this.overrides.gasLimit).toNumber() * factor));
    } else {
      this.gasMultiple = factor;
    }
  }
  /**
   * Estimate the total gas cost of this transaction (in both ether and wei)
   */
  async estimateGasCost() {
    const gasLimit = await this.estimateGasLimit();
    const gasPrice = await this.getGasPrice();
    const gasCost = gasLimit.mul(gasPrice);
    return {
      ether: formatEther(gasCost),
      wei: gasCost
    };
  }
  /**
   * Calculates the gas price for transactions (adding a 10% tip buffer)
   */
  async getGasPrice() {
    const gasPrice = await this.provider.getGasPrice();
    const maxGasPrice = parseUnits("300", "gwei");
    const extraTip = gasPrice.div(100).mul(10);
    const txGasPrice = gasPrice.add(extraTip);
    if (txGasPrice.gt(maxGasPrice)) {
      return maxGasPrice;
    }
    return txGasPrice;
  }
  /**
   * Get the address of the transaction signer
   */
  async getSignerAddress() {
    return this.signer.getAddress();
  }
  /**
   * Get gas overrides for the transaction
   */
  async getGasOverrides() {
    {
      return {};
    }
  }
  /**
   * Calculates the priority fee per gas according (adding a 10% buffer)
   */
  getPreferredPriorityFee(defaultPriorityFeePerGas) {
    const extraTip = defaultPriorityFeePerGas.div(100).mul(10);
    const txGasPrice = defaultPriorityFeePerGas.add(extraTip);
    const maxGasPrice = parseUnits("300", "gwei");
    const minGasPrice = parseUnits("2.5", "gwei");
    if (txGasPrice.gt(maxGasPrice)) {
      return maxGasPrice;
    }
    if (txGasPrice.lt(minGasPrice)) {
      return minGasPrice;
    }
    return txGasPrice;
  }
}
class Transaction extends TransactionContext {
  static fromContractWrapper(options2) {
    const signer = options2.contractWrapper.getSigner();
    if (!signer) {
      throw new Error("Cannot create a transaction without a signer. Please ensure that you have a connected signer.");
    }
    const optionsWithContract = {
      ...options2,
      contract: options2.contractWrapper.writeContract,
      provider: options2.contractWrapper.getProvider(),
      signer,
      gasless: options2.contractWrapper.options.gasless
    };
    return new Transaction(optionsWithContract);
  }
  static async fromContractInfo(options2) {
    const storage = options2.storage || new ThirdwebStorage();
    let contractAbi = options2.contractAbi;
    if (!contractAbi) {
      try {
        const metadata = await fetchContractMetadataFromAddress(options2.contractAddress, options2.provider, storage);
        contractAbi = metadata.abi;
      } catch {
        throw new Error(`Could resolve contract metadata for address ${options2.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`);
      }
    }
    const contract = new Contract(options2.contractAddress, contractAbi, options2.provider);
    const optionsWithContract = {
      ...options2,
      storage,
      contract
    };
    return new Transaction(optionsWithContract);
  }
  constructor(options2) {
    super({
      args: options2.args,
      overrides: options2.overrides,
      provider: options2.provider,
      signer: options2.signer,
      storage: options2.storage
    });
    _defineProperty(this, "method", void 0);
    _defineProperty(this, "contract", void 0);
    _defineProperty(this, "gaslessOptions", void 0);
    _defineProperty(this, "parse", void 0);
    this.method = options2.method;
    this.gaslessOptions = options2.gasless;
    this.parse = options2.parse;
    this.contract = options2.contract.connect(this.signer);
    this.storage = options2.storage || new ThirdwebStorage();
  }
  getTarget() {
    return this.contract.address;
  }
  getMethod() {
    return this.method;
  }
  getGaslessOptions() {
    return this.gaslessOptions;
  }
  setGaslessOptions(options2) {
    this.gaslessOptions = options2;
    return this;
  }
  setParse(parse2) {
    this.parse = parse2;
    return this;
  }
  /**
   * Encode the function data for this transaction
   */
  encode() {
    return this.contract.interface.encodeFunctionData(this.method, this.args);
  }
  /**
   * Get the signed transaction
   */
  async sign() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    const tx = await this.contract.populateTransaction[this.method](...this.args, overrides);
    const populatedTx = await this.contract.signer.populateTransaction(tx);
    const signedTx = await this.contract.signer.signTransaction(populatedTx);
    return signedTx;
  }
  /**
   * Simulate the transaction on-chain without executing
   */
  async simulate() {
    if (!this.contract.callStatic[this.method]) {
      throw this.functionError();
    }
    try {
      return await this.contract.callStatic[this.method](...this.args, ...this.overrides.value ? [{
        value: this.overrides.value
      }] : []);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Estimate the gas limit of this transaction
   */
  async estimateGasLimit() {
    if (!this.contract.estimateGas[this.method]) {
      throw this.functionError();
    }
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...this.args, this.overrides);
      if (this.gasMultiple) {
        return BigNumber.from(Math.floor(BigNumber.from(gasEstimate).toNumber() * this.gasMultiple));
      }
      return gasEstimate;
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction without waiting for it to be mined.
   */
  async send() {
    if (!this.contract.functions[this.method]) {
      throw this.functionError();
    }
    if (this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions)) {
      return this.sendGasless();
    }
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
      try {
        const abi = JSON.parse(this.contract.interface.format(utils$1.FormatTypes.json));
        if (isRouterContract(abi)) {
          overrides.gasLimit = overrides.gasLimit.mul(110).div(100);
        }
      } catch (err) {
        console.warn("Error raising gas limit", err);
      }
    }
    try {
      return await this.contract.functions[this.method](...this.args, overrides);
    } catch (err) {
      throw await this.transactionError(err);
    }
  }
  /**
   * Send the transaction and wait for it to be mined
   */
  async execute() {
    const tx = await this.send();
    let receipt;
    try {
      receipt = await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.transactionError(err);
    }
    if (this.parse) {
      return this.parse(receipt);
    }
    return {
      receipt
    };
  }
  /**
   * Execute the transaction with gasless
   */
  async sendGasless() {
    const tx = await this.prepareGasless();
    const txHash = await defaultGaslessSendFunction(tx, this.signer, this.provider, this.storage, this.gaslessOptions);
    let sentTx;
    let iteration = 1;
    while (!sentTx) {
      sentTx = await this.provider.getTransaction(txHash);
      if (!sentTx) {
        await new Promise((resolve) => setTimeout(resolve, Math.min(iteration * 1e3, 1e4)));
        iteration++;
      }
      if (iteration > 20) {
        throw new Error(`Unable to retrieve transaction with hash ${txHash}`);
      }
    }
    return sentTx;
  }
  async prepareGasless() {
    invariant$1(this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions), "No gasless options set on this transaction!");
    const args = [...this.args];
    if (this.method === "multicall" && Array.isArray(this.args[0]) && args[0].length > 0) {
      const from3 = await this.getSignerAddress();
      args[0] = args[0].map((tx) => pack(["bytes", "address"], [tx, from3]));
    }
    invariant$1(this.signer, "Cannot execute gasless transaction without valid signer");
    const chainId = (await this.provider.getNetwork()).chainId;
    const from2 = await (this.overrides.from || this.getSignerAddress());
    const to = this.contract.address;
    const value = this.overrides?.value || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.contract.interface.encodeFunctionData(this.method, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.contract.estimateGas[this.method](...args);
      gas = gasEstimate.mul(2);
    } catch (e2) {
    }
    if (gas.lt(1e5)) {
      gas = BigNumber.from(5e5);
    }
    if (this.overrides.gasLimit && BigNumber.from(this.overrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(this.overrides.gasLimit);
    }
    return {
      from: from2,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: this.method,
      functionArgs: args,
      callOverrides: this.overrides
    };
  }
  functionError() {
    return new Error(`Contract "${this.contract.address}" does not have function "${this.method}"`);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async transactionError(error) {
    const provider2 = this.provider;
    const network = await provider2.getNetwork();
    const from2 = await (this.overrides.from || this.getSignerAddress());
    const to = this.contract.address;
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = provider2.connection?.url;
    const functionSignature = this.contract.interface.getFunction(this.method);
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash2 = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;
    const reason = parseRevertReason(error);
    let sources = void 0;
    let contractName = void 0;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.contract.address, this.provider, this.storage);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
    }
    return new TransactionError({
      reason,
      from: from2,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash: hash2,
      contractName,
      sources
    }, error);
  }
}
class DeployTransaction extends TransactionContext {
  constructor(options2) {
    super(options2);
    _defineProperty(this, "factory", void 0);
    _defineProperty(this, "events", void 0);
    this.factory = options2.factory;
    this.events = options2.events;
  }
  encode() {
    return hexlify(concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]));
  }
  getTarget() {
    return AddressZero$1;
  }
  getMethod() {
    return "deploy";
  }
  async sign() {
    const populatedTx = await this.populateTransaction();
    return this.signer.signTransaction(populatedTx);
  }
  async simulate() {
    const populatedTx = await this.populateTransaction();
    return this.signer.call(populatedTx);
  }
  async estimateGasLimit() {
    try {
      const gasOverrides = await this.getGasOverrides();
      const overrides = {
        ...gasOverrides,
        ...this.overrides
      };
      const populatedTx = this.factory.getDeployTransaction(...this.args, overrides);
      return this.signer.estimateGas(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async send() {
    try {
      const populatedTx = await this.populateTransaction();
      return await this.signer.sendTransaction(populatedTx);
    } catch (err) {
      throw await this.deployError(err);
    }
  }
  async execute() {
    const tx = await this.send();
    try {
      await tx.wait();
    } catch (err) {
      await this.simulate();
      throw await this.deployError(err);
    }
    const contractAddress = getContractAddress({
      from: tx.from,
      nonce: tx.nonce
    });
    if (this.events) {
      this.events.emit("contractDeployed", {
        status: "completed",
        contractAddress,
        transactionHash: tx.hash
      });
    }
    return contractAddress;
  }
  async populateTransaction() {
    const gasOverrides = await this.getGasOverrides();
    const overrides = {
      ...gasOverrides,
      ...this.overrides
    };
    if (!overrides.gasLimit) {
      overrides.gasLimit = await this.estimateGasLimit();
    }
    return this.factory.getDeployTransaction(...this.args, overrides);
  }
  /**
   * Create a nicely formatted error message with tx metadata and solidity stack trace
   */
  async deployError(error) {
    const provider2 = this.provider;
    const network = await provider2.getNetwork();
    const from2 = await (this.overrides.from || this.getSignerAddress());
    const data = this.encode();
    const value = BigNumber.from(this.overrides.value || 0);
    const rpcUrl = provider2.connection?.url;
    const methodArgs = this.args.map((arg) => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, void 0, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map((arg) => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `deployContract(${joinedArgs})`;
    const hash2 = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;
    const reason = parseRevertReason(error);
    return new TransactionError({
      reason,
      from: from2,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash: hash2
    }, error);
  }
}
async function defaultGaslessSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  if (gaslessOptions && "biconomy" in gaslessOptions) {
    return biconomySendFunction(transaction, signer, provider2, gaslessOptions);
  }
  return defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions);
}
async function biconomySendFunction(transaction, signer, provider2, gaslessOptions) {
  const request = await biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions);
  const response = await fetch$1("https://api.biconomy.io/api/v2/meta-tx/native", request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.txHash) {
      throw new Error(`relay transaction failed: ${resp.log}`);
    }
    return resp.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function defenderSendFunction(transaction, signer, provider2, storage, gaslessOptions) {
  invariant$1(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  const request = await defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions);
  const response = await fetch$1(gaslessOptions.openzeppelin.relayerUrl, request);
  if (response.ok) {
    const resp = await response.json();
    if (!resp.result) {
      throw new Error(`Relay transaction failed: ${resp.message}`);
    }
    const result = JSON.parse(resp.result);
    return result.txHash;
  }
  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
}
async function defenderPrepareRequest(transaction, signer, provider2, storage, gaslessOptions) {
  invariant$1(gaslessOptions && "openzeppelin" in gaslessOptions, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
  invariant$1(signer, "provider is not set");
  invariant$1(provider2, "provider is not set");
  const forwarderAddress = gaslessOptions.openzeppelin.relayerForwarderAddress || (gaslessOptions.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(provider2, storage) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || await computeForwarderAddress(provider2, storage));
  const forwarder = new Contract(forwarderAddress, ForwarderABI, provider2);
  const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
  let domain;
  let types2;
  let message;
  if (gaslessOptions.experimentalChainlessSupport) {
    domain = {
      name: "GSNv2 Forwarder",
      version: "0.0.1",
      verifyingContract: forwarderAddress
    };
    types2 = {
      ForwardRequest: ChainAwareForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data,
      chainid: BigNumber.from(transaction.chainId).toString()
    };
  } else {
    domain = {
      name: gaslessOptions.openzeppelin.domainName,
      version: gaslessOptions.openzeppelin.domainVersion,
      chainId: transaction.chainId,
      verifyingContract: forwarderAddress
    };
    types2 = {
      ForwardRequest
    };
    message = {
      from: transaction.from,
      to: transaction.to,
      value: BigNumber.from(0).toString(),
      gas: BigNumber.from(transaction.gasLimit).toString(),
      nonce: BigNumber.from(nonce).toString(),
      data: transaction.data
    };
  }
  let signature2;
  if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
    const spender = transaction.functionArgs[0];
    const amount = transaction.functionArgs[1];
    const {
      message: permit,
      signature: sig
    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);
    const {
      r: r2,
      s: s2,
      v: v2
    } = splitSignature(sig);
    message = {
      to: transaction.to,
      owner: permit.owner,
      spender: permit.spender,
      value: BigNumber.from(permit.value).toString(),
      nonce: BigNumber.from(permit.nonce).toString(),
      deadline: BigNumber.from(permit.deadline).toString(),
      r: r2,
      s: s2,
      v: v2
    };
    signature2 = sig;
  } else {
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types2, message);
    signature2 = sig;
  }
  let messageType = "forward";
  if (message?.owner) {
    messageType = "permit";
  }
  return {
    method: "POST",
    body: JSON.stringify({
      request: message,
      signature: signature2,
      forwarderAddress,
      type: messageType
    })
  };
}
async function biconomyPrepareRequest(transaction, signer, provider2, gaslessOptions) {
  invariant$1(gaslessOptions && "biconomy" in gaslessOptions, "calling biconomySendFunction without biconomy");
  invariant$1(signer && provider2, "signer and provider must be set");
  const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider2);
  const batchId = 0;
  const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
  const request = {
    from: transaction.from,
    to: transaction.to,
    token: AddressZero$1,
    txGas: transaction.gasLimit.toNumber(),
    tokenGasPrice: "0",
    batchId,
    batchNonce: batchNonce.toNumber(),
    deadline: Math.floor(Date.now() / 1e3 + (gaslessOptions && "biconomy" in gaslessOptions && gaslessOptions.biconomy?.deadlineSeconds || 3600)),
    data: transaction.data
  };
  const hashToSign = arrayify(keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, keccak256$1(request.data)]));
  const signature2 = await signer.signMessage(hashToSign);
  return {
    method: "POST",
    body: JSON.stringify({
      from: transaction.from,
      apiId: gaslessOptions.biconomy.apiId,
      params: [request, signature2],
      to: transaction.to,
      gasLimit: transaction.gasLimit.toHexString()
    }),
    headers: {
      "x-api-key": gaslessOptions.biconomy.apiKey,
      "Content-Type": "application/json;charset=utf-8"
    }
  };
}
function buildDeployTransactionFunction(fn2) {
  async function executeFn() {
    const tx = await fn2(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn2;
  return executeFn;
}
function buildTransactionFunction(fn2) {
  async function executeFn() {
    const tx = await fn2(...arguments);
    return tx.execute();
  }
  executeFn.prepare = fn2;
  return executeFn;
}
class ContractAppURI {
  constructor(contractWrapper, metadata, storage) {
    _defineProperty(this, "featureName", FEATURE_APPURI.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async (appURI) => {
      if (detectContractFeature(this.contractWrapper, "AppURI")) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAppURI",
          args: [appURI]
        });
      }
      return await this.metadata.update.prepare({
        app_uri: appURI
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
    this.storage = storage;
  }
  /**
   * Get App URI
   * @returns the appURI (typically an IPFS hash)
   * @example
   * ```javascript
   * const appURI = await contract.app.get();
   * console.log(appURI) // "ipfs://some_ipfs_hash";
   * ```
   * @twfeature AppURI
   */
  async get() {
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return await this.contractWrapper.readContract.appURI();
    }
    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || "", this.storage.gatewayUrls);
  }
}
class ContractEvents {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  /**
   * Subscribe to transactions in this contract.
   * @remarks Will emit an "event" object containing the transaction status ('submitted' and 'completed') and hash
   * @example
   * ```javascript
   * contract.events.addTransactionListener((event) => {
   *   console.log(event);
   * }
   * ```
   * @param listener - the callback function that will be called on every transaction
   * @public
   */
  addTransactionListener(listener) {
    this.contractWrapper.addListener(EventType.Transaction, listener);
  }
  /**
   * Remove a transaction listener
   * @remarks Remove a listener that was added with addTransactionListener
   * @example
   * ```javascript
   * contract.events.removeTransactionListener((event) => {
   *  console.log(event);
   * }
   * ```
   * @param listener - the callback function to remove
   * @public
   */
  removeTransactionListener(listener) {
    this.contractWrapper.off(EventType.Transaction, listener);
  }
  /**
   * Subscribe to contract events
   * @remarks You can add a listener for any contract event to run a function when
   * the event is emitted. For example, if you wanted to listen for a "TokensMinted" event,
   * you could do the following:
   * @example
   * ```javascript
   * contract.events.addEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the callback function that will be called on every new event
   * @returns a function to un-subscribe from the event
   */
  addEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const address = this.contractWrapper.readContract.address;
    const filter3 = {
      address,
      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]
    };
    const wrappedListener = (log) => {
      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
    };
    this.contractWrapper.getProvider().on(filter3, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter3, wrappedListener);
    };
  }
  /**
   * Listen to all events emitted from this contract
   *
   * @example
   * ```javascript
   * contract.events.listenToAllEvents((event) => {
   *   console.log(event.eventName) // the name of the emitted event
   *   console.log(event.data) // event payload
   * }
   * ```
   * @public
   * @param listener - the callback function that will be called on every new event
   * @returns A function that can be called to stop listening to events
   */
  listenToAllEvents(listener) {
    const address = this.contractWrapper.readContract.address;
    const filter3 = {
      address
    };
    const wrappedListener = (log) => {
      try {
        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
      } catch (e2) {
        console.error("Could not parse event:", log, e2);
      }
    };
    this.contractWrapper.getProvider().on(filter3, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter3, wrappedListener);
    };
  }
  /**
   * Remove an event listener from this contract
   * @remarks Remove a listener that was added with addEventListener
   * @example
   * ```javascript
   * contract.events.removeEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the listener to unregister
   */
  removeEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    this.contractWrapper.readContract.off(event.name, listener);
  }
  /**
   * Remove all listeners on this contract
   * @remarks Remove all listeners from a contract
   * @example
   * ```javascript
   * contract.events.removeAllListeners();
   * ```
   * @public
   */
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const address = this.contractWrapper.readContract.address;
    const filter3 = {
      address
    };
    this.contractWrapper.getProvider().removeAllListeners(filter3);
  }
  /**
   * Get All Events
   * @remarks Get a list of all the events emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // Optionally pass in filters to limit the blocks from which events are retrieved
   * const filters = {
   *   fromBlock: 0,
   *   toBlock: 1000000,
   * }
   * const events = await contract.events.getAllEvents(filters);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks
   * @returns The event objects of the events emitted with event names and data for each event
   */
  async getAllEvents() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a2, b2) => {
      return filters.order === "desc" ? b2.blockNumber - a2.blockNumber : a2.blockNumber - b2.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  /**
   * Get Events
   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // The name of the event to get logs for
   * const eventName = "Transfer";
   *
   * // Optionally pass in options to limit the blocks from which events are retrieved
   * const options = {
   *   fromBlock: 0,
   *   toBlock: 1000000, // can also pass "latest"
   *   order: "desc",
   *   // Configure event filters (filter on indexed event parameters)
   *   filters: {
   *     from: "0x...",
   *     to: "0x..."
   *   }
   * };
   *
   * const events = await contract.events.getEvents(eventName, options);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param eventName - The name of the event to get logs for
   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions
   * @returns The requested event objects with event data
   */
  async getEvents(eventName) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);
    const args = options2.filters ? eventInterface.inputs.map((e2) => options2.filters[e2.name]) : [];
    const filter3 = this.contractWrapper.readContract.filters[event.name](...args);
    const events = await this.contractWrapper.readContract.queryFilter(filter3, options2.fromBlock, options2.toBlock);
    const orderedEvents = events.sort((a2, b2) => {
      return options2.order === "desc" ? b2.blockNumber - a2.blockNumber : a2.blockNumber - b2.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  parseEvents(events) {
    return events.map((e2) => {
      const transaction = Object.fromEntries(Object.entries(e2).filter((a2) => typeof a2[1] !== "function" && a2[0] !== "args"));
      if (e2.args) {
        const entries = Object.entries(e2.args);
        const args = entries.slice(entries.length / 2, entries.length);
        const data = {};
        for (const [key2, value] of args) {
          data[key2] = value;
        }
        return {
          eventName: e2.event || "",
          data,
          transaction
        };
      }
      return {
        eventName: e2.event || "",
        data: {},
        transaction
      };
    });
  }
  toContractEvent(event, args, rawLog) {
    const transaction = Object.fromEntries(Object.entries(rawLog).filter((a2) => typeof a2[1] !== "function" && a2[0] !== "args"));
    const results2 = {};
    event.inputs.forEach((param, index2) => {
      if (Array.isArray(args[index2])) {
        const components2 = param.components;
        if (components2) {
          const arr = args[index2];
          if (param.type === "tuple[]") {
            const objArray = [];
            for (let i2 = 0; i2 < arr.length; i2++) {
              const tuple = arr[i2];
              const obj = {};
              for (let j = 0; j < components2.length; j++) {
                const name2 = components2[j].name;
                obj[name2] = tuple[j];
              }
              objArray.push(obj);
            }
            results2[param.name] = objArray;
          } else {
            const obj = {};
            for (let i2 = 0; i2 < components2.length; i2++) {
              const name2 = components2[i2].name;
              obj[name2] = arr[i2];
            }
            results2[param.name] = obj;
          }
        }
      } else {
        results2[param.name] = args[index2];
      }
    });
    return {
      eventName: event.name,
      data: results2,
      transaction
    };
  }
}
class ContractInterceptor {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  /**
   * The next transaction executed will add/replace any overrides passed via the passed in hook.
   * @remarks Overridden values will be applied to the next transaction executed.
   * @example
   * ```javascript
   * contract.interceptor.overrideNextTransaction(() => ({
   *   gasLimit: 3000000,
   * }));
   * ```
   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)
   * @public
   */
  overrideNextTransaction(hook) {
    this.contractWrapper.withTransactionOverride(hook);
  }
}
class ContractPlatformFee {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_PLATFORM_FEE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async (platformFeeInfo) => {
      const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setPlatformFeeInfo",
        args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the platform fee recipient and basis points
   *
   * @example
   * ```javascript
   * const feeInfo = await contract.platformFee.get();
   * console.log(feeInfo.platform_fee_recipient);
   * console.log(feeInfo.platform_fee_basis_points);
   * ```
   * @twfeature PlatformFee
   */
  async get() {
    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.readContract.getPlatformFeeInfo();
    return CommonPlatformFeeSchema.parseAsync({
      platform_fee_recipient: platformFeeRecipient,
      platform_fee_basis_points: platformFeeBps
    });
  }
}
function extractEventsFromAbi(abi, metadata) {
  const parsedAbi = AbiSchema.parse(abi || []);
  const events = parsedAbi.filter((el2) => el2.type === "event");
  const parsed = [];
  for (const e2 of events) {
    const doc = extractCommentFromMetadata(e2.name, metadata, "events");
    parsed.push({
      inputs: e2.inputs || [],
      outputs: e2.outputs || [],
      name: e2.name || "unknown",
      comment: doc
    });
  }
  return parsed;
}
class ContractPublishedMetadata {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_cachedMetadata", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Get the published metadata for this contract
   * @public
   */
  async get() {
    if (this._cachedMetadata) {
      return this._cachedMetadata;
    }
    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
    return this._cachedMetadata;
  }
  /**
   * @public
   */
  async extractFunctions() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e2) {
    }
    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);
  }
  /**
   * @public
   */
  async extractEvents() {
    let publishedMetadata;
    try {
      publishedMetadata = await this.get();
    } catch (e2) {
    }
    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);
  }
}
class ContractRoles {
  /**
   * @internal
   * @remarks This is used for typing inside react hooks which is why it has to be public.
   */
  constructor(contractWrapper, _roles) {
    _defineProperty(this, "featureName", FEATURE_PERMISSIONS.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "roles", void 0);
    _defineProperty(this, "setAll", buildTransactionFunction(async (rolesWithAddresses) => {
      const roles = Object.keys(rolesWithAddresses);
      invariant$1(roles.length, "you must provide at least one role to set");
      invariant$1(roles.every((role) => this.roles.includes(role)), "this contract does not support the given role");
      const currentRoles = await this.getAll();
      const encoded = [];
      const sortedRoles = roles.sort((role) => role === "admin" ? 1 : -1);
      for (let i2 = 0; i2 < sortedRoles.length; i2++) {
        const role = sortedRoles[i2];
        const addresses = await Promise.all(rolesWithAddresses[role]?.map(async (addressOrEns) => await resolveAddress(addressOrEns)) || []);
        const currentAddresses = await Promise.all(currentRoles[role]?.map(async (addressOrEns) => await resolveAddress(addressOrEns)) || []);
        const toAdd = addresses.filter((address) => !currentAddresses.includes(address));
        const toRemove = currentAddresses.filter((address) => !addresses.includes(address));
        if (toAdd.length) {
          toAdd.forEach((address) => {
            encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("grantRole", [getRoleHash(role), address]));
          });
        }
        if (toRemove.length) {
          for (let j = 0; j < toRemove.length; j++) {
            const address = toRemove[j];
            const revokeFunctionName = await this.getRevokeRoleFunctionName(address);
            encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData(revokeFunctionName, [getRoleHash(role), address]));
          }
        }
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "grant", buildTransactionFunction(async (role, address) => {
      invariant$1(this.roles.includes(role), `this contract does not support the "${role}" role`);
      const resolvedAddress = await resolveAddress(address);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "grantRole",
        args: [getRoleHash(role), resolvedAddress]
      });
    }));
    _defineProperty(this, "revoke", buildTransactionFunction(async (role, address) => {
      invariant$1(this.roles.includes(role), `this contract does not support the "${role}" role`);
      const resolvedAddress = await resolveAddress(address);
      const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: revokeFunctionName,
        args: [getRoleHash(role), resolvedAddress]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.roles = _roles;
  }
  /** **************************
   * READ FUNCTIONS
   ****************************/
  /**
   * Get all members of all roles
   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.
   * @example
   * ```javascript
   * const rolesAndMembers = await contract.roles.getAll();
   * ```
   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.
   * @throws If the contract does not support roles this will throw an error.
   *
   * @public
   * @twfeature PermissionsEnumerable
   */
  async getAll() {
    invariant$1(this.roles.length, "this contract has no support for roles");
    const roles = {};
    for (const role of this.roles) {
      roles[role] = await this.get(role);
    }
    return roles;
  }
  /**
   * Get all members of a specific role
   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.
   * @param role - The Role to to get a memberlist for.
   * @returns The list of addresses that are members of the specific role.
   * @throws If you are requesting a role that does not exist on the contract this will throw an error.
   *
   * @example Say you want to get the list of addresses that are members of the minter role.
   * ```javascript
   * const minterAddresses = await contract.roles.get("minter");
   * ```
   *
   * @public
   * @twfeature Permissions
   */
  async get(role) {
    invariant$1(this.roles.includes(role), `this contract does not support the "${role}" role`);
    const wrapper = this.contractWrapper;
    if (hasFunction("getRoleMemberCount", wrapper) && hasFunction("getRoleMember", wrapper)) {
      const roleHash = getRoleHash(role);
      const count = (await wrapper.readContract.getRoleMemberCount(roleHash)).toNumber();
      return await Promise.all(Array.from(Array(count).keys()).map((i2) => wrapper.readContract.getRoleMember(roleHash, i2)));
    }
    throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.");
  }
  /**
   * Throws an error if an address is missing the roles specified.
   *
   * @param roles - The roles to check
   * @param address - The address to check
   *
   * @internal
   */
  async verify(roles, address) {
    await Promise.all(roles.map(async (role) => {
      const members = await this.get(role);
      const resolvedAddress = await resolveAddress(address);
      if (!members.map((a2) => a2.toLowerCase()).includes(resolvedAddress.toLowerCase())) {
        throw new MissingRoleError(resolvedAddress, role);
      }
    }));
  }
  /** **************************
   * PRIVATE FUNCTIONS
   ****************************/
  async getRevokeRoleFunctionName(address) {
    const resolvedAddress = await resolveAddress(address);
    const signerAddress = await this.contractWrapper.getSignerAddress();
    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {
      return "renounceRole";
    }
    return "revokeRole";
  }
}
class ContractRoyalty {
  constructor(contractWrapper, metadata) {
    _defineProperty(this, "featureName", FEATURE_ROYALTY.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "setDefaultRoyaltyInfo", buildTransactionFunction(async (royaltyData) => {
      const oldMetadata = await this.metadata.get();
      const mergedMetadata = await this.metadata.parseInputMetadata({
        ...oldMetadata,
        ...royaltyData
      });
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        const encoded = [this.contractWrapper.readContract.interface.encodeFunctionData("setDefaultRoyaltyInfo", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI])];
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => ({
            receipt,
            data: () => this.getDefaultRoyaltyInfo()
          })
        });
      } else {
        throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
      }
    }));
    _defineProperty(this, "setTokenRoyaltyInfo", buildTransactionFunction(async (tokenId, royaltyData) => {
      const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setRoyaltyInfoForToken",
        args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],
        parse: (receipt) => ({
          receipt,
          data: () => this.getDefaultRoyaltyInfo()
        })
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  /**
   * Get the royalty recipient and fee
   * @returns - The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */
  async getDefaultRoyaltyInfo() {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getDefaultRoyaltyInfo();
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  /**
   * Get the royalty recipient and fee of a particular token
   * @returns - The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */
  async getTokenRoyaltyInfo(tokenId) {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.readContract.getRoyaltyInfoForToken(tokenId);
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
}
class ContractPrimarySale {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_PRIMARY_SALE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "setRecipient", buildTransactionFunction(async (recipient) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setPrimarySaleRecipient",
        args: [recipient]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the primary sale recipient
   * @returns the wallet address.
   * @example
   * ```javascript
   * const salesRecipient = await contract.sales.getRecipient();
   * ```
   * @public
   * @twfeature PrimarySale
   */
  async getRecipient() {
    return await this.contractWrapper.readContract.primarySaleRecipient();
  }
}
function isNativeToken(tokenAddress) {
  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === AddressZero$1;
}
async function fetchCurrencyMetadata(provider2, asset) {
  if (isNativeToken(asset)) {
    const network = await provider2.getNetwork();
    const nativeToken = getNativeTokenByChainId(network.chainId);
    return {
      name: nativeToken.name,
      symbol: nativeToken.symbol,
      decimals: nativeToken.decimals
    };
  } else {
    const erc20 = new Contract(asset, ERC20MetadataAbi, provider2);
    const [name2, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);
    return {
      name: name2,
      symbol,
      decimals
    };
  }
}
async function fetchCurrencyValue(providerOrSigner, asset, price) {
  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);
  return {
    ...metadata,
    value: BigNumber.from(price),
    displayValue: formatUnits(price, metadata.decimals)
  };
}
async function normalizePriceValue(provider2, inputPrice, currencyAddress) {
  const metadata = await fetchCurrencyMetadata(provider2, currencyAddress);
  return parseUnits(AmountSchema.parse(inputPrice), metadata.decimals);
}
async function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {
  if (isNativeToken(currencyAddress)) {
    overrides["value"] = value;
  } else {
    const signer = contractToApprove.getSigner();
    const provider2 = contractToApprove.getProvider();
    const erc20 = new ContractWrapper(signer || provider2, currencyAddress, ERC20Abi, contractToApprove.options);
    const owner = await contractToApprove.getSignerAddress();
    const spender = contractToApprove.readContract.address;
    const allowance = await erc20.readContract.allowance(owner, spender);
    if (allowance.lt(value)) {
      await erc20.sendTransaction("approve", [spender, value]);
    }
    return overrides;
  }
}
function convertQuantityToBigNumber(quantity, tokenDecimals) {
  if (quantity === "unlimited") {
    return MaxUint256$1;
  } else {
    return parseUnits(quantity, tokenDecimals);
  }
}
async function parseSnapshotInputs(inputs) {
  const chunkSize = 25e3;
  const chunks = Array.from({
    length: Math.ceil(inputs.length / chunkSize)
  }, (_, i2) => inputs.slice(i2 * chunkSize, i2 * chunkSize + chunkSize));
  const results2 = [];
  for (const chunk of chunks) {
    results2.push(...await SnapshotInputSchema.parseAsync(chunk));
  }
  return results2;
}
const SHARD_NYBBLES = 2;
let SnapshotFormatVersion = /* @__PURE__ */ function(SnapshotFormatVersion2) {
  SnapshotFormatVersion2[SnapshotFormatVersion2["V1"] = 1] = "V1";
  SnapshotFormatVersion2[SnapshotFormatVersion2["V2"] = 2] = "V2";
  return SnapshotFormatVersion2;
}({});
class ShardedMerkleTree {
  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {
    _defineProperty(this, "shardNybbles", void 0);
    _defineProperty(this, "shards", void 0);
    _defineProperty(this, "trees", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "baseUri", void 0);
    _defineProperty(this, "originalEntriesUri", void 0);
    _defineProperty(this, "tokenDecimals", void 0);
    this.storage = storage;
    this.shardNybbles = shardNybbles;
    this.baseUri = baseUri;
    this.originalEntriesUri = originalEntriesUri;
    this.tokenDecimals = tokenDecimals;
    this.shards = {};
    this.trees = {};
  }
  static async fromUri(uri, storage) {
    try {
      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);
      if (shardedMerkleTreeInfo.isShardedMerkleTree) {
        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);
      }
    } catch (e2) {
      return void 0;
    }
  }
  static async fromShardedMerkleTreeInfo(info, storage) {
    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);
  }
  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {
    switch (snapshotFormatVersion) {
      case SnapshotFormatVersion.V1:
        return keccak256(["address", "uint256"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);
      case SnapshotFormatVersion.V2:
        return keccak256(["address", "uint256", "uint256", "address"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || "unlimited", currencyDecimals), entry.currencyAddress || AddressZero$1]);
    }
  }
  static async fetchAndCacheDecimals(cache, provider2, currencyAddress) {
    if (!currencyAddress) {
      return 18;
    }
    let currencyDecimals = cache[currencyAddress];
    if (currencyDecimals === void 0) {
      const currencyMetadata = await fetchCurrencyMetadata(provider2, currencyAddress);
      currencyDecimals = currencyMetadata.decimals;
      cache[currencyAddress] = currencyDecimals;
    }
    return currencyDecimals;
  }
  static async buildAndUpload(snapshotInput, tokenDecimals, provider2, storage, snapshotFormatVersion) {
    let shardNybbles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : SHARD_NYBBLES;
    const inputs = await parseSnapshotInputs(snapshotInput);
    const shards = {};
    for (const snapshotEntry of inputs) {
      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
      if (shards[shard] === void 0) {
        shards[shard] = [];
      }
      shards[shard].push(snapshotEntry);
    }
    const currencyDecimalMap = {};
    const subTrees = await Promise.all(Object.entries(shards).map(async (_ref) => {
      let [shard, entries] = _ref;
      return [shard, new dist.MerkleTree(await Promise.all(entries.map(async (entry) => {
        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry.currencyAddress);
        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);
      })), keccak256$1, {
        sort: true
      }).getHexRoot()];
    }));
    const roots2 = Object.fromEntries(subTrees);
    const tree = new dist.MerkleTree(Object.values(roots2), keccak256$1, {
      sort: true
    });
    const shardsToUpload = [];
    for (const [shardId, entries] of Object.entries(shards)) {
      const data = {
        proofs: tree.getProof(roots2[shardId]).map((value) => "0x" + value.data.toString("hex")),
        entries
      };
      shardsToUpload.push({
        data: JSON.stringify(data),
        name: `${shardId}.json`
      });
    }
    const uris = await storage.uploadBatch(shardsToUpload);
    const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
    const originalEntriesUri = await storage.upload(inputs);
    const shardedMerkleInfo = {
      merkleRoot: tree.getHexRoot(),
      baseUri,
      originalEntriesUri,
      shardNybbles,
      tokenDecimals,
      isShardedMerkleTree: true
    };
    const masterUri = await storage.upload(shardedMerkleInfo);
    return {
      shardedMerkleInfo,
      uri: masterUri
    };
  }
  async getProof(address, provider2, snapshotFormatVersion) {
    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();
    let shard = this.shards[shardId];
    const currencyDecimalMap = {};
    if (shard === void 0) {
      try {
        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);
        const hashedEntries = await Promise.all(shard.entries.map(async (entry2) => {
          const currencyDecimals2 = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry2.currencyAddress);
          return ShardedMerkleTree.hashEntry(entry2, this.tokenDecimals, currencyDecimals2, snapshotFormatVersion);
        }));
        this.trees[shardId] = new dist.MerkleTree(hashedEntries, keccak256$1, {
          sort: true
        });
      } catch (e2) {
        return null;
      }
    }
    const entry = shard.entries.find((i2) => i2.address.toLowerCase() === address.toLowerCase());
    if (!entry) {
      return null;
    }
    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider2, entry.currencyAddress);
    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
    const proof = this.trees[shardId].getProof(leaf).map((i2) => "0x" + i2.data.toString("hex"));
    return SnapshotEntryWithProofSchema.parseAsync({
      ...entry,
      proof: proof.concat(shard.proofs)
    });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e2) {
      console.warn("Could not fetch original snapshot entries", e2);
      return [];
    }
  }
}
let Status = /* @__PURE__ */ function(Status2) {
  Status2[Status2["UNSET"] = 0] = "UNSET";
  Status2[Status2["Created"] = 1] = "Created";
  Status2[Status2["Completed"] = 2] = "Completed";
  Status2[Status2["Cancelled"] = 3] = "Cancelled";
  Status2[Status2["Active"] = 4] = "Active";
  Status2[Status2["Expired"] = 5] = "Expired";
  return Status2;
}({});
let ClaimEligibility = /* @__PURE__ */ function(ClaimEligibility2) {
  ClaimEligibility2["NotEnoughSupply"] = "There is not enough supply to claim.";
  ClaimEligibility2["AddressNotAllowed"] = "This address is not on the allowlist.";
  ClaimEligibility2["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
  ClaimEligibility2["AlreadyClaimed"] = "You have already claimed the token.";
  ClaimEligibility2["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
  ClaimEligibility2["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
  ClaimEligibility2["NoClaimConditionSet"] = "There is no claim condition set.";
  ClaimEligibility2["NoWallet"] = "No wallet connected.";
  ClaimEligibility2["Unknown"] = "No claim conditions found.";
  return ClaimEligibility2;
}({});
async function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider2, storage, snapshotFormatVersion) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw2 = await storage.downloadJSON(snapshotUri);
    if (raw2.isShardedMerkleTree && raw2.merkleRoot === merkleRoot) {
      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw2, storage);
      return await merkleTree.getProof(address, provider2, snapshotFormatVersion);
    }
    const snapshotData = await SnapshotSchema.parseAsync(raw2);
    if (merkleRoot === snapshotData.merkleRoot) {
      return snapshotData.claims.find((c2) => c2.address.toLowerCase() === address.toLowerCase()) || null;
    }
  }
  return null;
}
function abstractContractModelToLegacy(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerTransaction: model.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0
  };
}
function abstractContractModelToNew(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot,
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    quantityLimitPerWallet: model.maxClaimablePerWallet,
    metadata: model.metadata || ""
  };
}
function legacyContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims
  };
}
function newContractModelToAbstract(model) {
  return {
    startTimestamp: model.startTimestamp,
    maxClaimableSupply: model.maxClaimableSupply,
    supplyClaimed: model.supplyClaimed,
    merkleRoot: model.merkleRoot.toString(),
    pricePerToken: model.pricePerToken,
    currency: model.currency,
    maxClaimablePerWallet: model.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: model.metadata
  };
}
async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
  const signer = contractToApprove.getSigner();
  const provider2 = contractToApprove.getProvider();
  const erc20 = new ContractWrapper(signer || provider2, currencyAddress, ERC20Abi, contractToApprove.options);
  const owner = await contractToApprove.getSignerAddress();
  const spender = contractToApprove.readContract.address;
  const allowance = await erc20.readContract.allowance(owner, spender);
  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(parseUnits("1", tokenDecimals));
  if (allowance.lt(totalPrice)) {
    await erc20.sendTransaction("approve", [spender, allowance.add(totalPrice)]);
  }
}
async function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {
  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);
  let proofs = [hexZeroPad([0], 32)];
  let priceInProof = activeClaimCondition.price;
  let currencyAddressInProof = activeClaimCondition.currencyAddress;
  try {
    if (!activeClaimCondition.merkleRootHash.toString().startsWith(AddressZero$1)) {
      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);
      if (snapshotEntry) {
        proofs = snapshotEntry.proof;
        maxClaimable = snapshotEntry.maxClaimable === "unlimited" ? MaxUint256$1 : parseUnits(snapshotEntry.maxClaimable, tokenDecimals);
        priceInProof = snapshotEntry.price === void 0 || snapshotEntry.price === "unlimited" ? MaxUint256$1 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || AddressZero$1);
        currencyAddressInProof = snapshotEntry.currencyAddress || AddressZero$1;
      } else {
        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {
          throw new Error("No claim found for this address");
        }
      }
    }
  } catch (e2) {
    if (e2?.message === "No claim found for this address") {
      throw e2;
    }
    console.warn("failed to check claim condition merkle root hash, continuing anyways", e2);
  }
  const overrides = await contractWrapper.getCallOverrides() || {};
  const pricePerToken = priceInProof.toString() !== MaxUint256$1.toString() ? priceInProof : activeClaimCondition.price;
  const currencyAddress = currencyAddressInProof !== AddressZero$1 ? currencyAddressInProof : activeClaimCondition.currencyAddress;
  if (pricePerToken.gt(0)) {
    if (isNativeToken(currencyAddress)) {
      overrides["value"] = BigNumber.from(pricePerToken).mul(quantity).div(parseUnits("1", tokenDecimals));
    } else if (checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);
    }
  }
  return {
    overrides,
    proofs,
    maxClaimable,
    price: pricePerToken,
    currencyAddress,
    priceInProof,
    currencyAddressInProof
  };
}
async function createSnapshot(snapshotInput, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const input = await parseSnapshotInputs(snapshotInput);
  const addresses = input.map((i2) => i2.address);
  const hasDuplicates = new Set(addresses).size < addresses.length;
  if (hasDuplicates) {
    throw new DuplicateLeafsError();
  }
  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider2, storage, snapshotFormatVersion);
  return {
    merkleRoot: tree.shardedMerkleInfo.merkleRoot,
    snapshotUri: tree.uri
  };
}
function compare(a2, b2) {
  const left2 = BigNumber.from(a2);
  const right2 = BigNumber.from(b2);
  if (left2.eq(right2)) {
    return 0;
  } else if (left2.gt(right2)) {
    return 1;
  } else {
    return -1;
  }
}
async function processSnapshotData(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const snapshotInfos = [];
  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput) => {
    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider2, storage, snapshotFormatVersion);
      snapshotInfos.push(snapshotInfo);
      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
    } else {
      conditionInput.merkleRootHash = hexZeroPad([0], 32);
    }
    return conditionInput;
  }));
  return {
    inputsWithSnapshots,
    snapshotInfos
  };
}
async function convertToContractModel(c2, tokenDecimals, provider2, storage) {
  const currency = c2.currencyAddress === AddressZero$1 ? NATIVE_TOKEN_ADDRESS : c2.currencyAddress;
  const maxClaimableSupply = convertQuantityToBigNumber(c2.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertQuantityToBigNumber(c2.maxClaimablePerWallet, tokenDecimals);
  let metadataOrUri;
  if (c2.metadata) {
    if (typeof c2.metadata === "string") {
      metadataOrUri = c2.metadata;
    } else {
      metadataOrUri = await storage.upload(c2.metadata);
    }
  }
  return {
    startTimestamp: c2.startTime,
    maxClaimableSupply,
    supplyClaimed: 0,
    maxClaimablePerWallet,
    pricePerToken: await normalizePriceValue(provider2, c2.price, currency),
    currency,
    merkleRoot: c2.merkleRootHash.toString(),
    waitTimeInSecondsBetweenClaims: c2.waitInSeconds || 0,
    metadata: metadataOrUri
  };
}
async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion) {
  const {
    inputsWithSnapshots,
    snapshotInfos
  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider2, storage, snapshotFormatVersion);
  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);
  const sortedConditions = (await Promise.all(parsedInputs.map((c2) => convertToContractModel(c2, tokenDecimals, provider2, storage)))).sort((a2, b2) => {
    return compare(a2.startTimestamp, b2.startTimestamp);
  });
  return {
    snapshotInfos,
    sortedConditions
  };
}
async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
  if (!merkleMetadata) {
    return null;
  }
  const snapshotUri = merkleMetadata[merkleRoot];
  if (snapshotUri) {
    const raw2 = await storage.downloadJSON(snapshotUri);
    if (raw2.isShardedMerkleTree && raw2.merkleRoot === merkleRoot) {
      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);
      return smt?.getAllEntries() || null;
    } else {
      const snapshotData = await SnapshotSchema.parseAsync(raw2);
      if (merkleRoot === snapshotData.merkleRoot) {
        return snapshotData.claims.map((claim) => ({
          address: claim.address,
          maxClaimable: claim.maxClaimable,
          price: claim.price,
          currencyAddress: claim.currencyAddress
        }));
      }
    }
  }
  return null;
}
function convertToReadableQuantity(bn2, tokenDecimals) {
  if (bn2.toString() === MaxUint256$1.toString()) {
    return "unlimited";
  } else {
    return formatUnits(bn2, tokenDecimals);
  }
}
async function transformResultToClaimCondition(pm, tokenDecimals, provider2, merkleMetadata, storage, shouldDownloadSnapshot) {
  const cv = await fetchCurrencyValue(provider2, pm.currency, pm.pricePerToken);
  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);
  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
  let resolvedMetadata;
  if (pm.metadata) {
    resolvedMetadata = await storage.downloadJSON(pm.metadata);
  }
  return ClaimConditionOutputSchema.parseAsync({
    startTime: pm.startTimestamp,
    maxClaimableSupply,
    maxClaimablePerWallet,
    currentMintSupply,
    availableSupply,
    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),
    price: BigNumber.from(pm.pricePerToken),
    currency: pm.currency,
    currencyAddress: pm.currency,
    currencyMetadata: cv,
    merkleRootHash: pm.merkleRoot,
    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : void 0,
    metadata: resolvedMetadata
  });
}
async function updateExistingClaimConditions(index2, claimConditionInput, existingConditions) {
  if (index2 >= existingConditions.length) {
    throw Error(`Index out of bounds - got index: ${index2} with ${existingConditions.length} conditions`);
  }
  const priceDecimals = existingConditions[index2].currencyMetadata.decimals;
  const priceInWei = existingConditions[index2].price;
  const priceInTokens = formatUnits(priceInWei, priceDecimals);
  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({
    ...existingConditions[index2],
    price: priceInTokens,
    ...claimConditionInput
  });
  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({
    ...newConditionParsed,
    price: priceInWei
  });
  return existingConditions.map((existingOutput, i2) => {
    let newConditionAtIndex;
    if (i2 === index2) {
      newConditionAtIndex = mergedConditionOutput;
    } else {
      newConditionAtIndex = existingOutput;
    }
    const formattedPrice = formatUnits(newConditionAtIndex.price, priceDecimals);
    return {
      ...newConditionAtIndex,
      price: formattedPrice
      // manually transform back to input price type
    };
  });
}
class DropClaimConditions {
  constructor(contractWrapper, _metadata, storage) {
    var _this = this;
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async function(claimConditionInputs) {
      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let claimConditionsProcessed = claimConditionInputs;
      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {
        resetClaimEligibilityForAll = true;
        if (claimConditionInputs.length === 0) {
          claimConditionsProcessed = [{
            startTime: /* @__PURE__ */ new Date(0),
            currencyAddress: AddressZero$1,
            price: 0,
            maxClaimableSupply: 0,
            maxClaimablePerWallet: 0,
            waitInSeconds: 0,
            merkleRootHash: hexZeroPad([0], 32),
            snapshot: []
          }];
        } else if (claimConditionInputs.length > 1) {
          throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
        }
      }
      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {
        claimConditionsProcessed.forEach((cc2) => {
          if (cc2.snapshot && cc2.snapshot.length > 0 && (cc2.maxClaimablePerWallet === void 0 || cc2.maxClaimablePerWallet === "unlimited")) {
            throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
          }
          if (cc2.snapshot && cc2.snapshot.length > 0 && cc2.maxClaimablePerWallet?.toString() === "0" && cc2.snapshot.map((s2) => {
            if (typeof s2 === "string") {
              return 0;
            } else {
              return Number(s2.maxClaimable?.toString() || 0);
            }
          }).reduce((acc, current) => {
            return acc + current;
          }, 0) === 0) {
            throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
          }
        });
      }
      const {
        snapshotInfos,
        sortedConditions
      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());
      const merkleInfo = {};
      snapshotInfos.forEach((s2) => {
        merkleInfo[s2.merkleRoot] = s2.snapshotUri;
      });
      const metadata = await _this.metadata.get();
      const encoded = [];
      if (!deepEqual$1(metadata.merkle, merkleInfo)) {
        const mergedMetadata = await _this.metadata.parseInputMetadata({
          ...metadata,
          merkle: merkleInfo
        });
        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);
        if (hasFunction("setContractURI", _this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI]));
        } else {
          throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
        }
      }
      const cw = _this.contractWrapper;
      if (_this.isLegacySinglePhaseDrop(cw)) {
        encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
      } else if (_this.isLegacyMultiPhaseDrop(cw)) {
        encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
      } else if (_this.isNewSinglePhaseDrop(cw)) {
        encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
      } else if (_this.isNewMultiphaseDrop(cw)) {
        encoded.push(cw.readContract.interface.encodeFunctionData("setClaimConditions", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
      } else {
        throw new Error("Contract does not support claim conditions");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "update", buildTransactionFunction(async (index2, claimConditionInput) => {
      const existingConditions = await this.getAll();
      const newConditionInputs = await updateExistingClaimConditions(index2, claimConditionInput, existingConditions);
      return await this.set.prepare(newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = _metadata;
  }
  /** ***************************************
   * READ FUNCTIONS
   *****************************************/
  /**
   * Get the currently active claim condition
   *
   * @returns the claim condition metadata
   */
  async getActive(options2) {
    const cc2 = await this.get();
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(cc2, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options2?.withAllowList || false);
  }
  async get(conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition();
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id2 = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id2);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition();
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id2 = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId();
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(id2);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  /**
   * Get all the claim conditions
   *
   * @returns the claim conditions metadata
   */
  async getAll(options2) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition();
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i2 = startId; i2 < startId + count; i2++) {
        conditions.push(await this.get(i2));
      }
      const metadata = await this.metadata.get();
      const decimals = await this.getTokenDecimals();
      return Promise.all(conditions.map((c2) => transformResultToClaimCondition(c2, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options2?.withAllowList || false)));
    } else {
      return [await this.getActive(options2)];
    }
  }
  /**
   * Can Claim
   *
   * @remarks Check if the drop can currently be claimed.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */
  async canClaim(quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
  }
  /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */
  async getClaimIneligibilityReasons(quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    const decimals = await this.getTokenDecimals();
    const quantityWithDecimals = parseUnits(AmountSchema.parse(quantity), decimals);
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const resolvedAddress = await resolveAddress(addressToCheck);
    try {
      claimCondition = await this.getActive();
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      console.warn("failed to get active claim condition", err);
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      const supplyWithDecimals = parseUnits(claimCondition.availableSupply, decimals);
      if (supplyWithDecimals.lt(quantityWithDecimals)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            });
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.readContract.verifyClaim(resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
          }
        } catch (e2) {
          console.warn("Merkle proof verification failed:", "reason" in e2 ? e2.reason : e2);
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimerProofs = await this.getClaimerProofs(resolvedAddress);
      let claimedSupply = BigNumber.from(0);
      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);
      if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
        claimedSupply = await this.contractWrapper.readContract.getSupplyClaimedByWallet(resolvedAddress);
      }
      if (this.isNewMultiphaseDrop(this.contractWrapper)) {
        const activeClaimConditionId = await this.contractWrapper.readContract.getActiveClaimConditionId();
        claimedSupply = await this.contractWrapper.readContract.getSupplyClaimedByWallet(activeClaimConditionId, resolvedAddress);
      }
      if (claimerProofs) {
        maxClaimable = convertQuantityToBigNumber(claimerProofs.maxClaimable, decimals);
      }
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
        activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId();
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(activeConditionIndex, resolvedAddress);
      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(resolvedAddress);
      }
      const now2 = BigNumber.from(Date.now()).div(1e3);
      if (lastClaimedTimestamp.gt(0) && now2.lt(timestampForNextClaim)) {
        if (timestampForNextClaim.eq(MaxUint256$1)) {
          reasons.push(ClaimEligibility.AlreadyClaimed);
        } else {
          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
        }
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));
      const provider2 = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider2.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider2, claimCondition.currencyAddress, ERC20Abi, {});
        const balance = await erc20.readContract.balanceOf(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  /**
   * Returns allow list information and merkle proofs for the given address.
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */
  async getClaimerProofs(claimerAddress, claimConditionId) {
    const claimCondition = await this.get(claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      const resolvedAddress = await resolveAddress(claimerAddress);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  /** ***************************************
   * PRIVATE FUNCTIONS
   *****************************************/
  async getTokenDecimals() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return this.contractWrapper.readContract.decimals();
    } else {
      return Promise.resolve(0);
    }
  }
  /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns - `overrides` and `proofs` as an object.
   * @internal
   */
  async prepareClaim(quantity, checkERC20Allowance) {
    let decimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let address = arguments.length > 3 ? arguments[3] : void 0;
    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();
    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, toUtf8Bytes("")];
    }
    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, toUtf8Bytes("")];
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress
   * @param quantity
   * @param options
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, quantity, options2) {
    if (options2?.pricePerToken) {
      throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(quantity, options2?.checkERC20Allowance === void 0 ? true : options2.checkERC20Allowance, await this.getTokenDecimals());
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV2") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
}
class Erc20 {
  /**
   * Mint tokens
   */
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "featureName", FEATURE_TOKEN.name);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "droppable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    _defineProperty(this, "transfer", buildTransactionFunction(async (to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transfer",
        args: [await resolveAddress(to), await this.normalizeAmount(amount)]
      });
    }));
    _defineProperty(this, "transferFrom", buildTransactionFunction(async (from2, to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom",
        args: [await resolveAddress(from2), await resolveAddress(to), await this.normalizeAmount(amount)]
      });
    }));
    _defineProperty(this, "setAllowance", buildTransactionFunction(async (spender, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: [await resolveAddress(spender), await this.normalizeAmount(amount)]
      });
    }));
    _defineProperty(this, "transferBatch", buildTransactionFunction(async (args) => {
      const encoded = await Promise.all(args.map(async (arg) => {
        const amountWithDecimals = await this.normalizeAmount(arg.amount);
        return this.contractWrapper.readContract.interface.encodeFunctionData("transfer", [await resolveAddress(arg.toAddress), amountWithDecimals]);
      }));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "mint", buildTransactionFunction(async (amount) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);
    }));
    _defineProperty(this, "mintTo", buildTransactionFunction(async (receiver, amount) => {
      return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to.prepare(receiver, amount);
    }));
    _defineProperty(this, "mintBatchTo", buildTransactionFunction(async (args) => {
      return assertEnabled(this.mintable?.batch, FEATURE_TOKEN_BATCH_MINTABLE).to.prepare(args);
    }));
    _defineProperty(this, "burn", buildTransactionFunction(async (amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens.prepare(amount);
    }));
    _defineProperty(this, "burnFrom", buildTransactionFunction(async (holder, amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from.prepare(holder, amount);
    }));
    _defineProperty(this, "claim", buildTransactionFunction(async (amount, options2) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options2);
    }));
    _defineProperty(this, "claimTo", buildTransactionFunction(async (destinationAddress, amount, options2) => {
      return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to.prepare(destinationAddress, amount, options2);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.mintable = this.detectErc20Mintable();
    this.burnable = this.detectErc20Burnable();
    this.droppable = this.detectErc20Droppable();
    this.signatureMintable = this.detectErc20SignatureMintable();
    this._chainId = chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  /**
   * @internal
   */
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  ////// Standard ERC20 Extension //////
  /**
   * Get the token metadata
   * @remarks name, symbol, etc...
   * @example
   * ```javascript
   * const token = await contract.erc20.get();
   * ```
   * @returns The token metadata
   * @twfeature ERC20
   */
  async get() {
    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());
  }
  /**
   * Get token balance for the currently connected wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const balance = await contract.erc20.balance();
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  /**
   * Get token balance for a specific wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc20.balanceOf(walletAddress);
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */
  async balanceOf(address) {
    return this.getValue(await this.contractWrapper.readContract.balanceOf(await resolveAddress(address)));
  }
  /**
   * Get the total supply for this token
   * @remarks Get how much supply has been minted
   * @example
   * ```javascript
   * const balance = await contract.erc20.totalSupply();
   * ```
   * @twfeature ERC20
   */
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.readContract.totalSupply());
  }
  /**
   * Get token allowance
   *
   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to check token allowance
   * const spenderAddress = "0x...";
   * const allowance = await contract.erc20.allowance(spenderAddress);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */
  async allowance(spender) {
    return await this.allowanceOf(await this.contractWrapper.getSignerAddress(), await resolveAddress(spender));
  }
  /**
   * Get token allowance of a specific wallet
   *
   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet who owns the funds
   * const owner = "{{wallet_address}}";
   * // Address of the wallet to check token allowance
   * const spender = "0x...";
   * const allowance = await contract.erc20.allowanceOf(owner, spender);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */
  async allowanceOf(owner, spender) {
    return await this.getValue(await this.contractWrapper.readContract.allowance(await resolveAddress(owner), await resolveAddress(spender)));
  }
  /**
   * Construct a mint transaction without executing it
   * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param amount - The amount of tokens you want to mint
   *
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   * @twfeature ERC20Mintable
   */
  async getMintTransaction(receiver, amount) {
    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).getMintTransaction(receiver, amount);
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc20.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
   */
  get claimConditions() {
    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC20 SignatureMint Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation
   * const signedPayload = contract.erc20.signature().generate(payload);
   *
   * // now the payload can be used to mint tokens
   * const tx = contract.erc20.signature.mint(signedPayload);
   * ```
   * @twfeature ERC20SignatureMintable
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * returns the wei amount from a token amount
   * @internal
   * @param amount
   */
  async normalizeAmount(amount) {
    const decimals = await this.contractWrapper.readContract.decimals();
    return parseUnits(AmountSchema.parse(amount), decimals);
  }
  /**
   * @internal
   */
  async getValue(value) {
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));
  }
  detectErc20Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20Mintable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) {
      return new Erc20Burnable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV2")) {
      return new Erc20Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc20SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) {
      return new Erc20SignatureMintable(this.contractWrapper);
    }
    return void 0;
  }
}
class Erc20Burnable {
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_BURNABLE.name);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "tokens", buildTransactionFunction(async (amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await this.erc20.normalizeAmount(amount)]
      });
    }));
    _defineProperty(this, "from", buildTransactionFunction(async (holder, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnFrom",
        args: [await resolveAddress(holder), await this.erc20.normalizeAmount(amount)]
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
}
class Erc20Droppable {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.nft.drop.claim.conditions.set(claimConditions);
   * ```
   */
  constructor(erc20, contractWrapper, storage) {
    _defineProperty(this, "claim", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "storage", void 0);
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);
  }
}
class Erc20Mintable {
  /**
   * Batch mint Tokens to many addresses
   */
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "batch", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (to, amount) => {
      return await this.getMintTransaction(to, amount);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.batch = this.detectErc20BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, amount) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await resolveAddress(to), await this.erc20.normalizeAmount(amount)]
    });
  }
  detectErc20BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) {
      return new Erc20BatchMintable(this.erc20, this.contractWrapper);
    }
    return void 0;
  }
}
class Erc20SignatureMintable {
  constructor(contractWrapper, roles) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_SIGNATURE_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "roles", void 0);
    _defineProperty(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature2 = signedPayload.signature;
      const message = await this.mapPayloadToContractStruct(mintRequest);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature2],
        overrides
      });
    }));
    _defineProperty(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const contractPayloads = await Promise.all(signedPayloads.map(async (s2) => {
        const message = await this.mapPayloadToContractStruct(s2.payload);
        const signature2 = s2.signature;
        const price = s2.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature: signature2
        };
      }));
      const encoded = contractPayloads.map((p2) => {
        return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [p2.message, p2.signature]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC20SignatureMintable
   *
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc20.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature2 = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature2);
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint a certain amount of tokens
   *
   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC20SignatureMintable
   */
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  /**
   * Generate a batch of signatures that can be used to mint many token signatures.
   *
   * @remarks See {@link Erc20SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC20SignatureMintable
   */
  async generateBatch(payloadsToSign) {
    await this.roles?.verify(["minter"], await this.contractWrapper.getSignerAddress());
    const parsedRequests = await Promise.all(payloadsToSign.map((m2) => Signature20PayloadInput.parseAsync(m2)));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant$1(signer, "No signer available");
    const name2 = await this.contractWrapper.readContract.name();
    return await Promise.all(parsedRequests.map(async (m2) => {
      const finalPayload = await Signature20PayloadOutput.parseAsync(m2);
      const signature2 = await this.contractWrapper.signTypedData(signer, {
        name: name2,
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        MintRequest: MintRequest20
      }, await this.mapPayloadToContractStruct(finalPayload));
      return {
        payload: finalPayload,
        signature: signature2.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    const amountWithDecimals = parseUnits(mintRequest.quantity, await this.contractWrapper.readContract.decimals());
    return {
      to: mintRequest.to,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      quantity: amountWithDecimals,
      price: normalizedPrice,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid
    };
  }
}
class Erc20ClaimableWithConditions {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.token.drop.claim.conditions.set(claimConditions);
   * ```
   */
  constructor(erc20, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (destinationAddress, amount, options2) => {
      const quantity = await this.erc20.normalizeAmount(amount);
      return await this.conditions.getClaimTransaction(destinationAddress, quantity, options2);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
}
class Erc20BatchMintable {
  constructor(erc20, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_TOKEN_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc20", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (args) => {
      const encoded = [];
      for (const arg of args) {
        encoded.push(this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [await resolveAddress(arg.toAddress), await this.erc20.normalizeAmount(arg.amount)]));
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
}
const InterfaceId_IERC721 = arrayify("0x80ac58cd");
const InterfaceId_IERC1155 = arrayify("0xd9b67a26");
const FALLBACK_METADATA = {
  name: "Failed to load NFT metadata"
};
async function fetchTokenMetadata(tokenId, tokenUri, storage) {
  const parsedUri = tokenUri.replace("{id}", hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));
  let jsonMetadata;
  try {
    jsonMetadata = await storage.downloadJSON(parsedUri);
  } catch (err) {
    const unparsedTokenIdUri = tokenUri.replace("{id}", BigNumber.from(tokenId).toString());
    try {
      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);
    } catch (e2) {
      console.warn(`failed to get token metadata: ${JSON.stringify({
        tokenId: tokenId.toString(),
        tokenUri
      })} -- falling back to default metadata`);
      jsonMetadata = FALLBACK_METADATA;
    }
  }
  return CommonNFTOutput.parse({
    ...jsonMetadata,
    id: BigNumber.from(tokenId).toString(),
    uri: tokenUri
  });
}
async function fetchTokenMetadataForContract(contractAddress, provider2, tokenId, storage) {
  let uri;
  const erc165 = new Contract(contractAddress, ERC165Abi, provider2);
  const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider2);
    uri = await erc721.tokenURI(tokenId);
  } else if (isERC1155) {
    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider2);
    uri = await erc1155.uri(tokenId);
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
  if (!uri) {
    return CommonNFTOutput.parse({
      ...FALLBACK_METADATA,
      id: BigNumber.from(tokenId).toString(),
      uri: ""
    });
  }
  return fetchTokenMetadata(tokenId, uri, storage);
}
async function uploadOrExtractURI(metadata, storage) {
  if (typeof metadata === "string") {
    return metadata;
  } else {
    return await storage.upload(CommonNFTInput.parse(metadata));
  }
}
async function uploadOrExtractURIs(metadatas, storage, startNumber, options2) {
  if (isUriList(metadatas)) {
    return metadatas;
  } else if (isMetadataList(metadatas)) {
    const uris = await storage.uploadBatch(metadatas.map((m2) => CommonNFTInput.parse(m2)), {
      rewriteFileNames: {
        fileStartNumber: startNumber || 0
      },
      onProgress: options2?.onProgress
    });
    return uris;
  } else {
    throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
  }
}
function getBaseUriFromBatch(uris) {
  const baseUri = uris[0].substring(0, uris[0].lastIndexOf("/"));
  for (let i2 = 0; i2 < uris.length; i2++) {
    const uri = uris[i2].substring(0, uris[i2].lastIndexOf("/"));
    if (baseUri !== uri) {
      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
    }
  }
  return baseUri.replace(/\/$/, "") + "/";
}
function isUriList(metadatas) {
  return metadatas.find((m2) => typeof m2 !== "string") === void 0;
}
function isMetadataList(metadatas) {
  return metadatas.find((m2) => typeof m2 !== "object") === void 0;
}
class Erc721Burnable {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_BURNABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "token", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [tokenId]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
}
class Erc721WithQuantitySignatureMintable {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_SIGNATURE_MINTABLE_V2.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature2 = signedPayload.signature;
      const overrides = await this.contractWrapper.getCallOverrides();
      const parse2 = (receipt) => {
        const t2 = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
        if (t2.length === 0) {
          throw new Error("No MintWithSignature event found");
        }
        const id2 = t2[0].args.tokenIdMinted;
        return {
          id: id2,
          receipt
        };
      };
      if (await this.isLegacyNFTContract()) {
        const message = await this.mapLegacyPayloadToContractStruct(mintRequest);
        const price = message.price;
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature2],
          overrides,
          parse: parse2
        });
      } else {
        const message = await this.mapPayloadToContractStruct(mintRequest);
        const price = message.pricePerToken.mul(message.quantity);
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature2],
          overrides,
          parse: parse2
        });
      }
    }));
    _defineProperty(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const isLegacyNFTContract = await this.isLegacyNFTContract();
      const contractPayloads = await Promise.all(signedPayloads.map(async (s2) => {
        let message;
        if (isLegacyNFTContract) {
          message = await this.mapLegacyPayloadToContractStruct(s2.payload);
        } else {
          message = await this.mapPayloadToContractStruct(s2.payload);
        }
        const signature2 = s2.signature;
        const price = s2.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature: signature2
        };
      }));
      const encoded = contractPayloads.map((p2) => {
        if (isLegacyNFTContract) {
          const contract = this.contractWrapper.readContract;
          return contract.interface.encodeFunctionData("mintWithSignature", [p2.message, p2.signature]);
        } else {
          const contract = this.contractWrapper.readContract;
          return contract.interface.encodeFunctionData("mintWithSignature", [p2.message, p2.signature]);
        }
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not available on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC721SignatureMint
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc721.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const mintRequest = signedPayload.payload;
    const signature2 = signedPayload.signature;
    let message;
    let verification;
    if (isLegacyNFTContract) {
      const contract = this.contractWrapper.readContract;
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature2);
    } else {
      const contract = this.contractWrapper.readContract;
      message = await this.mapPayloadToContractStruct(mintRequest);
      verification = await contract.verify(message, signature2);
    }
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint a dynamic NFT
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC721SignatureMint
   */
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  /**
   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.
   *
   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC721SignatureMint
   */
  async generateBatch(payloadsToSign) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const parsedRequests = await Promise.all(payloadsToSign.map((m2) => Signature721WithQuantityInput.parseAsync(m2)));
    const metadatas = parsedRequests.map((r2) => r2.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant$1(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m2, i2) => {
      const uri = uris[i2];
      const finalPayload = await Signature721WithQuantityOutput.parseAsync({
        ...m2,
        uri
      });
      let signature2;
      if (isLegacyNFTContract) {
        signature2 = await this.contractWrapper.signTypedData(signer, {
          name: "TokenERC721",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.readContract.address
        }, {
          MintRequest: MintRequest721
        }, await this.mapLegacyPayloadToContractStruct(finalPayload));
      } else {
        signature2 = await this.contractWrapper.signTypedData(
          signer,
          {
            name: "SignatureMintERC721",
            version: "1",
            chainId,
            verifyingContract: await this.contractWrapper.readContract.address
          },
          {
            MintRequest: MintRequest721withQuantity
          },
          // TYPEHASH
          await this.mapPayloadToContractStruct(finalPayload)
        );
      }
      return {
        payload: finalPayload,
        signature: signature2.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid
    };
  }
  async mapLegacyPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      price: normalizedPricePerToken,
      uri: mintRequest.uri,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
  async isLegacyNFTContract() {
    return detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1");
  }
}
class DelayedReveal {
  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {
    _defineProperty(this, "featureName", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "nextTokenIdToMintFn", void 0);
    _defineProperty(this, "createDelayedRevealBatch", buildTransactionFunction(async (placeholder, metadatas, password, options2) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.nextTokenIdToMintFn();
      const uris = await this.storage.uploadBatch(metadatas.map((m2) => CommonNFTInput.parse(m2)), {
        onProgress: options2?.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.readContract.getBaseURICount();
      const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);
      const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(toUtf8Bytes(baseUri), hashedPassword);
      let data;
      const legacyContract = await this.isLegacyContract();
      if (legacyContract) {
        data = encryptedBaseUri;
      } else {
        const chainId = await this.contractWrapper.getChainID();
        const provenanceHash = keccak256(["bytes", "bytes", "uint256"], [toUtf8Bytes(baseUri), hashedPassword, chainId]);
        data = defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = events[0].args.startTokenId;
          const endingIndex = events[0].args.endTokenId;
          const results2 = [];
          for (let id2 = startingIndex; id2.lte(endingIndex); id2 = id2.add(1)) {
            results2.push({
              id: id2,
              receipt
            });
          }
          return results2;
        }
      });
    }));
    _defineProperty(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const key2 = await this.hashDelayRevealPassword(batchId, password);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key2);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e2) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key2]
      });
    }));
    this.featureName = featureName;
    this.nextTokenIdToMintFn = nextTokenIdToMintFn;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  /**
   * Gets the list of unrevealed NFT batches.
   * @remarks Gets the list of unrevealed NFT batches.
   * @example
   * ```javascript
   * const batches = await contract.revealer.getBatchesToReveal();
   * ```
   * @public
   */
  async getBatchesToReveal() {
    const count = await this.contractWrapper.readContract.getBaseURICount();
    if (count.isZero()) {
      return [];
    }
    const countRangeArray = Array.from(Array(count.toNumber()).keys());
    const uriIndices = await Promise.all(countRangeArray.map((i2) => {
      if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) {
        return this.contractWrapper.readContract.getBatchIdAtIndex(i2);
      }
      if (hasFunction("baseURIIndices", this.contractWrapper)) {
        return this.contractWrapper.readContract.baseURIIndices(i2);
      }
      throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
    }));
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map((i2) => this.getNftMetadata(i2.toString())));
    const legacyContract = await this.isLegacyContract();
    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i2) => legacyContract ? this.getLegacyEncryptedData(i2) : this.contractWrapper.readContract.encryptedData(i2)));
    const encryptedBaseUris = encryptedUriData.map((data) => {
      if (hexDataLength(data) > 0) {
        if (legacyContract) {
          return data;
        }
        const result = defaultAbiCoder.decode(["bytes", "bytes32"], data);
        return result[0];
      } else {
        return data;
      }
    });
    return tokenMetadatas.map((meta, index2) => ({
      batchId: BigNumber.from(index2),
      batchUri: meta.uri,
      placeholderMetadata: meta
    })).filter((_, index2) => hexDataLength(encryptedBaseUris[index2]) > 0);
  }
  /**
   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.
   *
   * @internal
   */
  async hashDelayRevealPassword(batchTokenIndex, password) {
    const chainId = await this.contractWrapper.getChainID();
    const contractAddress = this.contractWrapper.readContract.address;
    return keccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchTokenIndex, contractAddress]);
  }
  async getNftMetadata(tokenId) {
    return fetchTokenMetadataForContract(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), tokenId, this.storage);
  }
  async isLegacyContract() {
    if (hasFunction("contractVersion", this.contractWrapper)) {
      try {
        const version2 = await this.contractWrapper.readContract.contractVersion();
        return version2 <= 2;
      } catch (e2) {
        return false;
      }
    }
    return false;
  }
  async getLegacyEncryptedData(index2) {
    const legacy = new Contract(this.contractWrapper.readContract.address, DeprecatedAbi, this.contractWrapper.getProvider());
    const result = await legacy.functions["encryptedBaseURI"](index2);
    if (result.length > 0) {
      return result[0];
    } else {
      return "0x";
    }
  }
}
const TieredDropPayloadSchema = BaseSignaturePayloadInput.extend({
  tierPriority: z$2.array(z$2.string()),
  royaltyRecipient: AddressOrEnsSchema.default(AddressZero$1),
  royaltyBps: BasisPointsSchema.default(0),
  quantity: BigNumberSchema.default(1)
});
async function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {
  let overrides = {};
  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;
  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);
  const totalCost = normalizedPrice.mul(quantity);
  if (totalCost.gt(0)) {
    if (currency === NATIVE_TOKEN_ADDRESS) {
      overrides = {
        value: totalCost
      };
    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);
    }
  }
  return overrides;
}
class Erc721 {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    _defineProperty(this, "featureName", FEATURE_NFT.name);
    _defineProperty(this, "query", void 0);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "lazyMintable", void 0);
    _defineProperty(this, "tieredDropable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "claimWithConditions", void 0);
    _defineProperty(this, "claimCustom", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    _defineProperty(this, "transfer", buildTransactionFunction(async (to, tokenId) => {
      const from2 = await this.contractWrapper.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [from2, await resolveAddress(to), tokenId]
      });
    }));
    _defineProperty(this, "transferFrom", buildTransactionFunction(async (from2, to, tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [await resolveAddress(from2), await resolveAddress(to), tokenId]
      });
    }));
    _defineProperty(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [await resolveAddress(operator), approved]
      });
    }));
    _defineProperty(this, "setApprovalForToken", buildTransactionFunction(async (operator, tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: [await resolveAddress(operator), tokenId]
      });
    }));
    _defineProperty(this, "mint", buildTransactionFunction(async (metadata) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);
    }));
    _defineProperty(this, "mintTo", buildTransactionFunction(async (receiver, metadata) => {
      return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);
    }));
    _defineProperty(this, "mintBatch", buildTransactionFunction(async (metadatas) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);
    }));
    _defineProperty(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadatas) => {
      return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);
    }));
    _defineProperty(this, "burn", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);
    }));
    _defineProperty(this, "lazyMint", buildTransactionFunction(async (metadatas, options2) => {
      return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options2);
    }));
    _defineProperty(this, "claim", buildTransactionFunction(async (quantity, options2) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options2);
    }));
    _defineProperty(this, "claimTo", buildTransactionFunction(async (destinationAddress, quantity, options2) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, quantity, options2);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, quantity, options2);
      }
      throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc721Enumerable();
    this.mintable = this.detectErc721Mintable();
    this.burnable = this.detectErc721Burnable();
    this.lazyMintable = this.detectErc721LazyMintable();
    this.tieredDropable = this.detectErc721TieredDrop();
    this.signatureMintable = this.detectErc721SignatureMintable();
    this.claimWithConditions = this.detectErc721ClaimableWithConditions();
    this.claimCustom = this.detectErc721Claimable();
    this._chainId = chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  ////// Standard ERC721 Extension //////
  /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc721.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC721
   */
  async get(tokenId) {
    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => AddressZero$1), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner,
      metadata,
      type: "ERC721",
      supply: "1"
    };
  }
  /**
   * Get the current owner of an NFT
   *
   * @param tokenId - the tokenId of the NFT
   * @returns the address of the owner
   * @twfeature ERC721
   */
  async ownerOf(tokenId) {
    return await this.contractWrapper.readContract.ownerOf(tokenId);
  }
  /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc721.balanceOf(walletAddress);
   * console.log(balance);
   * ```
   * @twfeature ERC721
   */
  async balanceOf(address) {
    return await this.contractWrapper.readContract.balanceOf(await resolveAddress(address));
  }
  /**
   * Get NFT balance for the currently connected wallet
   */
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(await resolveAddress(address), await resolveAddress(operator));
  }
  ////// ERC721 Supply Extension //////
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc721.getAll();
   * console.log(nfts);
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);
  }
  /**
   * Get all NFT owners
   * @example
   * ```javascript
   * const owners = await contract.erc721.getAllOwners();
   * console.log(owners);
   * ```
   * @returns an array of token ids and owners
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getAllOwners() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();
  }
  /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc721.totalCount();
   * console.log(count);
   * ```
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  /**
   * Get the total count NFTs minted in this contract
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async totalCirculatingSupply() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();
  }
  ////// ERC721 Enumerable Extension //////
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc721.getOwned(address);
   * console.log(nfts);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC721Supply | ERC721Enumerable
   */
  async getOwned(walletAddress) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if (this.query?.owned) {
      return this.query.owned.all(walletAddress);
    } else {
      const address = walletAddress || await this.contractWrapper.getSignerAddress();
      const allOwners = await this.getAllOwners();
      return Promise.all((allOwners || []).filter((i2) => address?.toLowerCase() === i2.owner?.toLowerCase()).map(async (i2) => await this.get(i2.tokenId)));
    }
  }
  /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */
  async getOwnedTokenIds(walletAddress) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if (this.query?.owned) {
      return this.query.owned.tokenIds(walletAddress);
    } else {
      const address = walletAddress || await this.contractWrapper.getSignerAddress();
      const allOwners = await this.getAllOwners();
      return (allOwners || []).filter((i2) => address?.toLowerCase() === i2.owner?.toLowerCase()).map((i2) => BigNumber.from(i2.tokenId));
    }
  }
  /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadata - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   * @twfeature ERC721Mintable
   */
  async getMintTransaction(receiver, metadata) {
    return this.mintTo.prepare(receiver, metadata);
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress
   * @param quantity
   * @param options
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async getClaimTransaction(destinationAddress, quantity, options2) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options2);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, quantity, options2);
    }
    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
  }
  /**
   * Get the claimed supply
   *
   * @remarks Get the number of claimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const claimedNFTCount = await contract.totalClaimedSupply();
   * console.log(`NFTs claimed: ${claimedNFTCount}`);
   * ```
   * @returns the unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async totalClaimedSupply() {
    const contract = this.contractWrapper;
    if (hasFunction("nextTokenIdToClaim", contract)) {
      return contract.readContract.nextTokenIdToClaim();
    }
    if (hasFunction("totalMinted", contract)) {
      return contract.readContract.totalMinted();
    }
    throw new Error("No function found on contract to get total claimed supply");
  }
  /**
   * Get the unclaimed supply
   *
   * @remarks Get the number of unclaimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();
   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);
   * ```
   * @returns the unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  async totalUnclaimedSupply() {
    return (await this.nextTokenIdToMint()).sub(await this.totalClaimedSupply());
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC721 Tiered Drop Extension //////
  /**
   * Tiered Drop
   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.
   * @twfeature ERC721TieredDrop
   */
  get tieredDrop() {
    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);
  }
  ////// ERC721 SignatureMint Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation
   * const signedPayload = contract.erc721.signature().generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc721.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);
  }
  ////// ERC721 DelayedReveal Extension //////
  /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc721.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC721Revealable
   */
  get revealer() {
    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * @internal
   */
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.tokenURI(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  /**
   * Return the next available token ID to mint
   * @internal
   */
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else if (hasFunction("totalSupply", this.contractWrapper)) {
      return await this.contractWrapper.readContract.totalSupply();
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
  }
  detectErc721Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return new Erc721Supply(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) {
      return new Erc721Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) {
      return new Erc721Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721LazyMintable")) {
      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721TieredDrop() {
    if (detectContractFeature(this.contractWrapper, "ERC721TieredDrop")) {
      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1") || detectContractFeature(this.contractWrapper, "ERC721SignatureMintV2")) {
      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV2")) {
      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimCustom")) {
      return new Erc721Claimable(this, this.contractWrapper);
    }
    return void 0;
  }
}
class Erc721LazyMintable {
  /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.nft.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   */
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_LAZY_MINTABLE.name);
    _defineProperty(this, "revealer", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "lazyMint", buildTransactionFunction(async (metadatas, options2) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch2 = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options2);
      const baseUri = getBaseUriFromBatch(batch2);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch2.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args.startTokenId;
          const endingIndex = event[0].args.endTokenId;
          const results2 = [];
          for (let id2 = startingIndex; id2.lte(endingIndex); id2 = id2.add(1)) {
            results2.push({
              id: id2,
              receipt,
              data: () => this.erc721.getTokenMetadata(id2)
            });
          }
          return results2;
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc721Revealable();
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());
    }
    return void 0;
  }
}
class Erc721Mintable {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "batch", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (to, metadata) => {
      const uri = await uploadOrExtractURI(metadata, this.storage);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [await resolveAddress(to), uri],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("Transfer", receipt?.logs);
          if (event.length === 0) {
            throw new Error("TransferEvent event not found");
          }
          const id2 = event[0].args.tokenId;
          return {
            id: id2,
            receipt,
            data: () => this.erc721.get(id2)
          };
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc721BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, metadata) {
    return this.to.prepare(await resolveAddress(to), metadata);
  }
  detectErc721BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) {
      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
}
class Erc721Supply {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_SUPPLY.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "owned", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.owned = this.detectErc721Owned();
  }
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.nft.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */
  async all(queryParams) {
    const start2 = BigNumber.from(queryParams?.start || 0).toNumber();
    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxSupply = await this.erc721.nextTokenIdToMint();
    const maxId = Math.min(maxSupply.toNumber(), start2 + count);
    return await Promise.all([...Array(maxId - start2).keys()].map((i2) => this.erc721.get((start2 + i2).toString())));
  }
  /**
   * Return all the owners of each token id in this contract
   * @returns
   */
  async allOwners() {
    return Promise.all([...new Array((await this.totalCount()).toNumber()).keys()].map(async (i2) => ({
      tokenId: i2,
      owner: await this.erc721.ownerOf(i2).catch(() => AddressZero$1)
    })));
  }
  /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  /**
   * Get the number of NFTs of this contract currently owned by end users
   * @returns the total number of NFTs of this contract in circulation (minted & not burned)
   * @public
   */
  async totalCirculatingSupply() {
    return await this.contractWrapper.readContract.totalSupply();
  }
  detectErc721Owned() {
    if (detectContractFeature(this.contractWrapper, "ERC721Enumerable")) {
      return new Erc721Enumerable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
}
class Erc721TieredDrop {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_TIERED_DROP.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "createBatchWithTier", buildTransactionFunction(async (metadatas, tier, options2) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch2 = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options2);
      const baseUri = getBaseUriFromBatch(batch2);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch2.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, tier, toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results2 = [];
          for (let id2 = startingIndex; id2.lte(endingIndex); id2 = id2.add(1)) {
            results2.push({
              id: id2,
              receipt,
              data: () => this.erc721.getTokenMetadata(id2)
            });
          }
          return results2;
        }
      });
    }));
    _defineProperty(this, "createDelayedRevealBatchWithTier", buildTransactionFunction(async (placeholder, metadatas, password, tier, options2) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const uris = await this.storage.uploadBatch(metadatas.map((m2) => CommonNFTInput.parse(m2)), {
        onProgress: options2?.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.readContract.getBaseURICount();
      const chainId = await this.contractWrapper.getChainID();
      const hashedPassword = keccak256(["string", "uint256", "uint256", "address"], [password, chainId, baseUriId, this.contractWrapper.readContract.address]);
      const encryptedBaseUri = await this.contractWrapper.readContract.encryptDecrypt(toUtf8Bytes(baseUri), hashedPassword);
      let data;
      const provenanceHash = keccak256(["bytes", "bytes", "uint256"], [toUtf8Bytes(baseUri), hashedPassword, chainId]);
      data = defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, tier, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results2 = [];
          for (let id2 = startingIndex; id2.lte(endingIndex); id2 = id2.add(1)) {
            results2.push({
              id: id2,
              receipt,
              data: () => this.erc721.getTokenMetadata(id2)
            });
          }
          return results2;
        }
      });
    }));
    _defineProperty(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const chainId = await this.contractWrapper.getChainID();
      const key2 = keccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchId, this.contractWrapper.readContract.address]);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key2);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e2) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key2]
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async getMetadataInTier(tier) {
    const tiers = await this.contractWrapper.readContract.getMetadataForAllTiers();
    const batches = tiers.find((t2) => t2.tier === tier);
    if (!batches) {
      throw new Error("Tier not found in contract.");
    }
    const nfts = await Promise.all(batches.ranges.map((range, i2) => {
      const nftsInRange = [];
      const baseUri = batches.baseURIs[i2];
      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {
        const uri = `${baseUri}/${j}`;
        const metadata = this.storage.downloadJSON(uri);
        nftsInRange.push(metadata);
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async getTokensInTier(tier) {
    const endIndex = await this.contractWrapper.readContract.getTokensInTierLen();
    if (endIndex.eq(0)) {
      return [];
    }
    const ranges = await this.contractWrapper.readContract.getTokensInTier(tier, 0, endIndex);
    const nfts = await Promise.all(ranges.map((range) => {
      const nftsInRange = [];
      for (let i2 = range.startIdInclusive.toNumber(); i2 < range.endIdNonInclusive.toNumber(); i2++) {
        nftsInRange.push(this.erc721.get(i2));
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async generate(payloadToSign) {
    const [payload] = await this.generateBatch([payloadToSign]);
    return payload;
  }
  async generateBatch(payloadsToSign) {
    const parsedPayloads = await Promise.all(payloadsToSign.map((payload) => TieredDropPayloadSchema.parseAsync(payload)));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant$1(signer, "No signer available");
    return await Promise.all(parsedPayloads.map(async (payload) => {
      const signature2 = await this.contractWrapper.signTypedData(signer, {
        name: "SignatureAction",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.readContract.address
      }, {
        GenericRequest
      }, await this.mapPayloadToContractStruct(payload));
      return {
        payload,
        signature: signature2.toString()
      };
    }));
  }
  async verify(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const verification = await this.contractWrapper.readContract.verify(message, signedPayload.signature);
    return verification[0];
  }
  async claimWithSignature(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("claimWithSignature", [message, signedPayload.signature], overrides);
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);
    const results2 = [];
    for (let id2 = startingIndex; id2.lt(endingIndex); id2 = id2.add(1)) {
      results2.push({
        id: id2,
        receipt,
        data: () => this.erc721.get(id2)
      });
    }
    return results2;
  }
  async mapPayloadToContractStruct(payload) {
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);
    const data = defaultAbiCoder.encode(["string[]", "address", "address", "uint256", "address", "uint256", "uint256", "address"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);
    return {
      uid: payload.uid,
      validityStartTimestamp: payload.mintStartTime,
      validityEndTimestamp: payload.mintEndTime,
      data
    };
  }
}
class Erc721ClaimableWithConditions {
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   */
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options2) => {
      const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options2);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results2 = [];
        for (let id2 = startingIndex; id2.lt(endingIndex); id2 = id2.add(1)) {
          results2.push({
            id: id2,
            receipt,
            data: () => this.erc721.get(id2)
          });
        }
        return results2;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
}
class Erc721Claimable {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_CLAIM_CUSTOM.name);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options2) => {
      const tx = await this.getClaimTransaction(destinationAddress, quantity, options2);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results2 = [];
        for (let id2 = startingIndex; id2.lt(endingIndex); id2 = id2.add(1)) {
          results2.push({
            id: id2,
            receipt,
            data: () => this.erc721.get(id2)
          });
        }
        return results2;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, quantity, options2) {
    let overrides = {};
    if (options2 && options2.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options2.pricePerToken, quantity, options2.currencyAddress, options2.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [destinationAddress, quantity],
      overrides
    });
  }
}
class Erc721BatchMintable {
  constructor(erc721, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_NFT_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "erc721", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (to, metadatas) => {
      const uris = await uploadOrExtractURIs(metadatas, this.storage);
      const resolvedAddress = await resolveAddress(to);
      const encoded = await Promise.all(uris.map(async (uri) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [resolvedAddress, uri])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e2) => {
            const id2 = e2.args.tokenIdMinted;
            return {
              id: id2,
              receipt,
              data: () => this.erc721.get(id2)
            };
          });
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
}
class Erc721Enumerable {
  constructor(erc721, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_NFT_ENUMERABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc721", void 0);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.nft.query.owned.all(address);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   */
  async all(walletAddress) {
    const tokenIds = await this.tokenIds(walletAddress);
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */
  async tokenIds(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    const balance = await this.contractWrapper.readContract.balanceOf(address);
    const indices = Array.from(Array(balance.toNumber()).keys());
    return await Promise.all(indices.map((i2) => this.contractWrapper.readContract.tokenOfOwnerByIndex(address, i2)));
  }
}
const AirdropAddressInput = z$2.object({
  address: AddressOrEnsSchema,
  quantity: AmountSchema.default(1)
});
const AirdropInputSchema = z$2.union([z$2.array(z$2.string()).transform(async (strings) => await Promise.all(strings.map((address) => AirdropAddressInput.parseAsync({
  address
})))), z$2.array(AirdropAddressInput)]);
class Erc1155SignatureMintable {
  constructor(contractWrapper, storage, roles) {
    _defineProperty(this, "featureName", FEATURE_EDITION_SIGNATURE_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "roles", void 0);
    _defineProperty(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature2 = signedPayload.signature;
      const message = await this.mapPayloadToContractStruct(mintRequest);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature2],
        overrides,
        parse: (receipt) => {
          const t2 = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
          if (t2.length === 0) {
            throw new Error("No MintWithSignature event found");
          }
          const id2 = t2[0].args.tokenIdMinted;
          return {
            id: id2,
            receipt
          };
        }
      });
    }));
    _defineProperty(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const contractPayloads = await Promise.all(signedPayloads.map(async (s2) => {
        const message = await this.mapPayloadToContractStruct(s2.payload);
        const signature2 = s2.signature;
        const price = s2.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature: signature2
        };
      }));
      const encoded = contractPayloads.map((p2) => {
        return this.contractWrapper.readContract.interface.encodeFunctionData("mintWithSignature", [p2.message, p2.signature]);
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not supported on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.roles = roles;
  }
  /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC1155SignatureMintable
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = contract.erc1155.signature.generate(payload);
   * // Now you can verify that the payload is valid
   * const isValid = await contract.erc1155.signature.verify(signedPayload);
   * ```
   */
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature2 = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.readContract.verify(message, signature2);
    return verification[0];
  }
  /**
   * Generate a signature that can be used to mint an NFT dynamically.
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */
  async generate(payloadToSign) {
    const payload = {
      ...payloadToSign,
      tokenId: MaxUint256$1
    };
    return this.generateFromTokenId(payload);
  }
  /**
   * Generate a signature that can be used to mint additionaly supply to an existing NFT.
   *
   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   tokenId: 0, // Instead of metadata, we specificy the token ID of the NFT to mint supply to
   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns the signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */
  async generateFromTokenId(payloadToSign) {
    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);
    return payloads[0];
  }
  /**
   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns an array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */
  async generateBatch(payloadsToSign) {
    const payloads = payloadsToSign.map((payload) => ({
      ...payload,
      tokenId: MaxUint256$1
    }));
    return this.generateBatchFromTokenIds(payloads);
  }
  /**
   * Genrate a batch of signatures that can be used to mint new NFTs or additionaly supply to existing NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}
   *
   * @param payloadsToSign - the payloads to sign with tokenIds specified
   * @returns an array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */
  async generateBatchFromTokenIds(payloadsToSign) {
    await this.roles?.verify(["minter"], await this.contractWrapper.getSignerAddress());
    const parsedRequests = await Promise.all(payloadsToSign.map((m2) => Signature1155PayloadInputWithTokenId.parseAsync(m2)));
    const metadatas = parsedRequests.map((r2) => r2.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant$1(signer, "No signer available");
    const contractInfo = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());
    const isLegacyContract = contractInfo?.type === "TokenERC1155";
    return await Promise.all(parsedRequests.map(async (m2, i2) => {
      const uri = uris[i2];
      const finalPayload = await Signature1155PayloadOutput.parseAsync({
        ...m2,
        uri
      });
      const signature2 = await this.contractWrapper.signTypedData(
        signer,
        {
          name: isLegacyContract ? "TokenERC1155" : "SignatureMintERC1155",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.readContract.address
        },
        {
          MintRequest: MintRequest1155
        },
        // TYPEHASH
        await this.mapPayloadToContractStruct(finalPayload)
      );
      return {
        payload: finalPayload,
        signature: signature2.toString()
      };
    }));
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns - The mapped payload.
   */
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      tokenId: mintRequest.tokenId,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
}
class ERC1155Claimable {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_CLAIM_CUSTOM.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options2) => {
      return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options2);
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options2) {
    let overrides = {};
    if (options2 && options2.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options2.pricePerToken, quantity, options2.currencyAddress, options2.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [await resolveAddress(destinationAddress), tokenId, quantity],
      overrides
    });
  }
}
class DropErc1155ClaimConditions {
  constructor(contractWrapper, _metadata, storage) {
    var _this = this;
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async function(tokenId, claimConditionInputs) {
      let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return _this.setBatch.prepare([{
        tokenId,
        claimConditions: claimConditionInputs
      }], resetClaimEligibilityForAll);
    }));
    _defineProperty(this, "setBatch", buildTransactionFunction(async function(claimConditionsForToken) {
      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const merkleInfo = {};
      const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async (_ref) => {
        let {
          tokenId,
          claimConditions
        } = _ref;
        let claimConditionsProcessed = claimConditions;
        if (_this.isLegacySinglePhaseDrop(_this.contractWrapper)) {
          resetClaimEligibilityForAll = true;
          if (claimConditions.length === 0) {
            claimConditionsProcessed = [{
              startTime: /* @__PURE__ */ new Date(0),
              currencyAddress: AddressZero$1,
              price: 0,
              maxClaimableSupply: 0,
              maxClaimablePerWallet: 0,
              waitInSeconds: 0,
              merkleRootHash: hexZeroPad([0], 32),
              snapshot: []
            }];
          } else if (claimConditions.length > 1) {
            throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
          }
        }
        if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {
          claimConditionsProcessed.forEach((cc2) => {
            if (cc2.snapshot && cc2.snapshot.length > 0 && (cc2.maxClaimablePerWallet === void 0 || cc2.maxClaimablePerWallet === "unlimited")) {
              throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
            }
            if (cc2.snapshot && cc2.snapshot.length > 0 && cc2.maxClaimablePerWallet?.toString() === "0" && cc2.snapshot.map((s2) => {
              if (typeof s2 === "string") {
                return 0;
              } else {
                return Number(s2.maxClaimable?.toString() || 0);
              }
            }).reduce((acc, current) => {
              return acc + current;
            }, 0) === 0) {
              throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
            }
          });
        }
        const {
          snapshotInfos,
          sortedConditions
        } = await processClaimConditionInputs(claimConditionsProcessed, 0, _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());
        snapshotInfos.forEach((s2) => {
          merkleInfo[s2.merkleRoot] = s2.snapshotUri;
        });
        return {
          tokenId,
          sortedConditions
        };
      }));
      const metadata = await _this.metadata.get();
      const encoded = [];
      for (const key2 of Object.keys(metadata.merkle || {})) {
        merkleInfo[key2] = metadata.merkle[key2];
      }
      if (!deepEqual$1(metadata.merkle, merkleInfo)) {
        const mergedMetadata = await _this.metadata.parseInputMetadata({
          ...metadata,
          merkle: merkleInfo
        });
        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);
        if (hasFunction("setContractURI", _this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setContractURI", [contractURI]));
        } else {
          throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
        }
      }
      processedClaimConditions.forEach((_ref2) => {
        let {
          tokenId,
          sortedConditions
        } = _ref2;
        if (_this.isLegacySinglePhaseDrop(_this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isLegacyMultiPhaseDrop(_this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
        } else if (_this.isNewSinglePhaseDrop(_this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isNewMultiphaseDrop(_this.contractWrapper)) {
          encoded.push(_this.contractWrapper.readContract.interface.encodeFunctionData("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
        } else {
          throw new Error("Contract does not support claim conditions");
        }
      });
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "update", buildTransactionFunction(async (tokenId, index2, claimConditionInput) => {
      const existingConditions = await this.getAll(tokenId);
      const newConditionInputs = await updateExistingClaimConditions(index2, claimConditionInput, existingConditions);
      return await this.set.prepare(tokenId, newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = _metadata;
  }
  /** ***************************************
   * READ FUNCTIONS
   *****************************************/
  /**
   * Get the currently active claim condition
   *
   * @returns the claim condition metadata
   */
  async getActive(tokenId, options2) {
    const mc2 = await this.get(tokenId);
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(mc2, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options2?.withAllowList || false);
  }
  async get(tokenId, conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id2 = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id2);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.readContract.claimCondition(tokenId);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id2 = conditionId !== void 0 ? conditionId : await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      const contractModel = await this.contractWrapper.readContract.getClaimConditionById(tokenId, id2);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  /**
   * Get all the claim conditions
   *
   * @returns the claim conditions metadata
   */
  async getAll(tokenId, options2) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.readContract.claimCondition(tokenId);
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i2 = startId; i2 < startId + count; i2++) {
        conditions.push(await this.get(tokenId, i2));
      }
      const metadata = await this.metadata.get();
      return Promise.all(conditions.map((c2) => transformResultToClaimCondition(c2, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options2?.withAllowList || false)));
    } else {
      return [await this.getActive(tokenId, options2)];
    }
  }
  /**
   * Can Claim
   *
   * @remarks Check if a particular NFT can currently be claimed by a given user.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */
  async canClaim(tokenId, quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
  }
  /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human-readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param tokenId - the token id to check
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */
  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const resolvedAddress = await resolveAddress(addressToCheck);
    try {
      claimCondition = await this.getActive(tokenId);
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
      }
    }
    const merkleRootArray = stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.readContract.verifyClaimMerkleProof(tokenId, resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            });
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.readContract.verifyClaim(tokenId, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
            await this.contractWrapper.readContract.verifyClaim(activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            });
          }
        } catch (e2) {
          console.warn("Merkle proof verification failed:", "reason" in e2 ? e2.reason : e2);
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (claimCondition.maxClaimablePerWallet === "0") {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.readContract.getActiveClaimConditionId(tokenId);
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, activeConditionIndex, resolvedAddress);
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.readContract.getClaimTimestamp(tokenId, resolvedAddress);
    }
    const now2 = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now2.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(MaxUint256$1)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(quantity);
      const provider2 = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider2.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const erc20 = new ContractWrapper(provider2, claimCondition.currencyAddress, ERC20Abi, {});
        const balance = await erc20.readContract.balanceOf(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  /**
   * Returns allow list information and merkle proofs for the given address.
   * @param tokenId - the token ID to check
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */
  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {
    const claimCondition = await this.get(tokenId, claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      const resolvedAddress = await resolveAddress(claimerAddress);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns - `overrides` and `proofs` as an object.
   */
  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {
    const addressToClaim = await resolveAddress(address ? address : await this.contractWrapper.getSignerAddress());
    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, toUtf8Bytes("")];
    }
    return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, toUtf8Bytes("")];
  }
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options2) {
    if (options2?.pricePerToken) {
      throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(tokenId, quantity, options2?.checkERC20Allowance || true);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
}
class Erc1155ClaimableWithConditions {
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_CLAIM_CONDITIONS_V2.name);
    _defineProperty(this, "conditions", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options2) => {
      return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options2);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
  }
}
class Erc1155 {
  get chainId() {
    return this._chainId;
  }
  constructor(contractWrapper, storage, chainId) {
    var _this = this;
    _defineProperty(this, "featureName", FEATURE_EDITION.name);
    _defineProperty(this, "query", void 0);
    _defineProperty(this, "mintable", void 0);
    _defineProperty(this, "burnable", void 0);
    _defineProperty(this, "lazyMintable", void 0);
    _defineProperty(this, "signatureMintable", void 0);
    _defineProperty(this, "claimWithConditions", void 0);
    _defineProperty(this, "claimCustom", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_chainId", void 0);
    _defineProperty(this, "transfer", buildTransactionFunction(async function(to, tokenId, amount) {
      let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
      const from2 = await _this.contractWrapper.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "safeTransferFrom",
        args: [from2, await resolveAddress(to), tokenId, amount, data]
      });
    }));
    _defineProperty(this, "transferFrom", buildTransactionFunction(async function(from2, to, tokenId, amount) {
      let data = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "safeTransferFrom",
        args: [await resolveAddress(from2), await resolveAddress(to), tokenId, amount, data]
      });
    }));
    _defineProperty(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [operator, approved]
      });
    }));
    _defineProperty(this, "airdrop", buildTransactionFunction(async function(tokenId, addresses) {
      let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0];
      const from2 = await _this.contractWrapper.getSignerAddress();
      const balanceOf = await _this.balanceOf(from2, tokenId);
      const input = await AirdropInputSchema.parseAsync(addresses);
      const totalToAirdrop = input.reduce((prev2, curr) => {
        return BigNumber.from(prev2).add(BigNumber.from(curr?.quantity || 1));
      }, BigNumber.from(0));
      if (balanceOf.lt(BigNumber.from(totalToAirdrop))) {
        throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);
      }
      const encoded = input.map((_ref) => {
        let {
          address: to,
          quantity
        } = _ref;
        return _this.contractWrapper.readContract.interface.encodeFunctionData("safeTransferFrom", [from2, to, tokenId, quantity, data]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: _this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "mint", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    _defineProperty(this, "mintTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    _defineProperty(this, "mintAdditionalSupply", buildTransactionFunction(async (tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
    }));
    _defineProperty(this, "mintAdditionalSupplyTo", buildTransactionFunction(async (receiver, tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);
    }));
    _defineProperty(this, "mintBatch", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    _defineProperty(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      return assertEnabled(this.mintable?.batch, FEATURE_EDITION_BATCH_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    _defineProperty(this, "burn", buildTransactionFunction(async (tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens.prepare(tokenId, amount);
    }));
    _defineProperty(this, "burnFrom", buildTransactionFunction(async (account, tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from.prepare(account, tokenId, amount);
    }));
    _defineProperty(this, "burnBatch", buildTransactionFunction(async (tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch.prepare(tokenIds, amounts);
    }));
    _defineProperty(this, "burnBatchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom.prepare(account, tokenIds, amounts);
    }));
    _defineProperty(this, "lazyMint", buildTransactionFunction(async (metadatas, options2) => {
      return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint.prepare(metadatas, options2);
    }));
    _defineProperty(this, "claim", buildTransactionFunction(async (tokenId, quantity, options2) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options2);
    }));
    _defineProperty(this, "claimTo", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options2) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options2);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, tokenId, quantity, options2);
      }
      throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc1155Enumerable();
    this.mintable = this.detectErc1155Mintable();
    this.burnable = this.detectErc1155Burnable();
    this.lazyMintable = this.detectErc1155LazyMintable();
    this.signatureMintable = this.detectErc1155SignatureMintable();
    this.claimCustom = this.detectErc1155Claimable();
    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();
    this._chainId = chainId;
  }
  /**
   * @internal
   */
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  ////// Standard ERC1155 functions //////
  /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC1155
   */
  async get(tokenId) {
    const [supply, metadata] = await Promise.all([this.contractWrapper.readContract.totalSupply(tokenId).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner: AddressZero$1,
      metadata,
      type: "ERC1155",
      supply: supply.toString()
    };
  }
  /**
   * Get the total supply of a specific token
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.totalSupply(tokenId);
   * ```
   * @param tokenId - The token ID to get the total supply of
   * @returns the total supply
   * @twfeature ERC1155
   */
  async totalSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * // Address of the wallet to check NFT balance
   * const walletAddress = "{{wallet_address}}";
   * const tokenId = 0; // Id of the NFT to check
   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);
   * ```
   * @twfeature ERC1155
   */
  async balanceOf(address, tokenId) {
    return await this.contractWrapper.readContract.balanceOf(await resolveAddress(address), tokenId);
  }
  /**
   * Get NFT balance for the currently connected wallet
   */
  async balance(tokenId) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
  }
  /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */
  async isApproved(address, operator) {
    return await this.contractWrapper.readContract.isApprovedForAll(await resolveAddress(address), await resolveAddress(operator));
  }
  /**
   * Return the next available token ID to mint
   * @internal
   */
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.readContract.nextTokenIdToMint();
    } else {
      throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
    }
  }
  ////// ERC1155 Enumerable Extension //////
  /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc1155.getAll();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC1155Enumerable
   */
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);
  }
  /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc1155.totalCount();
   * console.log(count);
   * ```
   * @returns the total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */
  async totalCount() {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();
  }
  /**
   * Get the total supply of a specific NFT
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */
  async totalCirculatingSupply(tokenId) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc1155.getOwned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC1155Enumerable
   */
  async getOwned(walletAddress) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);
  }
  /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadataWithSupply - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   * @twfeature ERC1155Mintable
   */
  async getMintTransaction(receiver, metadataWithSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).getMintTransaction(receiver, metadataWithSupply);
  }
  ////// ERC1155 Claimable Extension //////
  /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Optional claim verification data (e.g. price, currency, etc...)
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */
  async getClaimTransaction(destinationAddress, tokenId, quantity, options2) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options2);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options2);
    }
    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
  }
  /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);
   * ```
   * @twfeature ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
   */
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;
  }
  ////// ERC1155 SignatureMintable Extension //////
  /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation
   * const signedPayload = contract.erc1155.signature().generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc1155.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC1155SignatureMintable
   */
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);
  }
  ////// ERC1155 DelayedReveal Extension //////
  /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc1155.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC1155Revealable
   */
  get revealer() {
    return assertEnabled(this.lazyMintable?.revealer, FEATURE_EDITION_REVEALABLE);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * @internal
   * @param tokenId - the token Id to fetch
   */
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.readContract.uri(tokenId);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  detectErc1155Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) {
      return new Erc1155Enumerable(this, this.contractWrapper);
    }
  }
  detectErc1155Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) {
      return new Erc1155Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) {
      return new Erc1155Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV1") || detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV2")) {
      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) {
      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimCustom")) {
      return new ERC1155Claimable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV2")) {
      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
}
class Erc1155Burnable {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_BURNABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "tokens", buildTransactionFunction(async (tokenId, amount) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.from.prepare(account, tokenId, amount);
    }));
    _defineProperty(this, "from", buildTransactionFunction(async (account, tokenId, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await resolveAddress(account), tokenId, amount]
      });
    }));
    _defineProperty(this, "batch", buildTransactionFunction(async (tokenIds, amounts) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.batchFrom.prepare(account, tokenIds, amounts);
    }));
    _defineProperty(this, "batchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnBatch",
        args: [await resolveAddress(account), tokenIds, amounts]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
}
class Erc1155Enumerable {
  constructor(erc1155, contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_EDITION_ENUMERABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get All NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.edition.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */
  async all(queryParams) {
    const start2 = BigNumber.from(queryParams?.start || 0).toNumber();
    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalCount()).toNumber(), start2 + count);
    return await Promise.all([...Array(maxId - start2).keys()].map((i2) => this.erc1155.get((start2 + i2).toString())));
  }
  /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCount() {
    return await this.contractWrapper.readContract.nextTokenIdToMint();
  }
  /**
   * Get the supply of token for a given tokenId.
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns the total number of NFTs minted in this contract
   * @public
   */
  async totalCirculatingSupply(tokenId) {
    return await this.contractWrapper.readContract.totalSupply(tokenId);
  }
  /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.edition.query.owned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   */
  async owned(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    const maxId = await this.contractWrapper.readContract.nextTokenIdToMint();
    const balances = await this.contractWrapper.readContract.balanceOfBatch(Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys()));
    const ownedBalances = balances.map((b2, i2) => {
      return {
        tokenId: i2,
        balance: b2
      };
    }).filter((b2) => b2.balance.gt(0));
    return await Promise.all(ownedBalances.map(async (b2) => {
      const editionMetadata = await this.erc1155.get(b2.tokenId.toString());
      return {
        ...editionMetadata,
        owner: address,
        quantityOwned: b2.balance.toString()
      };
    }));
  }
}
class Erc1155LazyMintable {
  /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.edition.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.edition.drop.revealer.reveal(batchId, "my secret password");
   * ```
   */
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_LAZY_MINTABLE_V2.name);
    _defineProperty(this, "revealer", void 0);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "lazyMint", buildTransactionFunction(async (metadatas, options2) => {
      const startFileNumber = await this.erc1155.nextTokenIdToMint();
      const batch2 = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options2);
      const baseUri = batch2[0].substring(0, batch2[0].lastIndexOf("/"));
      for (let i2 = 0; i2 < batch2.length; i2++) {
        const uri = batch2[i2].substring(0, batch2[i2].lastIndexOf("/"));
        if (baseUri !== uri) {
          throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
        }
      }
      const parse2 = (receipt) => {
        const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = event[0].args.endTokenId;
        const results2 = [];
        for (let id2 = startingIndex; id2.lte(endingIndex); id2 = id2.add(1)) {
          results2.push({
            id: id2,
            receipt,
            data: () => this.erc1155.getTokenMetadata(id2)
          });
        }
        return results2;
      };
      const prebuiltInfo = await getPrebuiltInfo(this.contractWrapper.readContract.address, this.contractWrapper.getProvider());
      if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch2.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`],
          parse: parse2
        });
      } else {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch2.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`, toUtf8Bytes("")],
          parse: parse2
        });
      }
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc1155Revealable();
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  detectErc1155Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());
    }
    return void 0;
  }
  isLegacyEditionDropContract(contractWrapper, info) {
    return info && info.type === "DropERC1155" && info.version < 3 || false;
  }
}
class Erc1155Mintable {
  /**
   * Batch mint Tokens to many addresses
   */
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "batch", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const tx = await this.getMintTransaction(to, metadataWithSupply);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TransferSingle", receipt?.logs);
        if (event.length === 0) {
          throw new Error("TransferSingleEvent event not found");
        }
        const id2 = event[0].args.id;
        return {
          id: id2,
          receipt,
          data: () => this.erc1155.get(id2.toString())
        };
      });
      return tx;
    }));
    _defineProperty(this, "additionalSupplyTo", buildTransactionFunction(async (to, tokenId, additionalSupply) => {
      const metadata = await this.erc1155.getTokenMetadata(tokenId);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [await resolveAddress(to), tokenId, metadata.uri, additionalSupply],
        parse: (receipt) => {
          return {
            id: BigNumber.from(tokenId),
            receipt,
            data: () => this.erc1155.get(tokenId)
          };
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc1155BatchMintable();
  }
  /**
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   */
  async getMintTransaction(to, metadataWithSupply) {
    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await resolveAddress(to), MaxUint256$1, uri, metadataWithSupply.supply]
    });
  }
  detectErc1155BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) {
      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
    }
  }
}
class Erc1155BatchMintable {
  constructor(erc1155, contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_EDITION_BATCH_MINTABLE.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "erc1155", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const metadatas = metadataWithSupply.map((a2) => a2.metadata);
      const supplies = metadataWithSupply.map((a2) => a2.supply);
      const uris = await uploadOrExtractURIs(metadatas, this.storage);
      const resolvedAddress = await resolveAddress(to);
      const encoded = await Promise.all(uris.map(async (uri, index2) => this.contractWrapper.readContract.interface.encodeFunctionData("mintTo", [resolvedAddress, MaxUint256$1, uri, supplies[index2]])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e2) => {
            const id2 = e2.args.tokenIdMinted;
            return {
              id: id2,
              receipt,
              data: () => this.erc1155.get(id2)
            };
          });
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
}
class GasCostEstimator {
  constructor(contractWrapper) {
    _defineProperty(this, "contractWrapper", void 0);
    this.contractWrapper = contractWrapper;
  }
  /**
   * Estimates the cost of gas in native token of the current chain
   * Pass in the same parameters as the contract's function.
   * @remarks Estimate the cost of gas in native token of the current chain
   * @example
   * ```javascript
   * const costOfClaim = await nftDrop?.estimator.gasCostOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function
   * @public
   */
  async gasCostOf(fn2, args) {
    const price = await this.contractWrapper.getPreferredGasPrice();
    const gasUnits = await this.contractWrapper.estimateGas(fn2, args);
    return formatEther(gasUnits.mul(price));
  }
  /**
   * Estimates the gas limit of a transaction
   * Pass in the same parameters as the contract's function.
   * @remarks Estimates the gas limit of a transaction
   * @example
   * ```javascript
   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns the estimated gas limit of the transaction
   * @public
   */
  async gasLimitOf(fn2, args) {
    return this.contractWrapper.estimateGas(fn2, args);
  }
  /**
   * Returns the current gas price in gwei
   * @remarks Get the current gas price in gwei
   * @example
   * ```javascript
   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();
   * ```
   * @returns the current gas price in gwei
   * @public
   */
  async currentGasPriceInGwei() {
    const price = await this.contractWrapper.getProvider().getGasPrice();
    return formatUnits(price, "gwei");
  }
}
class ContractOwner {
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_OWNER.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async (address) => {
      const resolvedAddress = await resolveAddress(address);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setOwner",
        args: [resolvedAddress]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  /**
   * Get the current owner of the contract
   * @example
   * ```javascript
   * await contract.owner.get();
   * console.log("Owner address: ", ownerAddress);
   * ```
   * @returns the owner address
   * @twfeature Ownable
   */
  async get() {
    return this.contractWrapper.readContract.owner();
  }
}
function cleanCurrencyAddress(currencyAddress) {
  if (isNativeToken(currencyAddress)) {
    return NATIVE_TOKEN_ADDRESS;
  }
  return currencyAddress;
}
async function isTokenApprovedForTransfer(provider2, transferrerContractAddress, assetContract, tokenId, owner) {
  try {
    const erc165 = new Contract(assetContract, ERC165Abi, provider2);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(assetContract, Erc721Abi, provider2);
      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);
      if (approved) {
        return true;
      }
      let approvedAddress;
      try {
        approvedAddress = await asset.getApproved(tokenId);
      } catch (e2) {
      }
      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();
    } else if (isERC1155) {
      const asset = new Contract(assetContract, Erc1155Abi, provider2);
      return await asset.isApprovedForAll(owner, transferrerContractAddress);
    } else {
      console.error("Contract does not implement ERC 1155 or ERC 721.");
      return false;
    }
  } catch (err) {
    console.error("Failed to check if token is approved", err);
    return false;
  }
}
async function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from2) {
  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options);
  const isERC721 = await erc165.readContract.supportsInterface(InterfaceId_IERC721);
  const isERC1155 = await erc165.readContract.supportsInterface(InterfaceId_IERC1155);
  if (isERC721) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc721Abi, contractWrapper.options);
    const approved = await asset.readContract.isApprovedForAll(from2, marketplaceAddress);
    if (!approved) {
      const isTokenApproved = (await asset.readContract.getApproved(tokenId)).toLowerCase() === marketplaceAddress.toLowerCase();
      if (!isTokenApproved) {
        await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
      }
    }
  } else if (isERC1155) {
    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc1155Abi, contractWrapper.options);
    const approved = await asset.readContract.isApprovedForAll(from2, marketplaceAddress);
    if (!approved) {
      await asset.sendTransaction("setApprovalForAll", [marketplaceAddress, true]);
    }
  } else {
    throw Error("Contract must implement ERC 1155 or ERC 721.");
  }
}
function validateNewListingParam(param) {
  invariant$1(param.assetContractAddress !== void 0 && param.assetContractAddress !== null, "Asset contract address is required");
  invariant$1(param.buyoutPricePerToken !== void 0 && param.buyoutPricePerToken !== null, "Buyout price is required");
  invariant$1(param.listingDurationInSeconds !== void 0 && param.listingDurationInSeconds !== null, "Listing duration is required");
  invariant$1(param.startTimestamp !== void 0 && param.startTimestamp !== null, "Start time is required");
  invariant$1(param.tokenId !== void 0 && param.tokenId !== null, "Token ID is required");
  invariant$1(param.quantity !== void 0 && param.quantity !== null, "Quantity is required");
  switch (param.type) {
    case "NewAuctionListing": {
      invariant$1(param.reservePricePerToken !== void 0 && param.reservePricePerToken !== null, "Reserve price is required");
    }
  }
}
async function mapOffer(provider2, listingId, offer) {
  return {
    quantity: offer.quantityDesired,
    pricePerToken: offer.pricePerToken,
    currencyContractAddress: offer.currency,
    buyerAddress: offer.offeror,
    quantityDesired: offer.quantityWanted,
    currencyValue: await fetchCurrencyValue(provider2, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),
    listingId
  };
}
function isWinningBid(winningPrice, newBidPrice, bidBuffer) {
  bidBuffer = BigNumber.from(bidBuffer);
  winningPrice = BigNumber.from(winningPrice);
  newBidPrice = BigNumber.from(newBidPrice);
  if (winningPrice.eq(BigNumber.from(0))) {
    return false;
  }
  const buffer2 = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);
  return buffer2.gte(bidBuffer);
}
async function getAllInBatches(start2, end2, fn2) {
  let batches = [];
  while (end2 - start2 > DEFAULT_QUERY_ALL_COUNT) {
    batches.push(fn2(start2, start2 + DEFAULT_QUERY_ALL_COUNT - 1));
    start2 += DEFAULT_QUERY_ALL_COUNT;
  }
  batches.push(fn2(start2, end2 - 1));
  return await Promise.all(batches);
}
const DirectListingInputParamsSchema = z$2.object({
  /**
   * The address of the asset being listed.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token to list.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The price to pay per unit of NFTs listed.
   */
  pricePerToken: AmountSchema,
  /**
   * The start time of the listing.
   */
  startTimestamp: RawDateSchema.default(/* @__PURE__ */ new Date()),
  /**
   * The end time of the listing.
   */
  endTimestamp: EndDateSchema,
  /**
   * Whether the listing is reserved to be bought from a specific set of buyers.
   */
  isReservedListing: z$2.boolean().default(false)
});
class MarketplaceV3DirectListings {
  // utilities
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_DIRECT_LISTINGS.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "createListing", buildTransactionFunction(async (listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedListing.startTimestamp.lt(blockTime)) {
        parsedListing.startTimestamp = BigNumber.from(blockTime);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createListing",
        args: [{
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
    }));
    _defineProperty(this, "createListingsBatch", buildTransactionFunction(async (listings) => {
      const data = await Promise.all(listings.map(async (listing) => {
        const tx = await this.createListing.prepare(listing);
        return tx.encode();
      }));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
          return events.map((event) => {
            return {
              id: event.args.listingId,
              receipt
            };
          });
        }
      });
    }));
    _defineProperty(this, "updateListing", buildTransactionFunction(async (listingId, listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "updateListing",
        args: [listingId, {
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("UpdatedListing", receipt?.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
    }));
    _defineProperty(this, "cancelListing", buildTransactionFunction(async (listingId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelListing",
        args: [listingId]
      });
    }));
    _defineProperty(this, "buyFromListing", buildTransactionFunction(async (listingId, quantityDesired, receiver) => {
      if (receiver) {
        receiver = await resolveAddress(receiver);
      }
      const listing = await this.validateListing(BigNumber.from(listingId));
      const {
        valid,
        error
      } = await this.isStillValidListing(listing, quantityDesired);
      if (!valid) {
        throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
      }
      const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
      const quantity = BigNumber.from(quantityDesired);
      const value = BigNumber.from(listing.pricePerToken).mul(quantity);
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "buyFromListing",
        args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],
        overrides
      });
    }));
    _defineProperty(this, "approveBuyerForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (!isApproved) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, true]
        });
      } else {
        throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);
      }
    }));
    _defineProperty(this, "revokeBuyerApprovalForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (isApproved) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, false]
        });
      } else {
        throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);
      }
    }));
    _defineProperty(this, "approveCurrencyForListing", buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        invariant$1(pricePerTokenInCurrency === listing.pricePerToken, "Approving listing currency with a different price.");
      }
      const currencyPrice = await this.contractWrapper.readContract.currencyPriceForListing(listingId, resolvedCurrencyAddress);
      invariant$1(pricePerTokenInCurrency === currencyPrice, "Currency already approved with this price.");
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]
      });
    }));
    _defineProperty(this, "revokeCurrencyApprovalForListing", buildTransactionFunction(async (listingId, currencyContractAddress) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        throw new Error(`Can't revoke approval for main listing currency.`);
      }
      const currencyPrice = await this.contractWrapper.readContract.currencyPriceForListing(listingId, resolvedCurrencyAddress);
      invariant$1(!currencyPrice.isZero(), "Currency not approved.");
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of direct listings
   *
   * @returns Returns the total number of direct listings created.
   * @public
   *
   * @example
   * ```javascript
   * const totalListings = await contract.directListings.getTotalCount();
   * ```
   * @twfeature DirectListings
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalListings();
  }
  /**
   * Get all direct listings
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   * @twfeature DirectListings
   */
  async getAll(filter3) {
    const totalListings = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalListings.toNumber();
    if (end2 === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllListings);
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter3);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  /**
   * Get all valid direct listings
   *
   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   * @twfeature DirectListings
   */
  async getAllValid(filter3) {
    const totalListings = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalListings.toNumber();
    if (end2 === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllValidListings);
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter3);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  /**
   * Get a single direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   *
   * @param listingId - the listing id
   * @returns the Direct listing object
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   * @twfeature DirectListings
   */
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.getListing(listingId);
    return await this.mapListing(listing);
  }
  /**
   * Check if a buyer is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, "{{wallet_address}}");
   *
   * @param listingId - the listing id
   * @param buyer - buyer address
   * @twfeature DirectListings
   */
  async isBuyerApprovedForListing(listingId, buyer) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    if (!listing.isReservedListing) {
      throw new Error(`Listing ${listingId} is not a reserved listing.`);
    }
    return await this.contractWrapper.readContract.isBuyerApprovedForListing(listingId, await resolveAddress(buyer));
  }
  /**
   * Check if a currency is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currency - currency address
   * @twfeature DirectListings
   */
  async isCurrencyApprovedForListing(listingId, currency) {
    await this.validateListing(BigNumber.from(listingId));
    return await this.contractWrapper.readContract.isCurrencyApprovedForListing(listingId, await resolveAddress(currency));
  }
  /**
   * Check price per token for an approved currency
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currencyContractAddress - currency contract address
   * @twfeature DirectListings
   */
  async currencyPriceForListing(listingId, currencyContractAddress) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    if (resolvedCurrencyAddress === listing.currencyContractAddress) {
      return listing.pricePerToken;
    }
    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);
    if (!isApprovedCurrency) {
      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);
    }
    return await this.contractWrapper.readContract.currencyPriceForListing(listingId, resolvedCurrencyAddress);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if listing could not be found
   *
   * @param listingId - Listing to check for
   */
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the auction listing to the direct listing interface.
   *
   * @internal
   * @param listing - The listing to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapListing(listing) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (listing.status) {
      case 1:
        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      assetContractAddress: listing.assetContract,
      currencyContractAddress: listing.currency,
      pricePerToken: listing.pricePerToken.toString(),
      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId.toString(),
      quantity: listing.quantity.toString(),
      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),
      creatorAddress: listing.listingCreator,
      isReservedListing: listing.reserved,
      status
    };
  }
  /**
   * Use this method to check if a direct listing is still valid.
   *
   * Ways a direct listing can become invalid:
   * 1. The asset holder transferred the asset to another wallet
   * 2. The asset holder burned the asset
   * 3. The asset holder removed the approval on the marketplace
   *
   * @internal
   * @param listing - The listing to check.
   * @returns - True if the listing is valid, false otherwise.
   */
  async isStillValidListing(listing, quantity) {
    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider2 = this.contractWrapper.getProvider();
    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider2);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new Contract(listing.assetContractAddress, Erc721Abi, provider2);
      let owner;
      try {
        owner = await asset.ownerOf(listing.tokenId);
      } catch (e2) {
      }
      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();
      return {
        valid,
        error: valid ? void 0 : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const asset = new Contract(listing.assetContractAddress, Erc1155Abi, provider2);
      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? void 0 : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
  async applyFilter(listings, filter3) {
    let rawListings = [...listings];
    if (filter3) {
      if (filter3.seller) {
        const resolvedSeller = await resolveAddress(filter3.seller);
        rawListings = rawListings.filter((seller) => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
      }
      if (filter3.tokenContract) {
        const resolvedToken = await resolveAddress(filter3.tokenContract);
        rawListings = rawListings.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter3.tokenId !== void 0) {
        rawListings = rawListings.filter((tokenContract) => tokenContract.tokenId.toString() === filter3?.tokenId?.toString());
      }
    }
    return filter3?.count && filter3.count < rawListings.length ? rawListings.slice(0, filter3.count) : rawListings;
  }
}
const EnglishAuctionInputParamsSchema = z$2.object({
  /**
   * The address of the asset being auctioned.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token to auction.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The minimum price that a bid must be in order to be accepted.
   */
  minimumBidAmount: AmountSchema,
  /**
   * The buyout price of the auction.
   */
  buyoutBidAmount: AmountSchema,
  /**
   * This is a buffer e.g. x seconds.
   *
   * If a new winning bid is made less than x seconds before expirationTimestamp, the
   * expirationTimestamp is increased by x seconds.
   */
  timeBufferInSeconds: BigNumberishSchema.default(900),
  // 15 minutes by default
  /**
   * This is a buffer in basis points e.g. x%.
   *
   * To be considered as a new winning bid, a bid must be at least x% greater than
   * the current winning bid.
   */
  bidBufferBps: BigNumberishSchema.default(500),
  // 5% by default
  /**
   * The start time of the auction.
   */
  startTimestamp: RawDateSchema.default(/* @__PURE__ */ new Date()),
  /**
   * The end time of the auction.
   */
  endTimestamp: EndDateSchema
});
class MarketplaceV3EnglishAuctions {
  // utilities
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_ENGLISH_AUCTIONS.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "createAuction", buildTransactionFunction(async (auction) => {
      const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);
      const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedAuction.startTimestamp.lt(blockTime)) {
        parsedAuction.startTimestamp = BigNumber.from(blockTime);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAuction",
        args: [{
          assetContract: parsedAuction.assetContractAddress,
          tokenId: parsedAuction.tokenId,
          quantity: parsedAuction.quantity,
          currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),
          minimumBidAmount: normalizedMinBidAmount,
          buyoutBidAmount: normalizedBuyoutAmount,
          timeBufferInSeconds: parsedAuction.timeBufferInSeconds,
          bidBufferBps: parsedAuction.bidBufferBps,
          startTimestamp: parsedAuction.startTimestamp,
          endTimestamp: parsedAuction.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewAuction", receipt.logs)[0];
          return {
            id: event.args.auctionId,
            receipt
          };
        }
      });
    }));
    _defineProperty(this, "createAuctionsBatch", buildTransactionFunction(async (listings) => {
      const data = await Promise.all(listings.map(async (listing) => {
        const tx = await this.createAuction.prepare(listing);
        return tx.encode();
      }));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewAuction", receipt?.logs);
          return events.map((event) => {
            return {
              id: event.args.auctionId,
              receipt
            };
          });
        }
      });
    }));
    _defineProperty(this, "buyoutAuction", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);
      return this.makeBid.prepare(auctionId, formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));
    }));
    _defineProperty(this, "makeBid", buildTransactionFunction(async (auctionId, bidAmount) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);
      if (normalizedBidAmount.eq(BigNumber.from(0))) {
        throw new Error("Cannot make a bid with 0 value");
      }
      if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {
        throw new Error("Bid amount must be less than or equal to buyoutBidAmount");
      }
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);
        invariant$1(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
      } else {
        const tokenPrice = normalizedBidAmount;
        const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);
        invariant$1(tokenPrice.gte(minimumBidAmount), "Bid price is too low based on minimum bid amount");
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "bidInAuction",
        args: [auctionId, normalizedBidAmount],
        overrides
      });
    }));
    _defineProperty(this, "cancelAuction", buildTransactionFunction(async (auctionId) => {
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        throw new Error(`Bids already made.`);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelAuction",
        args: [auctionId]
      });
    }));
    _defineProperty(this, "closeAuctionForBidder", buildTransactionFunction(async (auctionId, closeFor) => {
      if (!closeFor) {
        closeFor = await this.contractWrapper.getSignerAddress();
      }
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionTokens",
          args: [BigNumber.from(auctionId)]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    _defineProperty(this, "closeAuctionForSeller", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionPayout",
          args: [BigNumber.from(auctionId)]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    _defineProperty(this, "executeSale", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        const winningBid = await this.getWinningBid(auctionId);
        invariant$1(winningBid, "No winning bid found");
        const closeForSeller = this.encoder.encode("collectAuctionPayout", [auctionId]);
        const closeForBuyer = this.encoder.encode("collectAuctionTokens", [auctionId]);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [[closeForSeller, closeForBuyer]]
        });
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of english auctions
   *
   * @returns Returns the total number of auctions created.
   * @public
   *
   * @example
   * ```javascript
   * const totalAuctions = await contract.englishAuctions.getTotalCount();
   * ```
   * @twfeature EnglishAuctions
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalAuctions();
  }
  /**
   * Get all english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   * @twfeature EnglishAuctions
   */
  async getAll(filter3) {
    const totalAuctions = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalAuctions.toNumber();
    if (end2 === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllAuctions);
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter3);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  /**
   * Get all valid english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   * @twfeature EnglishAuctions
   */
  async getAllValid(filter3) {
    const totalAuctions = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalAuctions.toNumber();
    if (end2 === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllValidAuctions);
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter3);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  /**
   * Get a single english auction
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const auction = await contract.englishAuctions.getAuction(auctionId);
   * ```
   *
   * @param auctionId - the auction Id
   * @returns the Auction object
   * @twfeature EnglishAuctions
   */
  async getAuction(auctionId) {
    const auction = await this.contractWrapper.readContract.getAuction(auctionId);
    return await this.mapAuction(auction);
  }
  /**
   * Get winning bid of an english auction
   *
   * @remarks Get the current highest bid of an active auction.
   *
   * @example
   * ```javascript
   * // The ID of the auction
   * const auctionId = 0;
   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @twfeature EnglishAuctions
   */
  async getWinningBid(auctionId) {
    await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.readContract.getWinningBid(auctionId);
    if (bid._bidder === AddressZero$1) {
      return void 0;
    }
    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());
  }
  /**
   * Check if a bid is or will be a winning bid
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const bidAmount = 100;
   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);
   * ```
   *
   * @param auctionId - Auction Id
   * @param bidAmount - Amount to bid
   * @returns true if the bid is or will be a winning bid
   * @twfeature EnglishAuctions
   */
  async isWinningBid(auctionId, bidAmount) {
    return await this.contractWrapper.readContract.isNewWinningBid(auctionId, bidAmount);
  }
  /**
   * Get the winner for a specific english auction
   *
   * @remarks Get the winner of the auction after an auction ends.
   *
   * @example
   * ```javascript
   * // The auction ID of a closed english auction
   * const auctionId = 0;
   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @returns the address of the auction winner
   * @twfeature EnglishAuctions
   */
  async getWinner(auctionId) {
    const auction = await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.readContract.getWinningBid(auctionId);
    const now2 = BigNumber.from(Math.floor(Date.now() / 1e3));
    const endTime = BigNumber.from(auction.endTimeInSeconds);
    if (now2.gt(endTime) && bid._bidder !== AddressZero$1) {
      return bid._bidder;
    }
    const closedAuctions = await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed());
    const closed = closedAuctions.find((a2) => a2.args.auctionId.eq(BigNumber.from(auctionId)));
    if (!closed) {
      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);
    }
    return closed.args.winningBidder;
  }
  /**
   * Get the buffer for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the buffer for
   * const auctionId = "0";
   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);
   * ```
   *
   * @param auctionId - id of the auction
   * @returns the buffer in basis points
   * @twfeature EnglishAuctions
   */
  async getBidBufferBps(auctionId) {
    return (await this.getAuction(auctionId)).bidBufferBps;
  }
  /**
   * Get the minimum next bid for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the minimum next bid for
   * const auctionId = "0";
   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);
   * ```
   *
   * @returns the minimum bid a user can place to outbid the previous highest bid
   * @param auctionId - id of the auction
   * @twfeature EnglishAuctions
   */
  async getMinimumNextBid(auctionId) {
    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), await this.validateAuction(BigNumber.from(auctionId))]);
    const currentBidOrReservePrice = winningBid ? (
      // if there is a winning bid use the value of it
      BigNumber.from(winningBid.bidAmount)
    ) : (
      // if there is no winning bid use the reserve price
      BigNumber.from(auction.minimumBidAmount)
    );
    const minimumNextBid = currentBidOrReservePrice.add(
      // the addition of the current bid and the buffer
      // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))
      currentBidOrReservePrice.mul(currentBidBufferBps).div(1e4)
    );
    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if auction could not be found
   *
   * @param auctionId - Auction to check for
   */
  async validateAuction(auctionId) {
    try {
      return await this.getAuction(auctionId);
    } catch (err) {
      console.error(`Error getting the auction with id ${auctionId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the auction to the auction interface.
   *
   * @internal
   * @param auction - The auction to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapAuction(auction) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (auction.status) {
      case 1:
        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: auction.auctionId.toString(),
      creatorAddress: auction.auctionCreator,
      assetContractAddress: auction.assetContract,
      tokenId: auction.tokenId.toString(),
      quantity: auction.quantity.toString(),
      currencyContractAddress: auction.currency,
      minimumBidAmount: auction.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),
      buyoutBidAmount: auction.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),
      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),
      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),
      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),
      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),
      status
    };
  }
  /**
   * Maps an auction-bid to the strict interface
   *
   * @internal
   * @param bid
   * @returns - A `Bid` object
   */
  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {
    const resolvedBidderAddress = await resolveAddress(bidderAddress);
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    return {
      auctionId,
      bidderAddress: resolvedBidderAddress,
      currencyContractAddress: resolvedCurrencyAddress,
      bidAmount,
      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)
    };
  }
  async applyFilter(auctions, filter3) {
    let rawAuctions = [...auctions];
    if (filter3) {
      if (filter3.seller) {
        const resolvedSeller = await resolveAddress(filter3.seller);
        rawAuctions = rawAuctions.filter((seller) => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
      }
      if (filter3.tokenContract) {
        const resolvedToken = await resolveAddress(filter3.tokenContract);
        rawAuctions = rawAuctions.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter3.tokenId !== void 0) {
        rawAuctions = rawAuctions.filter((tokenContract) => tokenContract.tokenId.toString() === filter3?.tokenId?.toString());
      }
    }
    return filter3?.count && filter3.count < rawAuctions.length ? rawAuctions.slice(0, filter3.count) : rawAuctions;
  }
}
const OfferInputParamsSchema = z$2.object({
  /**
   * The address of the asset being sought.
   */
  assetContractAddress: AddressOrEnsSchema,
  /**
   * The ID of the token.
   */
  tokenId: BigNumberishSchema,
  /**
   * The quantity of tokens to buy.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: BigNumberishSchema.default(1),
  /**
   * The address of the currency offered for the NFTs.
   */
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  /**
   * The total offer amount for the NFTs.
   */
  totalPrice: AmountSchema,
  /**
   * The end time of the offer.
   */
  endTimestamp: EndDateSchema
});
class MarketplaceV3Offers {
  // utilities
  constructor(contractWrapper, storage) {
    _defineProperty(this, "featureName", FEATURE_OFFERS.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "makeOffer", buildTransactionFunction(async (offer) => {
      const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);
      const chainId = await this.contractWrapper.getChainID();
      const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;
      const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "makeOffer",
        args: [{
          assetContract: parsedOffer.assetContractAddress,
          tokenId: parsedOffer.tokenId,
          quantity: parsedOffer.quantity,
          currency,
          totalPrice: normalizedTotalPrice,
          expirationTimestamp: parsedOffer.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewOffer", receipt?.logs);
          return {
            id: event[0].args.offerId,
            receipt
          };
        }
      });
    }));
    _defineProperty(this, "cancelOffer", buildTransactionFunction(async (offerId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelOffer",
        args: [offerId]
      });
    }));
    _defineProperty(this, "acceptOffer", buildTransactionFunction(async (offerId) => {
      const offer = await this.validateOffer(BigNumber.from(offerId));
      const {
        valid,
        error
      } = await this.isStillValidOffer(offer);
      if (!valid) {
        throw new Error(`Offer ${offerId} is no longer valid. ${error}`);
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "acceptOffer",
        args: [offerId],
        overrides
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /** ******************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the total number of offers
   *
   * @returns Returns the total number of offers created.
   * @public
   *
   * @example
   * ```javascript
   * const totalOffers = await contract.offers.getTotalCount();
   * ```
   * @twfeature Offers
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalOffers();
  }
  /**
   * Get all offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   * @twfeature Offers
   */
  async getAll(filter3) {
    const totalOffers = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalOffers.toNumber();
    if (end2 === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllOffers);
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter3);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  /**
   * Get all valid offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   * @twfeature Offers
   */
  async getAllValid(filter3) {
    const totalOffers = await this.getTotalCount();
    let start2 = BigNumber.from(filter3?.start || 0).toNumber();
    let end2 = totalOffers.toNumber();
    if (end2 === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    let batches = await getAllInBatches(start2, end2, this.contractWrapper.readContract.getAllValidOffers);
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter3);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  /**
   * Get a single offer
   *
   * @example
   * ```javascript
   * const offerId = 0;
   * const offer = await contract.offers.getOffer(offerId);
   * ```
   *
   * @param offerId - the listing id
   * @returns the Direct listing object
   * @twfeature Offers
   */
  async getOffer(offerId) {
    const offer = await this.contractWrapper.readContract.getOffer(offerId);
    return await this.mapOffer(offer);
  }
  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/
  /**
   * Throws error if offer could not be found
   *
   * @param offerId - offer to check for
   */
  async validateOffer(offerId) {
    try {
      return await this.getOffer(offerId);
    } catch (err) {
      console.error(`Error getting the offer with id ${offerId}`);
      throw err;
    }
  }
  /**
   * Helper method maps the offer to the offer interface.
   *
   * @internal
   * @param offer - The offer to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapOffer(offer) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (offer.status) {
      case 1:
        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: offer.offerId.toString(),
      offerorAddress: offer.offeror,
      assetContractAddress: offer.assetContract,
      currencyContractAddress: offer.currency,
      tokenId: offer.tokenId.toString(),
      quantity: offer.quantity.toString(),
      totalPrice: offer.totalPrice.toString(),
      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),
      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),
      status
    };
  }
  /**
   * Use this method to check if an offer is still valid.
   *
   * Ways an offer can become invalid:
   * 1. The offer has expired
   * 2. The offeror doesn't have enough balance of currency tokens
   * 3. The offeror removed the approval of currency tokens on the marketplace
   *
   * @internal
   * @param offer - The offer to check.
   * @returns - True if the offer is valid, false otherwise.
   */
  async isStillValidOffer(offer) {
    const now2 = BigNumber.from(Math.floor(Date.now() / 1e3));
    if (now2.gt(offer.endTimeInSeconds)) {
      return {
        valid: false,
        error: `Offer with ID ${offer.id} has expired`
      };
    }
    const chainId = await this.contractWrapper.getChainID();
    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;
    const provider2 = this.contractWrapper.getProvider();
    const erc20 = new ContractWrapper(provider2, currency, ERC20Abi, {});
    const offerorBalance = await erc20.readContract.balanceOf(offer.offerorAddress);
    if (offerorBalance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`
      };
    }
    const offerorAllowance = await erc20.readContract.allowance(offer.offerorAddress, this.getAddress());
    if (offerorAllowance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`
      };
    }
    return {
      valid: true,
      error: ""
    };
  }
  async applyFilter(offers, filter3) {
    let rawOffers = [...offers];
    if (filter3) {
      if (filter3.offeror) {
        const resolvedOfferor = await resolveAddress(filter3.offeror);
        rawOffers = rawOffers.filter((offeror) => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());
      }
      if (filter3.tokenContract) {
        const resolvedToken = await resolveAddress(filter3.tokenContract);
        rawOffers = rawOffers.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter3.tokenId !== void 0) {
        rawOffers = rawOffers.filter((tokenContract) => tokenContract.tokenId.toString() === filter3?.tokenId?.toString());
      }
    }
    return filter3?.count && filter3.count < rawOffers.length ? rawOffers.slice(0, filter3.count) : rawOffers;
  }
}
class SmartWalletFactory {
  // utilities
  constructor(contractWrapper) {
    _defineProperty(this, "featureName", FEATURE_SMART_WALLET_FACTORY.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "createWallet", buildTransactionFunction(async (walletAdmin, extraData) => {
      if (await this.isWalletDeployed(walletAdmin, extraData)) {
        throw new Error(`Wallet already deployed for admin: ${walletAdmin}`);
      }
      let data = toUtf8Bytes("");
      if (extraData) {
        data = extraData;
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAccount",
        args: [walletAdmin, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("AccountCreated", receipt?.logs);
          return {
            address: event[0].args.account,
            receipt
          };
        }
      });
    }));
    this.contractWrapper = contractWrapper;
    this.events = new ContractEvents(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /*********************************
   * READ FUNCTIONS
   *******************************/
  /**
   * Get the deterministic address of the smart wallet that will be created
   *
   * @example
   * ```javascript
   * const walletAddress = await contract.smartWalletFactory.predictWalletAddress(admin);
   * ```
   * @param admin - The admin of the smart wallet.
   * @param extraData - (Optional) Extra data to be passed to the smart wallet on creation.
   * @returns the deterministic address of the smart wallet that will be created for the given admin.
   *
   * @twfeature SmartWalletFactory
   */
  async predictWalletAddress(admin, extraData) {
    let data = toUtf8Bytes("");
    if (extraData) {
      data = extraData;
    }
    return this.contractWrapper.readContract.getAddress(admin, data);
  }
  /**
   * Get all signers who have authority on the given smart wallet
   *
   * @example
   * ```javascript
   * const allSigners = await contract.smartWalletFactory.getAssociatedSigners(admin);
   * ```
   * @param wallet - The smart wallet address.
   * @returns all signers who have authority on the given smart wallet.
   *
   * @twfeature SmartWalletFactory
   */
  async getAssociatedSigners(wallet) {
    return this.contractWrapper.readContract.getSignersOfAccount(wallet);
  }
  /**
   * Get all wallets on which the given signer has authority
   *
   * @example
   * ```javascript
   * const allWallets = await contract.smartWalletFactory.getAssociatedWallets(admin);
   * ```
   * @param signer - The smart wallet address.
   * @returns all wallets on which the given signer has authority.
   *
   * @twfeature SmartWalletFactory
   */
  async getAssociatedWallets(signer) {
    return this.contractWrapper.readContract.getAccountsOfSigner(signer);
  }
  /**
   * Get all wallets
   *
   * @example
   * ```javascript
   * const allWallets = await contract.smartWalletFactory.getAllWallets();
   * ```
   *
   * @returns all wallets created via the smart wallet factory.
   *
   * @twfeature SmartWalletFactory
   */
  async getAllWallets() {
    const filter3 = {
      fromBlock: 0,
      toBlock: "latest"
    };
    const events = await this.events.getEvents("AccountCreated", filter3);
    return events.map((event) => {
      return {
        account: event.data.account,
        admin: event.data.accountAdmin
      };
    });
  }
  /**
   * Check if a smart wallet has been deployed for the given admin
   *
   * @param admin - The admin of the smart wallet.
   * @param extraData - (Optional) Extra data to be passed to the smart wallet on creation.
   * @returns whether the smart wallet has been deployed for the given admin.
   */
  async isWalletDeployed(admin, extraData) {
    const addr = await this.predictWalletAddress(admin, extraData);
    return isContractDeployed(addr, this.contractWrapper.getProvider());
  }
}
class SmartContract {
  // utilities
  /**
   * Handle royalties
   */
  get royalties() {
    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);
  }
  /**
   * Handle permissions
   */
  get roles() {
    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);
  }
  /**
   * Handle primary sales
   */
  get sales() {
    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);
  }
  /**
   * Handle platform fees
   */
  get platformFees() {
    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);
  }
  /**
   * Set and get the owner of the contract
   */
  get owner() {
    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);
  }
  /**
   * Auto-detects ERC20 standard functions.
   */
  get erc20() {
    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);
  }
  /**
   * Auto-detects ERC721 standard functions.
   */
  get erc721() {
    return assertEnabled(this.detectErc721(), FEATURE_NFT);
  }
  /**
   * Auto-detects ERC1155 standard functions.
   */
  get erc1155() {
    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);
  }
  /**
   * Auto-detects AppURI standard functions.
   */
  get app() {
    return assertEnabled(this.detectApp(), FEATURE_APPURI);
  }
  /**
   * Direct listings
   * @remarks Create and manage direct listings in your marketplace.
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   *
   * // And on the buyers side:
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired);
   * ```
   */
  get directListings() {
    return assertEnabled(this.detectDirectListings(), FEATURE_DIRECT_LISTINGS);
  }
  /**
   * Auctions
   * @remarks Create and manage auctions in your marketplace.
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "1000",
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "100", // 100 bps stands for 1%
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   *
   * // And on the buyers side:
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   */
  get englishAuctions() {
    return assertEnabled(this.detectEnglishAuctions(), FEATURE_ENGLISH_AUCTIONS);
  }
  /**
   * Offers
   * @remarks Make and manage offers.
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   *
   * // And on the seller's side:
   * // The ID of the offer you want to accept
   * const offerId = 0;
   * await contract.offers.acceptOffer(offerId);
   * ```
   */
  get offers() {
    return assertEnabled(this.detectOffers(), FEATURE_OFFERS);
  }
  /**
   * Smart Wallet Factory
   *
   * @remarks Create smart wallets and fetch data about them.
   * @example
   * ```javascript
   *
   * // Predict the address of the smart wallet that will be created for an admin.
   * const deterministicAddress = await contract.smartWalletFactory.predictWalletAddress(admin, extraData);
   *
   * // Create smart wallets
   * const tx = await contract.smartWalletFactory.createWallet(admin, extraData);
   * // the same as `deterministicAddress`
   * const smartWalletAddress = tx.address;
   *
   * // Get all smart wallets created by the factory
   * const allWallets = await contract.smartWalletFactory.getAllWallets();
   *
   * // Get all smart wallets on which a signer has been given authority.
   * const associatedWallets = await contract.smartWalletFactory.getAssociatedWallets(signer);
   *
   * // Get all signers who have been given authority on a smart wallet.
   * const associatedSigners = await contract.smartWalletFactory.getAssociatedSigners(smartWalletAddress);
   *
   * // Check whether a smart wallet has already been created for a given admin.
   * const isWalletDeployed = await contract.smartWalletFactory.isWalletDeployed(admin, extraData);
   * ```
   */
  get smartWalletFactory() {
    return assertEnabled(this.detectSmartWalletFactory(), FEATURE_SMART_WALLET_FACTORY);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(network, address, abi, storage) {
    let options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    let chainId = arguments.length > 5 ? arguments[5] : void 0;
    let contractWrapper = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : new ContractWrapper(network, address, abi, options2);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "interceptor", void 0);
    _defineProperty(this, "encoder", void 0);
    _defineProperty(this, "estimator", void 0);
    _defineProperty(this, "publishedMetadata", void 0);
    _defineProperty(this, "abi", void 0);
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "_chainId", void 0);
    this._chainId = chainId;
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.abi = AbiSchema.parse(abi || []);
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);
    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  /**
   * Prepare a transaction for sending
   */
  prepare(method, args, overrides) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method,
      args,
      overrides
    });
  }
  /**
   * Call any function on this contract
   * @example
   * ```javascript
   * // read functions will return the data from the contract
   * const myValue = await contract.call("myReadFunction");
   * console.log(myValue);
   *
   * // write functions will return the transaction receipt
   * const tx = await contract.call("myWriteFunction", [arg1, arg2]);
   * const receipt = tx.receipt;
   *
   * // Optionally override transaction options
   * await contract.call("myWriteFunction", [arg1, arg2], {
   *  gasLimit: 1000000, // override default gas limit
   *  value: ethers.utils.parseEther("0.1"), // send 0.1 ether with the contract call
   * };
   * ```
   * @param functionName - the name of the function to call
   * @param args - the arguments of the function
   */
  async call(functionName, args, overrides) {
    return this.contractWrapper.call(functionName, args, overrides);
  }
  /** ********************
   * FEATURE DETECTION
   * ********************/
  detectRoyalties() {
    if (detectContractFeature(this.contractWrapper, "Royalty")) {
      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
      return new ContractRoyalty(this.contractWrapper, metadata);
    }
    return void 0;
  }
  detectRoles() {
    if (detectContractFeature(this.contractWrapper, "Permissions")) {
      return new ContractRoles(this.contractWrapper, ALL_ROLES);
    }
    return void 0;
  }
  detectPrimarySales() {
    if (detectContractFeature(this.contractWrapper, "PrimarySale")) {
      return new ContractPrimarySale(this.contractWrapper);
    }
    return void 0;
  }
  detectPlatformFees() {
    if (detectContractFeature(this.contractWrapper, "PlatformFee")) {
      return new ContractPlatformFee(this.contractWrapper);
    }
    return void 0;
  }
  detectErc20() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc721() {
    if (detectContractFeature(this.contractWrapper, "ERC721")) {
      return new Erc721(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectErc1155() {
    if (detectContractFeature(this.contractWrapper, "ERC1155")) {
      return new Erc1155(this.contractWrapper, this.storage, this.chainId);
    }
    return void 0;
  }
  detectOwnable() {
    if (detectContractFeature(this.contractWrapper, "Ownable")) {
      return new ContractOwner(this.contractWrapper);
    }
    return void 0;
  }
  detectApp() {
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return new ContractAppURI(this.contractWrapper, metadata, this.storage);
    } else if (detectContractFeature(this.contractWrapper, "ContractMetadata")) {
      return new ContractAppURI(this.contractWrapper, metadata, this.storage);
    }
    return void 0;
  }
  detectDirectListings() {
    if (detectContractFeature(this.contractWrapper, "DirectListings")) {
      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectEnglishAuctions() {
    if (detectContractFeature(this.contractWrapper, "EnglishAuctions")) {
      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectOffers() {
    if (detectContractFeature(this.contractWrapper, "Offers")) {
      return new MarketplaceV3Offers(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  // ========== Smart account features ==========
  detectSmartWalletFactory() {
    if (detectContractFeature(this.contractWrapper, FEATURE_SMART_WALLET_FACTORY.name)) {
      return new SmartWalletFactory(this.contractWrapper);
    }
    return void 0;
  }
}
async function extractFunctions(predeployMetadataUri, storage) {
  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);
}
async function extractConstructorParams(predeployMetadataUri, storage) {
  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractConstructorParamsFromAbi(meta.abi);
}
let decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
let src;
let srcEnd;
let position$2 = 0;
const LEGACY_RECORD_INLINE_ID = 105;
const RECORD_DEFINITIONS_ID = 57342;
const RECORD_INLINE_ID = 57343;
const BUNDLED_STRINGS_ID = 57337;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
let sequentialMode = false;
class Decoder {
  constructor(options2) {
    if (options2) {
      if ((options2.keyMap || options2._keyMap) && !options2.useRecords) {
        options2.useRecords = false;
        options2.mapsAsObjects = true;
      }
      if (options2.useRecords === false && options2.mapsAsObjects === void 0) {
        options2.mapsAsObjects = true;
      }
      if (options2.getStructures) {
        options2.getShared = options2.getStructures;
      }
      if (options2.getShared && !options2.structures) {
        (options2.structures = []).uninitialized = true;
      }
      if (options2.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k2, v2] of Object.entries(options2.keyMap)) {
          this.mapKey.set(v2, k2);
        }
      }
    }
    Object.assign(this, options2);
  }
  decodeKey(key2) {
    return this.keyMap ? this.mapKey.get(key2) || key2 : key2;
  }
  decode(source, end2) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end2) : Decoder.prototype.decode.call(defaultOptions, source, end2);
      });
    }
    srcEnd = end2 > -1 ? end2 : source.length;
    position$2 = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
}
function checkedRead() {
  try {
    let result = read$1();
    if (bundledStrings) {
      if (position$2 >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position$2 = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position$2 == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position$2 > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read$1() {
  let token2 = src[position$2++];
  let majorType = token2 >> 5;
  token2 = token2 & 31;
  if (token2 > 23) {
    switch (token2) {
      case 24:
        token2 = src[position$2++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token2 = dataView.getUint16(position$2);
        position$2 += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position$2);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position$2] & 127) << 1 | src[position$2 + 1] >> 7];
            position$2 += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position$2 += 4;
          return value;
        }
        token2 = dataView.getUint32(position$2);
        position$2 += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position$2);
          position$2 += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position$2) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token2 = dataView.getUint32(position$2 + 4);
        } else if (currentDecoder.int64AsNumber) {
          token2 = dataView.getUint32(position$2) * 4294967296;
          token2 += dataView.getUint32(position$2 + 4);
        } else {
          token2 = dataView.getBigUint64(position$2);
        }
        position$2 += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i2 = 0;
            while ((value = read$1()) != STOP_CODE) {
              array[i2++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : buffer.Buffer.concat(array);
          case 5:
            let key2;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key2 = read$1()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key2))] = read$1();
                }
              } else {
                while ((key2 = read$1()) != STOP_CODE) {
                  object[safeKey(key2)] = read$1();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap) {
                while ((key2 = read$1()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key2), read$1());
                }
              } else {
                while ((key2 = read$1()) != STOP_CODE) {
                  map.set(key2, read$1());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token2);
    }
  }
  switch (majorType) {
    case 0:
      return token2;
    case 1:
      return ~token2;
    case 2:
      return readBin(token2);
    case 3:
      if (srcStringEnd >= position$2) {
        return srcString.slice(position$2 - srcStringStart, (position$2 += token2) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token2 < 32) {
        let string2 = token2 < 16 ? shortStringInJS(token2) : longStringInJS(token2);
        if (string2 != null) {
          return string2;
        }
      }
      return readFixedString(token2);
    case 4:
      let array = new Array(token2);
      for (let i2 = 0; i2 < token2; i2++) {
        array[i2] = read$1();
      }
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i2 = 0; i2 < token2; i2++) {
            object[safeKey(currentDecoder.decodeKey(read$1()))] = read$1();
          }
        } else {
          for (let i2 = 0; i2 < token2; i2++) {
            object[safeKey(read$1())] = read$1();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap) {
          for (let i2 = 0; i2 < token2; i2++) {
            map.set(currentDecoder.decodeKey(read$1()), read$1());
          }
        } else {
          for (let i2 = 0; i2 < token2; i2++) {
            map.set(read$1(), read$1());
          }
        }
        return map;
      }
    case 6:
      if (token2 >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token2 & 8191];
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token2 < 65536) {
          if (token2 == RECORD_INLINE_ID) {
            return recordDefinition(read$1());
          } else if (token2 == RECORD_DEFINITIONS_ID) {
            let length2 = readJustLength();
            let id2 = read$1();
            for (let i2 = 2; i2 < length2; i2++) {
              recordDefinition([id2++, read$1()]);
            }
            return read$1();
          } else if (token2 == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token2 & 8191];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token2];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read$1);
        } else {
          return extension(read$1());
        }
      } else {
        let input = read$1();
        for (let i2 = 0; i2 < currentExtensionRanges.length; i2++) {
          let value = currentExtensionRanges[i2](token2, input);
          if (value !== void 0) {
            return value;
          }
        }
        return new Tag(input, token2);
      }
    case 7:
      switch (token2) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token2];
          if (packedValue !== void 0) {
            return packedValue;
          }
          throw new Error("Unknown token " + token2);
      }
    default:
      if (isNaN(token2)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token2);
  }
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length2 = src[position$2++];
    length2 = length2 & 31;
    if (length2 > 23) {
      switch (length2) {
        case 24:
          length2 = src[position$2++];
          break;
        case 25:
          length2 = dataView.getUint16(position$2);
          position$2 += 2;
          break;
        case 26:
          length2 = dataView.getUint32(position$2);
          position$2 += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position$2 - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length2) {
        return compiledReader(read$1);
      }
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= 3) {
      let array = this.length == length2 ? this : this.slice(0, length2);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k2) => currentDecoder.decodeKey(k2)).map((k2) => validName.test(k2) ? safeKey(k2) + ":r()" : "[" + JSON.stringify(k2) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key2) => validName.test(key2) ? safeKey(key2) + ":r()" : "[" + JSON.stringify(key2) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      }
      compiledReader.propertyCount = length2;
      this.compiledReader = compiledReader;
      return compiledReader(read$1);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i2 = 0; i2 < length2; i2++) {
        object[safeKey(currentDecoder.decodeKey(this[i2]))] = read$1();
      }
    } else {
      for (let i2 = 0; i2 < length2; i2++) {
        object[safeKey(this[i2])] = read$1();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key2) {
  return key2 === "__proto__" ? "__proto_" : key2;
}
let readFixedString = readStringJS;
function readStringJS(length2) {
  let result;
  if (length2 < 16) {
    if (result = shortStringInJS(length2)) {
      return result;
    }
  }
  if (length2 > 64 && decoder) {
    return decoder.decode(src.subarray(position$2, position$2 += length2));
  }
  const end2 = position$2 + length2;
  const units = [];
  result = "";
  while (position$2 < end2) {
    const byte1 = src[position$2++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position$2++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position$2++] & 63;
      const byte3 = src[position$2++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position$2++] & 63;
      const byte3 = src[position$2++] & 63;
      const byte4 = src[position$2++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length2) {
  let start2 = position$2;
  let bytes3 = new Array(length2);
  for (let i2 = 0; i2 < length2; i2++) {
    const byte = src[position$2++];
    if ((byte & 128) > 0) {
      position$2 = start2;
      return;
    }
    bytes3[i2] = byte;
  }
  return fromCharCode.apply(String, bytes3);
}
function shortStringInJS(length2) {
  if (length2 < 4) {
    if (length2 < 2) {
      if (length2 === 0) {
        return "";
      } else {
        let a2 = src[position$2++];
        if ((a2 & 128) > 1) {
          position$2 -= 1;
          return;
        }
        return fromCharCode(a2);
      }
    } else {
      let a2 = src[position$2++];
      let b2 = src[position$2++];
      if ((a2 & 128) > 0 || (b2 & 128) > 0) {
        position$2 -= 2;
        return;
      }
      if (length2 < 3) {
        return fromCharCode(a2, b2);
      }
      let c2 = src[position$2++];
      if ((c2 & 128) > 0) {
        position$2 -= 3;
        return;
      }
      return fromCharCode(a2, b2, c2);
    }
  } else {
    let a2 = src[position$2++];
    let b2 = src[position$2++];
    let c2 = src[position$2++];
    let d2 = src[position$2++];
    if ((a2 & 128) > 0 || (b2 & 128) > 0 || (c2 & 128) > 0 || (d2 & 128) > 0) {
      position$2 -= 4;
      return;
    }
    if (length2 < 6) {
      if (length2 === 4) {
        return fromCharCode(a2, b2, c2, d2);
      } else {
        let e2 = src[position$2++];
        if ((e2 & 128) > 0) {
          position$2 -= 5;
          return;
        }
        return fromCharCode(a2, b2, c2, d2, e2);
      }
    } else if (length2 < 8) {
      let e2 = src[position$2++];
      let f2 = src[position$2++];
      if ((e2 & 128) > 0 || (f2 & 128) > 0) {
        position$2 -= 6;
        return;
      }
      if (length2 < 7) {
        return fromCharCode(a2, b2, c2, d2, e2, f2);
      }
      let g2 = src[position$2++];
      if ((g2 & 128) > 0) {
        position$2 -= 7;
        return;
      }
      return fromCharCode(a2, b2, c2, d2, e2, f2, g2);
    } else {
      let e2 = src[position$2++];
      let f2 = src[position$2++];
      let g2 = src[position$2++];
      let h2 = src[position$2++];
      if ((e2 & 128) > 0 || (f2 & 128) > 0 || (g2 & 128) > 0 || (h2 & 128) > 0) {
        position$2 -= 8;
        return;
      }
      if (length2 < 10) {
        if (length2 === 8) {
          return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2);
        } else {
          let i2 = src[position$2++];
          if ((i2 & 128) > 0) {
            position$2 -= 9;
            return;
          }
          return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2);
        }
      } else if (length2 < 12) {
        let i2 = src[position$2++];
        let j = src[position$2++];
        if ((i2 & 128) > 0 || (j & 128) > 0) {
          position$2 -= 10;
          return;
        }
        if (length2 < 11) {
          return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j);
        }
        let k2 = src[position$2++];
        if ((k2 & 128) > 0) {
          position$2 -= 11;
          return;
        }
        return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j, k2);
      } else {
        let i2 = src[position$2++];
        let j = src[position$2++];
        let k2 = src[position$2++];
        let l2 = src[position$2++];
        if ((i2 & 128) > 0 || (j & 128) > 0 || (k2 & 128) > 0 || (l2 & 128) > 0) {
          position$2 -= 12;
          return;
        }
        if (length2 < 14) {
          if (length2 === 12) {
            return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j, k2, l2);
          } else {
            let m2 = src[position$2++];
            if ((m2 & 128) > 0) {
              position$2 -= 13;
              return;
            }
            return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j, k2, l2, m2);
          }
        } else {
          let m2 = src[position$2++];
          let n2 = src[position$2++];
          if ((m2 & 128) > 0 || (n2 & 128) > 0) {
            position$2 -= 14;
            return;
          }
          if (length2 < 15) {
            return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j, k2, l2, m2, n2);
          }
          let o2 = src[position$2++];
          if ((o2 & 128) > 0) {
            position$2 -= 15;
            return;
          }
          return fromCharCode(a2, b2, c2, d2, e2, f2, g2, h2, i2, j, k2, l2, m2, n2, o2);
        }
      }
    }
  }
}
function readBin(length2) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position$2, position$2 += length2)
  ) : src.subarray(position$2, position$2 += length2);
}
let f32Array = new Float32Array(1);
let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position$2++];
  let byte1 = src[position$2++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs2 = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs2 : abs2;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
class Tag {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
}
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer2) => {
  let value = BigInt(0);
  for (let i2 = 0, l2 = buffer2.byteLength; i2 < l2; i2++) {
    value = BigInt(buffer2[i2]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer2) => {
  return BigInt(-1) - currentExtensions[2](buffer2);
};
currentExtensions[4] = (fraction) => {
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
const recordDefinition = (definition) => {
  let id2 = definition[0] - 57344;
  let structure = definition[1];
  let existingStructure = currentStructures[id2];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id2] = existingStructure;
  }
  currentStructures[id2] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i2 = 2, l2 = definition.length; i2 < l2; i2++) {
      let key2 = currentDecoder.decodeKey(structure[i2 - 2]);
      object[safeKey(key2)] = definition[i2];
    }
  } else {
    for (let i2 = 2, l2 = definition.length; i2 < l2; i2++) {
      let key2 = structure[i2 - 2];
      object[safeKey(key2)] = definition[i2];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = (value) => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
let glbl = {
  Error,
  RegExp
};
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
const packedTable = (_read) => {
  if (src[position$2++] != 132) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = (id2) => {
  return stringRefs[id2];
};
currentExtensions[256] = (_read) => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = (_read) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id2 = referenceMap.id++;
  let token2 = src[position$2];
  let target;
  if (token2 >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  };
  referenceMap.set(id2, refEntry);
  let targetProperties = _read();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id2) => {
  let refEntry = referenceMap.get(id2);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (_read) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine$1(a2, b2) {
  if (typeof a2 === "string") {
    return a2 + b2;
  }
  if (a2 instanceof Array) {
    return a2.concat(b2);
  }
  return Object.assign({}, a2, b2);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
const SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine$1(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine$1(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine$1(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine$1(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine$1(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine$1(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    return input;
  }
});
const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
const typedArrays = [Uint8Array];
const typedArrayTags = [64];
for (let i2 = 0; i2 < typedArrays.length; i2++) {
  registerTypedArray(typedArrays[i2], typedArrayTags[i2]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer2) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      return new TypedArray(Uint8Array.prototype.slice.call(buffer2, 0).buffer);
    } : (buffer2) => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
      let elements = buffer2.length >> sizeShift;
      let ta2 = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i2 = 0; i2 < elements; i2++) {
        ta2[i2] = method.call(dv, i2 << sizeShift, littleEndian);
      }
      return ta2;
    };
  }
}
function readBundleExt() {
  let length2 = readJustLength();
  let bundlePosition = position$2 + read$1();
  for (let i2 = 2; i2 < length2; i2++) {
    let bundleLength = readJustLength();
    position$2 += bundleLength;
  }
  let dataPosition = position$2;
  position$2 = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position$2;
  position$2 = dataPosition;
  return read$1();
}
function readJustLength() {
  let token2 = src[position$2++] & 31;
  if (token2 > 23) {
    switch (token2) {
      case 24:
        token2 = src[position$2++];
        break;
      case 25:
        token2 = dataView.getUint16(position$2);
        position$2 += 2;
        break;
      case 26:
        token2 = dataView.getUint32(position$2);
        position$2 += 4;
        break;
    }
  }
  return token2;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position$2;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position$2 = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
const mult10 = new Array(147);
for (let i2 = 0; i2 < 256; i2++) {
  mult10[i2] = Number("1e" + Math.floor(45.15 - i2 * 0.30103));
}
const defaultDecoder = new Decoder({
  useRecords: false
});
const decode$1 = defaultDecoder.decode;
function hexToBytes(hex2) {
  hex2 = hex2.toString(16);
  if (!hex2.startsWith("0x")) {
    hex2 = `0x${hex2}`;
  }
  if (!isHexStrict(hex2)) {
    throw new Error(`Given value "${hex2}" is not a valid hex string.`);
  }
  hex2 = hex2.replace(/^0x/i, "");
  const bytes3 = [];
  for (let c2 = 0; c2 < hex2.length; c2 += 2) {
    bytes3.push(parseInt(hex2.slice(c2, c2 + 2), 16));
  }
  return bytes3;
}
function isHexStrict(hex2) {
  return (typeof hex2 === "string" || typeof hex2 === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex2.toString());
}
function extractIPFSHashFromBytecode(bytecode2) {
  const numericBytecode = hexToBytes(bytecode2);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 256 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode$1(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${bs58$1.encode(cborData["ipfs"])}`;
    } catch (e2) {
      console.warn("feature-detection ipfs cbor failed", e2);
    }
  }
  return void 0;
}
function extractMinimalProxyImplementationAddress(bytecode2) {
  if (bytecode2.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode2.slice(22, 62);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x36603057343d5230")) {
    const implementationAddress = bytecode2.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x3d3d3d3d363d3d37363d73")) {
    const implementationAddress = bytecode2.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode2.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode2.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  return void 0;
}
async function resolveContractUriFromAddress(address, provider2) {
  let bytecode2;
  try {
    bytecode2 = await provider2.getCode(address);
  } catch (e2) {
    throw new Error(`Failed to get bytecode for address ${address}: ${e2}`);
  }
  if (bytecode2 === "0x") {
    const chain = await provider2.getNetwork();
    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
  }
  try {
    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode2);
    if (implementationAddress) {
      return await resolveContractUriFromAddress(implementationAddress, provider2);
    }
  } catch (e2) {
  }
  try {
    const proxyStorage = await provider2.getStorageAt(address, BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    const implementationAddress = `0x${proxyStorage.slice(-40)}`;
    if (utils$1.isAddress(implementationAddress) && implementationAddress !== AddressZero$1) {
      return await resolveContractUriFromAddress(implementationAddress, provider2);
    }
  } catch (e2) {
  }
  return await extractIPFSHashFromBytecode(bytecode2);
}
class ContractPublisher extends RPCConnectionHandler {
  constructor(_network, options2, storage) {
    super(_network, options2);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "publisher", void 0);
    _defineProperty(this, "updatePublisherProfile", buildTransactionFunction(async (profileMetadata) => {
      const signer = this.getSigner();
      invariant$1(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const profileUri = await this.storage.upload(profileMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "setPublisherProfileUri",
        args: [publisher, profileUri]
      });
    }));
    _defineProperty(this, "publish", buildTransactionFunction(async (predeployUri, extraMetadata) => {
      const signer = this.getSigner();
      invariant$1(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);
      if (extraMetadata.factoryDeploymentData?.implementationAddresses) {
        const implementationsAddresses = Object.entries(extraMetadata.factoryDeploymentData.implementationAddresses);
        const entry = implementationsAddresses.find((_ref) => {
          let [, implementation2] = _ref;
          return implementation2 !== "";
        });
        const [network, implementation] = entry ? entry : [];
        if (network && implementation) {
          try {
            const compilerMetadata2 = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);
            const composite = await getCompositePluginABI(
              implementation,
              compilerMetadata2.abi,
              getChainProvider(parseInt(network), {
                thirdwebApiKey: DEFAULT_API_KEY$2
              }),
              {},
              // pass empty object for options instead of this.options
              this.storage
            );
            extraMetadata.compositeAbi = AbiSchema.parse(composite);
          } catch {
          }
        }
      }
      const latestContract = await this.getLatest(publisher, predeployMetadata.name);
      if (latestContract && latestContract.metadataUri) {
        const latestMetadata = await this.fetchPublishedContractInfo(latestContract);
        const latestVersion = latestMetadata.publishedMetadata.version;
        if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {
          throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);
        }
      }
      const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();
      const bytecode2 = fetchedBytecode.startsWith("0x") ? fetchedBytecode : `0x${fetchedBytecode}`;
      const bytecodeHash = keccak256(["bytes"], [bytecode2]);
      const contractId = predeployMetadata.name;
      const fullMetadata = FullPublishMetadataSchemaInput.parse({
        ...extraMetadata,
        metadataUri: predeployMetadata.metadataUri,
        bytecodeUri: predeployMetadata.bytecodeUri,
        name: predeployMetadata.name,
        analytics: predeployMetadata.analytics,
        publisher
      });
      const fullMetadataUri = await this.storage.upload(fullMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "publishContract",
        args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, AddressZero$1],
        parse: (receipt) => {
          const events = this.publisher.parseLogs("ContractPublished", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ContractPublished event found");
          }
          const contract = events[0].args.publishedContract;
          return {
            receipt,
            data: async () => this.toPublishedContract(contract)
          };
        }
      });
    }));
    _defineProperty(this, "unpublish", buildTransactionFunction(async (publisher, contractId) => {
      const resolvedPublisher = await resolveAddress(publisher);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "unpublishContract",
        args: [resolvedPublisher, contractId]
      });
    }));
    this.storage = storage;
    this.publisher = new ContractWrapper(_network, getContractPublisherAddress(), ContractPublisherAbi, options2);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.publisher.updateSignerOrProvider(network);
  }
  /**
   * @internal
   * @param metadataUri
   */
  async extractConstructorParams(metadataUri) {
    return extractConstructorParams(metadataUri, this.storage);
  }
  /**
   * @internal
   * @param predeployMetadataUri
   */
  async extractFunctions(predeployMetadataUri) {
    return extractFunctions(predeployMetadataUri, this.storage);
  }
  /**
   * @internal
   * @param predeployUri
   */
  async fetchCompilerMetadataFromPredeployURI(predeployUri) {
    return fetchPreDeployMetadata(predeployUri, this.storage);
  }
  /**
   * @internal
   * @param prepublishUri
   * @param publisherAddress
   */
  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {
    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);
    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : void 0;
    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : void 0;
    return {
      preDeployMetadata: preDeployMetadataFetched,
      latestPublishedContractMetadata
    };
  }
  /**
   * @internal
   * @param address
   */
  async fetchCompilerMetadataFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage);
  }
  /**
   * @internal
   * Get the full information about a published contract
   * @param contract
   */
  async fetchPublishedContractInfo(contract) {
    return {
      name: contract.id,
      publishedTimestamp: contract.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)
    };
  }
  /**
   * @internal
   * @param publishedMetadataUri
   */
  async fetchFullPublishMetadata(publishedMetadataUri) {
    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);
  }
  /**
   * @internal
   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case
   * // TODO will be easy to do with the multichain pattern of 3.0
   * @param compilerMetadataUri
   */
  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {
    const publishedMetadataUri = await this.publisher.readContract.getPublishedUriFromCompilerUri(compilerMetadataUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);
    }
    return await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => this.fetchFullPublishMetadata(uri)));
  }
  /**
   * @internal
   * TODO clean this up (see method above, too)
   */
  async resolveContractUriFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());
    invariant$1(contractUri, "Could not resolve contract URI from address");
    return contractUri;
  }
  /**
   * @internal
   * @param address
   */
  async fetchContractSourcesFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);
    return await fetchSourceFilesFromMetadata(metadata, this.storage);
  }
  /**
   * @internal
   * @param publisherAddress
   */
  async getPublisherProfile(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const profileUri = await this.publisher.readContract.getPublisherProfileUri(resolvedPublisherAddress);
    if (!profileUri || profileUri.length === 0) {
      return {};
    }
    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));
  }
  /**
   * @internal
   * @param publisherAddress
   */
  async getAll(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const data = await this.publisher.readContract.getAllPublishedContracts(resolvedPublisherAddress);
    const map = data.reduce((acc, curr) => {
      acc[curr.contractId] = curr;
      return acc;
    }, {});
    return Object.entries(map).map((_ref2) => {
      let [, struct] = _ref2;
      return this.toPublishedContract(struct);
    });
  }
  /**
   * @internal
   * @param publisherAddress
   * @param contractId
   */
  async getAllVersions(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const contractStructs = await this.publisher.readContract.getPublishedContractVersions(resolvedPublisherAddress, contractId);
    if (contractStructs.length === 0) {
      throw Error("Not found");
    }
    return contractStructs.map((d2) => this.toPublishedContract(d2));
  }
  async getVersion(publisherAddress, contractId) {
    let version2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    if (version2 === "latest") {
      return this.getLatest(resolvedPublisherAddress, contractId);
    }
    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);
    const versionMetadata = await Promise.all(allVersions.map((contract) => this.fetchPublishedContractInfo(contract)));
    const versionMatch = versionMetadata.find((metadata) => metadata.publishedMetadata.version === version2);
    invariant$1(versionMatch, "Contract version not found");
    return allVersions.find((contract) => contract.timestamp === versionMatch.publishedTimestamp);
  }
  async getLatest(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const model = await this.publisher.readContract.getPublishedContract(resolvedPublisherAddress, contractId);
    if (model && model.publishMetadataUri) {
      return this.toPublishedContract(model);
    }
    return void 0;
  }
  toPublishedContract(contractModel) {
    return PublishedContractSchema.parse({
      id: contractModel.contractId,
      timestamp: contractModel.publishTimestamp,
      metadataUri: contractModel.publishMetadataUri
    });
  }
}
const MultichainRegistry_address = "0xcdAD8FA86e18538aC207872E8ff3536501431B73";
function getMultichainRegistryAddress() {
  if ({ "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.multiChainRegistryAddress) {
    return { "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.multiChainRegistryAddress;
  } else {
    return MultichainRegistry_address;
  }
}
class MultichainRegistry {
  constructor(network, storage) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _defineProperty(this, "registryLogic", void 0);
    _defineProperty(this, "registryRouter", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "addContract", buildTransactionFunction(async (contract) => {
      return await this.addContracts.prepare([contract]);
    }));
    _defineProperty(this, "addContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = [];
      contracts.forEach((contact) => {
        encoded.push(this.registryLogic.readContract.interface.encodeFunctionData("add", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || ""]));
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "removeContract", buildTransactionFunction(async (contract) => {
      return await this.removeContracts.prepare([contract]);
    }));
    _defineProperty(this, "removeContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = await Promise.all(contracts.map(async (contract) => this.registryLogic.readContract.interface.encodeFunctionData("remove", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.storage = storage;
    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWRegistryABI, options2);
    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWRegistryRouterABI, options2);
  }
  async updateSigner(signer) {
    this.registryLogic.updateSignerOrProvider(signer);
    this.registryRouter.updateSignerOrProvider(signer);
  }
  async getContractMetadataURI(chainId, address) {
    return await this.registryLogic.readContract.getMetadataUri(chainId, await resolveAddress(address));
  }
  async getContractMetadata(chainId, address) {
    const uri = await this.getContractMetadataURI(chainId, address);
    if (!uri) {
      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);
    }
    return await this.storage.downloadJSON(uri);
  }
  async getContractAddresses(walletAddress) {
    return (await this.registryLogic.readContract.getAll(await resolveAddress(walletAddress))).filter((result) => isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== AddressZero$1).map((result) => ({
      address: result.deploymentAddress,
      chainId: result.chainId.toNumber()
    }));
  }
}
const LOCAL_NODE_PKEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
class UserWallet {
  constructor(network, options2) {
    _defineProperty(this, "connection", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "events", new EventEmitter$1());
    this.connection = new RPCConnectionHandler(network, options2);
    this.options = options2;
    this.events = new EventEmitter$1();
  }
  // TODO disconnect()
  // TODO switchChain()
  // TODO tokens()
  // TODO NFTs()
  // TODO this will become the source of truth of the signer and have every contract read from it
  // TODO separate signer and provider logics
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  /**
   * Transfer native or ERC20 tokens from this wallet to another wallet
   * @example
   * ```javascript
   *  // transfer 0.8 ETH
   * await sdk.wallet.transfer("0x...", 0.8);
   *  // transfer 0.8 tokens of `tokenContractAddress`
   * await sdk.wallet.transfer("0x...", 0.8, tokenContractAddress);
   * ```
   * @param to - the account to send funds to
   * @param amount - the amount in tokens
   * @param currencyAddress - Optional - ERC20 contract address of the token to transfer
   */
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const resolvedTo = await resolveAddress(to);
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const signer = this.requireWallet();
    const amountInWei = await normalizePriceValue(this.connection.getProvider(), amount, currencyAddress);
    if (isNativeToken(resolvedCurrency)) {
      const from2 = await signer.getAddress();
      const tx = await signer.sendTransaction({
        from: from2,
        to: resolvedTo,
        value: amountInWei
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      return {
        receipt: await this.createErc20(resolvedCurrency).sendTransaction("transfer", [resolvedTo, amountInWei])
      };
    }
  }
  /**
   * Fetch the native or ERC20 token balance of this wallet
   * @example
   * ```javascript
   * // native currency balance
   * const balance = await sdk.wallet.balance();
   * // ERC20 token balance
   * const erc20balance = await sdk.wallet.balance(tokenContractAddress);
   *
   * ```
   */
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const provider2 = this.connection.getProvider();
    let balance;
    if (isNativeToken(resolvedCurrency)) {
      balance = await provider2.getBalance(await this.getAddress());
    } else {
      balance = await this.createErc20(resolvedCurrency).readContract.balanceOf(await this.getAddress());
    }
    return await fetchCurrencyValue(provider2, resolvedCurrency, balance);
  }
  /**
   * Get the currently connected address
   * @example
   * ```javascript
   * const address = await sdk.wallet.getAddress();
   * ```
   */
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  /**
   * Get the currently connected wallet's chainId
   * @internal
   */
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  /**
   * Get the number of transactions sent from this address.
   * @param blockTag - Optional - the block tag to read the nonce from
   */
  async getNonce(blockTag) {
    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);
    return txCount;
  }
  /**
   * Checks whether there's a signer connected with the SDK
   * @internal
   */
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e2) {
      return false;
    }
  }
  /**
   * Sign any message with the connected wallet private key
   * @param message - the message to sign
   * @returns the signed message
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * const message = "Sign this message...";
   *
   * // Now we can sign the message with the connected wallet
   * const signature = await sdk.wallet.sign(message);
   * ```
   */
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  /**
   * Sign a typed data structure (EIP712) with the connected wallet private key
   * @param domain - the domain as EIP712 standard
   * @param types - the structure and data types as defined by the EIP712 standard
   * @param message - the data to sign
   * @returns the payload and its associated signature
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * // Now we can sign the message with the connected wallet
   * const { payload, signature } = await sdk.wallet.signTypedData(
   *   {
          name: "MyEIP721Domain",
          version: "1",
          chainId: 1,
          verifyingContract: "0x...",
        },
        { MyStruct: [ { name: "to", type: "address" }, { name: "quantity", type: "uint256" } ] },
        { to: "0x...", quantity: 1 },
   * );
   * ```
   */
  async signTypedData(domain, types2, message) {
    return await signTypedDataInternal(this.requireWallet(), domain, types2, message);
  }
  /**
   * Recover the signing address from a signed message
   * @param message - the original message that was signed
   * @param signature - the signature to recover the address from
   * @returns the address that signed the message
   *
   * @example
   * ```javascript
   * const message = "Sign this message...";
   * const signature = await sdk.wallet.sign(message);
   *
   * // Now we can recover the signing address
   * const address = sdk.wallet.recoverAddress(message, signature);
   * ```
   */
  recoverAddress(message, signature2) {
    const messageHash = hashMessage(message);
    const messageHashBytes = arrayify(messageHash);
    return recoverAddress(messageHashBytes, signature2);
  }
  /**
   * Send a raw transaction to the blockchain from the connected wallet
   * @param transactionRequest - raw transaction data to send to the blockchain
   */
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const tx = await signer.sendTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  /**
   * Request funds from a running local node to the currently connected wallet
   * @param amount the amount in native currency (in ETH) to request
   */
  async requestFunds(amount) {
    const chainId = await this.getChainId();
    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {
      const localWallet = new UserWallet(new Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options);
      return localWallet.transfer(await this.getAddress(), amount);
    } else {
      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);
    }
  }
  /** ***********************
   * PRIVATE FUNCTIONS
   * ***********************/
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant$1(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, ERC20Abi, this.options);
  }
}
async function getMetadataForPlugins(publishedMetadataUri, storage) {
  let pluginMetadata = [];
  const {
    compilerMetadata: compilerMetadata2,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishedMetadataUri, storage);
  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(compilerMetadata2.abi), "PluginRouter");
  if (isPluginRouter) {
    if (extendedMetadata && extendedMetadata.factoryDeploymentData?.implementationAddresses) {
      const implementationsAddresses = Object.entries(extendedMetadata.factoryDeploymentData.implementationAddresses);
      try {
        const entry = implementationsAddresses.find((_ref) => {
          let [, implementation2] = _ref;
          return implementation2 !== "";
        });
        const [network, implementation] = entry ? entry : [];
        if (network && implementation) {
          const provider2 = getChainProvider(parseInt(network), {});
          const contract = new ContractWrapper(provider2, implementation, getAllPluginsAbi, {});
          const pluginMap = await contract.call("getAllPlugins");
          const allPlugins = pluginMap.map((item) => item.pluginAddress);
          const pluginAddresses = Array.from(new Set(allPlugins));
          const pluginNames = (await Promise.all(pluginAddresses.map(async (address) => {
            const metadata = fetchContractMetadataFromAddress(address, provider2, storage);
            return metadata;
          }))).map((metadata) => metadata.name);
          const pluginUris = await Promise.all(pluginNames.map((name2) => {
            return fetchAndCachePublishedContractURI(name2);
          }));
          pluginMetadata = (await Promise.all(pluginUris.map(async (uri) => {
            return fetchAndCacheDeployMetadata(uri, storage);
          }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata);
        }
      } catch {
      }
    }
  }
  return pluginMetadata;
}
function getFunctionSignature(fnInputs) {
  return "(" + fnInputs.map((i2) => {
    return i2.type === "tuple" ? getFunctionSignature(i2.components) : i2.type;
  }).join(",") + ")";
}
function generatePluginFunctions(pluginAddress, pluginAbi) {
  const pluginInterface = new Interface(pluginAbi);
  const pluginFunctions = [];
  for (const fnFragment of Object.values(pluginInterface.functions)) {
    const fn2 = pluginInterface.getFunction(fnFragment.name);
    if (fn2.name.includes("_")) {
      continue;
    }
    pluginFunctions.push({
      functionSelector: pluginInterface.getSighash(fn2),
      functionSignature: fn2.name + getFunctionSignature(fn2.inputs),
      pluginAddress
    });
  }
  return pluginFunctions;
}
async function getDeploymentInfo(metadataUri, storage, provider2, create2Factory) {
  caches.deploymentPresets = {};
  const create2FactoryAddress = create2Factory ? create2Factory : await getCreate2FactoryAddress(provider2);
  const customParams = {};
  const finalDeploymentInfo = [];
  const {
    compilerMetadata: compilerMetadata2
  } = await fetchAndCacheDeployMetadata(metadataUri, storage);
  const pluginMetadata = await getMetadataForPlugins(metadataUri, storage);
  if (pluginMetadata.length > 0) {
    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(async (metadata) => {
      const info = await computeDeploymentInfo("plugin", provider2, storage, create2FactoryAddress, {
        metadata
      });
      return info;
    }));
    const mapInput = [];
    pluginMetadata.forEach((metadata, index2) => {
      const input = generatePluginFunctions(pluginDeploymentInfo[index2].transaction.predictedAddress, metadata.abi);
      mapInput.push(...input);
    });
    const pluginMapTransaction = await computeDeploymentInfo("plugin", provider2, storage, create2FactoryAddress, {
      contractName: "PluginMap",
      constructorParams: {
        _pluginsToAdd: {
          value: mapInput
        }
      }
    });
    customParams["_pluginMap"] = {
      value: pluginMapTransaction.transaction.predictedAddress
    };
    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);
  }
  const implementationDeployInfo = await computeDeploymentInfo("implementation", provider2, storage, create2FactoryAddress, {
    metadata: compilerMetadata2,
    constructorParams: customParams
  });
  const factoryInfo = await computeDeploymentInfo("infra", provider2, storage, create2FactoryAddress, {
    contractName: "TWCloneFactory"
  });
  finalDeploymentInfo.push(factoryInfo);
  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));
  finalDeploymentInfo.push(implementationDeployInfo);
  return finalDeploymentInfo;
}
async function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, constructorParamMap) {
  const provider2 = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY$2
  });
  const publishUri = await fetchAndCachePublishedContractURI(contractName);
  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);
  const create2Factory = await getCreate2FactoryAddress(provider2);
  invariant$1(create2Factory, "Thirdweb stack not found");
  const pluginMetadata = await getMetadataForPlugins(publishUri, storage);
  let encodedArgs;
  if (pluginMetadata.length > 0) {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider2, create2Factory);
    encodedArgs = deploymentInfo.find((contract) => contract.type === "implementation")?.encodedArgs;
  } else {
    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider2, storage, create2Factory, constructorParamMap);
  }
  return encodedArgs;
}
async function predictThirdwebContractAddress(contractName, chainId, storage) {
  const provider2 = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY$2
  });
  const publishUri = await fetchAndCachePublishedContractURI(contractName);
  const create2Factory = await getCreate2FactoryAddress(provider2);
  invariant$1(create2Factory, "Thirdweb stack not found");
  const pluginMetadata = await getMetadataForPlugins(publishUri, storage);
  if (pluginMetadata.length > 0) {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider2, create2Factory);
    const implementation2 = deploymentInfo.find((contract) => contract.type === "implementation")?.transaction.predictedAddress;
    invariant$1(implementation2, "Error computing address for plugin router");
    return implementation2;
  }
  const implementation = await computeDeploymentInfo("implementation", provider2, storage, create2Factory, {
    contractName
  });
  return implementation.transaction.predictedAddress;
}
async function getThirdwebContractAddress(contractName, chainId, storage) {
  const provider2 = getChainProvider(chainId, {
    thirdwebApiKey: DEFAULT_API_KEY$2
  });
  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage);
  const isDeployed = await isContractDeployed(contractAddress, provider2);
  invariant$1(isDeployed, "Contract not deployed yet");
  return contractAddress;
}
const VerificationStatus = {
  FAILED: "Fail - Unable to verify",
  SUCCESS: "Pass - Verified",
  PENDING: "Pending in queue",
  ALREADY_VERIFIED: "Contract source code already verified",
  AUTOMATICALLY_VERIFIED: "Already Verified"
};
const RequestStatus = {
  OK: "1",
  NOTOK: "0"
};
async function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage, constructorArgs) {
  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage);
  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, constructorArgs);
  console.info(`Verifying ${contractName} at address ${contractAddress}`);
  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs?.toString().replace("0x", ""));
  return guid;
}
async function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {
  try {
    const provider2 = getChainProvider(chainId, {});
    const compilerMetadata2 = await fetchContractMetadataFromAddress(contractAddress, provider2, storage);
    const compilerVersion = compilerMetadata2.metadata.compiler.version;
    const sources = await fetchSourceFilesFromMetadata(compilerMetadata2, storage);
    const sourcesWithUrl = compilerMetadata2.metadata.sources;
    const sourcesWithContents = {};
    for (const path of Object.keys(sourcesWithUrl)) {
      const sourceCode = sources.find((source) => path === source.filename);
      if (!sourceCode) {
        throw new Error(`Could not find source file for ${path}`);
      }
      sourcesWithContents[path] = {
        content: sourceCode.source
      };
    }
    const compilerInput = {
      language: "Solidity",
      sources: sourcesWithContents,
      settings: {
        optimizer: compilerMetadata2.metadata.settings.optimizer,
        evmVersion: compilerMetadata2.metadata.settings.evmVersion,
        remappings: compilerMetadata2.metadata.settings.remappings,
        outputSelection: {
          "*": {
            "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
            "": ["ast"]
          }
        }
      }
    };
    const compilationTarget = compilerMetadata2.metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const contractPath = targets[0];
    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata2.abi, provider2, storage);
    const requestBody = {
      apikey: explorerAPIKey,
      module: "contract",
      action: "verifysourcecode",
      contractaddress: contractAddress,
      sourceCode: JSON.stringify(compilerInput),
      codeformat: "solidity-standard-json-input",
      contractname: `${contractPath}:${compilerMetadata2.name}`,
      compilerversion: `v${compilerVersion}`,
      constructorArguements: encodedArgs
    };
    const parameters = new URLSearchParams({
      ...requestBody
    });
    const result = await fetch$1(explorerAPIUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: parameters.toString()
    });
    const data = await result.json();
    if (data.status === RequestStatus.OK) {
      return data.result;
    } else {
      throw new Error(`${data.result}`);
    }
  } catch (e2) {
    throw new Error(e2.toString());
  }
}
async function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {
  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}"`;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      try {
        const result = await fetch$1(endpoint, {
          method: "GET"
        });
        const data = await result.json();
        if (data?.result !== VerificationStatus.PENDING) {
          clearInterval(intervalId);
          resolve(data);
        }
      } catch (e2) {
        clearInterval(intervalId);
        reject(e2);
      }
    }, 3e3);
  });
}
async function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider2, storage) {
  const constructorParamTypes = extractConstructorParamsFromAbi(abi);
  if (constructorParamTypes.length === 0) {
    return "";
  }
  const requestBody = {
    apiKey: explorerAPIKey,
    module: "account",
    action: "txlist",
    address: contractAddress,
    page: "1",
    sort: "asc",
    offset: "1"
  };
  const parameters = new URLSearchParams({
    ...requestBody
  });
  const result = await fetch$1(explorerAPIUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: parameters.toString()
  });
  const data = await result.json();
  if (data && data.status === RequestStatus.OK && data.result[0] !== void 0) {
    const contract = new Interface(abi);
    const txDeployBytecode = data.result[0].input;
    let constructorArgs = "";
    if (contract.deploy.inputs.length === 0) {
      return "";
    }
    try {
      const bytecode2 = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider2, storage);
      if (bytecode2) {
        const bytecodeHex = bytecode2.startsWith("0x") ? bytecode2 : `0x${bytecode2}`;
        constructorArgs = txDeployBytecode.substring(bytecodeHex.length);
      }
    } catch (e2) {
    }
    if (!constructorArgs) {
      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      if (matches.length > 0) {
        constructorArgs = matches[0][2];
      }
    }
    if (!constructorArgs) {
      const constructorParamByteLength = constructorParamTypes.length * 64;
      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);
    }
    try {
      defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);
    } catch (e2) {
      throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.");
    }
    return constructorArgs;
  } else {
    return "";
  }
}
async function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider2, storage) {
  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider2);
  if (compilerMetaUri) {
    const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider("polygon", {}));
    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => fetchExtendedReleaseMetadata(uri, storage)));
    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : void 0;
  }
  return void 0;
}
class ContractVerifier extends RPCConnectionHandler {
  constructor(network, options2, storage) {
    super(network, options2);
    _defineProperty(this, "storage", void 0);
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
  }
  /**
   * Verifies a Thirdweb contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyThirdwebContract(
   *   "DropERC721",
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractName
   * @param explorerAPIUrl
   * @param explorerAPIKey
   */
  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, constructorArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
  /**
   * Verifies any contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const contractAddress = ""
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyContract(
   *   contractAddress,
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractAddress
   * @param explorerAPIUrl
   * @param explorerAPIKey
   */
  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    let encodedArgs;
    if (constructorArgs) {
      const paramTypes = Object.values(constructorArgs).map((arg) => {
        invariant$1(arg.type, "Param type is required");
        return arg.type;
      });
      const paramValues = Object.values(constructorArgs).map((arg) => {
        return arg.value;
      });
      encodedArgs = defaultAbiCoder.encode(paramTypes, paramValues);
    }
    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
}
function extractFunctionParamsFromAbi(abi, functionName) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
async function computeCloneFactoryAddress(provider2, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider2);
  }
  return (await computeDeploymentInfo("infra", provider2, storage, create2Factory, {
    contractName: "TWCloneFactory"
  })).transaction.predictedAddress;
}
function convertParamValues(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((p2, index2) => {
    if (p2 === "tuple" || p2.endsWith("[]")) {
      if (typeof constructorParamValues[index2] === "string") {
        return JSON.parse(constructorParamValues[index2]);
      } else {
        return constructorParamValues[index2];
      }
    }
    if (p2 === "bytes32") {
      invariant$1(isHexString(constructorParamValues[index2]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index2]}".`);
      return hexZeroPad(constructorParamValues[index2], 32);
    }
    if (p2.startsWith("bytes")) {
      invariant$1(isHexString(constructorParamValues[index2]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index2]}".`);
      return constructorParamValues[index2];
    }
    if (p2.startsWith("uint") || p2.startsWith("int")) {
      return BigNumber.from(constructorParamValues[index2].toString());
    }
    return constructorParamValues[index2];
  });
}
function estimateGasForDeploy(initCode) {
  let gasLimit = arrayify(initCode).map((x2) => x2 === 0 ? 4 : 16).reduce((sum, x2) => sum + x2) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32e3 + 21e3;
  gasLimit = Math.floor(gasLimit * 64 / 63);
  return gasLimit;
}
function createTransactionBatches(transactions) {
  let upperGasLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;
  transactions = transactions.filter((tx) => {
    return tx.data.length > 0;
  });
  if (transactions.length === 0) {
    return [];
  }
  let transactionBatches = [];
  let sum = 0;
  let batch2 = [];
  transactions.forEach((tx) => {
    const gas = estimateGasForDeploy(tx.data);
    if (sum + gas > upperGasLimit) {
      if (batch2.length === 0) {
        transactionBatches.push([tx]);
      } else {
        transactionBatches.push(batch2);
        sum = gas;
        batch2 = [tx];
      }
    } else {
      sum += gas;
      batch2.push(tx);
    }
  });
  if (batch2.length > 0) {
    transactionBatches.push(batch2);
  }
  return transactionBatches;
}
async function deployContractDeterministic(signer, transaction, options2) {
  let gasLimit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  invariant$1(signer.provider, "Provider required");
  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);
    let tx = {
      to: transaction.to,
      data: transaction.data
    };
    try {
      await signer.estimateGas(tx);
    } catch (e2) {
      console.debug("error estimating gas while deploying prebuilt: ", e2);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    options2?.notifier?.("deploying", "preset");
    await (await signer.sendTransaction(tx)).wait();
    options2?.notifier?.("deployed", "preset");
  }
}
function toWei(amount) {
  return parseEther(AmountSchema.parse(amount));
}
async function deployCreate2Factory(signer, options2) {
  invariant$1(signer.provider, "No provider");
  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, signer.provider);
  if (commonFactoryExists) {
    return COMMON_FACTORY;
  }
  const enforceEip155 = await isEIP155Enforced(signer.provider);
  const networkId = (await signer.provider.getNetwork()).chainId;
  const chainId = enforceEip155 ? networkId : 0;
  console.debug(`ChainId ${networkId} enforces EIP155: ${enforceEip155}`);
  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);
  const factoryExists = await isContractDeployed(deploymentInfo.deployment, signer.provider);
  if (!factoryExists) {
    const valueToSend = CUSTOM_GAS_FOR_CHAIN[networkId] ? BigNumber.from(CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice).mul(1e5) : toWei("0.01");
    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(valueToSend)) {
      await (await signer.sendTransaction({
        to: deploymentInfo.signer,
        value: valueToSend
      })).wait();
    }
    try {
      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);
      options2?.notifier?.("deploying", "create2Factory");
      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();
      options2?.notifier?.("deployed", "create2Factory");
    } catch (err) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);
    }
  }
  return deploymentInfo.deployment;
}
async function deployWithThrowawayDeployer(signer, transactions, options2) {
  let transactionBatches = createTransactionBatches(transactions);
  if (transactionBatches.length === 0) {
    return;
  }
  options2?.notifier?.("deploying", "infra");
  const deployTxns = await Promise.all(transactionBatches.map((txBatch) => {
    const deployer = new ContractFactory$1(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);
    return deployer;
  }));
  await Promise.all(deployTxns.map((tx) => {
    return tx.deployed();
  }));
  options2?.notifier?.("deployed", "infra");
}
const SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];
function getDefaultTrustedForwarders(chainId) {
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c2) => c2 === chainId);
  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].biconomyForwarder : AddressZero;
  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum].openzeppelinForwarder : AddressZero;
  return [openzeppelinForwarder, biconomyForwarder].filter((a2) => a2 !== AddressZero);
}
async function getDeployArguments(contractType2, metadata, contractURI, signer, storage) {
  const chainId = await signer.getChainId();
  const signerAddress = await signer.getAddress();
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c2) => c2 === chainId);
  let trustedForwarders = [];
  if (!chainEnum) {
    const forwarder = await computeForwarderAddress(signer.provider, storage);
    trustedForwarders = [forwarder];
  } else {
    trustedForwarders = contractType2 === PackInitializer.contractType ? [] : getDefaultTrustedForwarders(chainId);
  }
  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
    trustedForwarders.push(...metadata.trusted_forwarders);
  }
  switch (contractType2) {
    case NFTDropInitializer.contractType:
    case NFTCollectionInitializer.contractType:
      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];
    case SignatureDropInitializer.contractType:
      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];
    case MultiwrapInitializer.contractType:
      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
    case EditionDropInitializer.contractType:
    case EditionInitializer.contractType:
      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];
    case TokenDropInitializer.contractType:
    case TokenInitializer.contractType:
      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];
    case VoteInitializer.contractType:
      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
    case SplitInitializer.contractType:
      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s2) => s2.address), splitsMetadata.recipients.map((s2) => BigNumber.from(s2.sharesBps))];
    case MarketplaceInitializer.contractType:
    case MarketplaceV3Initializer.contractType:
      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];
    case PackInitializer.contractType:
      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
    default:
      return [];
  }
}
const APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  }
};
function getApprovedImplementation(chainId, contractType2) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType2 in approvedImpls) {
      return approvedImpls[contractType2];
    }
  }
  return null;
}
class ContractFactory extends ContractWrapper {
  // Map from contract type to version to deploy specific versions by default
  constructor(factoryAddr, network, storage, options2) {
    super(network, factoryAddr, TWFactoryAbi, options2);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [MarketplaceV3Initializer.contractType]: 1,
      [PackInitializer.contractType]: 2
    });
    _defineProperty(this, "deploy", buildTransactionFunction(async (contractType2, contractMetadata, eventEmitter, version2, onExecute) => {
      const contract = PREBUILT_CONTRACTS_MAP[contractType2];
      const metadata = await contract.schema.deploy.parseAsync(contractMetadata);
      const contractURI = await this.storage.upload(metadata);
      const implementationAddress = await this.getImplementation(contract, version2) || void 0;
      if (!implementationAddress || implementationAddress === AddressZero$1) {
        throw new Error(`No implementation found for ${contractType2}`);
      }
      const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);
      const signer = this.getSigner();
      invariant$1(signer, "A signer is required to deploy contracts");
      const args = await getDeployArguments(contractType2, metadata, contractURI, signer, this.storage);
      const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", args);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    _defineProperty(this, "deployProxyByImplementation", buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, onExecute) => {
      const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const blockNumber = await this.getProvider().getBlockNumber();
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, formatBytes32String(blockNumber.toString())],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    this.storage = storage;
  }
  /**
   *
   * @param contractType
   * @param metadata
   * @param contractURI
   * @returns
   * @internal
   */
  async getDeployArguments(contractType2, metadata, contractURI) {
    let trustedForwarders = contractType2 === PackInitializer.contractType ? [] : await this.getDefaultTrustedForwarders();
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    switch (contractType2) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, erc721metadata.primary_sale_recipient, erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, erc721metadata.platform_fee_recipient];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, signatureDropmetadata.primary_sale_recipient, signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, signatureDropmetadata.platform_fee_recipient];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, erc1155metadata.primary_sale_recipient, erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, erc1155metadata.platform_fee_recipient];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, erc20metadata.primary_sale_recipient, erc20metadata.platform_fee_recipient, erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, splitsMetadata.recipients.map((s2) => s2.address), splitsMetadata.recipients.map((s2) => BigNumber.from(s2.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceMetadata.platform_fee_recipient, marketplaceMetadata.platform_fee_basis_points];
      case MarketplaceV3Initializer.contractType:
        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), contractURI, trustedForwarders, marketplaceV3Metadata.platform_fee_recipient, marketplaceV3Metadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
        return [await this.getSignerAddress(), packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const chainId = await this.getChainID();
    return getDefaultTrustedForwarders(chainId);
  }
  async getImplementation(contract, version2) {
    const encodedType = formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version2 === void 0) {
      return approvedImplementation;
    }
    return this.readContract.getImplementation(encodedType, version2 !== void 0 ? version2 : this.DEFAULT_VERSION_MAP[contract.contractType]);
  }
  async getLatestVersion(contractType2) {
    const name2 = getContractName(contractType2);
    if (!name2) {
      throw new Error(`Invalid contract type ${contractType2}`);
    }
    const encodedType = formatBytes32String(name2);
    return this.readContract.currentVersion(encodedType);
  }
}
class ContractRegistry extends ContractWrapper {
  constructor(registryAddress, network, options2) {
    super(network, registryAddress, TWRegistryABI$1, options2);
    _defineProperty(this, "addContract", buildTransactionFunction(async (contractAddress) => {
      return await this.addContracts.prepare([contractAddress]);
    }));
    _defineProperty(this, "addContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const encoded = await Promise.all(contractAddresses.map(async (address) => this.readContract.interface.encodeFunctionData("add", [deployerAddress, await resolveAddress(address)])));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
    _defineProperty(this, "removeContract", buildTransactionFunction(async (contractAddress) => {
      return await this.removeContracts.prepare([contractAddress]);
    }));
    _defineProperty(this, "removeContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const encoded = await Promise.all(contractAddresses.map(async (address) => this.readContract.interface.encodeFunctionData("remove", [deployerAddress, await resolveAddress(address)])));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
  }
  async getContractAddresses(walletAddress) {
    return (await this.readContract.getAll(await resolveAddress(walletAddress))).filter((adr) => isAddress(adr) && adr.toLowerCase() !== AddressZero$1);
  }
}
class ThirdwebSDK extends RPCConnectionHandler {
  /**
   * Get an instance of the thirdweb SDK based on an AbstractWallet
   *
   * @example
   * ```javascript
   * import { ThirdwebSDK } from "@thirdweb-dev/sdk"
   *
   * const wallet = new AbstractWalletImplementation();
   * const sdk = await ThirdwebSDK.fromWallet(wallet, "mainnet");
   * ```
   *
   * @param wallet - the implementation of the AbstractWallet class to use for signing
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns an instance of the SDK
   *
   * @beta
   */
  static async fromWallet(wallet, network) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const signer = await wallet.getSigner();
    return ThirdwebSDK.fromSigner(signer, network, options2, storage);
  }
  /**
   * Get an instance of the thirdweb SDK based on an existing ethers signer
   *
   * @example
   * ```javascript
   * // get a signer from somewhere (createRandom is being used purely for example purposes)
   * const signer = ethers.Wallet.createRandom();
   *
   * // get an instance of the SDK with the signer already setup
   * const sdk = ThirdwebSDK.fromSigner(signer, "mainnet");
   * ```
   *
   * @param signer - a ethers Signer to be used for transactions
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns an instance of the SDK
   *
   * @beta
   */
  static fromSigner(signer, network) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    let signerWithProvider = signer;
    if (network && !signer.provider) {
      const provider2 = getChainProvider(network, options2);
      signerWithProvider = signer.connect(provider2);
    }
    const sdk = new ThirdwebSDK(network || signerWithProvider, options2, storage);
    sdk.updateSignerOrProvider(signerWithProvider);
    return sdk;
  }
  /**
   * Get an instance of the thirdweb SDK based on a private key.
   *
   * @remarks
   * This should only be used for backend services or scripts, with the private key stored in a secure way.
   * **NEVER** expose your private key to the public in any way.
   *
   * @example
   * ```javascript
   * const sdk = ThirdwebSDK.fromPrivateKey("SecretPrivateKey", "mainnet");
   * ```
   *
   * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns an instance of the SDK
   *
   * @public
   */
  static fromPrivateKey(privateKey, network) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const provider2 = getChainProvider(network, options2);
    const signer = new Wallet(privateKey, provider2);
    return new ThirdwebSDK(signer, options2, storage);
  }
  /**
   * @internal
   * the cache of contracts that we have already seen
   */
  constructor(network) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 ? arguments[2] : void 0;
    if (isChainConfig(network)) {
      options2 = {
        ...options2,
        // @ts-expect-error - we know that the network is assignable despite the readonly mismatch
        supportedChains: [network, ...options2.supportedChains || []]
      };
    }
    super(network, options2);
    _defineProperty(this, "contractCache", /* @__PURE__ */ new Map());
    _defineProperty(this, "_publisher", void 0);
    _defineProperty(this, "storageHandler", void 0);
    _defineProperty(this, "deployer", void 0);
    _defineProperty(this, "verifier", void 0);
    _defineProperty(this, "multiChainRegistry", void 0);
    _defineProperty(this, "wallet", void 0);
    _defineProperty(this, "storage", void 0);
    setSupportedChains(options2?.supportedChains);
    const configuredStorage = createStorage(storage, options2);
    this.storage = configuredStorage;
    this.storageHandler = configuredStorage;
    this.wallet = new UserWallet(network, options2);
    this.deployer = new ContractDeployer(network, options2, configuredStorage);
    this.verifier = new ContractVerifier(network, options2, configuredStorage);
    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);
    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  /**
   * Get an instance of a NFT Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const dropContract = await sdk.getDropContract("0x1234...");
   * + const dropContract = await sdk.getContract("0x1234...", "nft-drop");
   * ```
   */
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  /**
   * Get an instance of a Signature Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getSignatureDrop("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "signature-drop");
   * ```
   */
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  /**
   * Get an instance of a NFT Collection Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getNFTCollection("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "nft-collection");
   * ```
   */
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  /**
   * Get an instance of a Edition Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const editionDrop = await sdk.getEditionDrop("0x1234...");
   * + const editionDrop = await sdk.getContract("0x1234...", "edition-drop");
   * ```
   */
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  /**
   * Get an instance of a Edition contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const edition = await sdk.getEdition("0x1234...");
   * + const edition = await sdk.getContract("0x1234...", "edition");
   * ```
   */
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  /**
   * Get an instance of a Token Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const tokenDrop = await sdk.getTokenDrop("0x1234...");
   * + const tokenDrop = await sdk.getContract("0x1234...", "token-drop");
   * ```
   */
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  /**
   * Get an instance of a Token contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const token = await sdk.getToken("0x1234...");
   * + const token = await sdk.getContract("0x1234...", "token");
   * ```
   */
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  /**
   * Get an instance of a Vote contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const vote = await sdk.getVote("0x1234...");
   * + const vote = await sdk.getContract("0x1234...", "vote");
   * ```
   */
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  /**
   * Get an instance of a Split contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const split = await sdk.getSplit("0x1234...");
   * + const split = await sdk.getContract("0x1234...", "split");
   * ```
   */
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplace("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace");
   * ```
   */
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplaceV3("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace-v3");
   * ```
   */
  async getMarketplaceV3(contractAddress) {
    return await this.getContract(contractAddress, "marketplace-v3");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const pack = await sdk.getPack("0x1234...");
   * + const pack = await sdk.getContract("0x1234...", "pack");
   * ```
   */
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const multiWrap = await sdk.getMultiwrap("0x1234...");
   * + const multiWrap = await sdk.getContract("0x1234...", "multiwrap");
   * ```
   */
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @returns the contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}");
   * ```
   */
  async getContract(address, contractTypeOrABI) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    if (resolvedAddress in GENERATED_ABI) {
      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      try {
        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);
        newContract = await this.getContractFromAbi(resolvedAddress, metadata.abi);
      } catch (e2) {
        const resolvedContractType = await this.resolveContractType(address);
        if (resolvedContractType && resolvedContractType !== "custom") {
          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(address, this.getProvider(), this.storage);
          newContract = await this.getContractFromAbi(address, contractAbi);
        } else {
          const chainId = (await this.getProvider().getNetwork()).chainId;
          throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
        }
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);
    }
    this.contractCache.set(resolvedAddress, newContract);
    return newContract;
  }
  /**
   * @internal
   * @deprecated use {@link getContract} directly instead
   */
  async getBuiltInContract(address, contractType2) {
    return await this.getContract(address, contractType2);
  }
  /**
   * @param contractAddress - the address of the contract to attempt to resolve the contract type for
   * @returns the {@link ContractType} for the given contract address
   *
   */
  async resolveContractType(contractAddress) {
    try {
      const contract = new Contract(
        await resolveAddress(contractAddress),
        IThirdwebContractABI,
        // !provider only! - signer can break things here!
        this.getProvider()
      );
      const remoteContractType = toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  /**
   * Return all the contracts deployed by the specified address
   * @param walletAddress - the deployed address
   * @example
   * ```javascript
   * const contracts = sdk.getContractList("{{wallet_address}}");
   * ```
   */
  async getContractList(walletAddress) {
    const addresses = await (await this.deployer.getRegistry())?.getContractAddresses(await resolveAddress(walletAddress)) || [];
    const chainId = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(addresses.map(async (address) => {
      return {
        address,
        chainId,
        contractType: () => this.resolveContractType(address),
        metadata: async () => (await this.getContract(address)).metadata.get(),
        extensions: async () => getAllDetectedFeatureNames((await this.getContract(address)).abi)
      };
    }));
  }
  async getMultichainContractList(walletAddress) {
    let chains = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultChains;
    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);
    const chainMap = chains.reduce((acc, chain) => {
      acc[chain.chainId] = chain;
      return acc;
    }, {});
    const sdkMap = {};
    return contracts.map((_ref) => {
      let {
        address,
        chainId
      } = _ref;
      if (!chainMap[chainId]) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({}),
          extensions: async () => []
        };
      }
      try {
        let chainSDK = sdkMap[chainId];
        if (!chainSDK) {
          chainSDK = new ThirdwebSDK(chainId, {
            ...this.options,
            // need to disable readonly settings for this to work
            readonlySettings: void 0,
            // @ts-expect-error - zod doesn't like this
            supportedChains: chains
          });
          sdkMap[chainId] = chainSDK;
        }
        return {
          address,
          chainId,
          contractType: () => chainSDK.resolveContractType(address),
          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),
          extensions: async () => getAllDetectedFeatureNames((await chainSDK.getContract(address)).abi)
        };
      } catch (e2) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({}),
          extensions: async () => []
        };
      }
    });
  }
  /**
   * Update the active signer or provider for all contracts
   * @param network - the new signer or provider
   */
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());
    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  /**
   * Get an instance of a Custom contract from a json ABI
   * @param address - the address of the deployed contract
   * @param abi - the JSON abi
   * @returns the contract
   * @beta
   * @example
   * ```javascript
   * // Import your ABI from a JSON file
   * import myABI from "./path/to/myABI.json";
   *
   * const contract = sdk.getContractFromAbi(
   *   "{{contract_address}}",
   *   // Pass in the "abi" field from the JSON file
   *   myABI.abi
   * );
   * ```
   */
  async getContractFromAbi(address, abi) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    const [, provider2] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const parsedABI = typeof abi === "string" ? JSON.parse(abi) : abi;
    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedABI), provider2, this.options, this.storage), this.storageHandler, this.options, (await provider2.getNetwork()).chainId);
    this.contractCache.set(resolvedAddress, contract);
    return contract;
  }
  /**
   * Get the native balance of a given address (wallet or contract)
   * @example
   * ```javascript
   * const balance = await sdk.getBalance("0x...");
   * console.log(balance.displayValue);
   * ```
   * @param address - the address to check the balance for
   */
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));
  }
  /**
   * @internal
   */
  getPublisher() {
    return this._publisher;
  }
}
const THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
class ContractDeployer extends RPCConnectionHandler {
  /**
   * @internal
   * should never be accessed directly, use {@link ContractDeployer.getFactory} instead
   */
  /**
   * @internal
   * should never be accessed directly, use {@link ContractDeployer.getRegistry} instead
   */
  constructor(network, _options, storage) {
    var _this;
    super(network, _options);
    _this = this;
    _defineProperty(this, "_factory", void 0);
    _defineProperty(this, "_registry", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "events", void 0);
    _defineProperty(this, "transactionListener", (event) => {
      if (event.status === "submitted") {
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: event.transactionHash
        });
      }
    });
    _defineProperty(this, "deployNFTCollection", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployNFTDrop", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deploySignatureDrop", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployMultiwrap", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployEdition", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployEditionDrop", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployToken", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployTokenDrop", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployMarketplace", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployMarketplaceV3", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata);
    }));
    _defineProperty(this, "deployPack", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deploySplit", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployVote", buildDeployTransactionFunction(async (metadata) => {
      return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata);
    }));
    _defineProperty(this, "deployBuiltInContract", buildDeployTransactionFunction(async function(contractType2, contractMetadata) {
      let version2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
      const signer = _this.getSigner();
      invariant$1(signer, "A signer is required to deploy contracts");
      const parsedMetadata = {
        app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType2],
        ...await PREBUILT_CONTRACTS_MAP[contractType2].schema.deploy.parseAsync(contractMetadata)
      };
      if (_this.hasLocalFactory()) {
        let parsedVersion = void 0;
        try {
          parsedVersion = parseInt(version2);
          if (isNaN(parsedVersion)) {
            parsedVersion = void 0;
          }
        } catch (e2) {
          parsedVersion = void 0;
        }
        const factory2 = await _this.getFactory();
        if (!factory2) {
          throw new Error("Factory not found");
        }
        factory2.on(EventType.Transaction, _this.transactionListener);
        return factory2.deploy.prepare(contractType2, parsedMetadata, _this.events, parsedVersion, () => {
          factory2.off(EventType.Transaction, _this.transactionListener);
        });
      }
      const contractName = getContractName(contractType2);
      invariant$1(contractName, "Contract name not found");
      const contractURI = await _this.storage.upload(parsedMetadata);
      const constructorParams = await getDeployArguments(contractType2, parsedMetadata, contractURI, signer, _this.storage);
      const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, version2);
      return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams);
    }));
    _defineProperty(this, "deployReleasedContract", buildDeployTransactionFunction(async function(publisherAddress, contractName, constructorParams) {
      let version2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
      let options2 = arguments.length > 4 ? arguments[4] : void 0;
      const publishedContract = await _this.fetchPublishedContractFromPolygon(publisherAddress, contractName, version2);
      return await _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options2);
    }));
    _defineProperty(this, "deployViaFactory", buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedFactoryAddress = await resolveAddress(factoryAddress);
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const signer = this.getSigner();
      invariant$1(signer, "signer is required");
      const proxyFactory = new ContractFactory(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      proxyFactory.on(EventType.Transaction, this.transactionListener);
      return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, () => {
        proxyFactory.off(EventType.Transaction, this.transactionListener);
      });
    }));
    _defineProperty(this, "deployProxy", buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedAddress = await resolveAddress(implementationAddress);
      const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const {
        TWProxy__factory
      } = await __vitePreload(() => import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-ce1b71a8.js"), true ? [] : void 0);
      return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);
    }));
    _defineProperty(this, "deployViaAutoFactory", buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options2) => {
      const create2Factory = await deployCreate2Factory(signer, options2);
      const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory);
      const implementationAddress = deploymentInfo.find((i2) => i2.type === "implementation")?.transaction.predictedAddress;
      const transactionsToSend = deploymentInfo.filter((i2) => i2.transaction.data && i2.transaction.data.length > 0);
      const transactionsforDirectDeploy = transactionsToSend.filter((i2) => {
        return i2.type !== "infra";
      }).map((i2) => i2.transaction);
      const transactionsForThrowawayDeployer = transactionsToSend.filter((i2) => {
        return i2.type === "infra";
      }).map((i2) => i2.transaction);
      await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options2);
      await Promise.all(transactionsforDirectDeploy.map((tx) => {
        return deployContractDeterministic(signer, tx, options2);
      }));
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory);
      options2?.notifier?.("deploying", "proxy");
      const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues);
      options2?.notifier?.("deployed", "proxy");
      return proxyDeployTransaction;
    }));
    _defineProperty(this, "deployViaCustomFactory", buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {
      let customFactoryAddress = deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.customFactoryAddresses[chainId];
      const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);
      invariant$1(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);
      invariant$1(deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.factoryFunction, `customFactoryFunction not set'`);
      const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage);
      const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((p2) => p2.type);
      const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);
      let deployedImplementationAddress;
      const deployTransaction = await Transaction.fromContractInfo({
        contractAddress: resolvedCustomFactoryAddress,
        contractAbi: customFactoryMetadata.abi,
        provider: this.getProvider(),
        signer,
        method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
        args: factoryFunctionparamValues,
        parse: () => {
          return deployedImplementationAddress;
        }
      });
      deployedImplementationAddress = await deployTransaction.simulate();
      return deployTransaction;
    }));
    _defineProperty(this, "deployContractFromUri", buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options2) => {
      const signer = this.getSigner();
      invariant$1(signer, "A signer is required");
      const {
        compilerMetadata: compilerMetadata2,
        extendedMetadata
      } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
      const forceDirectDeploy = options2?.forceDirectDeploy || false;
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const isNetworkEnabled = extendedMetadata?.networksForDeployment?.networksEnabled.includes(chainId) || extendedMetadata?.networksForDeployment?.allNetworks;
      if (extendedMetadata?.networksForDeployment && !isNetworkEnabled) {
        throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);
      }
      if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== "standard") && !forceDirectDeploy) {
        if (extendedMetadata.deployType === "customFactory") {
          return await this.deployViaCustomFactory.prepare(constructorParamValues, {
            compilerMetadata: compilerMetadata2,
            extendedMetadata
          }, signer, chainId);
        } else {
          invariant$1(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
          const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata2.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map((p2) => p2.type);
          const paramValues2 = convertParamValues(initializerParamTypes, constructorParamValues);
          let implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
          if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
            return await this.deployViaAutoFactory.prepare(publishMetadataUri, {
              compilerMetadata: compilerMetadata2,
              extendedMetadata
            }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options2);
          }
          const resolvedImplementationAddress = await resolveAddress(implementationAddress);
          invariant$1(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);
          if (extendedMetadata.isDeployableViaFactory) {
            invariant$1(extendedMetadata.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
            const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];
            invariant$1(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
            const resolvedFactoryAddress = await resolveAddress(factoryAddress);
            return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata2.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          } else if (extendedMetadata.isDeployableViaProxy) {
            return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata2.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          }
        }
      }
      const bytecode2 = compilerMetadata2.bytecode.startsWith("0x") ? compilerMetadata2.bytecode : `0x${compilerMetadata2.bytecode}`;
      if (!isHexString(bytecode2)) {
        throw new Error(`Contract bytecode is invalid.

${bytecode2}`);
      }
      const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata2.abi).map((p2) => p2.type);
      const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);
      return this.deployContractWithAbi.prepare(compilerMetadata2.abi, bytecode2, paramValues);
    }));
    _defineProperty(this, "deployContractWithAbi", buildDeployTransactionFunction(async (abi, bytecode2, constructorParams) => {
      const signer = this.getSigner();
      const provider2 = this.getProvider();
      invariant$1(signer, "Signer is required to deploy contracts");
      const factory2 = new ContractFactory$1(abi, bytecode2).connect(signer);
      return new DeployTransaction({
        args: constructorParams,
        provider: provider2,
        signer,
        factory: factory2,
        storage: this.storage,
        events: this.events
      });
    }));
    this.storage = storage;
    this.events = new EventEmitter$1();
    this.getFactory();
    this.getRegistry();
  }
  /**
   * @internal
   * @param contractType
   */
  async getLatestBuiltInContractVersion(contractType2) {
    const factory2 = await this.getFactory();
    if (!factory2) {
      throw new Error("Factory not found");
    }
    return await factory2.getLatestVersion(contractType2);
  }
  /**
   * @internal
   */
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      if (!registryAddress) {
        return void 0;
      }
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref3) => {
      let {
        chainId
      } = _ref3;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      if (!factoryAddress) {
        return void 0;
      }
      const factory2 = new ContractFactory(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      return factory2;
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this._factory?.then((factory2) => {
      factory2?.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    this._registry?.then((registry) => {
      registry?.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  /**
   * @public
   * @param publishMetadataUri
   * @param options
   */
  async getTransactionsForDeploy(publishMetadataUri, options2) {
    let transactions = [];
    const provider2 = this.getProvider();
    invariant$1(provider2, "A provider is required");
    const {
      extendedMetadata
    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
    const forceDirectDeploy = options2?.forceDirectDeploy || false;
    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === "autoFactory") && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      let implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
      if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());
        transactions.push({
          contractType: "create2Factory",
          addresses: [create2FactoryAddress]
        });
        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress);
        const transactionsToSend = deploymentInfo.filter((i2) => i2.transaction.data && i2.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i2) => {
          return i2.type !== "infra";
        }).map((i2) => i2.transaction);
        transactionsforDirectDeploy.forEach((tx) => {
          transactions.push({
            contractType: "preset",
            addresses: [tx.predictedAddress]
          });
        });
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i2) => {
          return i2.type === "infra";
        }).map((i2) => i2.transaction);
        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);
        transactionBatches.forEach((batch2) => {
          const addresses = batch2.map((tx) => tx.predictedAddress);
          transactions.push({
            contractType: "infra",
            addresses
          });
        });
      }
      transactions = (await Promise.all(transactions.map(async (tx) => {
        const addresses = (await Promise.all(tx.addresses.map(async (address) => {
          const isDeployed = await isContractDeployed(address, provider2);
          return isDeployed ? null : address;
        }))).filter(Boolean);
        return addresses.length > 0 ? tx : null;
      }))).filter(Boolean);
      transactions.push({
        contractType: "proxy",
        addresses: []
      });
    } else {
      transactions.push({
        contractType: "custom",
        addresses: []
      });
    }
    return transactions;
  }
  /**
   * Listen to all deploy transactions from this deployer
   * @param listener the listener to add
   */
  addDeployListener(listener) {
    this.events.on("contractDeployed", listener);
  }
  /**
   * Remove a deploy listener
   * @param listener the listener to remove
   */
  removeDeployListener(listener) {
    this.events.off("contractDeployed", listener);
  }
  /**
   * Remove all deploy listeners
   */
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  // PRIVATE METHODS
  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version2) {
    const address = await resolveAddress(publisherAddress);
    const publishedContract = await new ThirdwebSDK("polygon").getPublisher().getVersion(address, contractName, version2);
    if (!publishedContract) {
      throw new Error(`No published contract found for '${contractName}' at version '${version2}' by '${address}'`);
    }
    return publishedContract;
  }
  hasLocalFactory() {
    return { "TERM_SESSION_ID": "bc90c290-89cf-42cd-b7b3-9effdd1cd641", "GJS_DEBUG_TOPICS": "JS ERROR;JS LOG", "LESSOPEN": "| /usr/bin/lesspipe %s", "LANGUAGE": "en_CA:en", "SNAP_INSTANCE_KEY": "", "J2SDKDIR": "/usr/lib/jvm/java-14-oracle", "USER": "brandon", "SNAP_COMMON": "/var/snap/intellij-idea-ultimate/common", "npm_config_user_agent": "npm/8.12.1 node/v18.4.0 linux x64 workspaces/false", "XDG_SESSION_TYPE": "wayland", "npm_node_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "J2REDIR": "/usr/lib/jvm/java-14-oracle", "SHLVL": "1", "npm_config_noproxy": "", "HOME": "/home/brandon", "SNAP_LIBRARY_PATH": "/var/lib/snapd/lib/gl:/var/lib/snapd/lib/gl32:/var/lib/snapd/void", "DESKTOP_SESSION": "ubuntu", "SNAP_USER_DATA": "/home/brandon/snap/intellij-idea-ultimate/430", "NVM_BIN": "/home/brandon/.nvm/versions/node/v18.4.0/bin", "npm_package_json": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/package.json", "NVM_INC": "/home/brandon/.nvm/versions/node/v18.4.0/include/node", "TERMINAL_EMULATOR": "JetBrains-JediTerm", "rvm_stored_umask": "0002", "GIO_LAUNCHED_DESKTOP_FILE": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SHELL_SESSION_MODE": "ubuntu", "GTK_MODULES": "gail:atk-bridge", "rvm_user_install_flag": "1", "MANAGERPID": "4527", "npm_config_userconfig": "/home/brandon/.npmrc", "npm_config_local_prefix": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "SYSTEMD_EXEC_PID": "4844", "DBUS_SESSION_BUS_ADDRESS": "unix:path=/run/user/1000/bus", "SNAP_REVISION": "430", "GIO_LAUNCHED_DESKTOP_FILE_PID": "80774", "COLOR": "1", "NVM_DIR": "/home/brandon/.nvm", "npm_config_metrics_registry": "https://registry.npmjs.org/", "IM_CONFIG_PHASE": "1", "WAYLAND_DISPLAY": "wayland-0", "LOGNAME": "brandon", "SNAP_CONTEXT": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "rvm_bin_path": "/home/brandon/.rvm/bin", "JOURNAL_STREAM": "8:66838", "_": "/home/brandon/.nvm/versions/node/v18.4.0/bin/npm", "npm_config_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "RUBY_VERSION": "ruby-3.0.0", "XDG_SESSION_CLASS": "user", "SNAP_VERSION": "2023.1.2", "IRBRC": "/home/brandon/.rvm/rubies/ruby-3.0.0/.irbrc", "USERNAME": "brandon", "TERM": "xterm-256color", "npm_config_cache": "/home/brandon/.npm", "GNOME_DESKTOP_SESSION_ID": "this-is-deprecated", "DOTNET_ROOT": "/usr/lib/dotnet", "RBENV_SHELL": "bash", "SNAP_INSTANCE_NAME": "intellij-idea-ultimate", "npm_config_node_gyp": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js", "PATH": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/node_modules/.bin:/Data/Work/blockchain/ideadao/configurator/node_modules/.bin:/Data/Work/blockchain/ideadao/node_modules/.bin:/Data/Work/blockchain/node_modules/.bin:/Data/Work/node_modules/.bin:/Data/node_modules/.bin:/node_modules/.bin:/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/node_modules/@npmcli/run-script/lib/node-gyp-bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/bin:/home/brandon/.nvm/versions/node/v18.4.0/bin:/home/brandon/.rbenv/shims:/home/brandon/.rbenv/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.cargo/bin:/home/brandon/.local/share/solana/install/active_release/bin:/home/brandon/.rvm/gems/ruby-3.0.0/bin:/home/brandon/.rvm/gems/ruby-3.0.0@global/bin:/home/brandon/.rvm/rubies/ruby-3.0.0/bin:/home/brandon/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/brandon/.dotnet/tools:/usr/lib/jvm/java-14-oracle/bin:/usr/lib/jvm/java-14-oracle/db/bin:/home/brandon/.rvm/bin:/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend/node_modules/.bin:/home/brandon/.rvm/bin", "SESSION_MANAGER": "local/brandon-MS-7B85:@/tmp/.ICE-unix/4822,unix/brandon-MS-7B85:/tmp/.ICE-unix/4822", "DERBY_HOME": "/usr/lib/jvm/java-14-oracle/db", "INVOCATION_ID": "f89c52985a254dd1a1bc1c183b2419d9", "NODE": "/home/brandon/.nvm/versions/node/v18.4.0/bin/node", "npm_package_name": "idea-create", "XDG_MENU_PREFIX": "gnome-", "BAMF_DESKTOP_FILE_HINT": "/var/lib/snapd/desktop/applications/intellij-idea-ultimate_intellij-idea-ultimate.desktop", "GNOME_SETUP_DISPLAY": ":1", "SNAP_DATA": "/var/snap/intellij-idea-ultimate/430", "XDG_RUNTIME_DIR": "/run/user/1000", "MY_RUBY_HOME": "/home/brandon/.rvm/rubies/ruby-3.0.0", "DISPLAY": ":0", "DESKTOP_STARTUP_ID": "IDEA-restart_TIME55719025", "LANG": "en_CA.UTF-8", "XDG_CURRENT_DESKTOP": "ubuntu:GNOME", "DOTNET_BUNDLE_EXTRACT_BASE_DIR": "/home/brandon/.cache/dotnet_bundle_extract", "XMODIFIERS": "@im=ibus", "XDG_SESSION_DESKTOP": "ubuntu", "XAUTHORITY": "/run/user/1000/.mutter-Xwaylandauth.9JLX61", "LS_COLORS": "rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", "npm_lifecycle_script": "vite build", "SSH_AGENT_LAUNCHER": "gnome-keyring", "SNAP_USER_COMMON": "/home/brandon/snap/intellij-idea-ultimate/common", "SSH_AUTH_SOCK": "/run/user/1000/keyring/ssh", "SNAP_ARCH": "amd64", "SNAP_COOKIE": "BJh9fMWr-vwscpCn3aHjUPLFrSXawDJ3gQh4I3XDh_9qFgFBBH6V", "SHELL": "/bin/bash", "npm_package_version": "2.0.0", "npm_lifecycle_event": "build", "QT_ACCESSIBILITY": "1", "rvm_prefix": "/home/brandon", "SNAP_REEXEC": "", "rvm_loaded_flag": "1", "GDMSESSION": "ubuntu", "GEM_HOME": "/home/brandon/.rvm/gems/ruby-3.0.0", "LESSCLOSE": "/usr/bin/lesspipe %s %s", "SNAP_NAME": "intellij-idea-ultimate", "rvm_version": "1.29.12 (latest)", "_INTELLIJ_FORCE_PREPEND_PATH": "/bin:", "GJS_DEBUG_OUTPUT": "stderr", "QT_IM_MODULE": "ibus", "npm_config_globalconfig": "/home/brandon/.nvm/versions/node/v18.4.0/etc/npmrc", "npm_config_init_module": "/home/brandon/.npm-init.js", "JAVA_HOME": "/usr/lib/jvm/java-14-oracle", "PWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "GEM_PATH": "/home/brandon/.rvm/gems/ruby-3.0.0:/home/brandon/.rvm/gems/ruby-3.0.0@global", "npm_execpath": "/home/brandon/.nvm/versions/node/v18.4.0/lib/node_modules/npm/bin/npm-cli.js", "XDG_CONFIG_DIRS": "/etc/xdg/xdg-ubuntu:/etc/xdg", "SNAP_REAL_HOME": "/home/brandon", "NVM_CD_FLAGS": "", "FIG_JETBRAINS_SHELL_INTEGRATION": "1", "XDG_DATA_DIRS": "/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop", "npm_config_global_prefix": "/home/brandon/.nvm/versions/node/v18.4.0", "SNAP": "/snap/intellij-idea-ultimate/430", "npm_command": "run-script", "rvm_path": "/home/brandon/.rvm", "INIT_CWD": "/Data/Work/blockchain/ideadao/configurator/Idea-nfts/Painter-Frontend", "EDITOR": "vi", "NODE_ENV": "production" }.factoryAddress !== void 0;
  }
}
const metadataCache = {};
const polygonSDK = new ThirdwebSDK("polygon");
function getCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function putInCache(address, chainId, metadata) {
  metadataCache[getCacheKey(address, chainId)] = metadata;
}
function getFromCache(address, chainId) {
  return metadataCache[getCacheKey(address, chainId)];
}
async function fetchContractMetadataFromAddress(address, provider2, storage) {
  const chainId = (await provider2.getNetwork()).chainId;
  const cached = getFromCache(address, chainId);
  if (cached) {
    return cached;
  }
  let metadata;
  try {
    const compilerMetadataUri = await resolveContractUriFromAddress(address, provider2);
    if (!compilerMetadataUri) {
      throw new Error(`Could not resolve metadata for contract at ${address}`);
    }
    metadata = await fetchContractMetadata(compilerMetadataUri, storage);
  } catch (e2) {
    console.warn("Failed to get Contract Metadata from IPFS, defaulting to onchain registry", e2);
    try {
      const importedUri = await polygonSDK.multiChainRegistry.getContractMetadataURI(chainId, address);
      if (!importedUri) {
        throw new Error(`Could not resolve metadata for contract at ${address}`);
      }
      metadata = await fetchContractMetadata(importedUri, storage);
    } catch (err) {
      throw new Error(`Could not resolve metadata for contract at ${address}`);
    }
  }
  if (!metadata) {
    throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  putInCache(address, chainId, metadata);
  return metadata;
}
async function fetchAbiFromAddress(address, provider2, storage) {
  try {
    const metadata = await fetchContractMetadataFromAddress(address, provider2, storage);
    if (metadata && metadata.abi) {
      return metadata.abi;
    }
  } catch (e2) {
  }
  return void 0;
}
class ContractMetadata {
  constructor(contractWrapper, schema, storage) {
    _defineProperty(this, "featureName", FEATURE_METADATA.name);
    _defineProperty(this, "contractWrapper", void 0);
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "set", buildTransactionFunction(async (metadata) => {
      const uri = await this._parseAndUploadMetadata(metadata);
      const wrapper = this.contractWrapper;
      if (this.supportsContractMetadata(wrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setContractURI",
          args: [uri],
          parse: (receipt) => {
            return {
              receipt,
              data: this.get
            };
          }
        });
      } else {
        throw new ExtensionNotImplementedError(FEATURE_METADATA);
      }
    }));
    _defineProperty(this, "update", buildTransactionFunction(async (metadata) => {
      return await this.set.prepare({
        ...await this.get(),
        ...metadata
      });
    }));
    this.contractWrapper = contractWrapper;
    this.schema = schema;
    this.storage = storage;
  }
  /**
   * @internal
   */
  parseOutputMetadata(metadata) {
    return this.schema.output.parseAsync(metadata);
  }
  /**
   * @internal
   */
  parseInputMetadata(metadata) {
    return this.schema.input.parseAsync(metadata);
  }
  /**
   * Get the metadata of this contract
   * @remarks Get the metadata of a contract
   * @example
   * ```javascript
   * const metadata = await contract.metadata.get();
   * console.log(metadata);
   * ```
   * @public
   * @returns the metadata of the given contract
   * @twfeature ContractMetadata
   */
  async get() {
    let data;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const uri = await this.contractWrapper.readContract.contractURI();
      if (uri && uri.includes("://")) {
        data = await this.storage.downloadJSON(uri);
      }
    }
    if (!data) {
      try {
        let contractName;
        try {
          if (hasFunction("name", this.contractWrapper)) {
            contractName = await this.contractWrapper.readContract.name();
          }
        } catch (err) {
        }
        let contractSymbol;
        try {
          if (hasFunction("symbol", this.contractWrapper)) {
            contractSymbol = await this.contractWrapper.readContract.symbol();
          }
        } catch (err) {
        }
        let publishedMetadata;
        try {
          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.readContract.address, this.contractWrapper.getProvider(), this.storage);
        } catch (err) {
        }
        data = {
          name: contractName || publishedMetadata?.name,
          symbol: contractSymbol,
          description: publishedMetadata?.info.title
        };
      } catch (e2) {
        throw new Error("Could not fetch contract metadata");
      }
    }
    return this.parseOutputMetadata(data);
  }
  /**
   *
   * @internal
   * @param metadata - the metadata to set
   * @returns
   */
  async _parseAndUploadMetadata(metadata) {
    const parsedMetadata = await this.parseInputMetadata(metadata);
    return this.storage.upload(parsedMetadata);
  }
  supportsContractMetadata(contractWrapper) {
    return detectContractFeature(contractWrapper, "ContractMetadata");
  }
}
const PropertiesInput = z$2.object({}).catchall(z$2.union([BigNumberTransformSchema, z$2.unknown()]));
z$2.union([z$2.array(PropertiesInput), PropertiesInput]).optional();
z$2.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
});
const EditionMetadataOutputSchema = z$2.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});
EditionMetadataOutputSchema.extend({
  owner: z$2.string(),
  quantityOwned: BigNumberSchema
});
z$2.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});
z$2.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}
function resolveIpfsUri(uri, options2) {
  if (!uri) {
    return void 0;
  }
  const gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options2?.gatewayUrl ? [options2?.gatewayUrl] : void 0));
  return replaceSchemeWithGatewayUrl(uri, gatewayUrls);
}
async function resolveMimeType(url) {
  if (!url) {
    return void 0;
  }
  const mimeType = mime.getType(url);
  if (mimeType) {
    return mimeType;
  }
  const res = await fetch(url, {
    method: "HEAD"
  });
  if (res.ok && res.headers.has("content-type")) {
    return res.headers.get("content-type") || void 0;
  }
  return void 0;
}
const ThirdwebThemeContext = /* @__PURE__ */ reactExports.createContext(void 0);
const LAST_CONNECTED_WALLET_STORAGE_KEY = "lastConnectedWallet";
let lastConnectedWalletStorage;
const walletInstanceToConfig = /* @__PURE__ */ new Map();
const ThirdwebWalletContext = /* @__PURE__ */ reactExports.createContext(void 0);
function ThirdwebWalletProvider(props) {
  const [signer, setSigner] = reactExports.useState(void 0);
  const [connectionStatus, setConnectionStatus] = reactExports.useState("unknown");
  const [activeWallet, setActiveWallet] = reactExports.useState();
  const [createdWalletInstance, setCreatedWalletInstance] = reactExports.useState();
  const [activeWalletConfig, setActiveWalletConfig] = reactExports.useState();
  if (!lastConnectedWalletStorage) {
    lastConnectedWalletStorage = props.createWalletStorage("coordinatorStorage");
  }
  const chainToConnect = props.autoSwitch ? props.activeChain : void 0;
  const theme2 = reactExports.useContext(ThirdwebThemeContext);
  const walletParams = reactExports.useMemo(() => {
    const walletChains = props.chains;
    const walletOptions = {
      chains: walletChains,
      dappMetadata: props.dAppMeta
    };
    return {
      ...walletOptions,
      chain: props.activeChain || props.chains[0],
      theme: theme2 || "dark"
    };
  }, [props.chains, props.dAppMeta, props.activeChain, theme2]);
  const createWalletInstance = reactExports.useCallback((walletConfig) => {
    const walletInstance = walletConfig.create(walletParams);
    if (walletInstance.walletId === walletIds.magicLink) {
      setCreatedWalletInstance(walletInstance);
    }
    walletInstanceToConfig.set(walletInstance, walletConfig);
    return walletInstance;
  }, [walletParams]);
  reactExports.useEffect(() => {
    if (activeWallet) {
      activeWallet.updateChains(props.chains);
    }
  }, [activeWallet, props.chains]);
  const setConnectedWallet = reactExports.useCallback(async function(wallet, connectParams) {
    let isAutoConnect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    setActiveWallet(wallet);
    const walletConfig = walletInstanceToConfig.get(wallet);
    if (!walletConfig) {
      throw new Error("Wallet config not found for given wallet instance. Do not create a wallet instance manually - use the useCreateWalletInstance() hook instead");
    }
    setActiveWalletConfig(walletConfig);
    setConnectionStatus("connected");
    const _signer = await wallet.getSigner();
    setSigner(_signer);
    if (isAutoConnect) {
      return;
    }
    const walletInfo = {
      walletId: walletConfig.id,
      connectParams
    };
    const personalWallet = wallet.getPersonalWallet();
    const personalWalletConfig = walletInstanceToConfig.get(personalWallet);
    if (personalWallet && personalWalletConfig) {
      walletInfo.connectParams = {
        ...walletInfo.connectParams,
        personalWallet: {
          walletId: personalWalletConfig.id,
          connectParams: personalWallet.getConnectParams()
        }
      };
      saveLastConnectedWalletInfo(walletInfo);
    } else {
      saveLastConnectedWalletInfo(walletInfo);
    }
  }, []);
  const storeLastActiveChainId = reactExports.useCallback(async (chainId) => {
    const lastConnectedWallet = await lastConnectedWalletStorage.getItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
    if (!lastConnectedWallet) {
      return;
    }
    try {
      const parsedWallet = JSON.parse(lastConnectedWallet);
      parsedWallet.connectParams.chainId = chainId;
      await lastConnectedWalletStorage.setItem(LAST_CONNECTED_WALLET_STORAGE_KEY, JSON.stringify(parsedWallet));
    } catch (error) {
      console.error(`Error saving the last active chain: ${error}`);
    }
  }, []);
  const switchChain = reactExports.useCallback(async (chainId) => {
    if (!activeWallet) {
      throw new Error("No active wallet");
    }
    await activeWallet.switchChain(chainId);
    const _signer = await activeWallet.getSigner();
    await storeLastActiveChainId(chainId);
    setSigner(_signer);
  }, [activeWallet, storeLastActiveChainId]);
  const autoConnectTriggered = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (autoConnectTriggered.current) {
      return;
    }
    if (props.shouldAutoConnect === false) {
      setConnectionStatus("disconnected");
      return;
    }
    if (activeWallet) {
      return;
    }
    if (connectionStatus !== "unknown") {
      return;
    }
    autoConnectTriggered.current = true;
    async function autoconnect() {
      const walletInfo = await getLastConnectedWalletInfo();
      if (!walletInfo) {
        setConnectionStatus("disconnected");
        return;
      }
      const walletObj = props.supportedWallets.find((W2) => W2.id === walletInfo.walletId);
      if (!walletObj) {
        setConnectionStatus("disconnected");
        return;
      }
      const personalWalletInfo = walletInfo.connectParams?.personalWallet;
      if (personalWalletInfo) {
        const personalWallets = walletObj.personalWallets || [];
        const personalWalleObj = personalWallets.find((W2) => W2.id === personalWalletInfo.walletId);
        if (personalWalleObj) {
          const personalWalletInstance = createWalletInstance(personalWalleObj);
          try {
            await personalWalletInstance.autoConnect(personalWalletInfo.connectParams);
          } catch (e2) {
            console.error(e2);
            setConnectionStatus("disconnected");
            return;
          }
          walletInfo.connectParams = {
            ...walletInfo.connectParams,
            personalWallet: personalWalletInstance
          };
        } else {
          setConnectionStatus("disconnected");
          return;
        }
      }
      const wallet = createWalletInstance(walletObj);
      try {
        setConnectionStatus("connecting");
        await wallet.autoConnect(walletInfo.connectParams);
        setConnectedWallet(wallet, walletInfo.connectParams, true);
      } catch (e2) {
        console.error(e2);
        lastConnectedWalletStorage.removeItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
        setConnectionStatus("disconnected");
      }
    }
    autoconnect();
  }, [createWalletInstance, props.supportedWallets, setConnectedWallet, props.shouldAutoConnect, activeWallet, connectionStatus]);
  const connectWallet = reactExports.useCallback(async function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const [WalletObj, connectParams] = args;
    const _connectedParams = {
      chainId: chainToConnect?.chainId,
      ...connectParams || {}
    };
    const wallet = createWalletInstance(WalletObj);
    setConnectionStatus("connecting");
    try {
      await wallet.connect(_connectedParams);
      setConnectedWallet(wallet, _connectedParams);
    } catch (e2) {
      console.error(`Error connecting to wallet: ${e2}`);
      setConnectionStatus("disconnected");
      throw e2;
    }
    return wallet;
  }, [createWalletInstance, setConnectedWallet, chainToConnect]);
  const onWalletDisconnect = reactExports.useCallback(async () => {
    await lastConnectedWalletStorage.removeItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
    setConnectionStatus("disconnected");
    setSigner(void 0);
    setActiveWallet(void 0);
    setActiveWalletConfig(void 0);
  }, []);
  const disconnectWallet = reactExports.useCallback(async () => {
    if (!activeWallet) {
      onWalletDisconnect();
      return;
    }
    const personalWallet = activeWallet.getPersonalWallet();
    await activeWallet.disconnect();
    if (personalWallet) {
      await personalWallet?.disconnect();
    }
    onWalletDisconnect();
  }, [activeWallet, onWalletDisconnect]);
  reactExports.useEffect(() => {
    if (!activeWallet) {
      return;
    }
    const update5 = async () => {
      const _signer = await activeWallet.getSigner();
      setSigner(_signer);
    };
    activeWallet.addListener("change", () => {
      update5();
    });
    activeWallet.addListener("disconnect", () => {
      onWalletDisconnect();
    });
    return () => {
      activeWallet.removeListener("change");
      activeWallet.removeListener("disconnect");
    };
  }, [activeWallet, onWalletDisconnect]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebWalletContext.Provider, {
    value: {
      disconnect: disconnectWallet,
      wallets: props.supportedWallets,
      connect: connectWallet,
      signer,
      activeWallet,
      activeWalletConfig,
      connectionStatus,
      setConnectionStatus,
      createWalletInstance,
      createdWalletInstance,
      createWalletStorage: props.createWalletStorage,
      switchChain,
      setConnectedWallet,
      activeChain: props.activeChain,
      chainToConnect,
      getWalletConfig: (walletInstance) => {
        return walletInstanceToConfig.get(walletInstance);
      }
    },
    children: props.children
  });
}
function useWalletContext() {
  const ctx = reactExports.useContext(ThirdwebWalletContext);
  if (!ctx) {
    throw new Error(`useWalletContext() can only be used inside <ThirdwebProvider />`);
  }
  return ctx;
}
async function getLastConnectedWalletInfo() {
  const str = await lastConnectedWalletStorage.getItem(LAST_CONNECTED_WALLET_STORAGE_KEY);
  if (!str) {
    return null;
  }
  return JSON.parse(str);
}
async function saveLastConnectedWalletInfo(walletInfo) {
  try {
    await lastConnectedWalletStorage.setItem(LAST_CONNECTED_WALLET_STORAGE_KEY, JSON.stringify(walletInfo));
  } catch (e2) {
    console.error("Error saving the last connected wallet info", e2);
  }
}
function useWallet() {
  const context = useWalletContext();
  invariant$1(context, "useWallet() hook must be used within a <ThirdwebProvider/>");
  return context.activeWallet;
}
function useWallets() {
  const context = useWalletContext();
  invariant$1(context, "useWallets() hook must be used within a <ThirdwebProvider/>");
  return context.wallets;
}
function useConnect() {
  const context = useWalletContext();
  invariant$1(context, "useConnect() hook must be used within a <ThirdwebProvider/>");
  return context.connect;
}
function useDisconnect() {
  const context = useWalletContext();
  invariant$1(context, "useDisconnect() hook must be used within a <ThirdwebProvider/>");
  return context.disconnect;
}
function useConnectionStatus() {
  const context = useWalletContext();
  invariant$1(context, "useConnectionStatus() must be used within a <ThirdwebProvider/>");
  return context.connectionStatus;
}
function useCreateWalletInstance() {
  const context = useWalletContext();
  invariant$1(context, "useCreateWalletInstance() must be used within a <ThirdwebProvider/>");
  return context.createWalletInstance;
}
function useSwitchChain() {
  const context = useWalletContext();
  invariant$1(context, "useSwitchChain() must be used within a <ThirdwebProvider/>");
  return context.switchChain;
}
const ThirdwebAuthContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useThirdwebAuthContext() {
  return reactExports.useContext(ThirdwebAuthContext);
}
const TW_CACHE_KEY_PREFIX = "tw-cache";
function enforceCachePrefix(input) {
  return [TW_CACHE_KEY_PREFIX, ...input.filter((i2) => typeof i2 !== "string" || i2 !== TW_CACHE_KEY_PREFIX)];
}
function createContractCacheKey() {
  let contractAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : AddressZero$1;
  let input = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return enforceCachePrefix(["contract", contractAddress, ...input]);
}
function createCacheKeyWithNetwork(input, chainId) {
  return enforceCachePrefix(cacheKeys.network.active(chainId).concat(input));
}
const cacheKeys = {
  auth: {
    user: () => enforceCachePrefix(["user"])
  },
  network: {
    active: (chainId) => enforceCachePrefix(["chainId", chainId])
  },
  wallet: {
    balance: (chainId, walletAddress, tokenAddress) => enforceCachePrefix(createCacheKeyWithNetwork(enforceCachePrefix(["balance", {
      walletAddress,
      tokenAddress
    }]), chainId))
  },
  contract: {
    read: (contractAddress, fnIdentity) => createContractCacheKey(contractAddress, ["read", fnIdentity]),
    type: (contractAddress) => createContractCacheKey(contractAddress, ["contract-type"]),
    compilerMetadata: (contractAddress) => createContractCacheKey(contractAddress, ["publish-metadata"]),
    typeAndCompilerMetadata: (contractAddress) => createContractCacheKey(contractAddress, ["contract-type-and-metadata"]),
    metadata: (contractAddress) => createContractCacheKey(contractAddress, ["metadata"]),
    extractFunctions: (contractAddress) => createContractCacheKey(contractAddress, ["extractFunctions"]),
    call: (contractAddress, functionName, args, overrides) => createContractCacheKey(contractAddress, ["call", functionName, args, overrides]),
    smartWalletFactory: {
      getAll: (contractAddress) => createContractCacheKey(contractAddress, ["smartWalletFactory"])
    },
    app: {
      get: (contractAddress) => createContractCacheKey(contractAddress, ["appURI"])
    },
    events: {
      getEvents: (contractAddress, eventName) => createContractCacheKey(contractAddress, ["events", "getEvents", {
        eventName
      }]),
      getAllEvents: (contractAddress) => createContractCacheKey(contractAddress, ["events", "getAllEvents"])
    },
    // specific contract types
    nft: {
      get: (contractAddress, tokenId) => createContractCacheKey(contractAddress, ["get", {
        tokenId
      }]),
      balanceOf: (contractAddress, owner, tokenId) => createContractCacheKey(contractAddress, ["balanceOf", {
        owner,
        tokenId
      }]),
      query: {
        all: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["query", "all", params] : ["query", "all"]),
        totalCirculatingSupply: (contractAddress) => createContractCacheKey(contractAddress, ["query", "totalCirculatingSupply"]),
        totalCount: (contractAddress) => createContractCacheKey(contractAddress, ["query", "totalCount"]),
        owned: {
          all: (contractAddress, owner) => createContractCacheKey(contractAddress, ["query", "owned", "all", owner])
        }
      },
      drop: {
        getAllUnclaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllUnclaimed", params] : ["getAllUnclaimed"]),
        getAllClaimed: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllClaimed", params] : ["getAllClaimed"]),
        totalUnclaimedSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalUnclaimedSupply"]),
        totalClaimedSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalClaimedSupply"]),
        revealer: {
          getBatchesToReveal: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getBatchesToReveal", params] : ["getBatchesToReveal"])
        }
      }
    },
    token: {
      totalSupply: (contractAddress) => createContractCacheKey(contractAddress, ["totalSupply"]),
      decimals: (contractAddress) => createContractCacheKey(contractAddress, ["decimals"]),
      balanceOf: (contractAddress, walletAddress) => createContractCacheKey(contractAddress, ["balanceOf", {
        walletAddress
      }])
    },
    marketplace: {
      getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["getListing", {
        listingId
      }]),
      getAllListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllListings", params] : ["getAllListings"]),
      getTotalCount: (contractAddress) => createContractCacheKey(contractAddress, ["getTotalCount"]),
      getActiveListings: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getActiveListings", params] : ["getActiveListings"]),
      getBidBufferBps: (contractAddress) => createContractCacheKey(contractAddress, ["getBidBufferBps"]),
      auction: {
        getWinningBid: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinningBid", {
          listingId
        }]),
        getWinner: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["auction", "getWinner", {
          listingId
        }])
      },
      directListings: {
        getAll: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllDirectListings", params] : ["getAllDirectListings"]),
        getAllValid: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllValidDirectListings", params] : ["getAllValidDirectListings"]),
        getListing: (contractAddress, listingId) => createContractCacheKey(contractAddress, ["getListing", {
          listingId
        }]),
        getTotalCount: (contractAddress) => createContractCacheKey(contractAddress, ["getTotalDirectListingsCount"])
      },
      englishAuctions: {
        getAll: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllEnglishAuctions", params] : ["getAllEnglishAuctions"]),
        getAllValid: (contractAddress, params) => createContractCacheKey(contractAddress, params ? ["getAllEValidEnglishAuctions", params] : ["getAllEValidEnglishAuctions"]),
        getAuction: (contractAddress, auctionId) => createContractCacheKey(contractAddress, ["getAuction", {
          auctionId
        }]),
        getWinningBid: (contractAddress, auctionId) => createContractCacheKey(contractAddress, ["getWinningBid", {
          auctionId
        }]),
        getTotalCount: (contractAddress) => createContractCacheKey(contractAddress, ["getTotalEnglishAuctionsCount"])
      }
    }
  },
  // extensions
  extensions: {
    claimConditions: {
      getActive: (contractAddress, tokenId, options2) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getActive", {
        tokenId
      }, options2] : ["claimConditions", "getActive", options2]),
      getAll: (contractAddress, tokenId, options2) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getAll", {
        tokenId
      }, options2] : ["claimConditions", "getAll", options2]),
      getClaimerProofs: (contractAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getClaimerProofs", {
        tokenId
      }] : ["claimConditions", "getClaimerProofs"]),
      getClaimIneligibilityReasons: (contractAddress, params, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getIneligibilityReasons", {
        tokenId
      }, params] : ["claimConditions", "getIneligibilityReasons", params]),
      // combinations of queries cache keys
      useActiveClaimConditionForWallet: (contractAddress, walletAddress, tokenId) => createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "useActiveClaimConditionForWallet", {
        tokenId,
        walletAddress
      }, ,] : ["claimConditions", "getIneligibilityReasons", {
        walletAddress
      }])
    },
    // primary sale contracts
    sales: {
      getRecipient: (contractAddress) => createContractCacheKey(contractAddress, ["sales"])
    },
    // royalties
    royalties: {
      getDefaultRoyaltyInfo: (contractAddress) => createContractCacheKey(contractAddress, ["royalties"])
    },
    // platform fees
    platformFees: {
      get: (contractAddress) => createContractCacheKey(contractAddress, ["platformFees"])
    },
    // contract metadata
    metadata: {
      get: (contractAddress) => createContractCacheKey(contractAddress, ["metadata"])
    },
    roles: {
      getAll: (contractAddress) => createContractCacheKey(contractAddress, ["roles"]),
      get: (contractAddress, role) => createContractCacheKey(contractAddress, ["roles", {
        role
      }])
    }
  }
};
const AUTH_TOKEN_STORAGE_KEY = "auth_token_storage_key";
function useLogout() {
  const queryClient = useQueryClient();
  const authConfig = useThirdwebAuthContext();
  const logout = useMutation({
    mutationFn: async () => {
      invariant$1(authConfig, "Please specify an authConfig in the ThirdwebProvider");
      invariant$1(authConfig.authUrl, "Please specify an authUrl in the authConfig.");
      await fetch(`${authConfig.authUrl}/logout`, {
        method: "POST",
        credentials: "include"
      });
      authConfig.secureStorage?.removeItem(AUTH_TOKEN_STORAGE_KEY);
      queryClient.invalidateQueries(cacheKeys.auth.user());
    }
  });
  return {
    logout: logout.mutateAsync,
    isLoading: logout.isLoading
  };
}
function useUser() {
  const authConfig = useThirdwebAuthContext();
  const {
    data: user,
    isLoading
  } = useQuery(cacheKeys.auth.user(), async () => {
    invariant$1(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    invariant$1(authConfig.authUrl, "Please specify an authUrl in the authConfig.");
    const token2 = await authConfig.secureStorage?.getItem(AUTH_TOKEN_STORAGE_KEY);
    const params = {
      credentials: "include",
      ...token2 ? {
        headers: {
          Authorization: `Bearer ${token2}`
        }
      } : {}
    };
    const res = await fetch(`${authConfig.authUrl}/user`, params);
    return await res.json();
  }, {
    enabled: !!authConfig
  });
  return {
    user,
    isLoggedIn: !!user,
    isLoading
  };
}
const ThirdwebAuthProvider = (_ref) => {
  let {
    value,
    children
  } = _ref;
  const authContext = reactExports.useMemo(() => {
    if (!value) {
      return void 0;
    }
    const context = {
      ...value,
      authUrl: value.authUrl?.replace(/\/$/, "")
    };
    return context;
  }, [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThirdwebAuthContext.Provider, {
    value: authContext,
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(DisconnectOnAccountSwitch, {})]
  });
};
function DisconnectOnAccountSwitch() {
  const {
    logout
  } = useLogout();
  const wallet = useWallet();
  const {
    isLoggedIn
  } = useUser();
  reactExports.useEffect(() => {
    const handleChange = (data) => {
      if (data.address) {
        logout();
      }
    };
    const shouldAddListener = wallet && isLoggedIn;
    if (shouldAddListener) {
      wallet.addListener("change", handleChange);
    }
    return () => {
      if (shouldAddListener) {
        wallet.removeListener("change", handleChange);
      }
    };
  }, [wallet, logout, isLoggedIn]);
  return null;
}
const updateChainRPCs = (chain, options2) => {
  try {
    return {
      ...chain,
      rpc: getChainRPCs(chain, options2)
    };
  } catch (error) {
    return chain;
  }
};
function useUpdateChainsWithApiKeys(supportedChains2, activeChain, thirdwebApiKey, alchemyApiKey, infuraApiKey) {
  const keys2 = reactExports.useMemo(() => ({
    thirdwebApiKey,
    alchemyApiKey,
    infuraApiKey
  }), [thirdwebApiKey, alchemyApiKey, infuraApiKey]);
  const supportedChainsWithKey = reactExports.useMemo(() => {
    return supportedChains2.map((chain) => updateChainRPCs(chain, keys2));
  }, [supportedChains2, keys2]);
  const activeChainIdOrObjWithKey = reactExports.useMemo(() => {
    if (!activeChain || typeof activeChain === "string" || typeof activeChain === "number") {
      return activeChain;
    }
    return updateChainRPCs(activeChain, keys2);
  }, [activeChain, keys2]);
  return [supportedChainsWithKey, activeChainIdOrObjWithKey];
}
const DEFAULT_API_KEY$1 = "fb52f0ca630bdd02f0d5210d9e8e3568272ac765dd0709272918eefb29d3ac9e";
const ThirdwebConfigContext = /* @__PURE__ */ reactExports.createContext({
  chains: defaultChains
});
const ThirdwebConfigProvider = (_ref) => {
  let {
    value,
    children
  } = _ref;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebConfigContext.Provider, {
    value,
    children
  });
};
function useThirdwebConfigContext() {
  return reactExports.useContext(ThirdwebConfigContext);
}
const INITIAL_CONTEXT_VALUE = {
  wallet: void 0,
  address: void 0,
  chainId: void 0,
  signer: void 0
};
const ThirdwebConnectedWalletContext = /* @__PURE__ */ reactExports.createContext(INITIAL_CONTEXT_VALUE);
const ThirdwebConnectedWalletProvider = (_ref) => {
  let {
    signer,
    children
  } = _ref;
  const {
    chains,
    thirdwebApiKey,
    alchemyApiKey,
    infuraApiKey
  } = useThirdwebConfigContext();
  const [contextValue, setContextValue] = reactExports.useState({
    ...INITIAL_CONTEXT_VALUE,
    signer: signer ? signer : void 0
  });
  reactExports.useEffect(() => {
    setContextValue((val) => ({
      ...val,
      signer: signer ? signer : void 0
    }));
  }, [signer]);
  reactExports.useEffect(() => {
    let s2 = signer;
    if (signer) {
      Promise.all([signer.getAddress(), signer.getChainId()]).then((_ref2) => {
        let [address, chainId] = _ref2;
        const chain = chains.find((c2) => c2.chainId === chainId);
        let rpcUrl = void 0;
        if (chain) {
          try {
            rpcUrl = getChainRPC(chain, {
              thirdwebApiKey,
              alchemyApiKey,
              infuraApiKey
            });
          } catch (e2) {
            console.error(e2);
          }
        }
        if (signer === s2) {
          const wallet = new UserWallet(signer, {
            readonlySettings: rpcUrl ? {
              rpcUrl,
              chainId
            } : void 0
          });
          setContextValue({
            wallet,
            address,
            chainId,
            signer
          });
        }
      }).catch((err) => {
      });
    } else {
      setContextValue(INITIAL_CONTEXT_VALUE);
    }
    return () => {
      s2 = void 0;
    };
  }, [signer, thirdwebApiKey, alchemyApiKey, infuraApiKey]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebConnectedWalletContext.Provider, {
    value: contextValue,
    children
  });
};
function useThirdwebConnectedWalletContext() {
  return reactExports.useContext(ThirdwebConnectedWalletContext);
}
const ThirdwebSDKContext = /* @__PURE__ */ reactExports.createContext({});
const WrappedThirdwebSDKProvider = (_ref) => {
  let {
    sdkOptions = {},
    storageInterface,
    supportedChains: supportedChains2,
    activeChain,
    signer,
    children,
    thirdwebApiKey,
    infuraApiKey,
    alchemyApiKey
  } = _ref;
  const activeChainId = reactExports.useMemo(() => {
    if (!activeChain) {
      return supportedChains2[0]?.chainId;
    }
    if (typeof activeChain === "number") {
      return activeChain;
    }
    if (typeof activeChain === "string") {
      return supportedChains2.find((c2) => c2.slug === activeChain)?.chainId;
    }
    return activeChain.chainId;
  }, [activeChain, supportedChains2]);
  const sdk = reactExports.useMemo(() => {
    let chainId = activeChainId;
    const supportedChain = supportedChains2.find((c2) => c2.chainId === chainId);
    if (!supportedChain && chainId !== void 0) {
      console.warn(`The chainId ${chainId} is not in the configured chains, please add it to the ThirdwebProvider`);
      chainId = void 0;
    }
    let readonlySettings = void 0;
    if (supportedChain && supportedChain.rpc.length > 0) {
      try {
        const rpcUrl = getChainRPC(supportedChain, {
          thirdwebApiKey,
          infuraApiKey,
          alchemyApiKey
        });
        readonlySettings = {
          chainId: supportedChain.chainId,
          rpcUrl
        };
      } catch (e2) {
      }
    }
    const mergedOptions = {
      readonlySettings,
      ...sdkOptions,
      supportedChains: supportedChains2
    };
    let sdk_ = void 0;
    if (chainId) {
      sdk_ = new ThirdwebSDK(chainId, {
        ...mergedOptions,
        infuraApiKey,
        alchemyApiKey,
        thirdwebApiKey
      }, storageInterface);
    }
    if (!sdk_) {
      if (supportedChains2.length > 0) {
        chainId = supportedChains2[0].chainId;
        sdk_ = new ThirdwebSDK(chainId, mergedOptions, storageInterface);
      } else {
        console.error("No chains configured, please pass a chain or chains to the ThirdwebProvider");
        return void 0;
      }
    }
    sdk_._chainId = chainId;
    return sdk_;
  }, [activeChainId, alchemyApiKey, infuraApiKey, supportedChains2, sdkOptions, storageInterface, thirdwebApiKey]);
  reactExports.useEffect(() => {
    if (sdk && sdk._chainId === activeChainId) {
      if (signer) {
        sdk.updateSignerOrProvider(signer);
      } else if (activeChainId) {
        sdk.updateSignerOrProvider(activeChainId);
      }
    }
  }, [sdk, sdk?._chainId, signer, activeChainId]);
  const ctxValue = reactExports.useMemo(() => ({
    sdk: sdk && sdk._chainId === activeChainId ? sdk : void 0,
    _inProvider: true
  }), [activeChainId, sdk]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebSDKContext.Provider, {
    value: ctxValue,
    children
  });
};
const ThirdwebSDKProvider = (_ref2) => {
  let {
    signer,
    children,
    queryClient,
    supportedChains: supportedChains2,
    activeChain,
    thirdwebApiKey = DEFAULT_API_KEY$1,
    alchemyApiKey,
    infuraApiKey,
    ...restProps
  } = _ref2;
  const supportedChainsNonNull = reactExports.useMemo(() => {
    return supportedChains2 || defaultChains;
  }, [supportedChains2]);
  const [supportedChainsWithKey, activeChainIdOrObjWithKey] = useUpdateChainsWithApiKeys(supportedChainsNonNull, activeChain || supportedChainsNonNull[0], thirdwebApiKey, alchemyApiKey, infuraApiKey);
  const mergedChains = reactExports.useMemo(() => {
    if (!activeChainIdOrObjWithKey || typeof activeChainIdOrObjWithKey === "string" || typeof activeChainIdOrObjWithKey === "number") {
      return supportedChainsWithKey;
    }
    const _mergedChains = [...supportedChainsWithKey.filter((c2) => c2.chainId !== activeChainIdOrObjWithKey.chainId), activeChainIdOrObjWithKey];
    return _mergedChains.filter((chain, index2, self2) => index2 === self2.findIndex((c2) => c2.chainId === chain.chainId));
  }, [supportedChainsWithKey, activeChainIdOrObjWithKey]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebConfigProvider, {
    value: {
      chains: mergedChains,
      thirdwebApiKey,
      alchemyApiKey,
      infuraApiKey
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebConnectedWalletProvider, {
      signer,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProviderWithDefault, {
        queryClient,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedThirdwebSDKProvider, {
          signer,
          supportedChains: mergedChains,
          thirdwebApiKey,
          alchemyApiKey,
          infuraApiKey,
          activeChain: activeChainIdOrObjWithKey,
          ...restProps,
          children
        })
      })
    })
  });
};
function useSDKContext() {
  const ctx = reactExports.useContext(ThirdwebSDKContext);
  invariant$1(ctx._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?");
  return ctx;
}
function useSDK() {
  const {
    sdk
  } = useSDKContext();
  return sdk;
}
function useSDKChainId() {
  const sdk = useSDK();
  return sdk?._chainId;
}
const ThirdwebProviderCore = (_ref) => {
  let {
    createWalletStorage = createAsyncLocalStorage,
    ...props
  } = _ref;
  const {
    activeChain
  } = props;
  const supportedChainsNonNull = reactExports.useMemo(() => {
    const isActiveChainObject = typeof activeChain === "object" && activeChain !== null;
    if (!isActiveChainObject) {
      return props.supportedChains || defaultChains;
    }
    if (!props.supportedChains) {
      return [...defaultChains, activeChain];
    }
    const isActiveChainInSupportedChains = props.supportedChains.find((c2) => c2.chainId === activeChain.chainId);
    if (!isActiveChainInSupportedChains) {
      return [...props.supportedChains, activeChain];
    }
    return props.supportedChains.map((c2) => c2.chainId === activeChain.chainId ? activeChain : c2);
  }, [props.supportedChains, activeChain]);
  const [supportedChainsWithKey, activeChainIdOrObjWithKey] = useUpdateChainsWithApiKeys(supportedChainsNonNull, props.activeChain || supportedChainsNonNull[0], props.thirdwebApiKey, props.alchemyApiKey, props.infuraApiKey);
  const activeChainWithKey = reactExports.useMemo(() => {
    if (typeof activeChainIdOrObjWithKey === "number") {
      const resolveChain = supportedChainsWithKey.find((chain) => chain.chainId === activeChainIdOrObjWithKey);
      if (!resolveChain) {
        throw new Error(`Invalid chainId: ${activeChainIdOrObjWithKey}. It is not one of supportedChains`);
      }
      return resolveChain;
    }
    if (typeof activeChainIdOrObjWithKey === "string") {
      const resolvedChain = supportedChainsWithKey.find((chain) => chain.slug === activeChainIdOrObjWithKey);
      if (!resolvedChain) {
        throw new Error(`Invalid chain: "${activeChainIdOrObjWithKey}". It is not one of supportedChains`);
      }
      return resolvedChain;
    }
    return activeChainIdOrObjWithKey;
  }, [activeChainIdOrObjWithKey, supportedChainsWithKey]);
  const dAppMeta = props.dAppMeta;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebThemeContext.Provider, {
    value: props.theme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebWalletProvider, {
      chains: supportedChainsWithKey,
      supportedWallets: props.supportedWallets,
      shouldAutoConnect: props.autoConnect,
      createWalletStorage,
      dAppMeta,
      activeChain: activeChainWithKey,
      autoSwitch: props.autoSwitch,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebSDKProviderWrapper, {
        queryClient: props.queryClient,
        sdkOptions: props.sdkOptions,
        supportedChains: supportedChainsWithKey,
        activeChain: activeChainWithKey,
        storageInterface: props.storageInterface,
        authConfig: props.authConfig,
        thirdwebApiKey: props.thirdwebApiKey,
        alchemyApiKey: props.alchemyApiKey,
        infuraApiKey: props.infuraApiKey,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebAuthProvider, {
          value: props.authConfig,
          children: props.children
        })
      })
    })
  });
};
const ThirdwebSDKProviderWrapper = (_ref2) => {
  let {
    children,
    ...props
  } = _ref2;
  const signer = useWalletContext()?.signer;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThirdwebSDKProvider, {
    signer,
    ...props,
    children
  });
};
function useSupportedChains() {
  return useThirdwebConfigContext().chains;
}
function useAddress() {
  return useThirdwebConnectedWalletContext().address;
}
function useChainId() {
  return useThirdwebConnectedWalletContext().chainId;
}
function useChain() {
  const chainId = useChainId();
  const chains = useSupportedChains();
  const chain = reactExports.useMemo(() => {
    return chains.find((_chain) => _chain.chainId === chainId);
  }, [chainId, chains]);
  const unknownChain = reactExports.useMemo(() => {
    if (!chain) {
      return defaultChains.find((c2) => c2.chainId === chainId);
    }
  }, [chainId, chain]);
  return chain || unknownChain;
}
function useActiveChain() {
  return useChain();
}
function useNetwork() {
  const chain = useActiveChain();
  const chainId = useChainId();
  const switchChain = useSwitchChain();
  const supportedChains2 = useSupportedChains();
  const wallet = useWallet();
  const isMetamaskInstalled = assertWindowEthereum(globalThis.window) ? globalThis.window.ethereum.isMetaMask : false;
  const isCoinbaseInstalled = assertWindowEthereum(globalThis.window) ? globalThis.window.ethereum.isCoinbaseWallet : false;
  const switchChainNotSupported = !wallet || wallet.walletId === walletIds.walletConnectV1 || wallet.walletId === walletIds.walletConnect || wallet.walletId === walletIds.metamask && !isMetamaskInstalled || wallet.walletId === walletIds.coinbase && !isCoinbaseInstalled;
  const [error, setError] = reactExports.useState(void 0);
  const [loading, setLoading] = reactExports.useState(false);
  const switchNetwork = reactExports.useCallback(async (_chainId) => {
    setLoading(true);
    setError(void 0);
    try {
      await switchChain(_chainId);
    } catch (e2) {
      setError(e2);
      setLoading(false);
      return {
        data: void 0,
        error: e2
      };
    }
    setLoading(false);
    return {
      data: supportedChains2.find((c2) => c2.chainId === _chainId) || defaultChains.find((c2) => c2.chainId === _chainId),
      error: void 0
    };
  }, [switchChain, supportedChains2]);
  return [{
    data: {
      chain: chainId === void 0 ? void 0 : chain || {
        chainId,
        unsupported: true
      },
      chains: wallet ? supportedChains2 : []
    },
    error,
    loading
  }, switchChainNotSupported ? void 0 : switchNetwork];
}
function useQueryWithNetwork(queryKey, queryFn, options2) {
  const activeChainId = useSDKChainId();
  const mergedOptions = {
    ...options2,
    enabled: !!(activeChainId && options2?.enabled)
  };
  return useQuery(createCacheKeyWithNetwork(queryKey, activeChainId), queryFn, mergedOptions);
}
async function fetchContractType(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return await sdk.resolveContractType(contractAddress);
  } catch (err) {
    console.error("failed to resolve contract type", err);
    return "custom";
  }
}
function useContractType(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(
    cacheKeys.contract.type(contractAddress),
    () => fetchContractType(contractAddress, sdk),
    // is immutable, so infinite stale time
    {
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk
    }
  );
}
const contractType = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.type(contractAddress), chainId),
  useQuery: useContractType,
  fetchQuery: fetchContractType
};
function fetchCompilerMetadata(contractAddress, sdk) {
  if (!contractAddress || !sdk) {
    return null;
  }
  try {
    return sdk.getPublisher().fetchCompilerMetadataFromAddress(contractAddress);
  } catch (err) {
    return null;
  }
}
function useCompilerMetadata(contractAddress) {
  const sdk = useSDK();
  return useQueryWithNetwork(
    cacheKeys.contract.compilerMetadata(contractAddress),
    () => fetchCompilerMetadata(contractAddress, sdk),
    // is immutable, so infinite stale time
    {
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk
    }
  );
}
const compilerMetadata = {
  cacheKey: (contractAddress, chainId) => createCacheKeyWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), chainId),
  useQuery: useCompilerMetadata,
  fetchQuery: fetchCompilerMetadata
};
function useContract(contractAddress, contractTypeOrABI) {
  const sdk = useSDK();
  const queryClient = useQueryClient();
  const activeChainId = useSDKChainId();
  const wallet = useAddress();
  const walletChainId = useChainId();
  const sdkTimestamp = sdk?._constructedAt;
  const contractQuery = useQueryWithNetwork(
    // need to add the wallet and walletChainId into the query key so this gets refreshed when the wallet / chain changes!
    neverPersist(["contract-instance", contractAddress, {
      wallet,
      walletChainId,
      sdkTimestamp
    }]),
    async () => {
      requiredParamInvariant(contractAddress, "contract address is required");
      invariant$1(sdk, "SDK not initialized");
      invariant$1(activeChainId, "active chain id is required");
      if (!contractTypeOrABI || contractTypeOrABI === "custom") {
        const cachedAbi = getCachedAbiForContract(contractAddress);
        if (cachedAbi) {
          return sdk.getContract(contractAddress, cachedAbi);
        }
        const resolvedContractType = await queryClient.fetchQuery(contractType.cacheKey(contractAddress, activeChainId), () => contractType.fetchQuery(contractAddress, sdk), {
          cacheTime: Infinity,
          staleTime: Infinity
        });
        let abi;
        if (resolvedContractType === "custom") {
          abi = (await queryClient.fetchQuery(compilerMetadata.cacheKey(contractAddress, activeChainId), () => compilerMetadata.fetchQuery(contractAddress, sdk), {
            cacheTime: Infinity,
            staleTime: Infinity,
            retry: 0
          }))?.abi;
        }
        invariant$1(resolvedContractType, "failed to resolve contract type");
        return sdk.getContract(contractAddress, abi || resolvedContractType);
      }
      return sdk.getContract(contractAddress, contractTypeOrABI);
    },
    {
      // keep the previous value around while we fetch the new one
      // this is important because otherwise it can lead to flickering (because we need to re-fetch the contract when sdk things change)
      keepPreviousData: true,
      // is immutable, so infinite cache & stale time (for a given key)
      cacheTime: Infinity,
      staleTime: Infinity,
      enabled: !!contractAddress && !!sdk && !!activeChainId,
      // never retry
      retry: 0
    }
  );
  return {
    ...contractQuery,
    data: contractQuery.data,
    contract: contractQuery.data
  };
}
function useStorage() {
  const sdk = useSDK();
  return sdk?.storage;
}
function useNetworkMismatch() {
  const walletChainId = useChainId();
  const sdkChainId = useSDKChainId();
  if (!sdkChainId) {
    return false;
  }
  if (sdkChainId === -1) {
    return false;
  }
  if (!walletChainId) {
    return false;
  }
  return sdkChainId !== walletChainId;
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$3(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$1 > 0 ? charat(characters, --position$1) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$1 < length ? charat(characters, position$1++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$1);
}
function caret() {
  return position$1;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$1(slice(position$1 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position$1;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position$1;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$1 - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position$1);
}
function compile(value) {
  return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$2(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$2(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$2(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
function memoize$2(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$1);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$1 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$3(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize$1([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$1([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize$1([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key2 = options2.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$2 = b$1 ? Symbol.for("react.element") : 60103, d$2 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$3 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$1 ? Symbol.for("react.profiler") : 60114, h$3 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$4 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$3 = b$1 ? Symbol.for("react.block") : 60121, w$3 = b$1 ? Symbol.for("react.fundamental") : 60117, x$2 = b$1 ? Symbol.for("react.responder") : 60118, y$2 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$2:
          case m$2:
          case e$1:
          case g$2:
          case f$3:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n$3:
              case t$3:
              case r$4:
              case h$3:
                return a2;
              default:
                return u2;
            }
        }
      case d$2:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$2;
}
reactIs_production_min.AsyncMode = l$2;
reactIs_production_min.ConcurrentMode = m$2;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$3;
reactIs_production_min.Element = c$2;
reactIs_production_min.ForwardRef = n$3;
reactIs_production_min.Fragment = e$1;
reactIs_production_min.Lazy = t$3;
reactIs_production_min.Memo = r$4;
reactIs_production_min.Portal = d$2;
reactIs_production_min.Profiler = g$2;
reactIs_production_min.StrictMode = f$3;
reactIs_production_min.Suspense = p$2;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$1(a2) || z$1(a2) === l$2;
};
reactIs_production_min.isConcurrentMode = A$1;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$3;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n$3;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$1;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t$3;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$4;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$2;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$2;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$3;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$1 || a2 === m$2 || a2 === g$2 || a2 === f$3 || a2 === p$2 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$3 || a2.$$typeof === r$4 || a2.$$typeof === h$3 || a2.$$typeof === k$2 || a2.$$typeof === n$3 || a2.$$typeof === w$3 || a2.$$typeof === x$2 || a2.$$typeof === y$2 || a2.$$typeof === v$3);
};
reactIs_production_min.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$2 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len2 = str.length;
  for (; len2 >= 4; ++i2, len2 -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len2) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$2(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles2 += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = $2AODx$react["useInsertionEffect"] ? $2AODx$react["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var useTheme$1 = function useTheme2() {
  return reactExports.useContext(ThemeContext);
};
var getTheme$1 = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$2({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme$1(outerTheme, theme2);
  });
});
var ThemeProvider$1 = function ThemeProvider2(props) {
  var theme2 = reactExports.useContext(ThemeContext);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ reactExports.createElement(ThemeContext.Provider, {
    value: theme2
  }, props.children);
};
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key: key2,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes$1 = function keyframes2() {
  var insertable = css$2.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$2(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options2, isReal) {
  var shouldForwardProp2;
  if (options2) {
    var optionsShouldForwardProp = options2.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options2) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options2 !== void 0) {
    identifierName = options2.label;
    targetClassName = options2.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options2, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len2 = args.length;
      var i2 = 1;
      for (; i2 < len2; i2++) {
        styles2.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$2({}, options2, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
const mauve$1 = {
  mauve1: "hsl(246, 6.0%, 9.0%)",
  mauve2: "hsl(240, 5.1%, 11.6%)",
  mauve3: "hsl(241, 5.0%, 14.3%)",
  mauve4: "hsl(242, 4.9%, 16.5%)",
  mauve5: "hsl(243, 4.9%, 18.8%)",
  mauve6: "hsl(244, 4.9%, 21.5%)",
  mauve7: "hsl(245, 4.9%, 25.4%)",
  mauve8: "hsl(247, 4.8%, 32.5%)",
  mauve9: "hsl(252, 4.0%, 45.2%)",
  mauve10: "hsl(247, 3.4%, 50.7%)",
  mauve11: "hsl(253, 4.0%, 63.7%)",
  mauve12: "hsl(256, 6.0%, 93.2%)"
};
const blue = {
  blue1: "hsl(206, 100%, 99.2%)",
  blue2: "hsl(210, 100%, 98.0%)",
  blue3: "hsl(209, 100%, 96.5%)",
  blue4: "hsl(210, 98.8%, 94.0%)",
  blue5: "hsl(209, 95.0%, 90.1%)",
  blue6: "hsl(209, 81.2%, 84.5%)",
  blue7: "hsl(208, 77.5%, 76.9%)",
  blue8: "hsl(206, 81.9%, 65.3%)",
  blue9: "hsl(206, 100%, 50.0%)",
  blue10: "hsl(208, 100%, 47.3%)",
  blue11: "hsl(211, 100%, 43.2%)",
  blue12: "hsl(211, 100%, 15.0%)"
};
const green = {
  green1: "hsl(136, 50.0%, 98.9%)",
  green2: "hsl(138, 62.5%, 96.9%)",
  green3: "hsl(139, 55.2%, 94.5%)",
  green4: "hsl(140, 48.7%, 91.0%)",
  green5: "hsl(141, 43.7%, 86.0%)",
  green6: "hsl(143, 40.3%, 79.0%)",
  green7: "hsl(146, 38.5%, 69.0%)",
  green8: "hsl(151, 40.2%, 54.1%)",
  green9: "hsl(151, 55.0%, 41.5%)",
  green10: "hsl(152, 57.5%, 37.6%)",
  green11: "hsl(153, 67.0%, 28.5%)",
  green12: "hsl(155, 40.0%, 14.0%)"
};
const mauve = {
  mauve1: "hsl(300, 20.0%, 99.0%)",
  mauve2: "hsl(300, 7.7%, 97.5%)",
  mauve3: "hsl(294, 5.5%, 95.3%)",
  mauve4: "hsl(289, 4.7%, 93.3%)",
  mauve5: "hsl(283, 4.4%, 91.3%)",
  mauve6: "hsl(278, 4.1%, 89.1%)",
  mauve7: "hsl(271, 3.9%, 86.3%)",
  mauve8: "hsl(255, 3.7%, 78.8%)",
  mauve9: "hsl(252, 4.0%, 57.3%)",
  mauve10: "hsl(253, 3.5%, 53.5%)",
  mauve11: "hsl(252, 4.0%, 44.8%)",
  mauve12: "hsl(260, 25.0%, 11.0%)"
};
const tomato = {
  tomato1: "hsl(10, 100%, 99.4%)",
  tomato2: "hsl(8, 100%, 98.4%)",
  tomato3: "hsl(8, 100%, 96.6%)",
  tomato4: "hsl(8, 100%, 94.3%)",
  tomato5: "hsl(8, 92.8%, 91.0%)",
  tomato6: "hsl(9, 84.7%, 86.3%)",
  tomato7: "hsl(10, 77.3%, 79.5%)",
  tomato8: "hsl(10, 71.6%, 71.0%)",
  tomato9: "hsl(10, 78.0%, 54.0%)",
  tomato10: "hsl(10, 71.5%, 50.0%)",
  tomato11: "hsl(10, 82.0%, 43.5%)",
  tomato12: "hsl(10, 50.0%, 13.5%)"
};
const darkTheme = {
  overlay: {
    subdued: "rgba(0, 0, 0, 0.74)"
  },
  bg: {
    base: mauve$1.mauve1,
    baseHover: mauve$1.mauve2,
    elevated: mauve$1.mauve3,
    elevatedHover: mauve$1.mauve4,
    highlighted: mauve$1.mauve5,
    inverted: mauve$1.mauve12,
    invertedFocused: mauve$1.mauve7,
    danger: tomato.tomato12
  },
  border: {
    base: mauve$1.mauve3,
    elevated: mauve$1.mauve4
  },
  badge: {
    secondary: mauve$1.mauve6
  },
  text: {
    neutral: mauve$1.mauve12,
    inverted: mauve$1.mauve1,
    secondary: mauve$1.mauve9,
    danger: tomato.tomato9
  },
  icon: {
    secondary: mauve$1.mauve11,
    primary: mauve$1.mauve12,
    inverted: mauve$1.mauve1,
    danger: tomato.tomato9,
    success: green.green7,
    link: blue.blue9
  },
  link: {
    primary: blue.blue9,
    primaryHover: mauve$1.mauve12
  },
  input: {
    bg: mauve$1.mauve3,
    bgHover: mauve$1.mauve5,
    outline: mauve$1.mauve5,
    focusRing: blue.blue9,
    errorRing: tomato.tomato9
  },
  tooltip: {
    bg: "black",
    text: "white"
  }
};
const lightTheme = {
  overlay: {
    subdued: "rgba(0, 0, 0, 0.4)"
  },
  bg: {
    base: mauve.mauve1,
    baseHover: mauve.mauve2,
    elevated: mauve.mauve3,
    elevatedHover: mauve.mauve4,
    highlighted: mauve.mauve5,
    inverted: mauve.mauve12,
    invertedFocused: mauve.mauve7,
    danger: tomato.tomato4
  },
  border: {
    base: mauve.mauve6,
    elevated: mauve.mauve7
  },
  badge: {
    secondary: mauve.mauve1
  },
  text: {
    neutral: mauve.mauve12,
    inverted: mauve.mauve1,
    secondary: mauve.mauve10,
    danger: tomato.tomato9
  },
  icon: {
    secondary: mauve.mauve10,
    primary: mauve.mauve12,
    inverted: mauve.mauve1,
    danger: tomato.tomato9,
    success: green.green9,
    link: blue.blue11
  },
  link: {
    primary: blue.blue11,
    primaryHover: mauve.mauve12
  },
  input: {
    bg: mauve.mauve3,
    bgHover: mauve$1.mauve5,
    outline: mauve.mauve7,
    focusRing: blue.blue11,
    errorRing: tomato.tomato10
  },
  tooltip: {
    bg: "black",
    text: "white"
  }
};
const fontSize = {
  xs: "12px",
  sm: "14px",
  md: "16px",
  lg: "20px",
  xl: "24px"
};
const spacing$1 = {
  xxs: "6px",
  xs: "8px",
  sm: "12px",
  md: "16px",
  lg: "24px",
  xl: "32px",
  xxl: "48px"
};
const radius = {
  sm: "6px",
  md: "8px",
  lg: "12px",
  xl: "20px",
  xxl: "32px"
};
const iconSize = {
  xs: "12",
  sm: "16",
  md: "24",
  lg: "32",
  xl: "48"
};
const media = {
  mobile: `@media (max-width: 640px)`
};
const shadow = {
  sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
  md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
  lg: "0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
  xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
};
const Spinner$1 = (props) => {
  const theme2 = useTheme$1();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Svg, {
    style: {
      width: iconSize[props.size],
      height: iconSize[props.size]
    },
    viewBox: "0 0 50 50",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, {
      cx: "25",
      cy: "25",
      r: "20",
      fill: "none",
      stroke: theme2.icon[props.color || "primary"],
      strokeWidth: "4"
    })
  });
};
const dashAnimation = keyframes$1`
 0% {
    stroke-dasharray: 1, 150;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -35;
  }
  100% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -124;
  }
`;
const rotateAnimation = keyframes$1`
100% {
    transform: rotate(360deg);
  }
`;
const Svg = newStyled.svg`
  animation: ${rotateAnimation} 2s linear infinite;
  width: 1em;
  height: 1em;
`;
const Circle = newStyled.circle`
  stroke-linecap: round;
  animation: ${dashAnimation} 1.5s ease-in-out infinite;
`;
const Spacer = (_ref) => {
  let {
    y: y2
  } = _ref;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: {
      height: spacing$1[y2]
    }
  });
};
const Button$1 = newStyled.button`
  all: unset;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.md};
  padding: ${spacing$1.sm} ${spacing$1.sm};
  font-size: ${fontSize.md};
  font-weight: 500;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  flex-shrink: 0;

  &:focus {
    box-shadow: 0 0 0 3px
      ${(p2) => {
  switch (p2.variant) {
    case "inverted":
      return p2.theme.bg.invertedFocused;
    case "secondary":
      return p2.theme.bg.highlighted;
    case "link":
      return "none";
    case "danger":
      return p2.theme.text.danger;
  }
}};
  }

  box-shadow: ${(p2) => {
  switch (p2.variant) {
    case "danger":
      return `0 0 0 2px ${p2.theme.text.danger}`;
    case "link":
      return "none";
    default:
      return "none";
  }
}};

  background: ${(p2) => {
  switch (p2.variant) {
    case "inverted":
      return p2.theme.bg.inverted;
    case "secondary":
      return p2.theme.bg.elevated;
    case "link":
      return "transparent";
    case "danger":
      return "none";
  }
}};
  color: ${(p2) => {
  switch (p2.variant) {
    case "inverted":
      return p2.theme.text.inverted;
    case "secondary":
      return p2.theme.text.neutral;
    case "link":
      return p2.theme.link.primary;
    case "danger":
      return p2.theme.text.danger;
  }
}};

  ${(p2) => {
  if (p2.variant === "link") {
    return `
      padding: 0;
      &:hover {
        color: ${p2.theme.text.neutral};
      }`;
  }
}}

  cursor: pointer;

  /* pressed effect */
  &:active {
    transform: translateY(1px);
  }

  &[disabled] {
    cursor: not-allowed;
  }
`;
const IconButton$1 = newStyled.button`
  all: unset;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.sm};
  -webkit-tap-highlight-color: transparent;
  color: ${(p2) => {
  switch (p2.variant) {
    case "neutral":
      return p2.theme.text.neutral;
    case "secondary":
      return p2.theme.text.secondary;
  }
}};
  padding: 2px;
  transition: background 0.2s ease, color 0.2s ease;
  &:hover {
    background: ${(p2) => p2.theme.bg.elevated};
    color: ${(p2) => p2.theme.text.neutral};
  }
`;
const InputButton = newStyled.button`
  all: unset;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.sm};
  padding: ${spacing$1.sm};
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  color: ${(p2) => p2.theme.text.secondary};
  &:hover {
    color: ${(p2) => p2.theme.text.neutral};
  }
  &[disabled] {
    cursor: not-allowed;
  }
`;
const Label = newStyled.label`
  font-size: ${fontSize.sm};
  color: ${(p2) => p2.theme.text.neutral};
  display: block;
`;
const Input = newStyled.input`
  font-size: ${fontSize.md};
  display: block;
  padding: ${spacing$1.sm};
  box-sizing: border-box;
  width: 100%;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${(p2) => p2.theme.text.neutral};
  -webkit-appearance: none;
  appearance: none;
  background: ${(p2) => {
  switch (p2.variant) {
    case "secondary":
      return p2.theme.bg.elevated;
    default:
      return "transparent";
  }
}};

  &::placeholder {
    color: ${(p2) => p2.theme.text.secondary};
  }

  box-shadow: 0 0 0 1.5px
    ${(p2) => {
  switch (p2.variant) {
    case "outline":
      return p2.theme.input.outline;
    case "transparent":
      return "transparent";
    case "secondary":
      return p2.theme.bg.elevated;
  }
}};

  /* when browser auto-fills the input  */
  &:-webkit-autofill {
    -webkit-text-fill-color: ${(p2) => p2.theme.text.neutral};
    -webkit-box-shadow: 0 0 0px 1000px ${(p2) => p2.theme.bg.elevated} inset !important;
    box-shadow: 0 0 0px 1000px ${(p2) => p2.theme.bg.elevated} inset !important;
    transition: background-color 5000s ease-in-out 0s;
  }

  &:-webkit-autofill:focus {
    -webkit-box-shadow: 0 0 0px 1000px ${(p2) => p2.theme.bg.elevated} inset,
      0 0 0 2px ${(p2) => p2.theme.input.focusRing} !important;
    box-shadow: 0 0 0px 1000px ${(p2) => p2.theme.bg.elevated} inset,
      0 0 0 2px ${(p2) => p2.theme.input.focusRing} !important;
  }

  &:focus {
    box-shadow: 0 0 0 2px ${(p2) => p2.theme.input.focusRing};
  }

  /* show overflow ellipsis for long text - but not if it's a type="password"  */
  &:not([type="password"]) {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  &[data-error="true"] {
    box-shadow: 0 0 0 2px ${(p2) => p2.theme.input.errorRing} !important;
  }

  &[disabled] {
    cursor: not-allowed;
  }
`;
const InputContainer = newStyled.div`
  display: flex;
  border-radius: ${radius.sm};
  box-shadow: 0 0 0px 1.5px ${(p2) => p2.theme.input.outline};

  /* show focus ring on container instead of input  */
  &:focus-within {
    box-shadow: 0 0 0px 2px ${(p2) => p2.theme.input.focusRing};
  }

  input:focus {
    box-shadow: none;
  }

  /* show error ring on container instead of input  */
  &[data-error="true"] {
    box-shadow: 0 0 0px 2px ${(p2) => p2.theme.input.errorRing};
  }
`;
const ErrorMessage = newStyled.p`
  all: unset;
  font-size: ${fontSize.sm};
  display: block;
  color: ${(p2) => p2.theme.input.errorRing};
  line-height: 1.5;
`;
newStyled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${spacing$1.sm};
`;
const Flex$1 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      display: "flex",
      flexDirection: props.flexDirection,
      justifyContent: props.justifyContent,
      alignItems: props.alignItems,
      gap: props.gap ? spacing$1[props.gap] : void 0,
      ...props.style || {}
    },
    children: [" ", props.children]
  });
};
var lib = {};
var mode$2 = {
  MODE_NUMBER: 1 << 0,
  MODE_ALPHA_NUM: 1 << 1,
  MODE_8BIT_BYTE: 1 << 2,
  MODE_KANJI: 1 << 3
};
var mode$1 = mode$2;
function QR8bitByte(data) {
  this.mode = mode$1.MODE_8BIT_BYTE;
  this.data = data;
}
QR8bitByte.prototype = {
  getLength: function(buffer2) {
    return this.data.length;
  },
  write: function(buffer2) {
    for (var i2 = 0; i2 < this.data.length; i2++) {
      buffer2.put(this.data.charCodeAt(i2), 8);
    }
  }
};
var _8BitByte = QR8bitByte;
var ErrorCorrectLevel = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
};
var ECL = ErrorCorrectLevel;
function QRRSBlock(totalCount, dataCount) {
  this.totalCount = totalCount;
  this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [
  // L
  // M
  // Q
  // H
  // 1
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  // 2
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  // 3
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  // 4		
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  // 5
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  // 6
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  // 7		
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  // 8
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  // 9
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  // 10		
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  // 11
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  // 12
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  // 13
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  // 14
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  // 15
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  // 16
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  // 17
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  // 18
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  // 19
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  // 20
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  // 21
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  // 22
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  // 23
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  // 24
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  // 25
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  // 26
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  // 27
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  // 28
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  // 29
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  // 30
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  // 31
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  // 32
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  // 33
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  // 34
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  // 35
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  // 36
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  // 37
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  // 38
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  // 39
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  // 40
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16]
];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
  var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  if (rsBlock == void 0) {
    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  }
  var length2 = rsBlock.length / 3;
  var list2 = new Array();
  for (var i2 = 0; i2 < length2; i2++) {
    var count = rsBlock[i2 * 3 + 0];
    var totalCount = rsBlock[i2 * 3 + 1];
    var dataCount = rsBlock[i2 * 3 + 2];
    for (var j = 0; j < count; j++) {
      list2.push(new QRRSBlock(totalCount, dataCount));
    }
  }
  return list2;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
  switch (errorCorrectLevel) {
    case ECL.L:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
    case ECL.M:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
    case ECL.Q:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
    case ECL.H:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var RSBlock$1 = QRRSBlock;
function QRBitBuffer() {
  this.buffer = new Array();
  this.length = 0;
}
QRBitBuffer.prototype = {
  get: function(index2) {
    var bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
  },
  put: function(num, length2) {
    for (var i2 = 0; i2 < length2; i2++) {
      this.putBit((num >>> length2 - i2 - 1 & 1) == 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var BitBuffer$1 = QRBitBuffer;
var QRMath = {
  glog: function(n2) {
    if (n2 < 1) {
      throw new Error("glog(" + n2 + ")");
    }
    return QRMath.LOG_TABLE[n2];
  },
  gexp: function(n2) {
    while (n2 < 0) {
      n2 += 255;
    }
    while (n2 >= 256) {
      n2 -= 255;
    }
    return QRMath.EXP_TABLE[n2];
  },
  EXP_TABLE: new Array(256),
  LOG_TABLE: new Array(256)
};
for (var i$2 = 0; i$2 < 8; i$2++) {
  QRMath.EXP_TABLE[i$2] = 1 << i$2;
}
for (var i$2 = 8; i$2 < 256; i$2++) {
  QRMath.EXP_TABLE[i$2] = QRMath.EXP_TABLE[i$2 - 4] ^ QRMath.EXP_TABLE[i$2 - 5] ^ QRMath.EXP_TABLE[i$2 - 6] ^ QRMath.EXP_TABLE[i$2 - 8];
}
for (var i$2 = 0; i$2 < 255; i$2++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i$2]] = i$2;
}
var math$2 = QRMath;
var math$1 = math$2;
function QRPolynomial(num, shift) {
  if (num.length == void 0) {
    throw new Error(num.length + "/" + shift);
  }
  var offset2 = 0;
  while (offset2 < num.length && num[offset2] == 0) {
    offset2++;
  }
  this.num = new Array(num.length - offset2 + shift);
  for (var i2 = 0; i2 < num.length - offset2; i2++) {
    this.num[i2] = num[i2 + offset2];
  }
}
QRPolynomial.prototype = {
  get: function(index2) {
    return this.num[index2];
  },
  getLength: function() {
    return this.num.length;
  },
  multiply: function(e2) {
    var num = new Array(this.getLength() + e2.getLength() - 1);
    for (var i2 = 0; i2 < this.getLength(); i2++) {
      for (var j = 0; j < e2.getLength(); j++) {
        num[i2 + j] ^= math$1.gexp(math$1.glog(this.get(i2)) + math$1.glog(e2.get(j)));
      }
    }
    return new QRPolynomial(num, 0);
  },
  mod: function(e2) {
    if (this.getLength() - e2.getLength() < 0) {
      return this;
    }
    var ratio = math$1.glog(this.get(0)) - math$1.glog(e2.get(0));
    var num = new Array(this.getLength());
    for (var i2 = 0; i2 < this.getLength(); i2++) {
      num[i2] = this.get(i2);
    }
    for (var i2 = 0; i2 < e2.getLength(); i2++) {
      num[i2] ^= math$1.gexp(math$1.glog(e2.get(i2)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e2);
  }
};
var Polynomial$2 = QRPolynomial;
var Mode = mode$2;
var Polynomial$1 = Polynomial$2;
var math = math$2;
var QRMaskPattern = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};
var QRUtil = {
  PATTERN_POSITION_TABLE: [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ],
  G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
  G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
  G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
  getBCHTypeInfo: function(data) {
    var d2 = data << 10;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
      d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
    }
    return (data << 10 | d2) ^ QRUtil.G15_MASK;
  },
  getBCHTypeNumber: function(data) {
    var d2 = data << 12;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
      d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
    }
    return data << 12 | d2;
  },
  getBCHDigit: function(data) {
    var digit = 0;
    while (data != 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  },
  getPatternPosition: function(typeNumber) {
    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  },
  getMask: function(maskPattern, i2, j) {
    switch (maskPattern) {
      case QRMaskPattern.PATTERN000:
        return (i2 + j) % 2 == 0;
      case QRMaskPattern.PATTERN001:
        return i2 % 2 == 0;
      case QRMaskPattern.PATTERN010:
        return j % 3 == 0;
      case QRMaskPattern.PATTERN011:
        return (i2 + j) % 3 == 0;
      case QRMaskPattern.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;
      case QRMaskPattern.PATTERN101:
        return i2 * j % 2 + i2 * j % 3 == 0;
      case QRMaskPattern.PATTERN110:
        return (i2 * j % 2 + i2 * j % 3) % 2 == 0;
      case QRMaskPattern.PATTERN111:
        return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  },
  getErrorCorrectPolynomial: function(errorCorrectLength) {
    var a2 = new Polynomial$1([1], 0);
    for (var i2 = 0; i2 < errorCorrectLength; i2++) {
      a2 = a2.multiply(new Polynomial$1([1, math.gexp(i2)], 0));
    }
    return a2;
  },
  getLengthInBits: function(mode2, type) {
    if (1 <= type && type < 10) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 10;
        case Mode.MODE_ALPHA_NUM:
          return 9;
        case Mode.MODE_8BIT_BYTE:
          return 8;
        case Mode.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type < 27) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 12;
        case Mode.MODE_ALPHA_NUM:
          return 11;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type < 41) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 14;
        case Mode.MODE_ALPHA_NUM:
          return 13;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + mode2);
      }
    } else {
      throw new Error("type:" + type);
    }
  },
  getLostPoint: function(qrCode) {
    var moduleCount = qrCode.getModuleCount();
    var lostPoint = 0;
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount; col++) {
        var sameCount = 0;
        var dark = qrCode.isDark(row, col);
        for (var r2 = -1; r2 <= 1; r2++) {
          if (row + r2 < 0 || moduleCount <= row + r2) {
            continue;
          }
          for (var c2 = -1; c2 <= 1; c2++) {
            if (col + c2 < 0 || moduleCount <= col + c2) {
              continue;
            }
            if (r2 == 0 && c2 == 0) {
              continue;
            }
            if (dark == qrCode.isDark(row + r2, col + c2)) {
              sameCount++;
            }
          }
        }
        if (sameCount > 5) {
          lostPoint += 3 + sameCount - 5;
        }
      }
    }
    for (var row = 0; row < moduleCount - 1; row++) {
      for (var col = 0; col < moduleCount - 1; col++) {
        var count = 0;
        if (qrCode.isDark(row, col))
          count++;
        if (qrCode.isDark(row + 1, col))
          count++;
        if (qrCode.isDark(row, col + 1))
          count++;
        if (qrCode.isDark(row + 1, col + 1))
          count++;
        if (count == 0 || count == 4) {
          lostPoint += 3;
        }
      }
    }
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount - 6; row++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
          lostPoint += 40;
        }
      }
    }
    var darkCount = 0;
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) {
          darkCount++;
        }
      }
    }
    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;
    return lostPoint;
  }
};
var util$1 = QRUtil;
var BitByte = _8BitByte;
var RSBlock = RSBlock$1;
var BitBuffer = BitBuffer$1;
var util = util$1;
var Polynomial = Polynomial$2;
function QRCode$2(typeNumber, errorCorrectLevel) {
  this.typeNumber = typeNumber;
  this.errorCorrectLevel = errorCorrectLevel;
  this.modules = null;
  this.moduleCount = 0;
  this.dataCache = null;
  this.dataList = [];
}
var proto = QRCode$2.prototype;
proto.addData = function(data) {
  var newData = new BitByte(data);
  this.dataList.push(newData);
  this.dataCache = null;
};
proto.isDark = function(row, col) {
  if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
    throw new Error(row + "," + col);
  }
  return this.modules[row][col];
};
proto.getModuleCount = function() {
  return this.moduleCount;
};
proto.make = function() {
  if (this.typeNumber < 1) {
    var typeNumber = 1;
    for (typeNumber = 1; typeNumber < 40; typeNumber++) {
      var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
      var buffer2 = new BitBuffer();
      var totalDataCount = 0;
      for (var i2 = 0; i2 < rsBlocks.length; i2++) {
        totalDataCount += rsBlocks[i2].dataCount;
      }
      for (var i2 = 0; i2 < this.dataList.length; i2++) {
        var data = this.dataList[i2];
        buffer2.put(data.mode, 4);
        buffer2.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
        data.write(buffer2);
      }
      if (buffer2.getLengthInBits() <= totalDataCount * 8)
        break;
    }
    this.typeNumber = typeNumber;
  }
  this.makeImpl(false, this.getBestMaskPattern());
};
proto.makeImpl = function(test2, maskPattern) {
  this.moduleCount = this.typeNumber * 4 + 17;
  this.modules = new Array(this.moduleCount);
  for (var row = 0; row < this.moduleCount; row++) {
    this.modules[row] = new Array(this.moduleCount);
    for (var col = 0; col < this.moduleCount; col++) {
      this.modules[row][col] = null;
    }
  }
  this.setupPositionProbePattern(0, 0);
  this.setupPositionProbePattern(this.moduleCount - 7, 0);
  this.setupPositionProbePattern(0, this.moduleCount - 7);
  this.setupPositionAdjustPattern();
  this.setupTimingPattern();
  this.setupTypeInfo(test2, maskPattern);
  if (this.typeNumber >= 7) {
    this.setupTypeNumber(test2);
  }
  if (this.dataCache == null) {
    this.dataCache = QRCode$2.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  }
  this.mapData(this.dataCache, maskPattern);
};
proto.setupPositionProbePattern = function(row, col) {
  for (var r2 = -1; r2 <= 7; r2++) {
    if (row + r2 <= -1 || this.moduleCount <= row + r2)
      continue;
    for (var c2 = -1; c2 <= 7; c2++) {
      if (col + c2 <= -1 || this.moduleCount <= col + c2)
        continue;
      if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
        this.modules[row + r2][col + c2] = true;
      } else {
        this.modules[row + r2][col + c2] = false;
      }
    }
  }
};
proto.getBestMaskPattern = function() {
  var minLostPoint = 0;
  var pattern = 0;
  for (var i2 = 0; i2 < 8; i2++) {
    this.makeImpl(true, i2);
    var lostPoint = util.getLostPoint(this);
    if (i2 == 0 || minLostPoint > lostPoint) {
      minLostPoint = lostPoint;
      pattern = i2;
    }
  }
  return pattern;
};
proto.createMovieClip = function(target_mc, instance_name, depth) {
  var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
  var cs = 1;
  this.make();
  for (var row = 0; row < this.modules.length; row++) {
    var y2 = row * cs;
    for (var col = 0; col < this.modules[row].length; col++) {
      var x2 = col * cs;
      var dark = this.modules[row][col];
      if (dark) {
        qr_mc.beginFill(0, 100);
        qr_mc.moveTo(x2, y2);
        qr_mc.lineTo(x2 + cs, y2);
        qr_mc.lineTo(x2 + cs, y2 + cs);
        qr_mc.lineTo(x2, y2 + cs);
        qr_mc.endFill();
      }
    }
  }
  return qr_mc;
};
proto.setupTimingPattern = function() {
  for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
    if (this.modules[r2][6] != null) {
      continue;
    }
    this.modules[r2][6] = r2 % 2 == 0;
  }
  for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
    if (this.modules[6][c2] != null) {
      continue;
    }
    this.modules[6][c2] = c2 % 2 == 0;
  }
};
proto.setupPositionAdjustPattern = function() {
  var pos = util.getPatternPosition(this.typeNumber);
  for (var i2 = 0; i2 < pos.length; i2++) {
    for (var j = 0; j < pos.length; j++) {
      var row = pos[i2];
      var col = pos[j];
      if (this.modules[row][col] != null) {
        continue;
      }
      for (var r2 = -2; r2 <= 2; r2++) {
        for (var c2 = -2; c2 <= 2; c2++) {
          if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
            this.modules[row + r2][col + c2] = true;
          } else {
            this.modules[row + r2][col + c2] = false;
          }
        }
      }
    }
  }
};
proto.setupTypeNumber = function(test2) {
  var bits = util.getBCHTypeNumber(this.typeNumber);
  for (var i2 = 0; i2 < 18; i2++) {
    var mod2 = !test2 && (bits >> i2 & 1) == 1;
    this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod2;
  }
  for (var i2 = 0; i2 < 18; i2++) {
    var mod2 = !test2 && (bits >> i2 & 1) == 1;
    this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod2;
  }
};
proto.setupTypeInfo = function(test2, maskPattern) {
  var data = this.errorCorrectLevel << 3 | maskPattern;
  var bits = util.getBCHTypeInfo(data);
  for (var i2 = 0; i2 < 15; i2++) {
    var mod2 = !test2 && (bits >> i2 & 1) == 1;
    if (i2 < 6) {
      this.modules[i2][8] = mod2;
    } else if (i2 < 8) {
      this.modules[i2 + 1][8] = mod2;
    } else {
      this.modules[this.moduleCount - 15 + i2][8] = mod2;
    }
  }
  for (var i2 = 0; i2 < 15; i2++) {
    var mod2 = !test2 && (bits >> i2 & 1) == 1;
    if (i2 < 8) {
      this.modules[8][this.moduleCount - i2 - 1] = mod2;
    } else if (i2 < 9) {
      this.modules[8][15 - i2 - 1 + 1] = mod2;
    } else {
      this.modules[8][15 - i2 - 1] = mod2;
    }
  }
  this.modules[this.moduleCount - 8][8] = !test2;
};
proto.mapData = function(data, maskPattern) {
  var inc = -1;
  var row = this.moduleCount - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = this.moduleCount - 1; col > 0; col -= 2) {
    if (col == 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (this.modules[row][col - c2] == null) {
          var dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) == 1;
          }
          var mask = util.getMask(maskPattern, row, col - c2);
          if (mask) {
            dark = !dark;
          }
          this.modules[row][col - c2] = dark;
          bitIndex--;
          if (bitIndex == -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || this.moduleCount <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
};
QRCode$2.PAD0 = 236;
QRCode$2.PAD1 = 17;
QRCode$2.createData = function(typeNumber, errorCorrectLevel, dataList) {
  var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer2 = new BitBuffer();
  for (var i2 = 0; i2 < dataList.length; i2++) {
    var data = dataList[i2];
    buffer2.put(data.mode, 4);
    buffer2.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
    data.write(buffer2);
  }
  var totalDataCount = 0;
  for (var i2 = 0; i2 < rsBlocks.length; i2++) {
    totalDataCount += rsBlocks[i2].dataCount;
  }
  if (buffer2.getLengthInBits() > totalDataCount * 8) {
    throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  }
  if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 != 0) {
    buffer2.putBit(false);
  }
  while (true) {
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCode$2.PAD0, 8);
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCode$2.PAD1, 8);
  }
  return QRCode$2.createBytes(buffer2, rsBlocks);
};
QRCode$2.createBytes = function(buffer2, rsBlocks) {
  var offset2 = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);
  for (var r2 = 0; r2 < rsBlocks.length; r2++) {
    var dcCount = rsBlocks[r2].dataCount;
    var ecCount = rsBlocks[r2].totalCount - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcdata[r2] = new Array(dcCount);
    for (var i2 = 0; i2 < dcdata[r2].length; i2++) {
      dcdata[r2][i2] = 255 & buffer2.buffer[i2 + offset2];
    }
    offset2 += dcCount;
    var rsPoly = util.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new Polynomial(dcdata[r2], rsPoly.getLength() - 1);
    var modPoly = rawPoly.mod(rsPoly);
    ecdata[r2] = new Array(rsPoly.getLength() - 1);
    for (var i2 = 0; i2 < ecdata[r2].length; i2++) {
      var modIndex = i2 + modPoly.getLength() - ecdata[r2].length;
      ecdata[r2][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
    }
  }
  var totalCodeCount = 0;
  for (var i2 = 0; i2 < rsBlocks.length; i2++) {
    totalCodeCount += rsBlocks[i2].totalCount;
  }
  var data = new Array(totalCodeCount);
  var index2 = 0;
  for (var i2 = 0; i2 < maxDcCount; i2++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i2 < dcdata[r2].length) {
        data[index2++] = dcdata[r2][i2];
      }
    }
  }
  for (var i2 = 0; i2 < maxEcCount; i2++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i2 < ecdata[r2].length) {
        data[index2++] = ecdata[r2][i2];
      }
    }
  }
  return data;
};
var QRCode_1 = QRCode$2;
var propTypes$2 = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes$2.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes$2.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var QRCodeSvg$1 = {};
Object.defineProperty(QRCodeSvg$1, "__esModule", {
  value: true
});
var _extends$1 = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key2 in source) {
      if (Object.prototype.hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
};
var _propTypes$1 = propTypesExports;
var _propTypes2$1 = _interopRequireDefault$1(_propTypes$1);
var _react$1 = reactExports;
var _react2$1 = _interopRequireDefault$1(_react$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$1(obj, keys2) {
  var target = {};
  for (var i2 in obj) {
    if (keys2.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
}
var propTypes$1 = {
  bgColor: _propTypes2$1.default.oneOfType([_propTypes2$1.default.object, _propTypes2$1.default.string]).isRequired,
  bgD: _propTypes2$1.default.string.isRequired,
  fgColor: _propTypes2$1.default.oneOfType([_propTypes2$1.default.object, _propTypes2$1.default.string]).isRequired,
  fgD: _propTypes2$1.default.string.isRequired,
  size: _propTypes2$1.default.number.isRequired,
  title: _propTypes2$1.default.string,
  viewBoxSize: _propTypes2$1.default.number.isRequired,
  xmlns: _propTypes2$1.default.string
};
var defaultProps$2 = {
  title: void 0,
  xmlns: "http://www.w3.org/2000/svg"
};
var QRCodeSvg = (0, _react$1.forwardRef)(function(_ref, ref) {
  var bgColor = _ref.bgColor, bgD = _ref.bgD, fgD = _ref.fgD, fgColor = _ref.fgColor, size2 = _ref.size, title = _ref.title, viewBoxSize = _ref.viewBoxSize, props = _objectWithoutProperties$1(_ref, ["bgColor", "bgD", "fgD", "fgColor", "size", "title", "viewBoxSize"]);
  return _react2$1.default.createElement(
    "svg",
    _extends$1({}, props, { height: size2, ref, viewBox: "0 0 " + viewBoxSize + " " + viewBoxSize, width: size2 }),
    title ? _react2$1.default.createElement(
      "title",
      null,
      title
    ) : null,
    _react2$1.default.createElement("path", { d: bgD, fill: bgColor }),
    _react2$1.default.createElement("path", { d: fgD, fill: fgColor })
  );
});
QRCodeSvg.displayName = "QRCodeSvg";
QRCodeSvg.propTypes = propTypes$1;
QRCodeSvg.defaultProps = defaultProps$2;
QRCodeSvg$1.default = QRCodeSvg;
Object.defineProperty(lib, "__esModule", {
  value: true
});
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key2 in source) {
      if (Object.prototype.hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
};
var _QRCode = QRCode_1;
var _QRCode2 = _interopRequireDefault(_QRCode);
var _ErrorCorrectLevel = ErrorCorrectLevel;
var _ErrorCorrectLevel2 = _interopRequireDefault(_ErrorCorrectLevel);
var _propTypes = propTypesExports;
var _propTypes2 = _interopRequireDefault(_propTypes);
var _react = reactExports;
var _react2 = _interopRequireDefault(_react);
var _QRCodeSvg = QRCodeSvg$1;
var _QRCodeSvg2 = _interopRequireDefault(_QRCodeSvg);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties(obj, keys2) {
  var target = {};
  for (var i2 in obj) {
    if (keys2.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
}
var propTypes = {
  bgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
  fgColor: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),
  level: _propTypes2.default.string,
  size: _propTypes2.default.number,
  value: _propTypes2.default.string.isRequired
};
var defaultProps$1 = {
  bgColor: "#FFFFFF",
  fgColor: "#000000",
  level: "L",
  size: 256
};
var QRCode$1 = (0, _react.forwardRef)(function(_ref, ref) {
  var bgColor = _ref.bgColor, fgColor = _ref.fgColor, level = _ref.level, size2 = _ref.size, value = _ref.value, props = _objectWithoutProperties(_ref, ["bgColor", "fgColor", "level", "size", "value"]);
  var qrcode = new _QRCode2.default(-1, _ErrorCorrectLevel2.default[level]);
  qrcode.addData(value);
  qrcode.make();
  var cells = qrcode.modules;
  return _react2.default.createElement(_QRCodeSvg2.default, _extends({}, props, {
    bgColor,
    bgD: cells.map(function(row, rowIndex) {
      return row.map(function(cell, cellIndex) {
        return !cell ? "M " + cellIndex + " " + rowIndex + " l 1 0 0 1 -1 0 Z" : "";
      }).join(" ");
    }).join(" "),
    fgColor,
    fgD: cells.map(function(row, rowIndex) {
      return row.map(function(cell, cellIndex) {
        return cell ? "M " + cellIndex + " " + rowIndex + " l 1 0 0 1 -1 0 Z" : "";
      }).join(" ");
    }).join(" "),
    ref,
    size: size2,
    viewBoxSize: cells.length
  }));
});
QRCode$1.displayName = "QRCode";
QRCode$1.propTypes = propTypes;
QRCode$1.defaultProps = defaultProps$1;
var _default = lib.default = QRCode$1;
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node2) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node2)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext2) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext2);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext2
    ];
    function Provider3(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context)
        return context;
      if (defaultContext2 !== void 0)
        return defaultContext2;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider3.displayName = rootComponentName + "Provider";
    return [
      Provider3,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext2) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext2);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id2, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1)
          return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends$2({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends$2({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children))
    return /* @__PURE__ */ reactExports.cloneElement(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node2) => {
  const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node2;
    reactExports.useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ reactExports.createElement(Comp, _extends$2({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node2}`;
  return {
    ...primitive,
    [node2]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    reactDomExports.flushSync(
      () => target.dispatchEvent(event)
    );
}
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}
const $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
const $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = reactExports.useContext($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = reactExports.useState(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = reactExports.useState({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node2) => setNode(node2)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  reactExports.useEffect(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  reactExports.useEffect(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  reactExports.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name2, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name2, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node2) => setContainer(node2)
  );
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container1.contains(relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleMutations = function(mutations) {
        const focusedElement = document.activeElement;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) {
            if (!(container1 !== null && container1 !== void 0 && container1.contains(focusedElement)))
              $d3863c46a17e8a28$var$focus(container1);
          }
        }
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container1)
        mutationObserver.observe(container1, {
          childList: true,
          subtree: true
        });
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  reactExports.useEffect(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = reactExports.useCallback((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container2 = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container2);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container2)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container2) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container2);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container2);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container2);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container2) {
  const nodes = [];
  const walker = document.createTreeWalker(container2, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node2) => {
      const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
      if (node2.disabled || node2.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container2) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container2
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node2, { upTo }) {
  if (getComputedStyle(node2).visibility === "hidden")
    return true;
  while (node2) {
    if (upTo !== void 0 && node2 === upTo)
      return false;
    if (getComputedStyle(node2).display === "none")
      return true;
    node2 = node2.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}
const $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _globalThis$document;
  const { container: container2 = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container2 ? /* @__PURE__ */ $7SXl2$reactdom.createPortal(/* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, portalProps, {
    ref: forwardedRef
  })), container2) : null;
});
function $fe963b355347cc68$export$3e6543de14f8614f(initialState2, machine) {
  return reactExports.useReducer((state2, event) => {
    const nextState = machine[state2][event];
    return nextState !== null && nextState !== void 0 ? nextState : state2;
  }, initialState2);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : reactExports.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ reactExports.cloneElement(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state2, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state2 === "mounted" ? currentAnimationName : "none";
  }, [
    state2
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles2 = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles2);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles2 === null || styles2 === void 0 ? void 0 : styles2.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          reactDomExports.flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state2),
    ref: reactExports.useCallback((node2) => {
      if (node2)
        stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles2) {
  return (styles2 === null || styles2 === void 0 ? void 0 : styles2.animationName) || "none";
}
let $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  reactExports.useEffect(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node2) => node2.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
function __rest$4(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray$2(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$2(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs$1(refs, defaultValue) {
  return useCallbackRef$2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
function __rest$3(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer2 = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer2.length) {
        return buffer2[buffer2.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer2.push(item);
      return function() {
        buffer2 = buffer2.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
      }
      buffer2 = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer2;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer2.length) {
        var cbs = buffer2;
        buffer2 = [];
        cbs.forEach(cb2);
        pendingQueue = buffer2;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer2 = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter3) {
          pendingQueue = pendingQueue.filter(filter3);
          return buffer2;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  return innerCreateMedium(defaults2, middleware2);
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign$4({ async: true, ssr: false }, options2);
  return medium;
}
var SideCar$3 = function(_a4) {
  var sideCar = _a4.sideCar, rest = __rest$3(_a4, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign$4({}, rest));
};
SideCar$3.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$3;
}
var effectCar$2 = createSidecarMedium();
var nothing$2 = function() {
  return;
};
var RemoveScroll$2 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a4 = reactExports.useState({
    onScrollCapture: nothing$2,
    onWheelCapture: nothing$2,
    onTouchMoveCapture: nothing$2
  }), callbacks = _a4[0], setCallbacks = _a4[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container2 = _b3 === void 0 ? "div" : _b3, rest = __rest$4(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs$1([ref, parentRef]);
  var containerProps = __assign$5(__assign$5({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar$2, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$5(__assign$5({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container2, __assign$5({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$2.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$2.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles2, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles2);
      return function() {
        sheet.remove();
      };
    }, [styles2 && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a4) {
    var styles2 = _a4.styles, dynamic = _a4.dynamic;
    useStyle2(styles2, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$1 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left2), parse$1(top2), parse$1(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var getStyles = function(_a4, allowRelative, gapMode, important) {
  var left2 = _a4.left, top2 = _a4.top, right2 = _a4.right, gap = _a4.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a4 = props.gapMode, gapMode = _a4 === void 0 ? "margin" : _a4;
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$2 = false;
if (typeof window !== "undefined") {
  try {
    var options$2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$2 = true;
        return true;
      }
    });
    window.addEventListener("test", options$2, options$2);
    window.removeEventListener("test", options$2, options$2);
  } catch (err) {
    passiveSupported$2 = false;
  }
}
var nonPassive$2 = passiveSupported$2 ? { passive: false } : false;
var alwaysContainsScroll$2 = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled$2 = function(node2, overflow) {
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll$2(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled$2 = function(node2) {
  return elementCanBeScrolled$2(node2, "overflowY");
};
var elementCouldBeHScrolled$2 = function(node2) {
  return elementCanBeScrolled$2(node2, "overflowX");
};
var locationCouldBeScrolled$2 = function(axis, node2) {
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$2(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables$2(axis, current), s2 = _a4[1], d2 = _a4[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables$2 = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$2 = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$2 = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled$2(node2) : elementCouldBeHScrolled$2(node2);
};
var getScrollVariables$2 = function(axis, node2) {
  return axis === "v" ? getVScrollVariables$2(node2) : getHScrollVariables$2(node2);
};
var getDirectionFactor$2 = function(axis, direction2) {
  return axis === "h" && direction2 === "rtl" ? -1 : 1;
};
var handleScroll$2 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$2(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables$2(axis, target), position2 = _a4[0], scroll_1 = _a4[1], capacity = _a4[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled$2(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY$2 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$2 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$2 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$2 = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle$2 = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter$2 = 0;
var lockStack$2 = [];
function RemoveScrollSideCar$2(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter$2++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$2([props.lockRef.current], (props.shards || []).map(extractRef$2), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$2(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$2(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$2(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$2(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack$2.length || lockStack$2[lockStack$2.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$2(event) : getTouchXY$2(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare$2(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$2).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY$2(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack$2.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$2);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$2);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$2);
    return function() {
      lockStack$2 = lockStack$2.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$2);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$2);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$2);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle$2(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar$2 = exportSidecar(effectCar$2, RemoveScrollSideCar$2);
var ReactRemoveScroll$2 = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$2, __assign$5({}, props, { ref, sideCar: SideCar$2 }));
});
ReactRemoveScroll$2.classNames = RemoveScroll$2.classNames;
const $67UHm$RemoveScroll = ReactRemoveScroll$2;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        var attr = node2.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node2) || 0) + 1;
        var markerValue = (markerCounter.get(node2) || 0) + 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        hiddenNodes.push(node2);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node2, true);
        }
        if (markerValue === 1) {
          node2.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node2.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
const $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
const [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
  const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogProvider, {
    scope: __scopeDialog,
    triggerRef,
    contentRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
    descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: reactExports.useCallback(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, children);
};
const $5d3850c4d0b4e6c7$var$TRIGGER_NAME = "DialogTrigger";
const $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...triggerProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
});
const $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
const [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
  forceMount: void 0
});
const $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
  const { __scopeDialog, forceMount, children, container: container2 } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$PortalProvider, {
    scope: __scopeDialog,
    forceMount
  }, reactExports.Children.map(
    children,
    (child) => /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, {
      asChild: true,
      container: container2
    }, child))
  ));
};
const $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
const $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
  return context.modal ? /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends$2({}, overlayProps, {
    ref: forwardedRef
  }))) : null;
});
const $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...overlayProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ reactExports.createElement($67UHm$RemoveScroll, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true,
      shards: [
        context.contentRef
      ]
    }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, overlayProps, {
      ref: forwardedRef,
      style: {
        pointerEvents: "auto",
        ...overlayProps.style
      }
    })))
  );
});
const $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
const $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })));
});
const $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
  reactExports.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$2({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (isRightClick)
        event.preventDefault();
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault()
    )
  }));
});
const $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  const hasPointerDownOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$2({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
const $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends$2({
    role: "dialog",
    id: context.contentId,
    "aria-describedby": context.descriptionId,
    "aria-labelledby": context.titleId,
    "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
  }, contentProps, {
    ref: composedRefs,
    onDismiss: () => context.onOpenChange(false)
  }))), false);
});
const $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
const $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...titleProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends$2({
    id: context.titleId
  }, titleProps, {
    ref: forwardedRef
  }));
});
const $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
const $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDialog, ...closeProps } = props;
  const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
    type: "button"
  }, closeProps, {
    ref: forwardedRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onClick,
      () => context.onOpenChange(false)
    )
  }));
});
function $5d3850c4d0b4e6c7$var$getState(open) {
  return open ? "open" : "closed";
}
const $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
const $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;
const $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
const $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
const $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
const $5d3850c4d0b4e6c7$export$f99233281efd08a0 = $5d3850c4d0b4e6c7$export$16f7638e4a34b909;
const $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var _excluded$T = ["color"];
var CheckIcon$2 = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$T);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$W = ["color"];
var ChevronDownIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$W);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$X = ["color"];
var ChevronLeftIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$X);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M8.84182 3.13514C9.04327 3.32401 9.05348 3.64042 8.86462 3.84188L5.43521 7.49991L8.86462 11.1579C9.05348 11.3594 9.04327 11.6758 8.84182 11.8647C8.64036 12.0535 8.32394 12.0433 8.13508 11.8419L4.38508 7.84188C4.20477 7.64955 4.20477 7.35027 4.38508 7.15794L8.13508 3.15794C8.32394 2.95648 8.64036 2.94628 8.84182 3.13514Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Y = ["color"];
var ChevronRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Y);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1r = ["color"];
var Cross2Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1r);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$33 = ["color"];
var MagnifyingGlassIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$33);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4O = ["color"];
var UploadIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4O);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.81825 1.18188C7.64251 1.00615 7.35759 1.00615 7.18185 1.18188L4.18185 4.18188C4.00611 4.35762 4.00611 4.64254 4.18185 4.81828C4.35759 4.99401 4.64251 4.99401 4.81825 4.81828L7.05005 2.58648V9.49996C7.05005 9.74849 7.25152 9.94996 7.50005 9.94996C7.74858 9.94996 7.95005 9.74849 7.95005 9.49996V2.58648L10.1819 4.81828C10.3576 4.99401 10.6425 4.99401 10.8182 4.81828C10.994 4.64254 10.994 4.35762 10.8182 4.18188L7.81825 1.18188ZM2.5 9.99997C2.77614 9.99997 3 10.2238 3 10.5V12C3 12.5538 3.44565 13 3.99635 13H11.0012C11.5529 13 12 12.5528 12 12V10.5C12 10.2238 12.2239 9.99997 12.5 9.99997C12.7761 9.99997 13 10.2238 13 10.5V12C13 13.104 12.1062 14 11.0012 14H3.99635C2.89019 14 2 13.103 2 12V10.5C2 10.2238 2.22386 9.99997 2.5 9.99997Z",
    fill: color2,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
const FormFieldWithIconButton = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Label, {
      htmlFor: props.id,
      children: props.label
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "sm"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(InputContainer, {
      "data-error": !!props.error,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Input, {
        variant: "transparent",
        required: props.required,
        name: props.name,
        autoComplete: props.autocomplete,
        id: props.id,
        onChange: (e2) => props.onChange(e2.target.value),
        value: props.value,
        type: props.noSave ? "text" : props.type,
        style: props.type === "password" && props.noSave ? {
          WebkitTextSecurity: "disc"
        } : void 0
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(InputButton, {
        type: "button",
        onClick: props.right.onClick,
        children: props.right.icon
      })]
    }), props.error && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "sm"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(ErrorMessage, {
        children: [" ", props.error, " "]
      })]
    })]
  });
};
const FormField = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Label, {
      htmlFor: props.id,
      children: props.label
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "sm"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Input, {
      variant: "outline",
      required: props.required,
      name: props.name,
      autoComplete: props.autocomplete,
      id: props.id,
      onChange: (e2) => props.onChange(e2.target.value),
      value: props.value,
      type: props.type,
      "data-error": !!props.errorMessage,
      placeholder: props.placeholder,
      disabled: props.disabled
    }), props.errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xs"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorMessage, {
        children: props.errorMessage
      })]
    })]
  });
};
const ModalTitle = newStyled($5d3850c4d0b4e6c7$export$f99233281efd08a0)`
  margin: 0;
  font-weight: 600;
  font-size: ${fontSize.lg};
  color: ${(p2) => p2.theme.text.neutral};
  text-align: left;
  ${media.mobile} {
    text-align: ${(p2) => p2.centerOnMobile ? "center" : "left"};
  }
`;
const ModalDescription = newStyled.p`
  all: unset;
  display: block;
  font-size: ${(p2) => p2.sm ? fontSize.sm : fontSize.md};
  color: ${(p2) => p2.theme.text.secondary};
  line-height: 1.5;
  ${media.mobile} {
    text-align: ${(p2) => p2.centerOnMobile ? "center" : "left"};
  }
`;
const BackButton = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
    variant: "secondary",
    onClick: props.onClick,
    style: props.style,
    type: "button",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftIcon, {
      style: {
        width: iconSize.md,
        height: iconSize.md
      }
    })
  });
};
const HelperLink = newStyled.a`
  all: unset;
  cursor: pointer;
  color: ${(p2) => p2.theme.link.primary};
  font-size: ${(p2) => p2.md ? fontSize.md : fontSize.sm};
  text-decoration: none;
  display: block;
  ${media.mobile} {
    text-align: center;
  }
  &:hover {
    color: ${(p2) => p2.theme.link.primaryHover};
    text-decoration: none;
  }
`;
function detectEnv(userAgent) {
  return detect(userAgent);
}
function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function detectOS() {
  const env = detectEnv();
  return env?.os ? env.os : void 0;
}
function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}
const Img = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
    width: props.width,
    height: props.height,
    src: resolveIpfsUri(props.src),
    alt: props.alt || "",
    loading: props.loading,
    decoding: "async",
    style: {
      height: props.height + "px",
      width: props.width + "px"
    },
    className: props.className
  });
};
const ConnectingScreen = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(BackButton, {
      onClick: props.onBack
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(IconContainer, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.xl,
        height: iconSize.xl
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "lg"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(TitleContainer, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ModalTitle, {
        children: "Connecting your wallet"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner$1, {
        size: "md",
        color: "link"
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "md"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(Desc, {
      centerOnMobile: true,
      children: ["Connect your wallet through the ", props.walletName, " ", isMobile() ? "application" : "pop-up"]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "xl"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(HelperLink, {
      target: "_blank",
      href: props.supportLink,
      children: ["Having troubles connecting to ", props.walletName, "?"]
    })]
  });
};
const TitleContainer = newStyled.div`
  display: flex;
  align-items: center;
  gap: ${spacing$1.md};
  ${media.mobile} {
    flex-direction: column;
    align-items: center;
    gap: ${spacing$1.xl};
  }
`;
const IconContainer = newStyled.div`
  display: flex;
  margin-top: ${spacing$1.lg};
  ${media.mobile} {
    justify-content: center;
    margin-top: 0;
  }
`;
const Desc = newStyled(ModalDescription)`
  ${media.mobile} {
    padding: 0 ${spacing$1.lg};
  }
`;
const fadeInAnimation = keyframes$1`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const FadeIn = newStyled.div`
  animation: ${fadeInAnimation} 0.15s ease-in;
`;
const Skeleton = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonDiv, {
    gradient: props.gradient,
    style: {
      height: props.height,
      width: props.width || "auto"
    }
  });
};
const skeletonAnimation = keyframes$1`
0% {
    background-color: var(--skeleton-c-1);
  }
  100% {
    background-color: var(--skeleton-c-2);
  }
`;
const SkeletonDiv = newStyled.div`
  background-size: 200% 200%;
  --skeleton-c-1: ${(p2) => p2.theme.bg[p2.gradient?.c1 || "elevated"]};
  --skeleton-c-2: ${(p2) => p2.theme.bg[p2.gradient?.c2 || "highlighted"]};
  animation: ${skeletonAnimation} 500ms ease-in-out infinite alternate;
  border-radius: ${radius.sm};
`;
const QRCode = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      position: "relative",
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    },
    children: [props.qrCodeUri ? /* @__PURE__ */ jsxRuntimeExports.jsx(FadeIn, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeContainer, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledReactQrCode, {
          value: props.qrCodeUri
        })
      })
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRSkeleton, {
      height: "200px",
      width: "200px"
    }), props.QRIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(QrCodeIconContainer, {
      children: props.QRIcon
    })]
  });
};
const QrCodeIconContainer = newStyled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: ${radius.md};
  display: flex;
  justify-content: center;
  align-content: center;
  padding: 4px;
`;
const QRCodeContainer = newStyled.div`
  background: white;
  padding: ${spacing$1.xxs};
  display: flex;
  justify-content: center;
  align-content: center;
  border-radius: ${radius.md};
  box-shadow: ${shadow.md};
`;
const StyledReactQrCode = newStyled(_default)`
  width: 200px;
  height: 200px;
  border-radius: ${radius.md};

  ${media.mobile} {
    width: 150px;
    height: 150px;
  }
`;
const QRSkeleton = newStyled(Skeleton)`
  width: 200px;
  height: 200px;
  border-radius: ${radius.md};
  ${media.mobile} {
    width: 150px;
    height: 150px;
  }
`;
const Apple = "ipfs://Qmcyb1akWqyu8W4DgVWzZUozrCkfES8ow36jNhjs7arwvc/AppleGray.svg";
const Chrome = "ipfs://QmPu4UKsektZixeZN4ixi8Ji9KbMuwcRKAp3JRK4jrcaMK/Chrome.svg";
const GooglePlay = "ipfs://QmTSu87iXWpfcCgy15DX3Mgp1Rqb8zFAwXdbLNh6WxmpC4/GooglePlay.svg";
const GetStartedScreen = (props) => {
  const [showScreen, setShowScreen] = reactExports.useState("base");
  const isScanScreen = showScreen === "android-scan" || showScreen === "ios-scan";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(BackButton, {
      style: isScanScreen ? {
        position: "absolute",
        top: spacing$1.lg,
        left: spacing$1.lg
      } : void 0,
      onClick: () => {
        if (showScreen === "base") {
          props.onBack();
        } else {
          setShowScreen("base");
        }
      }
    }), showScreen === "android-scan" && props.googlePlayStoreLink && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanScreen$1, {
      platformIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
        src: GooglePlay,
        width: iconSize.md,
        height: iconSize.md
      }),
      url: props.googlePlayStoreLink,
      platform: "Google Play",
      walletName: props.walletName,
      walletIconURL: props.walletIconURL
    }), showScreen === "ios-scan" && props.appleStoreLink && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanScreen$1, {
      platformIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
        width: iconSize.md,
        height: iconSize.md,
        src: Apple
      }),
      url: props.appleStoreLink,
      platform: "App Store",
      walletName: props.walletName,
      walletIconURL: props.walletIconURL
    }), showScreen === "base" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "lg"
      }), props.header || /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
          src: props.walletIconURL,
          width: iconSize.xl,
          height: iconSize.xl,
          alt: ""
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
          y: "lg"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalTitle, {
          children: ["Get started with ", props.walletName]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
          y: "sm"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ModalDescription, {
          children: "Download your preferred option and refresh this page"
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, {
        flexDirection: "column",
        gap: "xs",
        children: [props.chromeExtensionLink && /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonLink, {
          onClick: () => {
            window.open(props.chromeExtensionLink, "_blank");
          },
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
            width: iconSize.lg,
            height: iconSize.lg,
            src: Chrome
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: "Download Chrome Extension"
          })]
        }), props.googlePlayStoreLink && /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonLink, {
          as: "button",
          onClick: () => {
            if (isMobile()) {
              window.open(props.googlePlayStoreLink, "_blank");
            } else {
              setShowScreen("android-scan");
            }
          },
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
            width: iconSize.lg,
            height: iconSize.lg,
            src: GooglePlay
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: "Download on Google Play"
          })]
        }), props.appleStoreLink && /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonLink, {
          as: "button",
          onClick: () => {
            if (isMobile()) {
              window.open(props.appleStoreLink, "_blank");
            } else {
              setShowScreen("ios-scan");
            }
          },
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
            width: iconSize.lg,
            height: iconSize.lg,
            src: Apple
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: "Download on App Store"
          })]
        })]
      })]
    }), isScanScreen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(HelperLink, {
        as: "button",
        onClick: props.onBack,
        style: {
          textAlign: "center",
          display: "block",
          width: "100%"
        },
        children: ["I", `'`, "ve finished setting up my ", props.walletName, " on mobile"]
      })]
    }), !isScanScreen && props.footer]
  });
};
const ScanScreen$1 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center"
    },
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, {
      qrCodeUri: props.url,
      QRIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.lg,
        height: iconSize.lg
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "xl"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      style: {
        display: "flex",
        gap: spacing$1.sm,
        alignItems: "center"
      },
      children: [props.platformIcon, /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalTitle, {
        children: ["Install ", props.walletName, " on ", props.platform]
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "lg"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalDescription, {
      children: ["Scan QR with your phone to download ", /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}), " ", props.walletName, " for", " ", props.platform]
    })]
  });
};
const ButtonLink = newStyled.button`
  all: unset;
  text-decoration: none;
  padding: ${spacing$1.sm} ${spacing$1.md};
  border-radius: ${radius.sm};
  display: flex;
  align-items: center;
  gap: ${spacing$1.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${(p2) => p2.theme.text.neutral};
  background: ${(p2) => p2.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${(p2) => p2.theme.bg.highlighted};
    text-decoration: none;
    color: ${(p2) => p2.theme.text.neutral};
  }
`;
const ScanScreen = (props) => {
  const walletName = props.walletName.toLowerCase().includes("wallet") ? props.walletName : `${props.walletName} wallet`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [!props.hideBackButton && /* @__PURE__ */ jsxRuntimeExports.jsx(BackButton, {
      onClick: props.onBack,
      style: {
        position: "absolute",
        zIndex: 10,
        left: spacing$1.lg,
        top: spacing$1.lg
      }
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      style: {
        textAlign: "center"
      },
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, {
        qrCodeUri: props.qrCodeUri,
        QRIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
          width: iconSize.lg,
          height: iconSize.lg,
          src: props.walletIconURL
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalTitle, {
        style: {
          textAlign: "center"
        },
        children: ["Scan with ", walletName, " "]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "md"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalDescription, {
        children: ["Scan this QR code with your phone ", /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}), "camera or ", walletName, " to connect"]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "md"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        style: {
          display: "flex",
          justifyContent: "center"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner$1, {
          size: "md",
          color: "link"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkButton, {
        onClick: props.onGetStarted,
        children: [`Don't`, " have ", walletName, "?"]
      })]
    })]
  });
};
const LinkButton = newStyled.button`
  all: unset;
  color: ${(p2) => p2.theme.link.primary};
  font-size: ${fontSize.sm};
  cursor: pointer;
  &:hover {
    color: ${(p2) => p2.theme.link.primaryHover};
  }
`;
const CoinbaseScan = (_ref) => {
  let {
    walletConfig,
    onConnected,
    onGetStarted,
    onBack,
    hideBackButton
  } = _ref;
  const createInstance2 = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = reactExports.useState(void 0);
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = useWalletContext();
  const scanStarted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    (async () => {
      const wallet = createInstance2(walletConfig);
      const uri = await wallet.getQrUrl();
      setQrCodeUri(uri || void 0);
      setConnectionStatus("connecting");
      try {
        await wallet.connect({
          chainId: chainToConnect?.chainId
        });
        setConnectedWallet(wallet);
        onConnected();
      } catch {
        setConnectionStatus("disconnected");
      }
    })();
  }, [createInstance2, onConnected, walletConfig, chainToConnect?.chainId, setConnectedWallet, setConnectionStatus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScanScreen, {
    onBack,
    onGetStarted,
    qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL,
    hideBackButton
  });
};
const CoinbaseConnectUI = (_ref) => {
  let {
    walletConfig,
    close,
    goBack,
    supportedWallets
  } = _ref;
  const connect = useConnect();
  const {
    meta
  } = walletConfig;
  const [screen, setScreen] = reactExports.useState("loading");
  const connectPrompted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (screen !== "loading") {
      return;
    }
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;
    (async () => {
      if (isInstalled) {
        try {
          connectPrompted.current = true;
          setScreen("connecting");
          await connect(walletConfig);
          close();
        } catch (e2) {
          goBack();
          console.error(e2);
        }
      } else {
        if (isMobile()) {
          connect(walletConfig);
        } else {
          setScreen("scanning");
        }
      }
    })();
  }, [screen, walletConfig, close, connect, goBack]);
  if (screen === "connecting" || screen === "loading") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectingScreen, {
      onBack: goBack,
      walletName: meta.name,
      walletIconURL: meta.iconURL,
      supportLink: "https://help.coinbase.com/en/wallet/other-topics/troubleshooting-and-tips"
    });
  }
  if (screen === "get-started") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GetStartedScreen, {
      walletIconURL: meta.iconURL,
      walletName: meta.name,
      chromeExtensionLink: meta.urls?.chrome,
      googlePlayStoreLink: meta.urls?.android,
      appleStoreLink: meta.urls?.ios,
      onBack: goBack
    });
  }
  if (screen === "scanning") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CoinbaseScan, {
      onBack: goBack,
      onConnected: close,
      onGetStarted: () => setScreen("get-started"),
      walletConfig,
      hideBackButton: supportedWallets.length === 1
    });
  }
  return null;
};
const coinbaseWallet = () => {
  return {
    id: CoinbaseWallet.id,
    meta: {
      name: "Coinbase Wallet",
      iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
      urls: {
        chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
        android: "https://play.google.com/store/apps/details?id=org.toshi",
        ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
      }
    },
    create(options2) {
      return new CoinbaseWallet({
        ...options2,
        headlessMode: true
      });
    },
    connectUI: CoinbaseConnectUI,
    isInstalled() {
      if (assertWindowEthereum(globalThis.window)) {
        return globalThis.window.ethereum?.isCoinbaseWallet || globalThis.window.ethereum?.providers?.some((p2) => p2.isCoinbaseWallet) || false;
      }
      return false;
    }
  };
};
var coinbaseWallet$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  coinbaseWallet
});
const MetamaskScan = (_ref) => {
  let {
    onBack,
    onConnected,
    onGetStarted,
    walletConfig
  } = _ref;
  const createInstance2 = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = reactExports.useState();
  const {
    setConnectedWallet,
    chainToConnect,
    setConnectionStatus
  } = useWalletContext();
  const scanStarted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (scanStarted.current) {
      return;
    }
    scanStarted.current = true;
    const metamask = createInstance2(walletConfig);
    setConnectionStatus("connecting");
    metamask.connectWithQrCode({
      chainId: chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        setConnectedWallet(metamask);
        onConnected();
      }
    });
  }, [createInstance2, setConnectedWallet, chainToConnect, onConnected, walletConfig, setConnectionStatus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScanScreen, {
    onBack,
    onGetStarted,
    qrCodeUri,
    walletName: walletConfig.meta.name,
    walletIconURL: walletConfig.meta.iconURL
  });
};
const MetamaskConnectUI = (props) => {
  const [screen, setScreen] = reactExports.useState("connecting");
  const {
    walletConfig,
    close
  } = props;
  const connect = useConnect();
  const {
    goBack
  } = props;
  const connectPrompted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (connectPrompted.current) {
      return;
    }
    const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;
    (async () => {
      if (isInstalled) {
        try {
          connectPrompted.current = true;
          setScreen("connecting");
          await connect(walletConfig);
          close();
        } catch (e2) {
          goBack();
        }
      } else {
        if (isMobile()) {
          window.open(`https://metamask.app.link/dapp/${window.location.toString()}`);
        } else {
          setScreen("scanning");
        }
      }
    })();
  }, [walletConfig, close, connect, goBack]);
  if (screen === "connecting") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectingScreen, {
      onBack: props.goBack,
      walletName: walletConfig.meta.name,
      walletIconURL: walletConfig.meta.iconURL,
      supportLink: "https://support.metamask.io/hc/en-us/articles/4406430256539-User-Guide-Troubleshooting"
    });
  }
  if (screen === "get-started") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GetStartedScreen, {
      walletIconURL: walletConfig.meta.iconURL,
      walletName: walletConfig.meta.name,
      chromeExtensionLink: walletConfig.meta.urls?.chrome,
      googlePlayStoreLink: walletConfig.meta.urls?.android,
      appleStoreLink: walletConfig.meta.urls?.ios,
      onBack: props.goBack
    });
  }
  if (screen === "scanning") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MetamaskScan, {
      onBack: props.goBack,
      onConnected: close,
      onGetStarted: () => {
        setScreen("get-started");
      },
      walletConfig
    });
  }
  return null;
};
const metamaskWallet = () => {
  return {
    id: MetaMaskWallet.id,
    meta: MetaMaskWallet.meta,
    create: (options2) => {
      return new MetaMaskWallet({
        ...options2,
        qrcode: false
      });
    },
    connectUI: MetamaskConnectUI,
    isInstalled() {
      if (assertWindowEthereum(globalThis.window)) {
        return globalThis.window.ethereum.isMetaMask;
      }
      return false;
    }
  };
};
var metamaskWallet$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  metamaskWallet
});
const walletConnectV1 = () => {
  return {
    id: WalletConnectV1.id,
    meta: WalletConnectV1.meta,
    create(options2) {
      return new WalletConnectV1({
        ...options2,
        qrcode: true
      });
    }
  };
};
var walletConnectV1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  walletConnectV1
});
const defaultWallets = [metamaskWallet(), coinbaseWallet(), walletConnectV1()];
const WalletModalOpen = /* @__PURE__ */ reactExports.createContext(false);
const SetWalletModalOpen = /* @__PURE__ */ reactExports.createContext(void 0);
const ModalConfigCtx = /* @__PURE__ */ reactExports.createContext({
  title: "",
  theme: "dark",
  data: void 0
});
const SetModalConfigCtx = /* @__PURE__ */ reactExports.createContext(() => {
});
const WalletUIStatesProvider = (props) => {
  const [isWalletModalOpen, setIsWalletModalOpen] = reactExports.useState(false);
  const [modalConfig, setModalConfig] = reactExports.useState({
    title: "Choose your wallet",
    theme: props.theme || "dark",
    data: void 0
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WalletModalOpen.Provider, {
    value: isWalletModalOpen,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SetWalletModalOpen.Provider, {
      value: setIsWalletModalOpen,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalConfigCtx.Provider, {
        value: modalConfig,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SetModalConfigCtx.Provider, {
          value: setModalConfig,
          children: props.children
        })
      })
    })
  });
};
const useIsWalletModalOpen = () => {
  return reactExports.useContext(WalletModalOpen);
};
const useSetIsWalletModalOpen = () => {
  const context = reactExports.useContext(SetWalletModalOpen);
  if (context === void 0) {
    throw new Error("useSetWalletModalOpen must be used within a ThirdwebProvider");
  }
  return context;
};
const WalletSelector = (props) => {
  const localWalletInfo = props.walletConfigs.find((w2) => w2.id === walletIds.localWallet);
  const walletConfigs = props.walletConfigs.filter((w2) => w2.id !== walletIds.localWallet);
  const showGetStarted = !localWalletInfo && !!props.walletConfigs[0].meta.urls;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(ModalTitle, {
      children: [" ", props.title, " "]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
      y: "xl"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(WalletSelection, {
      walletConfigs,
      selectWallet: props.selectWallet
    }), localWalletInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Flex$1, {
        justifyContent: "center",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          variant: "link",
          onClick: () => {
            props.selectWallet(localWalletInfo);
          },
          children: "Continue as guest"
        })
      })]
    }), showGetStarted && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(HelperLink, {
        as: "button",
        onClick: props.onGetStarted,
        style: {
          display: "block",
          width: "100%",
          textAlign: "center"
        },
        children: "Need help getting started?"
      })]
    })]
  });
};
const WalletSelection = (props) => {
  const modalConfig = reactExports.useContext(ModalConfigCtx);
  const setModalConfig = reactExports.useContext(SetModalConfigCtx);
  const walletConfigs = props.walletConfigs.sort((a2, b2) => {
    const aInstalled = a2.isInstalled ? a2.isInstalled() : false;
    const bInstalled = b2.isInstalled ? b2.isInstalled() : false;
    if (aInstalled && !bInstalled) {
      return -1;
    }
    if (!aInstalled && bInstalled) {
      return 1;
    }
    return 0;
  }).sort((a2, b2) => {
    if (a2.selectUI && !b2.selectUI) {
      return -1;
    }
    if (!a2.selectUI && b2.selectUI) {
      return 1;
    }
    return 0;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WalletList, {
    children: walletConfigs.map((walletConfig) => {
      const isInstalled = walletConfig.isInstalled ? walletConfig.isInstalled() : false;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
        children: walletConfig.selectUI ? /* @__PURE__ */ jsxRuntimeExports.jsx(walletConfig.selectUI, {
          theme: modalConfig.theme,
          supportedWallets: props.walletConfigs,
          onSelect: (data) => {
            props.selectWallet(walletConfig);
            setModalConfig((config2) => ({
              ...config2,
              data
            }));
          },
          walletConfig
        }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(WalletButton, {
          type: "button",
          onClick: () => {
            props.selectWallet(walletConfig);
          },
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
            src: walletConfig.meta.iconURL,
            width: iconSize.lg,
            height: iconSize.lg,
            loading: "eager"
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(WalletName, {
            children: walletConfig.meta.name
          }), isInstalled && /* @__PURE__ */ jsxRuntimeExports.jsx(InstallBadge, {
            children: " Installed "
          })]
        })
      }, walletConfig.id);
    })
  });
};
const WalletList = newStyled.ul`
  all: unset;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing$1.xs};
  box-sizing: border-box;
`;
const WalletButton = newStyled.button`
  all: unset;
  padding: ${spacing$1.sm} ${spacing$1.md};
  border-radius: ${radius.sm};
  display: flex;
  align-items: center;
  gap: ${spacing$1.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${(p2) => p2.theme.text.neutral};
  background: ${(p2) => p2.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${(p2) => p2.theme.bg.highlighted};
  }
`;
const InstallBadge = newStyled.span`
  padding: ${spacing$1.xxs} ${spacing$1.xs};
  font-size: ${fontSize.xs};
  background-color: ${(p2) => p2.theme.badge.secondary};
  border-radius: ${radius.lg};
  margin-left: auto;
`;
const WalletName = newStyled.span`
  font-size: ${fontSize.md};
  font-weight: 500;
`;
function useIsHeadlessWallet() {
  const activeWallet = useWallet();
  if (!activeWallet) {
    return false;
  }
  const id2 = activeWallet.walletId;
  return id2 === walletIds.localWallet || id2 === walletIds.paper || id2 === walletIds.magicLink;
}
const HeadlessConnectUI = (_ref) => {
  let {
    close,
    walletConfig,
    open,
    supportedWallets
  } = _ref;
  const connect = useConnect();
  const prompted = reactExports.useRef(false);
  const singleWallet = supportedWallets.length === 1;
  reactExports.useEffect(() => {
    if (prompted.current) {
      return;
    }
    prompted.current = true;
    (async () => {
      close();
      try {
        await connect(walletConfig);
      } catch (e2) {
        if (!singleWallet) {
          open();
        }
        console.error(e2);
      }
    })();
  }, [walletConfig, connect, close, open, singleWallet]);
  return null;
};
const headlessConnectUID7ab9645_browser_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  B: BackButton,
  F: FormFieldWithIconButton,
  G: GetStartedScreen,
  H: HelperLink,
  I: Img,
  M: ModalTitle,
  S: Skeleton,
  W: WalletSelection,
  a: ModalDescription,
  b: HeadlessConnectUI,
  c: coinbaseWallet,
  d: defaultWallets,
  e: useIsWalletModalOpen,
  f: useSetIsWalletModalOpen,
  g: FormField,
  h: fadeInAnimation,
  i: isMobile,
  j: SetModalConfigCtx,
  k: ModalConfigCtx,
  l: WalletSelector,
  m: metamaskWallet,
  n: WalletUIStatesProvider,
  o: coinbaseWallet$1,
  p: metamaskWallet$1,
  q: walletConnectV1$1,
  u: useIsHeadlessWallet,
  w: walletConnectV1
}, Symbol.toStringTag, { value: "Module" }));
newStyled.div`
  display: flex;
  align-items: center;
  color: ${(p2) => p2.theme.text.secondary};
  font-size: ${fontSize.sm};
  &::before,
  &::after {
    content: "";
    flex: 1;
    border-bottom: 1px solid ${(p2) => p2.theme.bg.elevated};
  }

  span {
    margin: 0 1rem;
  }
`;
newStyled(InputButton)`
  background: ${(p2) => p2.theme.bg.highlighted};
  border-radius: 50%;
  padding: ${spacing$1.xxs};
  color: ${(p2) => p2.theme.text.neutral};
  position: absolute;
  top: 50%;
  right: ${spacing$1.sm};
  transform: translateY(-50%);
  &:hover {
    color: ${(p2) => p2.theme.text.neutral};
  }
`;
function t$2(t2) {
  return t2.split("-")[1];
}
function e(t2) {
  return "y" === t2 ? "height" : "width";
}
function n$2(t2) {
  return t2.split("-")[0];
}
function o$1(t2) {
  return ["top", "bottom"].includes(n$2(t2)) ? "x" : "y";
}
function i$1(i2, r2, a2) {
  let { reference: l2, floating: s2 } = i2;
  const c2 = l2.x + l2.width / 2 - s2.width / 2, f2 = l2.y + l2.height / 2 - s2.height / 2, m2 = o$1(r2), u2 = e(m2), g2 = l2[u2] / 2 - s2[u2] / 2, d2 = "x" === m2;
  let p2;
  switch (n$2(r2)) {
    case "top":
      p2 = { x: c2, y: l2.y - s2.height };
      break;
    case "bottom":
      p2 = { x: c2, y: l2.y + l2.height };
      break;
    case "right":
      p2 = { x: l2.x + l2.width, y: f2 };
      break;
    case "left":
      p2 = { x: l2.x - s2.width, y: f2 };
      break;
    default:
      p2 = { x: l2.x, y: l2.y };
  }
  switch (t$2(r2)) {
    case "start":
      p2[m2] -= g2 * (a2 && d2 ? -1 : 1);
      break;
    case "end":
      p2[m2] += g2 * (a2 && d2 ? -1 : 1);
  }
  return p2;
}
const r$3 = async (t2, e2, n2) => {
  const { placement: o2 = "bottom", strategy: r2 = "absolute", middleware: a2 = [], platform: l2 } = n2, s2 = a2.filter(Boolean), c2 = await (null == l2.isRTL ? void 0 : l2.isRTL(e2));
  let f2 = await l2.getElementRects({ reference: t2, floating: e2, strategy: r2 }), { x: m2, y: u2 } = i$1(f2, o2, c2), g2 = o2, d2 = {}, p2 = 0;
  for (let n3 = 0; n3 < s2.length; n3++) {
    const { name: a3, fn: h2 } = s2[n3], { x: y2, y: x2, data: w2, reset: v2 } = await h2({ x: m2, y: u2, initialPlacement: o2, placement: g2, strategy: r2, middlewareData: d2, rects: f2, platform: l2, elements: { reference: t2, floating: e2 } });
    m2 = null != y2 ? y2 : m2, u2 = null != x2 ? x2 : u2, d2 = { ...d2, [a3]: { ...d2[a3], ...w2 } }, v2 && p2 <= 50 && (p2++, "object" == typeof v2 && (v2.placement && (g2 = v2.placement), v2.rects && (f2 = true === v2.rects ? await l2.getElementRects({ reference: t2, floating: e2, strategy: r2 }) : v2.rects), { x: m2, y: u2 } = i$1(f2, g2, c2)), n3 = -1);
  }
  return { x: m2, y: u2, placement: g2, strategy: r2, middlewareData: d2 };
};
function a$1(t2, e2) {
  return "function" == typeof t2 ? t2(e2) : t2;
}
function l$1(t2) {
  return "number" != typeof t2 ? function(t3) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t3 };
  }(t2) : { top: t2, right: t2, bottom: t2, left: t2 };
}
function s$1(t2) {
  return { ...t2, top: t2.y, left: t2.x, right: t2.x + t2.width, bottom: t2.y + t2.height };
}
async function c$1(t2, e2) {
  var n2;
  void 0 === e2 && (e2 = {});
  const { x: o2, y: i2, platform: r2, rects: c2, elements: f2, strategy: m2 } = t2, { boundary: u2 = "clippingAncestors", rootBoundary: g2 = "viewport", elementContext: d2 = "floating", altBoundary: p2 = false, padding: h2 = 0 } = a$1(e2, t2), y2 = l$1(h2), x2 = f2[p2 ? "floating" === d2 ? "reference" : "floating" : d2], w2 = s$1(await r2.getClippingRect({ element: null == (n2 = await (null == r2.isElement ? void 0 : r2.isElement(x2))) || n2 ? x2 : x2.contextElement || await (null == r2.getDocumentElement ? void 0 : r2.getDocumentElement(f2.floating)), boundary: u2, rootBoundary: g2, strategy: m2 })), v2 = "floating" === d2 ? { ...c2.floating, x: o2, y: i2 } : c2.reference, b2 = await (null == r2.getOffsetParent ? void 0 : r2.getOffsetParent(f2.floating)), A2 = await (null == r2.isElement ? void 0 : r2.isElement(b2)) && await (null == r2.getScale ? void 0 : r2.getScale(b2)) || { x: 1, y: 1 }, R2 = s$1(r2.convertOffsetParentRelativeRectToViewportRelativeRect ? await r2.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v2, offsetParent: b2, strategy: m2 }) : v2);
  return { top: (w2.top - R2.top + y2.top) / A2.y, bottom: (R2.bottom - w2.bottom + y2.bottom) / A2.y, left: (w2.left - R2.left + y2.left) / A2.x, right: (R2.right - w2.right + y2.right) / A2.x };
}
const f$2 = Math.min, m$1 = Math.max;
function u$2(t2, e2, n2) {
  return m$1(t2, f$2(e2, n2));
}
const g$1 = (n2) => ({ name: "arrow", options: n2, async fn(i2) {
  const { x: r2, y: s2, placement: c2, rects: m2, platform: g2, elements: d2 } = i2, { element: p2, padding: h2 = 0 } = a$1(n2, i2) || {};
  if (null == p2)
    return {};
  const y2 = l$1(h2), x2 = { x: r2, y: s2 }, w2 = o$1(c2), v2 = e(w2), b2 = await g2.getDimensions(p2), A2 = "y" === w2, R2 = A2 ? "top" : "left", P2 = A2 ? "bottom" : "right", E2 = A2 ? "clientHeight" : "clientWidth", T2 = m2.reference[v2] + m2.reference[w2] - x2[w2] - m2.floating[v2], D2 = x2[w2] - m2.reference[w2], L2 = await (null == g2.getOffsetParent ? void 0 : g2.getOffsetParent(p2));
  let k2 = L2 ? L2[E2] : 0;
  k2 && await (null == g2.isElement ? void 0 : g2.isElement(L2)) || (k2 = d2.floating[E2] || m2.floating[v2]);
  const O2 = T2 / 2 - D2 / 2, B2 = k2 / 2 - b2[v2] / 2 - 1, C2 = f$2(y2[R2], B2), H2 = f$2(y2[P2], B2), S2 = C2, F2 = k2 - b2[v2] - H2, M2 = k2 / 2 - b2[v2] / 2 + O2, V2 = u$2(S2, M2, F2), W2 = null != t$2(c2) && M2 != V2 && m2.reference[v2] / 2 - (M2 < S2 ? C2 : H2) - b2[v2] / 2 < 0;
  return { [w2]: x2[w2] - (W2 ? M2 < S2 ? S2 - M2 : F2 - M2 : 0), data: { [w2]: V2, centerOffset: M2 - V2 } };
} }), d$1 = ["top", "right", "bottom", "left"];
d$1.reduce((t2, e2) => t2.concat(e2, e2 + "-start", e2 + "-end"), []);
const h$2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function y$1(t2) {
  return t2.replace(/left|right|bottom|top/g, (t3) => h$2[t3]);
}
function x$1(n2, i2, r2) {
  void 0 === r2 && (r2 = false);
  const a2 = t$2(n2), l2 = o$1(n2), s2 = e(l2);
  let c2 = "x" === l2 ? a2 === (r2 ? "end" : "start") ? "right" : "left" : "start" === a2 ? "bottom" : "top";
  return i2.reference[s2] > i2.floating[s2] && (c2 = y$1(c2)), { main: c2, cross: y$1(c2) };
}
const w$2 = { start: "end", end: "start" };
function v$2(t2) {
  return t2.replace(/start|end/g, (t3) => w$2[t3]);
}
const A = function(e2) {
  return void 0 === e2 && (e2 = {}), { name: "flip", options: e2, async fn(o2) {
    var i2;
    const { placement: r2, middlewareData: l2, rects: s2, initialPlacement: f2, platform: m2, elements: u2 } = o2, { mainAxis: g2 = true, crossAxis: d2 = true, fallbackPlacements: p2, fallbackStrategy: h2 = "bestFit", fallbackAxisSideDirection: w2 = "none", flipAlignment: b2 = true, ...A2 } = a$1(e2, o2), R2 = n$2(r2), P2 = n$2(f2) === f2, E2 = await (null == m2.isRTL ? void 0 : m2.isRTL(u2.floating)), T2 = p2 || (P2 || !b2 ? [y$1(f2)] : function(t2) {
      const e3 = y$1(t2);
      return [v$2(t2), e3, v$2(e3)];
    }(f2));
    p2 || "none" === w2 || T2.push(...function(e3, o3, i3, r3) {
      const a2 = t$2(e3);
      let l3 = function(t2, e4, n2) {
        const o4 = ["left", "right"], i4 = ["right", "left"], r4 = ["top", "bottom"], a3 = ["bottom", "top"];
        switch (t2) {
          case "top":
          case "bottom":
            return n2 ? e4 ? i4 : o4 : e4 ? o4 : i4;
          case "left":
          case "right":
            return e4 ? r4 : a3;
          default:
            return [];
        }
      }(n$2(e3), "start" === i3, r3);
      return a2 && (l3 = l3.map((t2) => t2 + "-" + a2), o3 && (l3 = l3.concat(l3.map(v$2)))), l3;
    }(f2, b2, w2, E2));
    const D2 = [f2, ...T2], L2 = await c$1(o2, A2), k2 = [];
    let O2 = (null == (i2 = l2.flip) ? void 0 : i2.overflows) || [];
    if (g2 && k2.push(L2[R2]), d2) {
      const { main: t2, cross: e3 } = x$1(r2, s2, E2);
      k2.push(L2[t2], L2[e3]);
    }
    if (O2 = [...O2, { placement: r2, overflows: k2 }], !k2.every((t2) => t2 <= 0)) {
      var B2, C2;
      const t2 = ((null == (B2 = l2.flip) ? void 0 : B2.index) || 0) + 1, e3 = D2[t2];
      if (e3)
        return { data: { index: t2, overflows: O2 }, reset: { placement: e3 } };
      let n2 = null == (C2 = O2.filter((t3) => t3.overflows[0] <= 0).sort((t3, e4) => t3.overflows[1] - e4.overflows[1])[0]) ? void 0 : C2.placement;
      if (!n2)
        switch (h2) {
          case "bestFit": {
            var H2;
            const t3 = null == (H2 = O2.map((t4) => [t4.placement, t4.overflows.filter((t5) => t5 > 0).reduce((t5, e4) => t5 + e4, 0)]).sort((t4, e4) => t4[1] - e4[1])[0]) ? void 0 : H2[0];
            t3 && (n2 = t3);
            break;
          }
          case "initialPlacement":
            n2 = f2;
        }
      if (r2 !== n2)
        return { reset: { placement: n2 } };
    }
    return {};
  } };
};
function R$1(t2, e2) {
  return { top: t2.top - e2.height, right: t2.right - e2.width, bottom: t2.bottom - e2.height, left: t2.left - e2.width };
}
function P$2(t2) {
  return d$1.some((e2) => t2[e2] >= 0);
}
const E$1 = function(t2) {
  return void 0 === t2 && (t2 = {}), { name: "hide", options: t2, async fn(e2) {
    const { rects: n2 } = e2, { strategy: o2 = "referenceHidden", ...i2 } = a$1(t2, e2);
    switch (o2) {
      case "referenceHidden": {
        const t3 = R$1(await c$1(e2, { ...i2, elementContext: "reference" }), n2.reference);
        return { data: { referenceHiddenOffsets: t3, referenceHidden: P$2(t3) } };
      }
      case "escaped": {
        const t3 = R$1(await c$1(e2, { ...i2, altBoundary: true }), n2.floating);
        return { data: { escapedOffsets: t3, escaped: P$2(t3) } };
      }
      default:
        return {};
    }
  } };
};
const L$1 = function(e2) {
  return void 0 === e2 && (e2 = 0), { name: "offset", options: e2, async fn(i2) {
    const { x: r2, y: l2 } = i2, s2 = await async function(e3, i3) {
      const { placement: r3, platform: l3, elements: s3 } = e3, c2 = await (null == l3.isRTL ? void 0 : l3.isRTL(s3.floating)), f2 = n$2(r3), m2 = t$2(r3), u2 = "x" === o$1(r3), g2 = ["left", "top"].includes(f2) ? -1 : 1, d2 = c2 && u2 ? -1 : 1, p2 = a$1(i3, e3);
      let { mainAxis: h2, crossAxis: y2, alignmentAxis: x2 } = "number" == typeof p2 ? { mainAxis: p2, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...p2 };
      return m2 && "number" == typeof x2 && (y2 = "end" === m2 ? -1 * x2 : x2), u2 ? { x: y2 * d2, y: h2 * g2 } : { x: h2 * g2, y: y2 * d2 };
    }(i2, e2);
    return { x: r2 + s2.x, y: l2 + s2.y, data: s2 };
  } };
};
function k$1(t2) {
  return "x" === t2 ? "y" : "x";
}
const O$1 = function(t2) {
  return void 0 === t2 && (t2 = {}), { name: "shift", options: t2, async fn(e2) {
    const { x: i2, y: r2, placement: l2 } = e2, { mainAxis: s2 = true, crossAxis: f2 = false, limiter: m2 = { fn: (t3) => {
      let { x: e3, y: n2 } = t3;
      return { x: e3, y: n2 };
    } }, ...g2 } = a$1(t2, e2), d2 = { x: i2, y: r2 }, p2 = await c$1(e2, g2), h2 = o$1(n$2(l2)), y2 = k$1(h2);
    let x2 = d2[h2], w2 = d2[y2];
    if (s2) {
      const t3 = "y" === h2 ? "bottom" : "right";
      x2 = u$2(x2 + p2["y" === h2 ? "top" : "left"], x2, x2 - p2[t3]);
    }
    if (f2) {
      const t3 = "y" === y2 ? "bottom" : "right";
      w2 = u$2(w2 + p2["y" === y2 ? "top" : "left"], w2, w2 - p2[t3]);
    }
    const v2 = m2.fn({ ...e2, [h2]: x2, [y2]: w2 });
    return { ...v2, data: { x: v2.x - i2, y: v2.y - r2 } };
  } };
}, B = function(t2) {
  return void 0 === t2 && (t2 = {}), { options: t2, fn(e2) {
    const { x: i2, y: r2, placement: l2, rects: s2, middlewareData: c2 } = e2, { offset: f2 = 0, mainAxis: m2 = true, crossAxis: u2 = true } = a$1(t2, e2), g2 = { x: i2, y: r2 }, d2 = o$1(l2), p2 = k$1(d2);
    let h2 = g2[d2], y2 = g2[p2];
    const x2 = a$1(f2, e2), w2 = "number" == typeof x2 ? { mainAxis: x2, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...x2 };
    if (m2) {
      const t3 = "y" === d2 ? "height" : "width", e3 = s2.reference[d2] - s2.floating[t3] + w2.mainAxis, n2 = s2.reference[d2] + s2.reference[t3] - w2.mainAxis;
      h2 < e3 ? h2 = e3 : h2 > n2 && (h2 = n2);
    }
    if (u2) {
      var v2, b2;
      const t3 = "y" === d2 ? "width" : "height", e3 = ["top", "left"].includes(n$2(l2)), o2 = s2.reference[p2] - s2.floating[t3] + (e3 && (null == (v2 = c2.offset) ? void 0 : v2[p2]) || 0) + (e3 ? 0 : w2.crossAxis), i3 = s2.reference[p2] + s2.reference[t3] + (e3 ? 0 : (null == (b2 = c2.offset) ? void 0 : b2[p2]) || 0) - (e3 ? w2.crossAxis : 0);
      y2 < o2 ? y2 = o2 : y2 > i3 && (y2 = i3);
    }
    return { [d2]: h2, [p2]: y2 };
  } };
}, C$1 = function(e2) {
  return void 0 === e2 && (e2 = {}), { name: "size", options: e2, async fn(i2) {
    const { placement: r2, rects: l2, platform: s2, elements: u2 } = i2, { apply: g2 = () => {
    }, ...d2 } = a$1(e2, i2), p2 = await c$1(i2, d2), h2 = n$2(r2), y2 = t$2(r2), x2 = "x" === o$1(r2), { width: w2, height: v2 } = l2.floating;
    let b2, A2;
    "top" === h2 || "bottom" === h2 ? (b2 = h2, A2 = y2 === (await (null == s2.isRTL ? void 0 : s2.isRTL(u2.floating)) ? "start" : "end") ? "left" : "right") : (A2 = h2, b2 = "end" === y2 ? "top" : "bottom");
    const R2 = v2 - p2[b2], P2 = w2 - p2[A2], E2 = !i2.middlewareData.shift;
    let T2 = R2, D2 = P2;
    if (x2) {
      const t2 = w2 - p2.left - p2.right;
      D2 = y2 || E2 ? f$2(P2, t2) : t2;
    } else {
      const t2 = v2 - p2.top - p2.bottom;
      T2 = y2 || E2 ? f$2(R2, t2) : t2;
    }
    if (E2 && !y2) {
      const t2 = m$1(p2.left, 0), e3 = m$1(p2.right, 0), n2 = m$1(p2.top, 0), o2 = m$1(p2.bottom, 0);
      x2 ? D2 = w2 - 2 * (0 !== t2 || 0 !== e3 ? t2 + e3 : m$1(p2.left, p2.right)) : T2 = v2 - 2 * (0 !== n2 || 0 !== o2 ? n2 + o2 : m$1(p2.top, p2.bottom));
    }
    await g2({ ...i2, availableWidth: D2, availableHeight: T2 });
    const L2 = await s2.getDimensions(u2.floating);
    return w2 !== L2.width || v2 !== L2.height ? { reset: { rects: true } } : {};
  } };
};
function n$1(t2) {
  var e2;
  return (null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
}
function o(t2) {
  return n$1(t2).getComputedStyle(t2);
}
function i(t2) {
  return t2 instanceof n$1(t2).Node;
}
function r$2(t2) {
  return i(t2) ? (t2.nodeName || "").toLowerCase() : "";
}
function l(t2) {
  return t2 instanceof n$1(t2).HTMLElement;
}
function c(t2) {
  return t2 instanceof n$1(t2).Element;
}
function s(t2) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t2 instanceof n$1(t2).ShadowRoot || t2 instanceof ShadowRoot;
}
function f$1(t2) {
  const { overflow: e2, overflowX: n2, overflowY: i2, display: r2 } = o(t2);
  return /auto|scroll|overlay|hidden|clip/.test(e2 + i2 + n2) && !["inline", "contents"].includes(r2);
}
function u$1(t2) {
  return ["table", "td", "th"].includes(r$2(t2));
}
function a(t2) {
  const e2 = d(), n2 = o(t2);
  return "none" !== n2.transform || "none" !== n2.perspective || !e2 && !!n2.backdropFilter && "none" !== n2.backdropFilter || !e2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective", "filter"].some((t3) => (n2.willChange || "").includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => (n2.contain || "").includes(t3));
}
function d() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function h$1(t2) {
  return ["html", "body", "#document"].includes(r$2(t2));
}
const p$1 = Math.min, m = Math.max, g = Math.round;
function y(t2) {
  const e2 = o(t2);
  let n2 = parseFloat(e2.width) || 0, i2 = parseFloat(e2.height) || 0;
  const r2 = l(t2), c2 = r2 ? t2.offsetWidth : n2, s2 = r2 ? t2.offsetHeight : i2, f2 = g(n2) !== c2 || g(i2) !== s2;
  return f2 && (n2 = c2, i2 = s2), { width: n2, height: i2, fallback: f2 };
}
function x(t2) {
  return c(t2) ? t2 : t2.contextElement;
}
const w$1 = { x: 1, y: 1 };
function v$1(t2) {
  const e2 = x(t2);
  if (!l(e2))
    return w$1;
  const n2 = e2.getBoundingClientRect(), { width: o2, height: i2, fallback: r2 } = y(e2);
  let c2 = (r2 ? g(n2.width) : n2.width) / o2, s2 = (r2 ? g(n2.height) : n2.height) / i2;
  return c2 && Number.isFinite(c2) || (c2 = 1), s2 && Number.isFinite(s2) || (s2 = 1), { x: c2, y: s2 };
}
const b = { x: 0, y: 0 };
function L(t2, e2, o2) {
  var i2, r2;
  if (void 0 === e2 && (e2 = true), !d())
    return b;
  const l2 = t2 ? n$1(t2) : window;
  return !o2 || e2 && o2 !== l2 ? b : { x: (null == (i2 = l2.visualViewport) ? void 0 : i2.offsetLeft) || 0, y: (null == (r2 = l2.visualViewport) ? void 0 : r2.offsetTop) || 0 };
}
function E(e2, o2, i2, r2) {
  void 0 === o2 && (o2 = false), void 0 === i2 && (i2 = false);
  const l2 = e2.getBoundingClientRect(), s2 = x(e2);
  let f2 = w$1;
  o2 && (r2 ? c(r2) && (f2 = v$1(r2)) : f2 = v$1(e2));
  const u2 = L(s2, i2, r2);
  let a2 = (l2.left + u2.x) / f2.x, d2 = (l2.top + u2.y) / f2.y, h2 = l2.width / f2.x, p2 = l2.height / f2.y;
  if (s2) {
    const t2 = n$1(s2), e3 = r2 && c(r2) ? n$1(r2) : r2;
    let o3 = t2.frameElement;
    for (; o3 && r2 && e3 !== t2; ) {
      const t3 = v$1(o3), e4 = o3.getBoundingClientRect(), i3 = getComputedStyle(o3);
      e4.x += (o3.clientLeft + parseFloat(i3.paddingLeft)) * t3.x, e4.y += (o3.clientTop + parseFloat(i3.paddingTop)) * t3.y, a2 *= t3.x, d2 *= t3.y, h2 *= t3.x, p2 *= t3.y, a2 += e4.x, d2 += e4.y, o3 = n$1(o3).frameElement;
    }
  }
  return s$1({ width: h2, height: p2, x: a2, y: d2 });
}
function R(t2) {
  return ((i(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
}
function T(t2) {
  return c(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
}
function S(t2) {
  return E(R(t2)).left + T(t2).scrollLeft;
}
function C(t2) {
  if ("html" === r$2(t2))
    return t2;
  const e2 = t2.assignedSlot || t2.parentNode || s(t2) && t2.host || R(t2);
  return s(e2) ? e2.host : e2;
}
function F$1(t2) {
  const e2 = C(t2);
  return h$1(e2) ? e2.ownerDocument.body : l(e2) && f$1(e2) ? e2 : F$1(e2);
}
function W(t2, e2) {
  var o2;
  void 0 === e2 && (e2 = []);
  const i2 = F$1(t2), r2 = i2 === (null == (o2 = t2.ownerDocument) ? void 0 : o2.body), l2 = n$1(i2);
  return r2 ? e2.concat(l2, l2.visualViewport || [], f$1(i2) ? i2 : []) : e2.concat(i2, W(i2));
}
function D(e2, i2, r2) {
  let s2;
  if ("viewport" === i2)
    s2 = function(t2, e3) {
      const o2 = n$1(t2), i3 = R(t2), r3 = o2.visualViewport;
      let l2 = i3.clientWidth, c2 = i3.clientHeight, s3 = 0, f2 = 0;
      if (r3) {
        l2 = r3.width, c2 = r3.height;
        const t3 = d();
        (!t3 || t3 && "fixed" === e3) && (s3 = r3.offsetLeft, f2 = r3.offsetTop);
      }
      return { width: l2, height: c2, x: s3, y: f2 };
    }(e2, r2);
  else if ("document" === i2)
    s2 = function(t2) {
      const e3 = R(t2), n2 = T(t2), i3 = t2.ownerDocument.body, r3 = m(e3.scrollWidth, e3.clientWidth, i3.scrollWidth, i3.clientWidth), l2 = m(e3.scrollHeight, e3.clientHeight, i3.scrollHeight, i3.clientHeight);
      let c2 = -n2.scrollLeft + S(t2);
      const s3 = -n2.scrollTop;
      return "rtl" === o(i3).direction && (c2 += m(e3.clientWidth, i3.clientWidth) - r3), { width: r3, height: l2, x: c2, y: s3 };
    }(R(e2));
  else if (c(i2))
    s2 = function(t2, e3) {
      const n2 = E(t2, true, "fixed" === e3), o2 = n2.top + t2.clientTop, i3 = n2.left + t2.clientLeft, r3 = l(t2) ? v$1(t2) : { x: 1, y: 1 };
      return { width: t2.clientWidth * r3.x, height: t2.clientHeight * r3.y, x: i3 * r3.x, y: o2 * r3.y };
    }(i2, r2);
  else {
    const t2 = L(e2);
    s2 = { ...i2, x: i2.x - t2.x, y: i2.y - t2.y };
  }
  return s$1(s2);
}
function H(t2, e2) {
  const n2 = C(t2);
  return !(n2 === e2 || !c(n2) || h$1(n2)) && ("fixed" === o(n2).position || H(n2, e2));
}
function O(t2, e2) {
  return l(t2) && "fixed" !== o(t2).position ? e2 ? e2(t2) : t2.offsetParent : null;
}
function P$1(t2, e2) {
  const i2 = n$1(t2);
  if (!l(t2))
    return i2;
  let c2 = O(t2, e2);
  for (; c2 && u$1(c2) && "static" === o(c2).position; )
    c2 = O(c2, e2);
  return c2 && ("html" === r$2(c2) || "body" === r$2(c2) && "static" === o(c2).position && !a(c2)) ? i2 : c2 || function(t3) {
    let e3 = C(t3);
    for (; l(e3) && !h$1(e3); ) {
      if (a(e3))
        return e3;
      e3 = C(e3);
    }
    return null;
  }(t2) || i2;
}
function V(t2, e2, n2) {
  const o2 = l(e2), i2 = R(e2), c2 = "fixed" === n2, s2 = E(t2, true, c2, e2);
  let u2 = { scrollLeft: 0, scrollTop: 0 };
  const a2 = { x: 0, y: 0 };
  if (o2 || !o2 && !c2)
    if (("body" !== r$2(e2) || f$1(i2)) && (u2 = T(e2)), l(e2)) {
      const t3 = E(e2, true, c2, e2);
      a2.x = t3.x + e2.clientLeft, a2.y = t3.y + e2.clientTop;
    } else
      i2 && (a2.x = S(i2));
  return { x: s2.left + u2.scrollLeft - a2.x, y: s2.top + u2.scrollTop - a2.y, width: s2.width, height: s2.height };
}
const k = { getClippingRect: function(t2) {
  let { element: e2, boundary: n2, rootBoundary: i2, strategy: l2 } = t2;
  const s2 = "clippingAncestors" === n2 ? function(t3, e3) {
    const n3 = e3.get(t3);
    if (n3)
      return n3;
    let i3 = W(t3).filter((t4) => c(t4) && "body" !== r$2(t4)), l3 = null;
    const s3 = "fixed" === o(t3).position;
    let u3 = s3 ? C(t3) : t3;
    for (; c(u3) && !h$1(u3); ) {
      const e4 = o(u3), n4 = a(u3);
      n4 || "fixed" !== e4.position || (l3 = null), (s3 ? !n4 && !l3 : !n4 && "static" === e4.position && l3 && ["absolute", "fixed"].includes(l3.position) || f$1(u3) && !n4 && H(t3, u3)) ? i3 = i3.filter((t4) => t4 !== u3) : l3 = e4, u3 = C(u3);
    }
    return e3.set(t3, i3), i3;
  }(e2, this._c) : [].concat(n2), u2 = [...s2, i2], d2 = u2[0], g2 = u2.reduce((t3, n3) => {
    const o2 = D(e2, n3, l2);
    return t3.top = m(o2.top, t3.top), t3.right = p$1(o2.right, t3.right), t3.bottom = p$1(o2.bottom, t3.bottom), t3.left = m(o2.left, t3.left), t3;
  }, D(e2, d2, l2));
  return { width: g2.right - g2.left, height: g2.bottom - g2.top, x: g2.left, y: g2.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
  let { rect: e2, offsetParent: n2, strategy: o2 } = t2;
  const i2 = l(n2), c2 = R(n2);
  if (n2 === c2)
    return e2;
  let s2 = { scrollLeft: 0, scrollTop: 0 }, u2 = { x: 1, y: 1 };
  const a2 = { x: 0, y: 0 };
  if ((i2 || !i2 && "fixed" !== o2) && (("body" !== r$2(n2) || f$1(c2)) && (s2 = T(n2)), l(n2))) {
    const t3 = E(n2);
    u2 = v$1(n2), a2.x = t3.x + n2.clientLeft, a2.y = t3.y + n2.clientTop;
  }
  return { width: e2.width * u2.x, height: e2.height * u2.y, x: e2.x * u2.x - s2.scrollLeft * u2.x + a2.x, y: e2.y * u2.y - s2.scrollTop * u2.y + a2.y };
}, isElement: c, getDimensions: function(t2) {
  return y(t2);
}, getOffsetParent: P$1, getDocumentElement: R, getScale: v$1, async getElementRects(t2) {
  let { reference: e2, floating: n2, strategy: o2 } = t2;
  const i2 = this.getOffsetParent || P$1, r2 = this.getDimensions;
  return { reference: V(e2, await i2(n2), o2), floating: { x: 0, y: 0, ...await r2(n2) } };
}, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o(t2).direction };
function z(t2, e2, n2, o2) {
  void 0 === o2 && (o2 = {});
  const { ancestorScroll: i2 = true, ancestorResize: r2 = true, elementResize: l2 = true, animationFrame: s2 = false } = o2, f2 = i2 || r2 ? [...c(t2) ? W(t2) : t2.contextElement ? W(t2.contextElement) : [], ...W(e2)] : [];
  f2.forEach((t3) => {
    const e3 = !c(t3) && t3.toString().includes("V");
    !i2 || s2 && !e3 || t3.addEventListener("scroll", n2, { passive: true }), r2 && t3.addEventListener("resize", n2);
  });
  let u2, a2 = null;
  l2 && (a2 = new ResizeObserver(() => {
    n2();
  }), c(t2) && !s2 && a2.observe(t2), c(t2) || !t2.contextElement || s2 || a2.observe(t2.contextElement), a2.observe(e2));
  let d2 = s2 ? E(t2) : null;
  return s2 && function e3() {
    const o3 = E(t2);
    !d2 || o3.x === d2.x && o3.y === d2.y && o3.width === d2.width && o3.height === d2.height || n2();
    d2 = o3, u2 = requestAnimationFrame(e3);
  }(), n2(), () => {
    var t3;
    f2.forEach((t4) => {
      i2 && t4.removeEventListener("scroll", n2), r2 && t4.removeEventListener("resize", n2);
    }), null == (t3 = a2) || t3.disconnect(), a2 = null, s2 && cancelAnimationFrame(u2);
  };
}
const M = (t2, n2, o2) => {
  const i2 = /* @__PURE__ */ new Map(), r2 = { platform: k, ...o2 }, l2 = { ...r2.platform, _c: i2 };
  return r$3(t2, n2, { ...r2, platform: l2 });
};
const arrow$2 = (options2) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options2,
    fn(state2) {
      const {
        element,
        padding: padding2
      } = typeof options2 === "function" ? options2(state2) : options2;
      if (element && isRef(element)) {
        if (element.current != null) {
          return g$1({
            element: element.current,
            padding: padding2
          }).fn(state2);
        }
        return {};
      } else if (element) {
        return g$1({
          element,
          padding: padding2
        }).fn(state2);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length2, i2, keys2;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length2; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length2; i2-- !== 0; ) {
      const key2 = keys2[i2];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node2) => {
    if (node2 != referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, [_setReference]);
  const setFloating = reactExports.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update5 = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    M(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update5);
      } else {
        update5();
      }
    }
  }, [referenceEl, floatingEl, update5, whileElementsMountedRef]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update: update5,
    refs,
    elements,
    floatingStyles
  }), [data, update5, refs, elements, floatingStyles]);
}
const $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends$2({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ reactExports.createElement("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
const $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size2;
}
const $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
const [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
const [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
const $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
const [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
const $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = reactExports.useState(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node2) => setContent(node2)
  );
  const [arrow2, setArrow] = reactExports.useState(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: z,
    elements: {
      reference: context.anchor
    },
    middleware: [
      L$1({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions && O$1({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? B() : void 0,
        ...detectOverflowOptions
      }),
      avoidCollisions && A({
        ...detectOverflowOptions
      }),
      C$1({
        ...detectOverflowOptions,
        apply: ({ elements, rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          const contentStyle = elements.floating.style;
          contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
          contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
          contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
          contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
        }
      }),
      arrow2 && arrow$2({
        element: arrow2,
        padding: arrowPadding
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached && E$1({
        strategy: "referenceHidden"
      })
    ]
  });
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPositioned)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPositioned,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  return /* @__PURE__ */ reactExports.createElement("div", {
    ref: refs.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...floatingStyles,
      transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
    "data-side": placedSide,
    "data-align": placedAlign
  }, contentProps, {
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPositioned ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  }))));
});
const $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
const $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ reactExports.forwardRef(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ reactExports.createElement("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ reactExports.createElement($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends$2({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
const $cf1ac5d9fe0e8206$var$transformOrigin = (options2) => ({
  name: "transformOrigin",
  options: options2,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x2,
        y: y2
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
const $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
const $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
function __rest$2(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray$1(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var effectCar$1 = createSidecarMedium();
var nothing$1 = function() {
  return;
};
var RemoveScroll$1 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a4 = reactExports.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a4[0], setCallbacks = _a4[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container2 = _b3 === void 0 ? "div" : _b3, rest = __rest$2(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs$1([ref, parentRef]);
  var containerProps = __assign$3(__assign$3({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar$1, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$3(__assign$3({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container2, __assign$3({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive$1 = passiveSupported$1 ? { passive: false } : false;
var alwaysContainsScroll$1 = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled$1 = function(node2, overflow) {
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll$1(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled$1 = function(node2) {
  return elementCanBeScrolled$1(node2, "overflowY");
};
var elementCouldBeHScrolled$1 = function(node2) {
  return elementCanBeScrolled$1(node2, "overflowX");
};
var locationCouldBeScrolled$1 = function(axis, node2) {
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$1(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables$1(axis, current), s2 = _a4[1], d2 = _a4[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables$1 = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$1 = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$1 = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled$1(node2) : elementCouldBeHScrolled$1(node2);
};
var getScrollVariables$1 = function(axis, node2) {
  return axis === "v" ? getVScrollVariables$1(node2) : getHScrollVariables$1(node2);
};
var getDirectionFactor$1 = function(axis, direction2) {
  return axis === "h" && direction2 === "rtl" ? -1 : 1;
};
var handleScroll$1 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$1(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables$1(axis, target), position2 = _a4[0], scroll_1 = _a4[1], capacity = _a4[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled$1(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY$1 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$1 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$1 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$1 = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle$1 = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack$1 = [];
function RemoveScrollSideCar$1(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter$1++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray$1([props.lockRef.current], (props.shards || []).map(extractRef$1), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$1(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$1(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack$1.length || lockStack$1[lockStack$1.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$1(event) : getTouchXY$1(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare$1(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$1).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY$1(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack$1.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$1);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$1);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$1);
    return function() {
      lockStack$1 = lockStack$1.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$1);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle$1(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar$1 = exportSidecar(effectCar$1, RemoveScrollSideCar$1);
var ReactRemoveScroll$1 = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$1, __assign$3({}, props, { ref, sideCar: SideCar$1 }));
});
ReactRemoveScroll$1.classNames = RemoveScroll$1.classNames;
const $am6gm$RemoveScroll = ReactRemoveScroll$1;
const $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
const [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
const $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
const $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
const [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
const $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
const $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })));
});
const $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($am6gm$RemoveScroll, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends$2({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
const $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  const hasPointerDownOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends$2({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
      hasPointerDownOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented) {
        hasInteractedOutsideRef.current = true;
        if (event.detail.originalEvent.type === "pointerdown")
          hasPointerDownOutsideRef.current = true;
      }
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
      if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
        event.preventDefault();
    }
  }));
});
const $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends$2({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
const $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends$2({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
const $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
const $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;
const $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({}, props, {
    ref: forwardedRef,
    style: {
      // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal",
      ...props.style
    }
  }));
});
const $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;
const [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1("Tooltip", [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
const $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const $a093c7e1ec25a057$var$PROVIDER_NAME = "TooltipProvider";
const $a093c7e1ec25a057$var$TOOLTIP_OPEN = "tooltip.open";
const [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);
const $a093c7e1ec25a057$var$TOOLTIP_NAME = "Tooltip";
const [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);
const $a093c7e1ec25a057$var$PORTAL_NAME = "TooltipPortal";
const [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {
  forceMount: void 0
});
const $a093c7e1ec25a057$var$CONTENT_NAME = "TooltipContent";
const $a093c7e1ec25a057$export$e9003e2be37ec060 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.disableHoverableContent ? /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends$2({
    side
  }, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentHoverable, _extends$2({
    side
  }, contentProps, {
    ref: forwardedRef
  })));
});
const $a093c7e1ec25a057$var$TooltipContentHoverable = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [
    onPointerInTransitChange
  ]);
  const handleCreateGraceArea = reactExports.useCallback((event, hoverTarget) => {
    const currentTarget = event.currentTarget;
    const exitPoint = {
      x: event.clientX,
      y: event.clientY
    };
    const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = $a093c7e1ec25a057$var$getHull([
      ...paddedExitPoints,
      ...hoverTargetPoints
    ]);
    setPointerGraceArea(graceArea);
    onPointerInTransitChange(true);
  }, [
    onPointerInTransitChange
  ]);
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [
    handleRemoveGraceArea
  ]);
  reactExports.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [
    trigger,
    content,
    handleCreateGraceArea,
    handleRemoveGraceArea
  ]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = {
          x: event.clientX,
          y: event.clientY
        };
        const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget)
          handleRemoveGraceArea();
        else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [
    trigger,
    content,
    pointerGraceArea,
    onClose,
    handleRemoveGraceArea
  ]);
  return /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends$2({}, props, {
    ref: composedRefs
  }));
});
const [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {
  isInside: false
});
const $a093c7e1ec25a057$var$TooltipContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, children, "aria-label": ariaLabel, onEscapeKeyDown, onPointerDownOutside, ...contentProps } = props;
  const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const { onClose } = context;
  reactExports.useEffect(() => {
    document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
    return () => document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
  }, [
    onClose
  ]);
  reactExports.useEffect(() => {
    if (context.trigger) {
      const handleScroll2 = (event) => {
        const target = event.target;
        if (target !== null && target !== void 0 && target.contains(context.trigger))
          onClose();
      };
      window.addEventListener("scroll", handleScroll2, {
        capture: true
      });
      return () => window.removeEventListener("scroll", handleScroll2, {
        capture: true
      });
    }
  }, [
    context.trigger,
    onClose
  ]);
  return /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents: false,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside: (event) => event.preventDefault(),
    onDismiss: onClose
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends$2({
    "data-state": context.stateAttribute
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /* @__PURE__ */ reactExports.createElement($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {
    scope: __scopeTooltip,
    isInside: true
  }, /* @__PURE__ */ reactExports.createElement($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {
    id: context.contentId,
    role: "tooltip"
  }, ariaLabel || children))));
});
const $a093c7e1ec25a057$var$ARROW_NAME = "TooltipArrow";
const $a093c7e1ec25a057$export$c27ee0ad710f7559 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTooltip, ...arrowProps } = props;
  const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
  const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip);
  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends$2({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $a093c7e1ec25a057$var$getExitSideFromRect(point3, rect) {
  const top2 = Math.abs(rect.top - point3.y);
  const bottom2 = Math.abs(rect.bottom - point3.y);
  const right2 = Math.abs(rect.right - point3.x);
  const left2 = Math.abs(rect.left - point3.x);
  switch (Math.min(top2, bottom2, right2, left2)) {
    case left2:
      return "left";
    case right2:
      return "right";
    case top2:
      return "top";
    case bottom2:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function $a093c7e1ec25a057$var$getPaddedExitPoints(exitPoint, exitSide, padding2 = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({
        x: exitPoint.x - padding2,
        y: exitPoint.y + padding2
      }, {
        x: exitPoint.x + padding2,
        y: exitPoint.y + padding2
      });
      break;
    case "bottom":
      paddedExitPoints.push({
        x: exitPoint.x - padding2,
        y: exitPoint.y - padding2
      }, {
        x: exitPoint.x + padding2,
        y: exitPoint.y - padding2
      });
      break;
    case "left":
      paddedExitPoints.push({
        x: exitPoint.x + padding2,
        y: exitPoint.y - padding2
      }, {
        x: exitPoint.x + padding2,
        y: exitPoint.y + padding2
      });
      break;
    case "right":
      paddedExitPoints.push({
        x: exitPoint.x - padding2,
        y: exitPoint.y - padding2
      }, {
        x: exitPoint.x - padding2,
        y: exitPoint.y + padding2
      });
      break;
  }
  return paddedExitPoints;
}
function $a093c7e1ec25a057$var$getPointsFromRect(rect) {
  const { top: top2, right: right2, bottom: bottom2, left: left2 } = rect;
  return [
    {
      x: left2,
      y: top2
    },
    {
      x: right2,
      y: top2
    },
    {
      x: right2,
      y: bottom2
    },
    {
      x: left2,
      y: bottom2
    }
  ];
}
function $a093c7e1ec25a057$var$isPointInPolygon(point3, polygon) {
  const { x: x2, y: y2 } = point3;
  let inside = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi2 = polygon[i2].x;
    const yi2 = polygon[i2].y;
    const xj2 = polygon[j].x;
    const yj2 = polygon[j].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $a093c7e1ec25a057$var$getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b2) => {
    if (a2.x < b2.x)
      return -1;
    else if (a2.x > b2.x)
      return 1;
    else if (a2.y < b2.y)
      return -1;
    else if (a2.y > b2.y)
      return 1;
    else
      return 0;
  });
  return $a093c7e1ec25a057$var$getHullPresorted(newPoints);
}
function $a093c7e1ec25a057$var$getHullPresorted(points) {
  if (points.length <= 1)
    return points.slice();
  const upperHull = [];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2];
    while (upperHull.length >= 2) {
      const q2 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x))
        upperHull.pop();
      else
        break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i1 = points.length - 1; i1 >= 0; i1--) {
    const p2 = points[i1];
    while (lowerHull.length >= 2) {
      const q2 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q2.x - r2.x) * (p2.y - r2.y) >= (q2.y - r2.y) * (p2.x - r2.x))
        lowerHull.pop();
      else
        break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y)
    return upperHull;
  else
    return upperHull.concat(lowerHull);
}
const $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;
const $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name2) {
  const PROVIDER_NAME = name2 + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ React.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  const COLLECTION_SLOT_NAME = name2 + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  const ITEM_SLOT_NAME = name2 + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  function useCollection(scope) {
    const context = useCollectionContext(name2 + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}
const $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ reactExports.createContext(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = reactExports.useContext($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}
const $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
const [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
const [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
const [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
const $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends$2({}, props, {
    ref: forwardedRef
  }))));
});
const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir: dir2, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction2 = $f631663db3294ace$export$b39126d51d94e6f3(dir2);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node2 = ref.current;
    if (node2) {
      node2.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node2.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction2,
    loop,
    currentTabStopId,
    onItemFocus: reactExports.useCallback(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: reactExports.useCallback(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: reactExports.useCallback(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: reactExports.useCallback(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
const $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
const $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
  const id2 = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id2;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  reactExports.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id: id2,
    focusable,
    active
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id2);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id2)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last")
          candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
const $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key2, dir2) {
  if (dir2 !== "rtl")
    return key2;
  return key2 === "ArrowLeft" ? "ArrowRight" : key2 === "ArrowRight" ? "ArrowLeft" : key2;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir2) {
  const key2 = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir2);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key2))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key2))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key2];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
const $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
const $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;
const $69cb30bb0017df05$var$TABS_NAME = "Tabs";
const [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($69cb30bb0017df05$var$TABS_NAME, [
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
const $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
const $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
const $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends$2({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled,
    active: isSelected
  }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
    type: "button",
    role: "tab",
    "aria-selected": isSelected,
    "aria-controls": contentId,
    "data-state": isSelected ? "active" : "inactive",
    "data-disabled": disabled ? "" : void 0,
    disabled,
    id: triggerId
  }, triggerProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false)
        context.onValueChange(value);
      else
        event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if ([
        " ",
        "Enter"
      ].includes(event.key))
        context.onValueChange(value);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      const isAutomaticActivation = context.activationMode !== "manual";
      if (!isSelected && !disabled && isAutomaticActivation)
        context.onValueChange(value);
    })
  })));
});
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
const $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
function __rest$1(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a4 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a4[0], setCallbacks = _a4[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container2 = _b3 === void 0 ? "div" : _b3, rest = __rest$1(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs$1([ref, parentRef]);
  var containerProps = __assign$2(__assign$2({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign$2(__assign$2({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container2, __assign$2({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  var styles2 = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles2[overflow] !== "hidden" && // contains scroll inside self
    !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a4 = getScrollVariables(axis, current), s2 = _a4[1], d2 = _a4[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a4) {
  var scrollTop = _a4.scrollTop, scrollHeight = _a4.scrollHeight, clientHeight = _a4.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a4) {
  var scrollLeft = _a4.scrollLeft, scrollWidth = _a4.scrollWidth, clientWidth = _a4.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction2) {
  return axis === "h" && direction2 === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a4 = getScrollVariables(axis, target), position2 = _a4[0], scroll_1 = _a4[1], capacity = _a4[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name2, delta, target, should) {
    var event = { name: name2, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign$2({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
const $epM9y$RemoveScroll = ReactRemoveScroll;
const $6cc32821e9371a1c$var$SELECTION_KEYS = [
  "Enter",
  " "
];
const $6cc32821e9371a1c$var$FIRST_KEYS = [
  "ArrowDown",
  "PageUp",
  "Home"
];
const $6cc32821e9371a1c$var$LAST_KEYS = [
  "ArrowUp",
  "PageDown",
  "End"
];
const $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
  ...$6cc32821e9371a1c$var$FIRST_KEYS,
  ...$6cc32821e9371a1c$var$LAST_KEYS
];
const $6cc32821e9371a1c$var$MENU_NAME = "Menu";
const [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
  $6cc32821e9371a1c$var$createCollectionScope,
  $cf1ac5d9fe0e8206$export$722aac194ae923,
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
const $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
const [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
  forceMount: void 0
});
const $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
const [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
const $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, rootContext.modal ? /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends$2({}, contentProps, {
    ref: forwardedRef
  })))));
});
const $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  reactExports.useEffect(() => {
    const content = ref.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends$2({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    ),
    onDismiss: () => context.onOpenChange(false)
  }));
});
const $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends$2({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  }));
});
const $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
  const [currentItemId, setCurrentItemId] = reactExports.useState(null);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
  const timerRef = reactExports.useRef(0);
  const searchRef = reactExports.useRef("");
  const pointerGraceTimerRef = reactExports.useRef(0);
  const pointerGraceIntentRef = reactExports.useRef(null);
  const pointerDirRef = reactExports.useRef("right");
  const lastPointerXRef = reactExports.useRef(0);
  const ScrollLockWrapper = disableOutsideScroll ? $epM9y$RemoveScroll : reactExports.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  } : void 0;
  const handleTypeaheadSearch = (key2) => {
    var _items$find, _items$find2;
    const search = searchRef.current + key2;
    const items = getItems().filter(
      (item) => !item.disabled
    );
    const currentItem = document.activeElement;
    const currentMatch = (_items$find = items.find(
      (item) => item.ref.current === currentItem
    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
    const values = items.map(
      (item) => item.textValue
    );
    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
    const newItem = (_items$find2 = items.find(
      (item) => item.textValue === nextMatch
    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "")
        timerRef.current = window.setTimeout(
          () => updateSearch(""),
          1e3
        );
    })(search);
    if (newItem)
      setTimeout(
        () => newItem.focus()
      );
  };
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
    var _pointerGraceIntentRe, _pointerGraceIntentRe2;
    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: reactExports.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    onItemLeave: reactExports.useCallback((event) => {
      var _contentRef$current;
      if (isPointerMovingToSubmenu(event))
        return;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
      setCurrentItemId(null);
    }, [
      isPointerMovingToSubmenu
    ]),
    onTriggerLeave: reactExports.useCallback((event) => {
      if (isPointerMovingToSubmenu(event))
        event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: reactExports.useCallback((intent) => {
      pointerGraceIntentRef.current = intent;
    }, [])
  }, /* @__PURE__ */ reactExports.createElement(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    trapped: trapFocus,
    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
      var _contentRef$current2;
      event.preventDefault();
      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
    }),
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends$2({
    asChild: true
  }, rovingFocusGroupScope, {
    dir: rootContext.dir,
    orientation: "vertical",
    loop,
    currentTabStopId: currentItemId,
    onCurrentTabStopIdChange: setCurrentItemId,
    onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
      if (!rootContext.isUsingKeyboardRef.current)
        event.preventDefault();
    })
  }), /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends$2({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
    "data-radix-menu-content": "",
    dir: rootContext.dir
  }, popperScope, contentProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...contentProps.style
    },
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
      const target = event.target;
      const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      if (isKeyDownInside) {
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && isCharacterKey)
          handleTypeaheadSearch(event.key);
      }
      const content = contentRef.current;
      if (event.target !== content)
        return;
      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))
        return;
      event.preventDefault();
      const items = getItems().filter(
        (item) => !item.disabled
      );
      const candidateNodes = items.map(
        (item) => item.ref.current
      );
      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
        candidateNodes.reverse();
      $6cc32821e9371a1c$var$focusFirst(candidateNodes);
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
      if (!event.currentTarget.contains(event.target)) {
        window.clearTimeout(timerRef.current);
        searchRef.current = "";
      }
    }),
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
      if (event.currentTarget.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
        pointerDirRef.current = newDir;
        lastPointerXRef.current = event.clientX;
      }
    }))
  })))))));
});
const $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
const $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
const $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = reactExports.useRef(null);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const isPointerDownRef = reactExports.useRef(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
        bubbles: true,
        cancelable: true
      });
      menuItem.addEventListener(
        $6cc32821e9371a1c$var$ITEM_SELECT,
        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
        {
          once: true
        }
      );
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented)
        isPointerDownRef.current = false;
      else
        rootContext.onClose();
    }
  };
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends$2({}, itemProps, {
    ref: composedRefs,
    disabled,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
    onPointerDown: (event) => {
      var _props$onPointerDown;
      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
      isPointerDownRef.current = true;
    },
    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
      var _event$currentTarget;
      if (!isPointerDownRef.current)
        (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ")
        return;
      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  }));
});
const $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const [isFocused, setIsFocused] = reactExports.useState(false);
  const [textContent, setTextContent] = reactExports.useState("");
  reactExports.useEffect(() => {
    const menuItem = ref.current;
    if (menuItem) {
      var _menuItem$textContent;
      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
    }
  }, [
    itemProps.children
  ]);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends$2({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled
  }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
    role: "menuitem",
    "data-highlighted": isFocused ? "" : void 0,
    "aria-disabled": disabled || void 0,
    "data-disabled": disabled ? "" : void 0
  }, itemProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      if (disabled)
        contentContext.onItemLeave(event);
      else {
        contentContext.onItemEnter(event);
        if (!event.defaultPrevented) {
          const item = event.currentTarget;
          item.focus();
        }
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
      (event) => contentContext.onItemLeave(event)
    )),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => setIsFocused(true)
    ),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsFocused(false)
    )
  }))));
});
const $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
  value: void 0,
  onValueChange: () => {
  }
});
const $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
  checked: false
});
const $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
function $6cc32821e9371a1c$var$getOpenState(open) {
  return open ? "open" : "closed";
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every(
    (char2) => char2 === search[0]
  );
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter(
      (v2) => v2 !== currentMatch
    );
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function $6cc32821e9371a1c$var$isPointInPolygon(point3, polygon) {
  const { x: x2, y: y2 } = point3;
  let inside = false;
  for (let i2 = 0, j = polygon.length - 1; i2 < polygon.length; j = i2++) {
    const xi2 = polygon[i2].x;
    const yi2 = polygon[i2].y;
    const xj2 = polygon[j].x;
    const yj2 = polygon[j].y;
    const intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
  if (!area)
    return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
const $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
const $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
const $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
const [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
const $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
const [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
const $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
const $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends$2({
    id: context.contentId,
    "aria-labelledby": context.triggerId
  }, menuScope, contentProps, {
    ref: forwardedRef,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      if (!hasInteractedOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick)
        hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
const $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends$2({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
const $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;
const SecondaryText = newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p2) => p2.theme.text.secondary};
  margin: 0;
`;
newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p2) => p2.theme.text.neutral};
  margin: 0;
`;
newStyled.span`
  font-size: ${fontSize.md};
  color: ${(p2) => p2.theme.text.danger};
  margin: 0;
`;
newStyled.p`
  font-size: ${fontSize.md};
  color: ${(props) => props.theme.text.secondary};
  margin: 0;
`;
resolveIpfsUri("ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png");
newStyled.div`
  width: 28%;
  height: 28%;
  border-radius: 50%;
  position: absolute;
  top: 60%;
  right: 0px;
  background-color: #00d395;
  box-shadow: 0 0 0 2px ${(p2) => p2.theme.bg.elevated};
`;
const slideUpAndFade$1 = keyframes$1`
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`;
newStyled($a093c7e1ec25a057$export$7c6e2c02157bb7d2)`
  background: ${(p2) => p2.theme.tooltip.bg};
  color: ${(p2) => p2.theme.tooltip.text};
  border-radius: ${radius.sm};
  line-height: 1;
  padding: ${spacing$1.sm} ${spacing$1.md};
  font-size: ${fontSize.sm};
  box-shadow: ${shadow.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${slideUpAndFade$1} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`;
newStyled($a093c7e1ec25a057$export$21b07c8f274aebd5)`
  fill: ${(p2) => p2.theme.tooltip.bg};
`;
newStyled(CheckIcon$2)`
  color: ${(p2) => p2.theme.icon.success};
`;
const scrollbar = (_ref) => {
  let {
    track,
    thumb,
    hover
  } = _ref;
  return `
&::-webkit-scrollbar {
  width: 6px;
}

&::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px ${track};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb {
  background: ${thumb};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb:hover {
  background: ${hover};
}`;
};
const overlayEnter = keyframes$1`
 from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const Overlay = newStyled.div`
  background-color: ${(p2) => p2.theme.overlay.subdued};
  z-index: 9999;
  position: fixed;
  inset: 0;
  animation: ${overlayEnter} 400ms cubic-bezier(0.16, 1, 0.3, 1);
`;
const Modal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, {
    open: props.open,
    onOpenChange: props.setOpen,
    children: [props.trigger && /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, {
      asChild: true,
      children: props.trigger
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs($5d3850c4d0b4e6c7$export$602eac185826482c, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, {
        asChild: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, {})
      }), /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, {
        asChild: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, {
          style: props.style,
          children: [props.title && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, {
            children: [" ", props.title]
          }), props.children, !props.hideCloseIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(CrossContainer, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, {
              asChild: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
                variant: "secondary",
                type: "button",
                "aria-label": "Close",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cross2Icon, {
                  style: {
                    width: iconSize.md,
                    height: iconSize.md,
                    color: "inherit"
                  }
                })
              })
            })
          })]
        })
      })]
    })]
  });
};
const CrossContainer = newStyled.div`
  position: absolute;
  top: ${spacing$1.lg};
  right: ${spacing$1.lg};

  ${media.mobile} {
    right: ${spacing$1.md};
  }
`;
const modalAnimationDesktop = keyframes$1`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`;
const modalAnimationMobile = keyframes$1`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`;
const DialogContent = newStyled.div`
  z-index: 10000;
  background-color: ${(p2) => p2.theme.bg.base};
  border-radius: ${radius.xl};
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100vw - 40px);
  box-sizing: border-box;
  overflow-y: auto;
  padding: ${spacing$1.lg};
  padding-bottom: ${spacing$1.xl};
  animation: ${modalAnimationDesktop} 200ms ease;
  box-shadow: ${shadow.lg};
  line-height: 1;

  &:focus {
    outline: none;
  }

  ${(p2) => scrollbar({
  track: "transparent",
  thumb: p2.theme.bg.elevated,
  hover: p2.theme.bg.highlighted
})}

  /* open from bottom on mobile */
  ${media.mobile} {
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100vw;
    transform: none;
    width: 100vw;
    animation: ${modalAnimationMobile} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1);
    border-radius: ${radius.xxl};
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    max-width: none !important;
  }

  & *::selection {
    background-color: ${(p2) => p2.theme.bg.inverted};
    color: ${(p2) => p2.theme.text.inverted};
  }
`;
const DialogTitle = newStyled($5d3850c4d0b4e6c7$export$f99233281efd08a0)`
  margin: 0;
  font-weight: 500;
  color: ${(p2) => p2.theme.text.neutral};
  font-size: ${fontSize.lg};
`;
newStyled($69cb30bb0017df05$export$41fb9f06171c75f4)`
  all: unset;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${(p2) => p2.theme.text.secondary};
  cursor: pointer;
  padding: ${spacing$1.sm} ${spacing$1.sm};
  -webkit-tap-highlight-color: transparent;
  border-radius: ${radius.lg};
  transition: background 0.2s ease, color 0.2s ease;
  &[data-state="active"] {
    background: ${(p2) => p2.theme.bg.elevated};
    color: ${(p2) => p2.theme.text.neutral};
  }
`;
newStyled.p`
  font-size: ${fontSize.sm};
  color: ${(p2) => p2.theme.text.secondary};
  margin: 0;
`;
newStyled.div`
  box-sizing: border-box;
  overflow: auto;
  padding-right: 10px;
  padding-bottom: ${spacing$1.lg};
  width: calc(100% + 16px);
  -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  ${(p2) => scrollbar({
  track: "transparent",
  thumb: p2.theme.bg.elevated,
  hover: p2.theme.bg.highlighted
})}
`;
newStyled.ul`
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing$1.xs};
  box-sizing: border-box;
`;
newStyled.button`
  all: unset;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  align-items: center;
  gap: ${spacing$1.md};
  padding: ${spacing$1.sm} ${spacing$1.md};
  border-radius: ${radius.md};
  cursor: pointer;
  transition: background 0.2s ease;
  background: ${(p2) => p2.theme.bg.elevated};
  color: ${(p2) => p2.theme.text.neutral};
  font-weight: 600;
  font-size: ${fontSize.md};
  &:hover {
    background: ${(p2) => p2.theme.bg.highlighted};
  }

  ${media.mobile} {
    font-size: ${fontSize.sm};
  }
`;
newStyled(MagnifyingGlassIcon)`
  color: ${(p2) => p2.theme.text.secondary};
  position: absolute;
  left: 18px;
`;
newStyled(Input)`
  padding: ${spacing$1.sm} ${spacing$1.md} ${spacing$1.sm} 60px;
`;
newStyled.div`
  font-size: ${fontSize.sm};
  color: ${(p2) => p2.theme.link.primary};
`;
newStyled.div`
  font-size: ${fontSize.sm};
  color: ${(p2) => p2.theme.text.danger};
`;
const dropdownContentFade = keyframes$1`
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
`;
newStyled($d08ef79370b62062$export$7c6e2c02157bb7d2)`
  width: 360px;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: ${radius.lg};
  padding: ${spacing$1.lg};
  animation: ${dropdownContentFade} 400ms cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  border: 1px solid ${(props) => props.theme.border.base};
  background-color: ${(props) => props.theme.bg.base};
  z-index: 1000000;
  line-height: 1;
`;
newStyled.button`
  all: unset;
  background: ${(props) => props.theme.bg.base};
  border: 1px solid ${(props) => props.theme.border.base};
  padding: ${spacing$1.sm} ${spacing$1.sm};
  border-radius: ${radius.lg};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: ${spacing$1.md};
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  animation: ${fadeInAnimation} 300ms ease;

  ${media.mobile} {
    gap: ${spacing$1.sm};
    padding: ${spacing$1.xs} ${spacing$1.sm};
    img {
      width: ${iconSize.md}px;
      height: ${iconSize.md}px;
    }
  }

  &:hover {
    transition: background 250ms ease;
    background: ${(props) => props.theme.bg.baseHover};
    border-color: ${(props) => props.theme.bg.highlighted};
  }
`;
newStyled.span`
  color: ${(props) => props.theme.text.secondary};
  font-size: ${fontSize.xs};
  font-weight: 500;
`;
newStyled.div`
  display: flex;
  flex-direction: column;
`;
newStyled.span`
  color: ${(props) => props.theme.text.neutral};
  font-size: ${fontSize.sm};
  font-weight: 500;
`;
newStyled.span`
  font-size: ${fontSize.md};
  color: ${(props) => props.theme.text.neutral};
  font-weight: 500;
`;
newStyled.span`
  font-size: ${fontSize.sm};
  color: ${(props) => props.theme.text.secondary};
  font-weight: 500;
`;
newStyled.label`
  font-size: ${fontSize.sm};
  color: ${(props) => props.theme.text.secondary};
  font-weight: 500;
`;
const MenuButton$1 = newStyled.button`
  all: unset;
  padding: ${spacing$1.sm} ${spacing$1.sm};
  border-radius: ${radius.md};
  background-color: ${(props) => props.theme.bg.base};
  border: 1px solid ${(props) => props.theme.border.elevated};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  width: 100%;
  cursor: pointer;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${(props) => props.theme.text.neutral} !important;
  gap: ${spacing$1.sm};
  -webkit-tap-highlight-color: transparent;
  line-height: 1.3;

  &:not([disabled]):hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${(props) => props.theme.link.primary};
    box-shadow: 0 0 0 1px ${(props) => props.theme.link.primary};
  }

  &[disabled] {
    cursor: not-allowed;
    svg {
      display: none;
    }
  }

  &[disabled]:hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${(props) => props.theme.text.danger};
    box-shadow: 0 0 0 1px ${(props) => props.theme.text.danger};
  }
`;
MenuButton$1.withComponent("a");
newStyled($d08ef79370b62062$export$6d08773d2e66f8f2)`
  outline: none;
`;
newStyled(ChevronRightIcon)`
  color: ${(props) => props.theme.text.secondary};
`;
newStyled(IconButton$1)`
  margin-right: -${spacing$1.xxs};
  margin-left: auto;
  color: ${(props) => props.theme.icon.secondary};
  &:hover {
    color: ${(props) => props.theme.icon.danger};
    background: none;
  }
`;
newStyled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${(props) => props.theme.icon.secondary};
`;
newStyled.div`
  display: flex;
  align-items: center;
  gap: ${spacing$1.sm};

  ${media.mobile} {
    justify-content: center;
    flex-direction: column;
    gap: ${spacing$1.md};
  }
`;
newStyled(ModalDescription)`
  ${media.mobile} {
    max-width: 240px;
    margin: 0 auto;
  }
`;
newStyled.div`
  ${media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;
newStyled(Button$1)`
  animation: ${fadeInAnimation} 300ms ease;
`;
let video;
function supportsVideoType(mimeType) {
  if (!mimeType || !mimeType.startsWith("video/")) {
    return "";
  }
  if (!video) {
    video = document.createElement("video");
  }
  return video.canPlayType(mimeType);
}
function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
let audio;
function supportsAudioType(mimeType) {
  if (!mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }
  if (!audio) {
    audio = document.createElement("audio");
  }
  return audio.canPlayType(mimeType);
}
function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}
function mergeRefs$1(refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
const CarbonDocumentUnknown = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
const CarbonDocumentAudio = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
const CarbonPauseFilled = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
const CarbonPlayFilledAlt = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};
const ModelViewer = /* @__PURE__ */ reactExports.lazy(() => __vitePreload(() => import("./ModelViewer-68c3eb38.browser.esm-493d1b56.js"), true ? ["creator/assets/ModelViewer-68c3eb38.browser.esm-493d1b56.js","creator/assets/lit-element-6ea6fe70.js"] : void 0));
const PlayButton = (_ref) => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const onMouseEnter = () => setIsHovering(true);
  const onMouseLeave = () => setIsHovering(false);
  const onMouseDown = () => setIsHovering(false);
  const onMouseUp = () => setIsHovering(true);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {}
    },
    onClick,
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onMouseUp,
    children: !isPlaying ? /* @__PURE__ */ jsxRuntimeExports.jsx(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};
const VideoPlayer = /* @__PURE__ */ React.forwardRef((_ref2, ref) => {
  let {
    src: src2,
    alt,
    poster,
    requireInteraction,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = reactExports.useRef(null);
  const [playing, setPlaying] = reactExports.useState(!requireInteraction);
  const [muted, setMuted] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("video", {
      ref: mergeRefs$1([videoRef, ref]),
      src: src2 ?? void 0,
      poster: poster ?? void 0,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        if (playing) {
          videoRef.current?.play();
        }
      },
      width,
      height,
      controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(PlayButton, {
      onClick: () => {
        setPlaying((prev2) => !prev2);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
const AudioPlayer = /* @__PURE__ */ React.forwardRef((_ref3, ref) => {
  let {
    src: src2,
    alt,
    poster,
    style,
    height,
    width,
    ...restProps
  } = _ref3;
  const audioRef = reactExports.useRef(null);
  const [playing, setPlaying] = reactExports.useState(false);
  const [muted, setMuted] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      height,
      width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(PlayButton, {
      onClick: () => {
        setPlaying((prev2) => !prev2);
        setMuted(false);
      },
      isPlaying: playing
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("audio", {
      ref: mergeRefs$1([audioRef, ref]),
      src: src2 ?? void 0,
      loop: true,
      playsInline: true,
      muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
const IframePlayer = /* @__PURE__ */ React.forwardRef((_ref4, ref) => {
  let {
    src: src2,
    alt,
    poster,
    requireInteraction,
    style,
    ...restProps
  } = _ref4;
  const [playing, setPlaying] = reactExports.useState(!requireInteraction);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("iframe", {
      src: playing ? src2 ?? void 0 : void 0,
      ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(PlayButton, {
      onClick: () => {
        setPlaying((prev2) => !prev2);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
const LinkPlayer = /* @__PURE__ */ React.forwardRef((_ref5, ref) => {
  let {
    src: src2,
    alt,
    style,
    ...restProps
  } = _ref5;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src2 ?? void 0,
          target: "_blank",
          ref,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";
const MediaRenderer = /* @__PURE__ */ React.forwardRef((_ref6, ref) => {
  let {
    src: src2,
    poster,
    alt,
    gatewayUrl,
    requireInteraction = false,
    width = "300px",
    height = "300px",
    style,
    mimeType,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    width,
    height,
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src2 ?? void 0, mimeType, gatewayUrl);
  const possiblePosterSrc = useResolvedMediaType(poster ?? void 0, void 0, gatewayUrl);
  if (!videoOrImageSrc.mimeType) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      style: mergedStyle,
      ...restProps,
      ref,
      alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("model")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, {
      fallback: poster ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
        style: mergedStyle,
        src: poster,
        alt,
        ref,
        ...restProps
      }) : null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModelViewer, {
        style: mergedStyle,
        src: videoOrImageSrc.url || "",
        poster,
        alt,
        ...restProps
      })
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt,
      ref,
      ...restProps
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt,
    ref,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";
function useResolvedMediaType(uri, mimeType, gatewayUrl) {
  const storage = useStorage();
  const resolvedUrl = reactExports.useMemo(() => resolveIpfsUri(uri, gatewayUrl ? {
    gatewayUrl
  } : storage ? {
    gatewayUrl: storage.gatewayUrls["ipfs://"][0]
  } : void 0), [uri, storage, gatewayUrl]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl && !mimeType,
    initialData: mimeType
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}
const ThirdwebNftMedia = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
  let {
    metadata,
    width = "300px",
    height = "300px",
    style,
    ...props
  } = _ref;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: metadata.name?.toString() || "",
    ref,
    width,
    height,
    style: {
      ...style
    },
    ...props
  });
});
ThirdwebNftMedia.displayName = "ThirdwebNftMedia";
const slideUpAndFade = keyframes$1`
from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
newStyled($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2)`
  border-radius: ${radius.sm};
  padding: ${spacing$1.sm} ${spacing$1.md};
  background-color: ${(p2) => p2.theme.bg.inverted};
  box-shadow: ${shadow.md};
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  animation-name: ${slideUpAndFade};
  color: ${(p2) => p2.theme.text.inverted};
  font-size: ${fontSize.md};
`;
newStyled($cb5cc270b50c6fcd$export$21b07c8f274aebd5)`
  fill: ${(p2) => p2.theme.bg.inverted};
`;
newStyled.div`
  display: flex;
  align-items: center;
  gap: ${spacing$1.sm};
`;
const DEFAULT_API_KEY = "f9e23156ccfc6173c5267eaabf320fb692ffab1c2d572095a58091cbb67590cd";
const GetStartedWithWallets = (_ref) => {
  let {
    onBack
  } = _ref;
  const walletConfigs = useWallets();
  const {
    meta
  } = walletConfigs[0];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GetStartedScreen, {
    onBack: () => {
      onBack();
    },
    walletIconURL: meta.iconURL,
    walletName: meta.name,
    appleStoreLink: meta.urls?.ios,
    googlePlayStoreLink: meta.urls?.android,
    chromeExtensionLink: meta.urls?.chrome,
    header: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ModalTitle, {
        children: " Get started with EVM wallets "
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "md"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ModalDescription, {
        children: "An EVM Wallet is your gateway to interact with web3 apps on Ethereum and other custom blockchains."
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        style: {
          display: "flex",
          gap: spacing$1.md,
          alignItems: "center"
        },
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SecondaryText, {
          children: "We recommend"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          style: {
            display: "flex",
            gap: spacing$1.xs,
            alignItems: "center"
          },
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Img, {
            src: meta.iconURL,
            width: iconSize.md,
            height: iconSize.md
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(NeutralText, {
            children: meta.name
          })]
        })]
      })]
    }),
    footer: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
        y: "xl"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(HelperLink, {
        target: "_blank",
        href: "https://ethereum.org/en/wallets/find-wallet/",
        style: {
          textAlign: "center"
        },
        children: "Learn more about wallets"
      }), " "]
    })
  });
};
const NeutralText = newStyled.p`
  font-size: ${fontSize.md};
  color: ${(p2) => p2.theme.text.neutral};
  margin: 0;
`;
const reservedScreens = {
  main: "main",
  getStarted: "getStarted"
};
const ConnectModal = () => {
  const {
    theme: theme2,
    title
  } = reactExports.useContext(ModalConfigCtx);
  const walletConfigs = useWallets();
  const initialScreen = walletConfigs.length === 1 && !walletConfigs[0].selectUI ? walletConfigs[0] : reservedScreens.main;
  const [screen, setScreen] = reactExports.useState(initialScreen);
  const isWalletModalOpen = useIsWalletModalOpen();
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const connectionStatus = useConnectionStatus();
  const wallet = useWallet();
  const walletModalConfig = reactExports.useContext(ModalConfigCtx);
  const setWalletModalConfig = reactExports.useContext(SetModalConfigCtx);
  const disconnect = useDisconnect();
  const handleClose = reactExports.useCallback(function() {
    let reset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (reset) {
      setScreen(initialScreen);
    }
    if (connectionStatus === "connecting") {
      disconnect();
    }
    setIsWalletModalOpen(false);
  }, [setIsWalletModalOpen, initialScreen, connectionStatus, disconnect]);
  const handleBack = reactExports.useCallback(() => {
    setScreen(initialScreen);
  }, [setScreen, initialScreen]);
  const isWrapperConnected = !!wallet?.getPersonalWallet();
  const isWrapperScreen = typeof screen !== "string" && !!screen.personalWallets;
  const prevConnectionStatus = reactExports.useRef(connectionStatus);
  reactExports.useEffect(() => {
    if (!isWrapperConnected && isWrapperScreen && !isWalletModalOpen && connectionStatus === "connected" && prevConnectionStatus.current === "connecting") {
      setIsWalletModalOpen(true);
    }
    prevConnectionStatus.current = connectionStatus;
  }, [isWalletModalOpen, connectionStatus, setIsWalletModalOpen, isWrapperScreen, isWrapperConnected]);
  const WalletConnectUI = typeof screen !== "string" && (screen.connectUI || HeadlessConnectUI);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
    theme: typeof theme2 === "object" ? theme2 : theme2 === "light" ? lightTheme : darkTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, {
      style: {
        maxWidth: "480px"
      },
      open: isWalletModalOpen,
      setOpen: (value) => {
        setIsWalletModalOpen(value);
        if (!value) {
          setScreen(initialScreen);
        }
        if (connectionStatus === "connecting") {
          disconnect();
        }
      },
      children: [screen === reservedScreens.main && /* @__PURE__ */ jsxRuntimeExports.jsx(WalletSelector, {
        title,
        walletConfigs,
        onGetStarted: () => {
          setScreen(reservedScreens.getStarted);
        },
        selectWallet: setScreen
      }), screen === reservedScreens.getStarted && /* @__PURE__ */ jsxRuntimeExports.jsx(GetStartedWithWallets, {
        onBack: handleBack
      }), WalletConnectUI && /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectUI, {
        supportedWallets: walletConfigs,
        theme: theme2,
        goBack: handleBack,
        close: handleClose,
        isOpen: isWalletModalOpen,
        open: () => {
          setIsWalletModalOpen(true);
        },
        walletConfig: screen,
        selectionData: walletModalConfig.data,
        setSelectionData: (data) => {
          setWalletModalConfig((config2) => ({
            ...config2,
            data
          }));
        }
      })]
    })
  });
};
const ThirdwebProvider = (_ref) => {
  let {
    thirdwebApiKey = DEFAULT_API_KEY,
    supportedWallets,
    theme: theme2,
    children,
    ...restProps
  } = _ref;
  const wallets = supportedWallets || defaultWallets;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WalletUIStatesProvider, {
    theme: theme2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
      theme: theme2 === "dark" ? darkTheme : lightTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ThirdwebProviderCore, {
        theme: theme2,
        thirdwebApiKey,
        supportedWallets: wallets,
        ...restProps,
        children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectModal, {})]
      })
    })
  });
};
function useMetamask() {
  const connect = useConnect();
  return reactExports.useCallback(async (connectOptions) => {
    const {
      metamaskWallet: metamaskWallet2
    } = await __vitePreload(() => Promise.resolve().then(() => headlessConnectUID7ab9645_browser_esm), true ? void 0 : void 0).then(function(n2) {
      return n2.p;
    });
    return connect(metamaskWallet2(), connectOptions);
  }, [connect]);
}
function useCoinbaseWallet() {
  const connect = useConnect();
  return reactExports.useCallback(async (connectOptions) => {
    const {
      coinbaseWallet: coinbaseWallet2
    } = await __vitePreload(() => Promise.resolve().then(() => headlessConnectUID7ab9645_browser_esm), true ? void 0 : void 0).then(function(n2) {
      return n2.o;
    });
    return connect(coinbaseWallet2(), connectOptions);
  }, [connect]);
}
function useWalletConnect() {
  const connect = useConnect();
  return reactExports.useCallback(async (options2) => {
    const {
      walletConnect
    } = await __vitePreload(() => import("./walletConnect-999b71fe.browser.esm-72c3f4b3.js"), true ? [] : void 0);
    return connect(walletConnect(options2), options2);
  }, [connect]);
}
newStyled.div`
  display: flex;
  align-items: center;
  width: 130px;
  padding: ${spacing$1.xs};
`;
newStyled.div`
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background-color: ${(p2) => p2.theme.bg.highlighted};
  box-shadow: 0 0 0 3px ${(p2) => p2.theme.bg.base},
    0 0 0 5px ${(p2) => p2.theme.bg.highlighted};

  &[data-active="true"] {
    background-color: ${(p2) => p2.theme.link.primary};
    box-shadow: 0 0 0 3px ${(p2) => p2.theme.bg.base},
      0 0 0 5px ${(p2) => p2.theme.link.primary};

    position: relative;
    z-index: 2;
  }
`;
newStyled.div`
  flex-grow: 1;
  height: 4px;
  background-color: ${(p2) => p2.theme.bg.highlighted};
  &[data-active="true"] {
    background-color: ${(p2) => p2.theme.link.primary};
  }
`;
newStyled.div`
  margin-top: ${spacing$1.lg};
`;
newStyled.p`
  font-size: ${fontSize.sm};
  color: ${(p2) => p2.theme.link.primary};
  text-align: right;
`;
newStyled.select`
  width: 100%;
  padding: ${spacing$1.sm};
  box-sizing: border-box;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${(p2) => p2.theme.text.neutral};
  background: transparent;
  font-size: ${fontSize.md};
  box-shadow: 0 0 0 1.5px ${(p2) => p2.theme.input.outline};
  appearance: none;

  &:focus {
    box-shadow: 0 0 0 2px ${(p2) => p2.theme.input.focusRing};
  }

  &:invalid {
    color: ${(p2) => p2.theme.text.secondary};
  }
  &[data-error="true"] {
    box-shadow: 0 0 0 1.5px ${(p2) => p2.theme.input.errorRing};
  }

  &[disabled] {
    opacity: 1;
    cursor: not-allowed;
  }
`;
newStyled(ChevronDownIcon)`
  color: ${(p2) => p2.theme.icon.secondary};
`;
newStyled(UploadIcon)`
  color: ${(props) => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
newStyled.div`
  border: 2px solid ${(p2) => p2.theme.bg.elevated};
  border-radius: ${radius.md};
  padding: ${spacing$1.xl} ${spacing$1.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${(p2) => p2.theme.link.primary};
    svg {
      color: ${(p2) => p2.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${(p2) => p2.theme.input.errorRing};
  }
`;
newStyled.p`
  color: ${(p2) => p2.theme.input.errorRing};
  font-size: ${fontSize.sm};
  margin: 0;
`;
newStyled.span`
  color: ${(p2) => p2.theme.text.secondary};
  font-size: ${fontSize.sm};
`;
newStyled.p`
  color: ${(p2) => p2.theme.text.neutral};
  font-size: ${fontSize.md};
  margin: 0;
  font-weight: 600;
`;
newStyled.p`
  font-size: ${fontSize.sm};
  margin: 0;
  color: ${(p2) => p2.theme.link.primary};
`;
newStyled.div`
  margin-top: ${spacing$1.lg};
`;
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var parse_1 = parse;
var serialize_1 = serialize;
var decode = decodeURIComponent;
var encode$2 = encodeURIComponent;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var pairs = str.split(";");
  var dec = opt.decode || decode;
  for (var i2 = 0; i2 < pairs.length; i2++) {
    var pair = pairs[i2];
    var index2 = pair.indexOf("=");
    if (index2 < 0) {
      continue;
    }
    var key2 = pair.substring(0, index2).trim();
    if (void 0 == obj[key2]) {
      var val = pair.substring(index2 + 1, pair.length).trim();
      if (val[0] === '"') {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
  }
  return obj;
}
function serialize(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode$2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e2) {
    return str;
  }
}
function hasDocumentCookie() {
  return typeof document === "object" && typeof document.cookie === "string";
}
function parseCookies(cookies2, options2) {
  if (typeof cookies2 === "string") {
    return parse_1(cookies2, options2);
  } else if (typeof cookies2 === "object" && cookies2 !== null) {
    return cookies2;
  } else {
    return {};
  }
}
function isParsingCookie(value, doNotParse) {
  if (typeof doNotParse === "undefined") {
    doNotParse = !value || value[0] !== "{" && value[0] !== "[" && value[0] !== '"';
  }
  return !doNotParse;
}
function readCookie(value, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var cleanValue = cleanupCookieValue(value);
  if (isParsingCookie(cleanValue, options2.doNotParse)) {
    try {
      return JSON.parse(cleanValue);
    } catch (e2) {
    }
  }
  return value;
}
function cleanupCookieValue(value) {
  if (value && value[0] === "j" && value[1] === ":") {
    return value.substr(2);
  }
  return value;
}
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var Cookies = (
  /** @class */
  function() {
    function Cookies2(cookies2, options2) {
      var _this = this;
      this.changeListeners = [];
      this.HAS_DOCUMENT_COOKIE = false;
      this.cookies = parseCookies(cookies2, options2);
      new Promise(function() {
        _this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();
      }).catch(function() {
      });
    }
    Cookies2.prototype._updateBrowserValues = function(parseOptions) {
      if (!this.HAS_DOCUMENT_COOKIE) {
        return;
      }
      this.cookies = parse_1(document.cookie, parseOptions);
    };
    Cookies2.prototype._emitChange = function(params) {
      for (var i2 = 0; i2 < this.changeListeners.length; ++i2) {
        this.changeListeners[i2](params);
      }
    };
    Cookies2.prototype.get = function(name2, options2, parseOptions) {
      if (options2 === void 0) {
        options2 = {};
      }
      this._updateBrowserValues(parseOptions);
      return readCookie(this.cookies[name2], options2);
    };
    Cookies2.prototype.getAll = function(options2, parseOptions) {
      if (options2 === void 0) {
        options2 = {};
      }
      this._updateBrowserValues(parseOptions);
      var result = {};
      for (var name_1 in this.cookies) {
        result[name_1] = readCookie(this.cookies[name_1], options2);
      }
      return result;
    };
    Cookies2.prototype.set = function(name2, value, options2) {
      var _a4;
      if (typeof value === "object") {
        value = JSON.stringify(value);
      }
      this.cookies = __assign$1(__assign$1({}, this.cookies), (_a4 = {}, _a4[name2] = value, _a4));
      if (this.HAS_DOCUMENT_COOKIE) {
        document.cookie = serialize_1(name2, value, options2);
      }
      this._emitChange({ name: name2, value, options: options2 });
    };
    Cookies2.prototype.remove = function(name2, options2) {
      var finalOptions = options2 = __assign$1(__assign$1({}, options2), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 });
      this.cookies = __assign$1({}, this.cookies);
      delete this.cookies[name2];
      if (this.HAS_DOCUMENT_COOKIE) {
        document.cookie = serialize_1(name2, "", finalOptions);
      }
      this._emitChange({ name: name2, value: void 0, options: options2 });
    };
    Cookies2.prototype.addChangeListener = function(callback) {
      this.changeListeners.push(callback);
    };
    Cookies2.prototype.removeChangeListener = function(callback) {
      var idx = this.changeListeners.indexOf(callback);
      if (idx >= 0) {
        this.changeListeners.splice(idx, 1);
      }
    };
    return Cookies2;
  }()
);
const Cookies$1 = Cookies;
var CookiesContext = reactExports.createContext(new Cookies$1());
var Provider = CookiesContext.Provider;
CookiesContext.Consumer;
const CookiesContext$1 = CookiesContext;
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var CookiesProvider = (
  /** @class */
  function(_super) {
    __extends(CookiesProvider2, _super);
    function CookiesProvider2(props) {
      var _this = _super.call(this, props) || this;
      if (props.cookies) {
        _this.cookies = props.cookies;
      } else {
        _this.cookies = new Cookies$1();
      }
      return _this;
    }
    CookiesProvider2.prototype.render = function() {
      return reactExports.createElement(Provider, { value: this.cookies }, this.props.children);
    };
    return CookiesProvider2;
  }(reactExports.Component)
);
const CookiesProvider$1 = CookiesProvider;
function isInBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
}
function useCookies(dependencies) {
  var cookies2 = reactExports.useContext(CookiesContext$1);
  if (!cookies2) {
    throw new Error("Missing <CookiesProvider>");
  }
  var initialCookies = cookies2.getAll();
  var _a4 = reactExports.useState(initialCookies), allCookies = _a4[0], setCookies = _a4[1];
  var previousCookiesRef = reactExports.useRef(allCookies);
  if (isInBrowser()) {
    reactExports.useLayoutEffect(function() {
      function onChange() {
        var newCookies = cookies2.getAll();
        if (shouldUpdate(dependencies || null, newCookies, previousCookiesRef.current)) {
          setCookies(newCookies);
        }
        previousCookiesRef.current = newCookies;
      }
      cookies2.addChangeListener(onChange);
      return function() {
        cookies2.removeChangeListener(onChange);
      };
    }, [cookies2]);
  }
  var setCookie = reactExports.useMemo(function() {
    return cookies2.set.bind(cookies2);
  }, [cookies2]);
  var removeCookie = reactExports.useMemo(function() {
    return cookies2.remove.bind(cookies2);
  }, [cookies2]);
  return [allCookies, setCookie, removeCookie];
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
  if (!dependencies) {
    return true;
  }
  for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
    var dependency = dependencies_1[_i];
    if (newCookies[dependency] !== oldCookies[dependency]) {
      return true;
    }
  }
  return false;
}
var css$1 = String.raw;
var vhPolyfill = css$1`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
var CSSPolyfill = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: vhPolyfill });
var CSSReset = ({ scope = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Global,
  {
    styles: css$1`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
  }
);
function getErrorMessage(hook, provider2) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider2}`;
}
function createContext$1(options2 = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options2;
  const Context = reactExports.createContext(defaultValue);
  Context.displayName = name2;
  function useContext() {
    var _a4;
    const context = reactExports.useContext(Context);
    if (!context && strict) {
      const error = new Error(
        errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName)
      );
      error.name = "ContextError";
      (_a4 = Error.captureStackTrace) == null ? void 0 : _a4.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext, Context];
}
var [PortalManagerContextProvider, usePortalManager] = createContext$1({
  strict: false,
  name: "PortalManagerContext"
});
function PortalManager(props) {
  const { children, zIndex } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalManagerContextProvider, { value: { zIndex }, children });
}
PortalManager.displayName = "PortalManager";
var useSafeLayoutEffect$2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : reactExports.useEffect;
var [PortalContextProvider, usePortalContext] = createContext$1({
  strict: false,
  name: "PortalContext"
});
var PORTAL_CLASSNAME = "chakra-portal";
var PORTAL_SELECTOR = `.chakra-portal`;
var Container = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: props.zIndex,
      top: 0,
      left: 0,
      right: 0
    },
    children: props.children
  }
);
var DefaultPortal = (props) => {
  const { appendToParentPortal, children } = props;
  const [tempNode, setTempNode] = reactExports.useState(null);
  const portal = reactExports.useRef(null);
  const [, forceUpdate] = reactExports.useState({});
  reactExports.useEffect(() => forceUpdate({}), []);
  const parentPortal = usePortalContext();
  const manager = usePortalManager();
  useSafeLayoutEffect$2(() => {
    if (!tempNode)
      return;
    const doc = tempNode.ownerDocument;
    const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
    if (!host)
      return;
    portal.current = doc.createElement("div");
    portal.current.className = PORTAL_CLASSNAME;
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, [tempNode]);
  const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
  return portal.current ? reactDomExports.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(PortalContextProvider, { value: portal.current, children: _children }),
    portal.current
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      ref: (el2) => {
        if (el2)
          setTempNode(el2);
      }
    }
  );
};
var ContainerPortal = (props) => {
  const { children, containerRef, appendToParentPortal } = props;
  const containerEl = containerRef.current;
  const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
  const portal = reactExports.useMemo(() => {
    const node2 = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
    if (node2)
      node2.className = PORTAL_CLASSNAME;
    return node2;
  }, [containerEl]);
  const [, forceUpdate] = reactExports.useState({});
  useSafeLayoutEffect$2(() => forceUpdate({}), []);
  useSafeLayoutEffect$2(() => {
    if (!portal || !host)
      return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  if (host && portal) {
    return reactDomExports.createPortal(
      /* @__PURE__ */ jsxRuntimeExports.jsx(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
      portal
    );
  }
  return null;
};
function Portal(props) {
  const portalProps = {
    appendToParentPortal: true,
    ...props
  };
  const { containerRef, ...rest } = portalProps;
  return containerRef ? /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerPortal, { containerRef, ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultPortal, { ...rest });
}
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";
function useTheme() {
  const theme2 = reactExports.useContext(
    ThemeContext
  );
  if (!theme2) {
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  }
  return theme2;
}
var ColorModeContext = reactExports.createContext({});
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
  const context = reactExports.useContext(ColorModeContext);
  if (context === void 0) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }
  return context;
}
var classNames = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function getColorModeUtils(options2 = {}) {
  const { preventTransition = true } = options2;
  const utils2 = {
    setDataset: (value) => {
      const cleanup = preventTransition ? utils2.preventTransition() : void 0;
      document.documentElement.dataset.theme = value;
      document.documentElement.style.colorScheme = value;
      cleanup == null ? void 0 : cleanup();
    },
    setClassName(dark) {
      document.body.classList.add(dark ? classNames.dark : classNames.light);
      document.body.classList.remove(dark ? classNames.light : classNames.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(fallback) {
      var _a4;
      const dark = (_a4 = utils2.query().matches) != null ? _a4 : fallback === "dark";
      return dark ? "dark" : "light";
    },
    addListener(fn2) {
      const mql = utils2.query();
      const listener = (e2) => {
        fn2(e2.matches ? "dark" : "light");
      };
      if (typeof mql.addListener === "function")
        mql.addListener(listener);
      else
        mql.addEventListener("change", listener);
      return () => {
        if (typeof mql.removeListener === "function")
          mql.removeListener(listener);
        else
          mql.removeEventListener("change", listener);
      };
    },
    preventTransition() {
      const css2 = document.createElement("style");
      css2.appendChild(
        document.createTextNode(
          `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
        )
      );
      document.head.appendChild(css2);
      return () => {
        (() => window.getComputedStyle(document.body))();
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(css2);
          });
        });
      };
    }
  };
  return utils2;
}
var STORAGE_KEY = "chakra-ui-color-mode";
function createLocalStorageManager(key2) {
  return {
    ssr: false,
    type: "localStorage",
    get(init3) {
      if (!(globalThis == null ? void 0 : globalThis.document))
        return init3;
      let value;
      try {
        value = localStorage.getItem(key2) || init3;
      } catch (e2) {
      }
      return value || init3;
    },
    set(value) {
      try {
        localStorage.setItem(key2, value);
      } catch (e2) {
      }
    }
  };
}
var localStorageManager = createLocalStorageManager(STORAGE_KEY);
var noop$2 = () => {
};
function getTheme(manager, fallback) {
  return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
}
function ColorModeProvider(props) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode,
      disableTransitionOnChange
    } = {},
    colorModeManager = localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  const [colorMode, rawSetColorMode] = reactExports.useState(
    () => getTheme(colorModeManager, defaultColorMode)
  );
  const [resolvedColorMode, setResolvedColorMode] = reactExports.useState(
    () => getTheme(colorModeManager)
  );
  const { getSystemTheme, setClassName, setDataset, addListener } = reactExports.useMemo(
    () => getColorModeUtils({ preventTransition: disableTransitionOnChange }),
    [disableTransitionOnChange]
  );
  const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
  const setColorMode = reactExports.useCallback(
    (value2) => {
      const resolved = value2 === "system" ? getSystemTheme() : value2;
      rawSetColorMode(resolved);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager.set(resolved);
    },
    [colorModeManager, getSystemTheme, setClassName, setDataset]
  );
  useSafeLayoutEffect$2(() => {
    if (initialColorMode === "system") {
      setResolvedColorMode(getSystemTheme());
    }
  }, []);
  reactExports.useEffect(() => {
    const managerValue = colorModeManager.get();
    if (managerValue) {
      setColorMode(managerValue);
      return;
    }
    if (initialColorMode === "system") {
      setColorMode("system");
      return;
    }
    setColorMode(defaultColorMode);
  }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
  const toggleColorMode = reactExports.useCallback(() => {
    setColorMode(resolvedValue === "dark" ? "light" : "dark");
  }, [resolvedValue, setColorMode]);
  reactExports.useEffect(() => {
    if (!useSystemColorMode)
      return;
    return addListener(setColorMode);
  }, [useSystemColorMode, addListener, setColorMode]);
  const context = reactExports.useMemo(
    () => ({
      colorMode: value != null ? value : resolvedValue,
      toggleColorMode: value ? noop$2 : toggleColorMode,
      setColorMode: value ? noop$2 : setColorMode,
      forced: value !== void 0
    }),
    [resolvedValue, toggleColorMode, setColorMode, value]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorModeContext.Provider, { value: context, children });
}
ColorModeProvider.displayName = "ColorModeProvider";
function useChakra() {
  const colorModeResult = useColorMode();
  const theme2 = useTheme();
  return { ...colorModeResult, theme: theme2 };
}
function getBreakpointValue(theme2, value, fallback) {
  var _a4, _b3;
  if (value == null)
    return value;
  const getValue = (val) => {
    var _a22, _b22;
    return (_b22 = (_a22 = theme2.__breakpoints) == null ? void 0 : _a22.asArray) == null ? void 0 : _b22[val];
  };
  return (_b3 = (_a4 = getValue(value)) != null ? _a4 : getValue(fallback)) != null ? _b3 : fallback;
}
function getTokenValue(theme2, value, fallback) {
  var _a4, _b3;
  if (value == null)
    return value;
  const getValue = (val) => {
    var _a22, _b22;
    return (_b22 = (_a22 = theme2.__cssMap) == null ? void 0 : _a22[val]) == null ? void 0 : _b22.value;
  };
  return (_b3 = (_a4 = getValue(value)) != null ? _a4 : getValue(fallback)) != null ? _b3 : fallback;
}
function getToken(scale2, token2, fallback) {
  const _token = Array.isArray(token2) ? token2 : [token2];
  const _fallback = Array.isArray(fallback) ? fallback : [fallback];
  return (theme2) => {
    const fallbackArr = _fallback.filter(Boolean);
    const result = _token.map((token22, index2) => {
      var _a4, _b3;
      if (scale2 === "breakpoints") {
        return getBreakpointValue(theme2, token22, (_a4 = fallbackArr[index2]) != null ? _a4 : token22);
      }
      const path = `${scale2}.${token22}`;
      return getTokenValue(theme2, path, (_b3 = fallbackArr[index2]) != null ? _b3 : token22);
    });
    return Array.isArray(token2) ? result : result[0];
  };
}
var cx = (...classNames2) => classNames2.filter(Boolean).join(" ");
function isDev() {
  return false;
}
function isObject$1(value) {
  const type = typeof value;
  return value != null && (type === "object" || type === "function") && !Array.isArray(value);
}
var warn = (options2) => {
  const { condition, message } = options2;
  if (condition && isDev()) {
    console.warn(message);
  }
};
function runIfFn$2(valueOrFn, ...args) {
  return isFunction$4(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var isFunction$4 = (value) => typeof value === "function";
var dataAttr = (condition) => condition ? "" : void 0;
var ariaAttr = (condition) => condition ? true : void 0;
function callAllHandlers$1(...fns) {
  return function func(event) {
    fns.some((fn2) => {
      fn2 == null ? void 0 : fn2(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function callAll(...fns) {
  return function mergedFn(arg) {
    fns.forEach((fn2) => {
      fn2 == null ? void 0 : fn2(arg);
    });
  };
}
var lodash_mergewith = { exports: {} };
lodash_mergewith.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags2 = {};
  typedArrayTags2[float32Tag] = typedArrayTags2[float64Tag] = typedArrayTags2[int8Tag] = typedArrayTags2[int16Tag] = typedArrayTags2[int32Tag] = typedArrayTags2[uint8Tag] = typedArrayTags2[uint8ClampedTag] = typedArrayTags2[uint16Tag] = typedArrayTags2[uint32Tag] = true;
  typedArrayTags2[argsTag] = typedArrayTags2[arrayTag] = typedArrayTags2[arrayBufferTag] = typedArrayTags2[boolTag] = typedArrayTags2[dataViewTag] = typedArrayTags2[dateTag] = typedArrayTags2[errorTag] = typedArrayTags2[funcTag] = typedArrayTags2[mapTag] = typedArrayTags2[numberTag] = typedArrayTags2[objectTag] = typedArrayTags2[regexpTag] = typedArrayTags2[setTag] = typedArrayTags2[stringTag] = typedArrayTags2[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var objectCtorString = funcToString.call(Object);
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, allocUnsafe2 = Buffer ? Buffer.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable2 = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty2 = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto2) {
      if (!isObject2(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object.prototype = proto2;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size2 = data.size;
    data.set(key2, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assignMergeValue(object, key2, value) {
    if (value !== void 0 && !eq4(object[key2], value) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty2.call(object, key2) && eq4(objValue, value)) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function assocIndexOf(array, key2) {
    var length2 = array.length;
    while (length2--) {
      if (eq4(array[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key2, value) {
    if (key2 == "__proto__" && defineProperty2) {
      defineProperty2(object, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key2] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags2[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key2 in object) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key2) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key2, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key2, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key2, newValue);
  }
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  var baseSetToString = !defineProperty2 ? identity2 : function(func, string2) {
    return defineProperty2(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string2),
      "writable": true
    });
  };
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length2 = buffer2.length, result = allocUnsafe2 ? allocUnsafe2(length2) : new buffer2.constructor(length2);
    buffer2.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index2 = -1, length2 = source.length;
    array || (array = Array(length2));
    while (++index2 < length2) {
      array[index2] = source[index2];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key2 = props[index2];
      var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object, key2, newValue);
      } else {
        assignValue(object, key2, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object = Object(object);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
      while (length2--) {
        var key2 = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key2], key2, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData(map, key2) {
    var data = map.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex(value, length2) {
    var type = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isIterateeCall(value, index2, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq4(object[index2], value);
    }
    return false;
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key2 in Object(object)) {
        result.push(key2);
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
      while (++index2 < length2) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key2) {
    if (key2 === "constructor" && typeof object[key2] === "function") {
      return;
    }
    if (key2 == "__proto__") {
      return;
    }
    return object[key2];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq4(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  function constant(value) {
    return function() {
      return value;
    };
  }
  function identity2(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = mergeWith2;
})(lodash_mergewith, lodash_mergewith.exports);
var lodash_mergewithExports = lodash_mergewith.exports;
const mergeWith = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergewithExports);
var isImportant = (value) => /!(important)?$/.test(value);
var withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
var tokenToCSSVar = (scale2, value) => (theme2) => {
  const valueStr = String(value);
  const important = isImportant(valueStr);
  const valueWithoutImportant = withoutImportant(valueStr);
  const key2 = scale2 ? `${scale2}.${valueWithoutImportant}` : valueWithoutImportant;
  let transformed = isObject$1(theme2.__cssMap) && key2 in theme2.__cssMap ? theme2.__cssMap[key2].varRef : value;
  transformed = withoutImportant(transformed);
  return important ? `${transformed} !important` : transformed;
};
function createTransform(options2) {
  const { scale: scale2, transform: transform2, compose } = options2;
  const fn2 = (value, theme2) => {
    var _a4;
    const _value = tokenToCSSVar(scale2, value)(theme2);
    let result = (_a4 = transform2 == null ? void 0 : transform2(_value, theme2)) != null ? _a4 : _value;
    if (compose) {
      result = compose(result, theme2);
    }
    return result;
  };
  return fn2;
}
var pipe$2 = (...fns) => (v2) => fns.reduce((a2, b2) => b2(a2), v2);
function toConfig(scale2, transform2) {
  return (property) => {
    const result = { property, scale: scale2 };
    result.transform = createTransform({
      scale: scale2,
      transform: transform2
    });
    return result;
  };
}
var getRtl = ({ rtl, ltr }) => (theme2) => theme2.direction === "rtl" ? rtl : ltr;
function logical(options2) {
  const { property, scale: scale2, transform: transform2 } = options2;
  return {
    scale: scale2,
    property: getRtl(property),
    transform: scale2 ? createTransform({
      scale: scale2,
      compose: transform2
    }) : transform2
  };
}
var transformTemplate = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function getTransformTemplate() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...transformTemplate
  ].join(" ");
}
function getTransformGpuTemplate() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...transformTemplate
  ].join(" ");
}
var filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
};
var backdropFilterTemplate = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
    "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
    "--chakra-ring-width": value,
    boxShadow: [
      `var(--chakra-ring-offset-shadow)`,
      `var(--chakra-ring-shadow)`,
      `var(--chakra-shadow, 0 0 #0000)`
    ].join(", ")
  };
}
var flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
var directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var valueSet = new Set(Object.values(directionMap));
var globalSet = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]);
var trimSpace = (str) => str.trim();
function parseGradient(value, theme2) {
  if (value == null || globalSet.has(value))
    return value;
  const prevent = isCSSFunction(value) || globalSet.has(value);
  if (!prevent)
    return `url('${value}')`;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const results2 = regex.exec(value);
  const type = results2 == null ? void 0 : results2[1];
  const values = results2 == null ? void 0 : results2[2];
  if (!type || !values)
    return value;
  const _type = type.includes("-gradient") ? type : `${type}-gradient`;
  const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
  if ((stops == null ? void 0 : stops.length) === 0)
    return value;
  const direction2 = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction2);
  const _values = stops.map((stop) => {
    if (valueSet.has(stop))
      return stop;
    const firstStop = stop.indexOf(" ");
    const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
    const key2 = `colors.${_color}`;
    const color2 = key2 in theme2.__cssMap ? theme2.__cssMap[key2].varRef : _color;
    return _stopOrFunc ? [
      color2,
      ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
    ].join(" ") : color2;
  });
  return `${_type}(${_values.join(", ")})`;
}
var isCSSFunction = (value) => {
  return typeof value === "string" && value.includes("(") && value.includes(")");
};
var gradientTransform = (value, theme2) => parseGradient(value, theme2 != null ? theme2 : {});
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
var analyzeCSSValue = (value) => {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
};
var wrap = (str) => (value) => `${str}(${value})`;
var transformFunctions = {
  filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip(value) {
    return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
  },
  transform(value) {
    if (value === "auto")
      return getTransformTemplate();
    if (value === "auto-gpu")
      return getTransformGpuTemplate();
    return value;
  },
  vh(value) {
    return value === "$100vh" ? "var(--chakra-vh)" : value;
  },
  px(value) {
    if (value == null)
      return value;
    const { unitless } = analyzeCSSValue(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  },
  fraction(value) {
    return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
  },
  float(value, theme2) {
    const map = { left: "right", right: "left" };
    return theme2.direction === "rtl" ? map[value] : value;
  },
  degree(value) {
    if (isCssVar(value) || value == null)
      return value;
    const unitless = typeof value === "string" && !value.endsWith("deg");
    return typeof value === "number" || unitless ? `${value}deg` : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: wrap("hue-rotate"),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage(value) {
    if (value == null)
      return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? `url(${value})` : value;
  },
  outline(value) {
    const isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
  },
  flexDirection(value) {
    var _a4;
    const { space: space2, divide: divide2 } = (_a4 = flexDirectionTemplate[value]) != null ? _a4 : {};
    const result = { flexDirection: value };
    if (space2)
      result[space2] = 1;
    if (divide2)
      result[divide2] = 1;
    return result;
  }
};
var t$1 = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  gradients: toConfig("gradients", transformFunctions.gradient),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  spaceT: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  degreeT(property) {
    return { property, transform: transformFunctions.degree };
  },
  prop(property, scale2, transform2) {
    return {
      property,
      scale: scale2,
      ...scale2 && {
        transform: createTransform({ scale: scale2, transform: transform2 })
      }
    };
  },
  propT(property, transform2) {
    return { property, transform: transform2 };
  },
  sizes: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.px)),
  sizesT: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.fraction)),
  shadows: toConfig("shadows"),
  logical,
  blur: toConfig("blur", transformFunctions.blur)
};
var background = {
  background: t$1.colors("background"),
  backgroundColor: t$1.colors("backgroundColor"),
  backgroundImage: t$1.gradients("backgroundImage"),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: { transform: transformFunctions.bgClip },
  bgSize: t$1.prop("backgroundSize"),
  bgPosition: t$1.prop("backgroundPosition"),
  bg: t$1.colors("background"),
  bgColor: t$1.colors("backgroundColor"),
  bgPos: t$1.prop("backgroundPosition"),
  bgRepeat: t$1.prop("backgroundRepeat"),
  bgAttachment: t$1.prop("backgroundAttachment"),
  bgGradient: t$1.gradients("backgroundImage"),
  bgClip: { transform: transformFunctions.bgClip }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
var border = {
  border: t$1.borders("border"),
  borderWidth: t$1.borderWidths("borderWidth"),
  borderStyle: t$1.borderStyles("borderStyle"),
  borderColor: t$1.colors("borderColor"),
  borderRadius: t$1.radii("borderRadius"),
  borderTop: t$1.borders("borderTop"),
  borderBlockStart: t$1.borders("borderBlockStart"),
  borderTopLeftRadius: t$1.radii("borderTopLeftRadius"),
  borderStartStartRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t$1.radii("borderTopRightRadius"),
  borderStartEndRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t$1.borders("borderRight"),
  borderInlineEnd: t$1.borders("borderInlineEnd"),
  borderBottom: t$1.borders("borderBottom"),
  borderBlockEnd: t$1.borders("borderBlockEnd"),
  borderBottomLeftRadius: t$1.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t$1.radii("borderBottomRightRadius"),
  borderLeft: t$1.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t$1.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t$1.borders(["borderLeft", "borderRight"]),
  borderInline: t$1.borders("borderInline"),
  borderY: t$1.borders(["borderTop", "borderBottom"]),
  borderBlock: t$1.borders("borderBlock"),
  borderTopWidth: t$1.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t$1.borderWidths("borderBlockStartWidth"),
  borderTopColor: t$1.colors("borderTopColor"),
  borderBlockStartColor: t$1.colors("borderBlockStartColor"),
  borderTopStyle: t$1.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t$1.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t$1.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t$1.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t$1.colors("borderBottomColor"),
  borderBlockEndColor: t$1.colors("borderBlockEndColor"),
  borderBottomStyle: t$1.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t$1.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t$1.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t$1.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t$1.colors("borderLeftColor"),
  borderInlineStartColor: t$1.colors("borderInlineStartColor"),
  borderLeftStyle: t$1.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t$1.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t$1.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t$1.borderWidths("borderInlineEndWidth"),
  borderRightColor: t$1.colors("borderRightColor"),
  borderInlineEndColor: t$1.colors("borderInlineEndColor"),
  borderRightStyle: t$1.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t$1.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t$1.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t$1.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: t$1.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t$1.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});
var color$1 = {
  color: t$1.colors("color"),
  textColor: t$1.colors("color"),
  fill: t$1.colors("fill"),
  stroke: t$1.colors("stroke")
};
var effect$3 = {
  boxShadow: t$1.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t$1.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t$1.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect$3, {
  shadow: effect$3.boxShadow
});
var filter$1 = {
  filter: { transform: transformFunctions.filter },
  blur: t$1.blur("--chakra-blur"),
  brightness: t$1.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t$1.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t$1.degreeT("--chakra-hue-rotate"),
  invert: t$1.propT("--chakra-invert", transformFunctions.invert),
  saturate: t$1.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t$1.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: { transform: transformFunctions.backdropFilter },
  backdropBlur: t$1.blur("--chakra-backdrop-blur"),
  backdropBrightness: t$1.propT(
    "--chakra-backdrop-brightness",
    transformFunctions.brightness
  ),
  backdropContrast: t$1.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t$1.degreeT("--chakra-backdrop-hue-rotate"),
  backdropInvert: t$1.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t$1.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
var flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: { transform: transformFunctions.flexDirection },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t$1.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t$1.space("gap"),
  rowGap: t$1.space("rowGap"),
  columnGap: t$1.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
var grid = {
  gridGap: t$1.space("gridGap"),
  gridColumnGap: t$1.space("gridColumnGap"),
  gridRowGap: t$1.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
var interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: { transform: transformFunctions.outline },
  outlineOffset: true,
  outlineColor: t$1.colors("outlineColor")
};
var layout$1 = {
  width: t$1.sizesT("width"),
  inlineSize: t$1.sizesT("inlineSize"),
  height: t$1.sizes("height"),
  blockSize: t$1.sizes("blockSize"),
  boxSize: t$1.sizes(["width", "height"]),
  minWidth: t$1.sizes("minWidth"),
  minInlineSize: t$1.sizes("minInlineSize"),
  minHeight: t$1.sizes("minHeight"),
  minBlockSize: t$1.sizes("minBlockSize"),
  maxWidth: t$1.sizes("maxWidth"),
  maxInlineSize: t$1.sizes("maxInlineSize"),
  maxHeight: t$1.sizes("maxHeight"),
  maxBlockSize: t$1.sizes("maxBlockSize"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  aspectRatio: true,
  hideFrom: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a4, _b3, _c2;
      const breakpoint = (_c2 = (_b3 = (_a4 = theme2.__breakpoints) == null ? void 0 : _a4.get(value)) == null ? void 0 : _b3.minW) != null ? _c2 : value;
      const mq = `@media screen and (min-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a4, _b3, _c2;
      const breakpoint = (_c2 = (_b3 = (_a4 = theme2.__breakpoints) == null ? void 0 : _a4.get(value)) == null ? void 0 : _b3._minW) != null ? _c2 : value;
      const mq = `@media screen and (max-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  float: t$1.propT("float", transformFunctions.float),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout$1, {
  w: layout$1.width,
  h: layout$1.height,
  minW: layout$1.minWidth,
  maxW: layout$1.maxWidth,
  minH: layout$1.minHeight,
  maxH: layout$1.maxHeight,
  overscroll: layout$1.overscrollBehavior,
  overscrollX: layout$1.overscrollBehaviorX,
  overscrollY: layout$1.overscrollBehaviorY
});
var list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t$1.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t$1.prop("listStyleImage")
};
function get$1(obj, path, fallback, index2) {
  const key2 = typeof path === "string" ? path.split(".") : [path];
  for (index2 = 0; index2 < key2.length; index2 += 1) {
    if (!obj)
      break;
    obj = obj[key2[index2]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize$1 = (fn2) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path, fallback, index2) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */ new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn2(obj, path, fallback, index2);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet$1 = memoize$1(get$1);
var srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
var srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};
var getWithPriority = (theme2, key2, styles2) => {
  const result = {};
  const obj = memoizedGet$1(theme2, key2, {});
  for (const prop in obj) {
    const isInStyles = prop in styles2 && styles2[prop] != null;
    if (!isInStyles)
      result[prop] = obj[prop];
  }
  return result;
};
var others = {
  srOnly: {
    transform(value) {
      if (value === true)
        return srOnly;
      if (value === "focusable")
        return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `layerStyles.${value}`, styles2)
  },
  textStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `textStyles.${value}`, styles2)
  },
  apply: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, value, styles2)
  }
};
var position = {
  position: true,
  pos: t$1.prop("position"),
  zIndex: t$1.prop("zIndex", "zIndices"),
  inset: t$1.spaceT("inset"),
  insetX: t$1.spaceT(["left", "right"]),
  insetInline: t$1.spaceT("insetInline"),
  insetY: t$1.spaceT(["top", "bottom"]),
  insetBlock: t$1.spaceT("insetBlock"),
  top: t$1.spaceT("top"),
  insetBlockStart: t$1.spaceT("insetBlockStart"),
  bottom: t$1.spaceT("bottom"),
  insetBlockEnd: t$1.spaceT("insetBlockEnd"),
  left: t$1.spaceT("left"),
  insetInlineStart: t$1.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: t$1.spaceT("right"),
  insetInlineEnd: t$1.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(position, {
  insetStart: position.insetInlineStart,
  insetEnd: position.insetInlineEnd
});
var ring = {
  ring: { transform: transformFunctions.ring },
  ringColor: t$1.colors("--chakra-ring-color"),
  ringOffset: t$1.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t$1.colors("--chakra-ring-offset-color"),
  ringInset: t$1.prop("--chakra-ring-inset")
};
var space = {
  margin: t$1.spaceT("margin"),
  marginTop: t$1.spaceT("marginTop"),
  marginBlockStart: t$1.spaceT("marginBlockStart"),
  marginRight: t$1.spaceT("marginRight"),
  marginInlineEnd: t$1.spaceT("marginInlineEnd"),
  marginBottom: t$1.spaceT("marginBottom"),
  marginBlockEnd: t$1.spaceT("marginBlockEnd"),
  marginLeft: t$1.spaceT("marginLeft"),
  marginInlineStart: t$1.spaceT("marginInlineStart"),
  marginX: t$1.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t$1.spaceT("marginInline"),
  marginY: t$1.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t$1.spaceT("marginBlock"),
  padding: t$1.space("padding"),
  paddingTop: t$1.space("paddingTop"),
  paddingBlockStart: t$1.space("paddingBlockStart"),
  paddingRight: t$1.space("paddingRight"),
  paddingBottom: t$1.space("paddingBottom"),
  paddingBlockEnd: t$1.space("paddingBlockEnd"),
  paddingLeft: t$1.space("paddingLeft"),
  paddingInlineStart: t$1.space("paddingInlineStart"),
  paddingInlineEnd: t$1.space("paddingInlineEnd"),
  paddingX: t$1.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t$1.space("paddingInline"),
  paddingY: t$1.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t$1.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
var textDecoration = {
  textDecorationColor: t$1.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: { property: "textDecoration" },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t$1.shadows("textShadow")
};
var transform = {
  clipPath: true,
  transform: t$1.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t$1.spaceT("--chakra-translate-x"),
  translateY: t$1.spaceT("--chakra-translate-y"),
  skewX: t$1.degreeT("--chakra-skew-x"),
  skewY: t$1.degreeT("--chakra-skew-y"),
  scaleX: t$1.prop("--chakra-scale-x"),
  scaleY: t$1.prop("--chakra-scale-y"),
  scale: t$1.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t$1.degreeT("--chakra-rotate")
};
var transition$1 = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t$1.prop("transitionDuration", "transition.duration"),
  transitionProperty: t$1.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t$1.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
};
var typography$1 = {
  fontFamily: t$1.prop("fontFamily", "fonts"),
  fontSize: t$1.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t$1.prop("fontWeight", "fontWeights"),
  lineHeight: t$1.prop("lineHeight", "lineHeights"),
  letterSpacing: t$1.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  textIndent: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  isTruncated: {
    transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
};
var scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollMargin: t$1.spaceT("scrollMargin"),
  scrollMarginTop: t$1.spaceT("scrollMarginTop"),
  scrollMarginBottom: t$1.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t$1.spaceT("scrollMarginLeft"),
  scrollMarginRight: t$1.spaceT("scrollMarginRight"),
  scrollMarginX: t$1.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t$1.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  scrollPadding: t$1.spaceT("scrollPadding"),
  scrollPaddingTop: t$1.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t$1.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t$1.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t$1.spaceT("scrollPaddingRight"),
  scrollPaddingX: t$1.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t$1.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function resolveReference(operand) {
  if (isObject$1(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add$1 = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract$1 = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply$1 = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide$1 = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate$1 = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply$1(value, -1);
};
var calc$1 = Object.assign(
  (x2) => ({
    add: (...operands) => calc$1(add$1(x2, ...operands)),
    subtract: (...operands) => calc$1(subtract$1(x2, ...operands)),
    multiply: (...operands) => calc$1(multiply$1(x2, ...operands)),
    divide: (...operands) => calc$1(divide$1(x2, ...operands)),
    negate: () => calc$1(negate$1(x2)),
    toString: () => x2.toString()
  }),
  {
    add: add$1,
    subtract: subtract$1,
    multiply: multiply$1,
    divide: divide$1,
    negate: negate$1
  }
);
function replaceWhiteSpace$1(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape$2(value) {
  const valueStr = replaceWhiteSpace$1(value.toString());
  return escapeSymbol(escapeDot(valueStr));
}
function escapeDot(value) {
  if (value.includes("\\."))
    return value;
  const isDecimal2 = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal2 ? value.replace(".", `\\.`) : value;
}
function escapeSymbol(value) {
  return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix$1(value, prefix2 = "") {
  return [prefix2, value].filter(Boolean).join("-");
}
function toVarReference(name2, fallback) {
  return `var(${name2}${fallback ? `, ${fallback}` : ""})`;
}
function toVarDefinition(value, prefix2 = "") {
  return escape$2(`--${addPrefix$1(value, prefix2)}`);
}
function cssVar$1(name2, fallback, cssVarPrefix) {
  const cssVariable = toVarDefinition(name2, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}
function defineCssVars(scope, keys2) {
  const vars2 = {};
  for (const key2 of keys2) {
    if (Array.isArray(key2)) {
      const [name2, fallback] = key2;
      vars2[name2] = cssVar$1(`${scope}-${name2}`, fallback);
      continue;
    }
    vars2[key2] = cssVar$1(`${scope}-${key2}`);
  }
  return vars2;
}
function getLastItem(array) {
  const length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
function analyzeCSSValue2(value) {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
}
function px$1(value) {
  if (value == null)
    return value;
  const { unitless } = analyzeCSSValue2(value);
  return unitless || typeof value === "number" ? `${value}px` : value;
}
var sortByBreakpointValue = (a2, b2) => parseInt(a2[1], 10) > parseInt(b2[1], 10) ? 1 : -1;
var sortBps = (breakpoints2) => Object.fromEntries(Object.entries(breakpoints2).sort(sortByBreakpointValue));
function normalize(breakpoints2) {
  const sorted = sortBps(breakpoints2);
  return Object.assign(Object.values(sorted), sorted);
}
function keys(breakpoints2) {
  const value = Object.keys(sortBps(breakpoints2));
  return new Set(value);
}
function subtract2(value) {
  var _a4;
  if (!value)
    return value;
  value = (_a4 = px$1(value)) != null ? _a4 : value;
  const OFFSET = -0.02;
  return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m2) => `${parseFloat(m2) + OFFSET}`);
}
function toMediaQueryString(min2, max2) {
  const query = ["@media screen"];
  if (min2)
    query.push("and", `(min-width: ${px$1(min2)})`);
  if (max2)
    query.push("and", `(max-width: ${px$1(max2)})`);
  return query.join(" ");
}
function analyzeBreakpoints(breakpoints2) {
  var _a4;
  if (!breakpoints2)
    return null;
  breakpoints2.base = (_a4 = breakpoints2.base) != null ? _a4 : "0px";
  const normalized = normalize(breakpoints2);
  const queries = Object.entries(breakpoints2).sort(sortByBreakpointValue).map(([breakpoint, minW], index2, entry) => {
    var _a22;
    let [, maxW] = (_a22 = entry[index2 + 1]) != null ? _a22 : [];
    maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
    return {
      _minW: subtract2(minW),
      breakpoint,
      minW,
      maxW,
      maxWQuery: toMediaQueryString(null, maxW),
      minWQuery: toMediaQueryString(minW),
      minMaxQuery: toMediaQueryString(minW, maxW)
    };
  });
  const _keys = keys(breakpoints2);
  const _keysArr = Array.from(_keys.values());
  return {
    keys: _keys,
    normalized,
    isResponsive(test2) {
      const keys2 = Object.keys(test2);
      return keys2.length > 0 && keys2.every((key2) => _keys.has(key2));
    },
    asObject: sortBps(breakpoints2),
    asArray: normalize(breakpoints2),
    details: queries,
    get(key2) {
      return queries.find((q2) => q2.breakpoint === key2);
    },
    media: [
      null,
      ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
    ],
    toArrayValue(test2) {
      if (!isObject$1(test2)) {
        throw new Error("toArrayValue: value must be an object");
      }
      const result = _keysArr.map((bp) => {
        var _a22;
        return (_a22 = test2[bp]) != null ? _a22 : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    },
    toObjectValue(test2) {
      if (!Array.isArray(test2)) {
        throw new Error("toObjectValue: value must be an array");
      }
      return test2.reduce((acc, value, index2) => {
        const key2 = _keysArr[index2];
        if (key2 != null && value != null)
          acc[key2] = value;
        return acc;
      }, {});
    }
  };
}
var state = {
  hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
  focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
  focusVisible: (str, post) => `${str}:focus-visible ${post}`,
  focusWithin: (str, post) => `${str}:focus-within ${post}`,
  active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
  disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
  invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
  checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
  indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
  readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
  expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
  placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
};
var toGroup = (fn2) => merge$1((v2) => fn2(v2, "&"), "[role=group]", "[data-group]", ".group");
var toPeer = (fn2) => merge$1((v2) => fn2(v2, "~ &"), "[data-peer]", ".peer");
var merge$1 = (fn2, ...selectors) => selectors.map(fn2).join(", ");
var pseudoSelectors = {
  _hover: "&:hover, &[data-hover]",
  _active: "&:active, &[data-active]",
  _focus: "&:focus, &[data-focus]",
  _highlighted: "&[data-highlighted]",
  _focusWithin: "&:focus-within",
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  _before: "&::before",
  _after: "&::after",
  _empty: "&:empty",
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  _checked: "&[aria-checked=true], &[data-checked]",
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  _valid: "&[data-valid], &[data-state=valid]",
  _loading: "&[data-loading], &[aria-busy=true]",
  _selected: "&[aria-selected=true], &[data-selected]",
  _hidden: "&[hidden], &[data-hidden]",
  _autofill: "&:-webkit-autofill",
  _even: "&:nth-of-type(even)",
  _odd: "&:nth-of-type(odd)",
  _first: "&:first-of-type",
  _firstLetter: "&::first-letter",
  _last: "&:last-of-type",
  _notFirst: "&:not(:first-of-type)",
  _notLast: "&:not(:last-of-type)",
  _visited: "&:visited",
  _activeLink: "&[aria-current=page]",
  _activeStep: "&[aria-current=step]",
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  _groupHover: toGroup(state.hover),
  _peerHover: toPeer(state.hover),
  _groupFocus: toGroup(state.focus),
  _peerFocus: toPeer(state.focus),
  _groupFocusVisible: toGroup(state.focusVisible),
  _peerFocusVisible: toPeer(state.focusVisible),
  _groupActive: toGroup(state.active),
  _peerActive: toPeer(state.active),
  _groupDisabled: toGroup(state.disabled),
  _peerDisabled: toPeer(state.disabled),
  _groupInvalid: toGroup(state.invalid),
  _peerInvalid: toPeer(state.invalid),
  _groupChecked: toGroup(state.checked),
  _peerChecked: toPeer(state.checked),
  _groupFocusWithin: toGroup(state.focusWithin),
  _peerFocusWithin: toPeer(state.focusWithin),
  _peerPlaceholderShown: toPeer(state.placeholderShown),
  _placeholder: "&::placeholder",
  _placeholderShown: "&:placeholder-shown",
  _fullScreen: "&:fullscreen",
  _selection: "&::selection",
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  _mediaDark: "@media (prefers-color-scheme: dark)",
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  _horizontal: "&[data-orientation=horizontal]",
  _vertical: "&[data-orientation=vertical]"
};
var pseudoPropNames = Object.keys(
  pseudoSelectors
);
function tokenToCssVar(token2, prefix2) {
  return cssVar$1(String(token2).replace(/\./g, "-"), void 0, prefix2);
}
function createThemeVars(flatTokens, options2) {
  let cssVars2 = {};
  const cssMap = {};
  for (const [token2, tokenValue] of Object.entries(flatTokens)) {
    const { isSemantic, value } = tokenValue;
    const { variable, reference: reference2 } = tokenToCssVar(token2, options2 == null ? void 0 : options2.cssVarPrefix);
    if (!isSemantic) {
      if (token2.startsWith("space")) {
        const keys2 = token2.split(".");
        const [firstKey, ...referenceKeys] = keys2;
        const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
        const negativeValue = calc$1.negate(value);
        const negatedReference = calc$1.negate(reference2);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          var: variable,
          varRef: negatedReference
        };
      }
      cssVars2[variable] = value;
      cssMap[token2] = {
        value,
        var: variable,
        varRef: reference2
      };
      continue;
    }
    const lookupToken = (maybeToken) => {
      const scale2 = String(token2).split(".")[0];
      const withScale = [scale2, maybeToken].join(".");
      const resolvedTokenValue = flatTokens[withScale];
      if (!resolvedTokenValue)
        return maybeToken;
      const { reference: reference22 } = tokenToCssVar(withScale, options2 == null ? void 0 : options2.cssVarPrefix);
      return reference22;
    };
    const normalizedValue = isObject$1(value) ? value : { default: value };
    cssVars2 = mergeWith(
      cssVars2,
      Object.entries(normalizedValue).reduce(
        (acc, [conditionAlias, conditionValue]) => {
          var _a4, _b3;
          if (!conditionValue)
            return acc;
          const tokenReference = lookupToken(`${conditionValue}`);
          if (conditionAlias === "default") {
            acc[variable] = tokenReference;
            return acc;
          }
          const conditionSelector = (_b3 = (_a4 = pseudoSelectors) == null ? void 0 : _a4[conditionAlias]) != null ? _b3 : conditionAlias;
          acc[conditionSelector] = { [variable]: tokenReference };
          return acc;
        },
        {}
      )
    );
    cssMap[token2] = {
      value: reference2,
      var: variable,
      varRef: reference2
    };
  }
  return {
    cssVars: cssVars2,
    cssMap
  };
}
function omit$2(object, keysToOmit = []) {
  const clone2 = Object.assign({}, object);
  for (const key2 of keysToOmit) {
    if (key2 in clone2) {
      delete clone2[key2];
    }
  }
  return clone2;
}
function pick(object, keysToPick) {
  const result = {};
  for (const key2 of keysToPick) {
    if (key2 in object) {
      result[key2] = object[key2];
    }
  }
  return result;
}
function isObject5(value) {
  return typeof value === "object" && value != null && !Array.isArray(value);
}
function walkObject(target, predicate, options2 = {}) {
  const { stop, getKey } = options2;
  function inner(value, path = []) {
    var _a4;
    if (isObject5(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key2 = (_a4 = getKey == null ? void 0 : getKey(prop)) != null ? _a4 : prop;
        const childPath = [...path, key2];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        result[key2] = inner(child, childPath);
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
var tokens = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function extractTokens(theme2) {
  const _tokens = tokens;
  return pick(theme2, _tokens);
}
function extractSemanticTokens(theme2) {
  return theme2.semanticTokens;
}
function omitVars(rawTheme) {
  const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
  return cleanTheme;
}
var isSemanticCondition = (key2) => pseudoPropNames.includes(key2) || "default" === key2;
function flattenTokens({
  tokens: tokens2,
  semanticTokens: semanticTokens2
}) {
  const result = {};
  walkObject(tokens2, (value, path) => {
    if (value == null)
      return;
    result[path.join(".")] = { isSemantic: false, value };
  });
  walkObject(
    semanticTokens2,
    (value, path) => {
      if (value == null)
        return;
      result[path.join(".")] = { isSemantic: true, value };
    },
    {
      stop: (value) => Object.keys(value).every(isSemanticCondition)
    }
  );
  return result;
}
function toCSSVar(rawTheme) {
  var _a4;
  const theme2 = omitVars(rawTheme);
  const tokens2 = extractTokens(theme2);
  const semanticTokens2 = extractSemanticTokens(theme2);
  const flatTokens = flattenTokens({ tokens: tokens2, semanticTokens: semanticTokens2 });
  const cssVarPrefix = (_a4 = theme2.config) == null ? void 0 : _a4.cssVarPrefix;
  const {
    cssMap,
    cssVars: cssVars2
  } = createThemeVars(flatTokens, { cssVarPrefix });
  const defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme2, {
    __cssVars: { ...defaultCssVars, ...cssVars2 },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme2.breakpoints)
  });
  return theme2;
}
var systemProps = mergeWith(
  {},
  background,
  border,
  color$1,
  flexbox,
  layout$1,
  filter$1,
  ring,
  interactivity,
  grid,
  others,
  position,
  effect$3,
  space,
  scroll,
  typography$1,
  textDecoration,
  transform,
  list,
  transition$1
);
Object.assign({}, space, layout$1, flexbox, grid, position);
var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
var styleProps = { ...systemProps, ...pseudoSelectors };
var isStyleProp = (prop) => prop in styleProps;
var expandResponsive = (styles2) => (theme2) => {
  if (!theme2.__breakpoints)
    return styles2;
  const { isResponsive, toArrayValue, media: medias } = theme2.__breakpoints;
  const computedStyles = {};
  for (const key2 in styles2) {
    let value = runIfFn$2(styles2[key2], theme2);
    if (value == null)
      continue;
    value = isObject$1(value) && isResponsive(value) ? toArrayValue(value) : value;
    if (!Array.isArray(value)) {
      computedStyles[key2] = value;
      continue;
    }
    const queries = value.slice(0, medias.length).length;
    for (let index2 = 0; index2 < queries; index2 += 1) {
      const media2 = medias == null ? void 0 : medias[index2];
      if (!media2) {
        computedStyles[key2] = value[index2];
        continue;
      }
      computedStyles[media2] = computedStyles[media2] || {};
      if (value[index2] == null) {
        continue;
      }
      computedStyles[media2][key2] = value[index2];
    }
  }
  return computedStyles;
};
function splitByComma(value) {
  const chunks = [];
  let chunk = "";
  let inParens = false;
  for (let i2 = 0; i2 < value.length; i2++) {
    const char2 = value[i2];
    if (char2 === "(") {
      inParens = true;
      chunk += char2;
    } else if (char2 === ")") {
      inParens = false;
      chunk += char2;
    } else if (char2 === "," && !inParens) {
      chunks.push(chunk);
      chunk = "";
    } else {
      chunk += char2;
    }
  }
  chunk = chunk.trim();
  if (chunk) {
    chunks.push(chunk);
  }
  return chunks;
}
function isCssVar2(value) {
  return /^var\(--.+\)$/.test(value);
}
var isCSSVariableTokenValue = (key2, value) => key2.startsWith("--") && typeof value === "string" && !isCssVar2(value);
var resolveTokenValue = (theme2, value) => {
  var _a4, _b3;
  if (value == null)
    return value;
  const getVar = (val) => {
    var _a22, _b22;
    return (_b22 = (_a22 = theme2.__cssMap) == null ? void 0 : _a22[val]) == null ? void 0 : _b22.varRef;
  };
  const getValue = (val) => {
    var _a22;
    return (_a22 = getVar(val)) != null ? _a22 : val;
  };
  const [tokenValue, fallbackValue] = splitByComma(value);
  value = (_b3 = (_a4 = getVar(tokenValue)) != null ? _a4 : getValue(fallbackValue)) != null ? _b3 : getValue(value);
  return value;
};
function getCss(options2) {
  const { configs = {}, pseudos = {}, theme: theme2 } = options2;
  const css2 = (stylesOrFn, nested = false) => {
    var _a4, _b3, _c2;
    const _styles = runIfFn$2(stylesOrFn, theme2);
    const styles2 = expandResponsive(_styles)(theme2);
    let computedStyles = {};
    for (let key2 in styles2) {
      const valueOrFn = styles2[key2];
      let value = runIfFn$2(valueOrFn, theme2);
      if (key2 in pseudos) {
        key2 = pseudos[key2];
      }
      if (isCSSVariableTokenValue(key2, value)) {
        value = resolveTokenValue(theme2, value);
      }
      let config2 = configs[key2];
      if (config2 === true) {
        config2 = { property: key2 };
      }
      if (isObject$1(value)) {
        computedStyles[key2] = (_a4 = computedStyles[key2]) != null ? _a4 : {};
        computedStyles[key2] = mergeWith(
          {},
          computedStyles[key2],
          css2(value, true)
        );
        continue;
      }
      let rawValue = (_c2 = (_b3 = config2 == null ? void 0 : config2.transform) == null ? void 0 : _b3.call(config2, value, theme2, _styles)) != null ? _c2 : value;
      rawValue = (config2 == null ? void 0 : config2.processResult) ? css2(rawValue, true) : rawValue;
      const configProperty = runIfFn$2(config2 == null ? void 0 : config2.property, theme2);
      if (!nested && (config2 == null ? void 0 : config2.static)) {
        const staticStyles = runIfFn$2(config2.static, theme2);
        computedStyles = mergeWith({}, computedStyles, staticStyles);
      }
      if (configProperty && Array.isArray(configProperty)) {
        for (const property of configProperty) {
          computedStyles[property] = rawValue;
        }
        continue;
      }
      if (configProperty) {
        if (configProperty === "&" && isObject$1(rawValue)) {
          computedStyles = mergeWith({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }
        continue;
      }
      if (isObject$1(rawValue)) {
        computedStyles = mergeWith({}, computedStyles, rawValue);
        continue;
      }
      computedStyles[key2] = rawValue;
    }
    return computedStyles;
  };
  return css2;
}
var css = (styles2) => (theme2) => {
  const cssFn = getCss({
    theme: theme2,
    pseudos: pseudoSelectors,
    configs: systemProps
  });
  return cssFn(styles2);
};
function defineStyle(styles2) {
  return styles2;
}
function defineStyleConfig(config2) {
  return config2;
}
function createMultiStyleConfigHelpers(parts) {
  return {
    definePartsStyle(config2) {
      return config2;
    },
    defineMultiStyleConfig(config2) {
      return { parts, ...config2 };
    }
  };
}
function normalize2(value, toArray2) {
  if (Array.isArray(value))
    return value;
  if (isObject$1(value))
    return toArray2(value);
  if (value != null)
    return [value];
}
function getNextIndex$1(values, i2) {
  for (let j = i2 + 1; j < values.length; j++) {
    if (values[j] != null)
      return j;
  }
  return -1;
}
function createResolver(theme2) {
  const breakpointUtil = theme2.__breakpoints;
  return function resolver2(config2, prop, value, props) {
    var _a4, _b3;
    if (!breakpointUtil)
      return;
    const result = {};
    const normalized = normalize2(value, breakpointUtil.toArrayValue);
    if (!normalized)
      return result;
    const len2 = normalized.length;
    const isSingle = len2 === 1;
    const isMultipart = !!config2.parts;
    for (let i2 = 0; i2 < len2; i2++) {
      const key2 = breakpointUtil.details[i2];
      const nextKey = breakpointUtil.details[getNextIndex$1(normalized, i2)];
      const query = toMediaQueryString(key2.minW, nextKey == null ? void 0 : nextKey._minW);
      const styles2 = runIfFn$2((_a4 = config2[prop]) == null ? void 0 : _a4[normalized[i2]], props);
      if (!styles2)
        continue;
      if (isMultipart) {
        (_b3 = config2.parts) == null ? void 0 : _b3.forEach((part) => {
          mergeWith(result, {
            [part]: isSingle ? styles2[part] : { [query]: styles2[part] }
          });
        });
        continue;
      }
      if (!isMultipart) {
        if (isSingle)
          mergeWith(result, styles2);
        else
          result[query] = styles2;
        continue;
      }
      result[query] = styles2;
    }
    return result;
  };
}
function resolveStyleConfig(config2) {
  return (props) => {
    var _a4;
    const { variant, size: size2, theme: theme2 } = props;
    const recipe = createResolver(theme2);
    return mergeWith(
      {},
      runIfFn$2((_a4 = config2.baseStyle) != null ? _a4 : {}, props),
      recipe(config2, "sizes", size2, props),
      recipe(config2, "variants", variant, props)
    );
  };
}
function getCSSVar(theme2, scale2, value) {
  var _a4, _b3, _c2;
  return (_c2 = (_b3 = (_a4 = theme2.__cssMap) == null ? void 0 : _a4[`${scale2}.${value}`]) == null ? void 0 : _b3.varRef) != null ? _c2 : value;
}
function omitThemingProps(props) {
  return omit$2(props, ["styleConfig", "size", "variant", "colorScheme"]);
}
var requiredChakraThemeKeys = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function isChakraTheme(unit) {
  if (!isObject$1(unit)) {
    return false;
  }
  return requiredChakraThemeKeys.every(
    (propertyName) => Object.prototype.hasOwnProperty.call(unit, propertyName)
  );
}
var transitionProperty = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
};
var transitionTimingFunction = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
};
var transitionDuration = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
};
var transition = {
  property: transitionProperty,
  easing: transitionTimingFunction,
  duration: transitionDuration
};
var transition_default = transition;
var zIndices = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
};
var z_index_default = zIndices;
var borders$1 = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
};
var borders_default = borders$1;
var breakpoints = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
};
var breakpoints_default = breakpoints;
var colors = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  },
  linkedin: {
    50: "#E8F4F9",
    100: "#CFEDFB",
    200: "#9BDAF3",
    300: "#68C7EC",
    400: "#34B3E4",
    500: "#00A0DC",
    600: "#008CC9",
    700: "#0077B5",
    800: "#005E93",
    900: "#004471"
  },
  facebook: {
    50: "#E8F4F9",
    100: "#D9DEE9",
    200: "#B7C2DA",
    300: "#6482C0",
    400: "#4267B2",
    500: "#385898",
    600: "#314E89",
    700: "#29487D",
    800: "#223B67",
    900: "#1E355B"
  },
  messenger: {
    50: "#D0E6FF",
    100: "#B9DAFF",
    200: "#A2CDFF",
    300: "#7AB8FF",
    400: "#2E90FF",
    500: "#0078FF",
    600: "#0063D1",
    700: "#0052AC",
    800: "#003C7E",
    900: "#002C5C"
  },
  whatsapp: {
    50: "#dffeec",
    100: "#b9f5d0",
    200: "#90edb3",
    300: "#65e495",
    400: "#3cdd78",
    500: "#22c35e",
    600: "#179848",
    700: "#0c6c33",
    800: "#01421c",
    900: "#001803"
  },
  twitter: {
    50: "#E5F4FD",
    100: "#C8E9FB",
    200: "#A8DCFA",
    300: "#83CDF7",
    400: "#57BBF5",
    500: "#1DA1F2",
    600: "#1A94DA",
    700: "#1681BF",
    800: "#136B9E",
    900: "#0D4D71"
  },
  telegram: {
    50: "#E3F2F9",
    100: "#C5E4F3",
    200: "#A2D4EC",
    300: "#7AC1E4",
    400: "#47A9DA",
    500: "#0088CC",
    600: "#007AB8",
    700: "#006BA1",
    800: "#005885",
    900: "#003F5E"
  }
};
var colors_default = colors;
var radii = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
var radius_default = radii;
var shadows = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
};
var shadows_default = shadows;
var blur = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
};
var blur_default = blur;
var typography = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    "3": ".75rem",
    "4": "1rem",
    "5": "1.25rem",
    "6": "1.5rem",
    "7": "1.75rem",
    "8": "2rem",
    "9": "2.25rem",
    "10": "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
};
var typography_default = typography;
var spacing = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
};
var largeSizes = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
};
var container = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
};
var sizes$m = {
  ...spacing,
  ...largeSizes,
  container
};
var sizes_default = sizes$m;
var foundations = {
  breakpoints: breakpoints_default,
  zIndices: z_index_default,
  radii: radius_default,
  blur: blur_default,
  colors: colors_default,
  ...typography_default,
  sizes: sizes_default,
  shadows: shadows_default,
  space: spacing,
  borders: borders_default,
  transition: transition_default
};
var { defineMultiStyleConfig: defineMultiStyleConfig$p, definePartsStyle: definePartsStyle$p } = createMultiStyleConfigHelpers([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]);
var $size$4 = cssVar$1("stepper-indicator-size");
var $iconSize = cssVar$1("stepper-icon-size");
var $titleFontSize = cssVar$1("stepper-title-font-size");
var $descFontSize = cssVar$1("stepper-description-font-size");
var $accentColor = cssVar$1("stepper-accent-color");
var baseStyle$F = definePartsStyle$p(({ colorScheme: c2 }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [$accentColor.variable]: `colors.${c2}.500`,
    _dark: {
      [$accentColor.variable]: `colors.${c2}.200`
    }
  },
  title: {
    fontSize: $titleFontSize.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: $descFontSize.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: $titleFontSize.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: $iconSize.reference,
    height: $iconSize.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: $size$4.reference,
    height: $size$4.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: $accentColor.reference
    },
    "&[data-status=complete]": {
      bg: $accentColor.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: $accentColor.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${$size$4.reference} - 8px)`,
      top: `calc(${$size$4.reference} + 4px)`,
      insetStart: `calc(${$size$4.reference} / 2 - 1px)`
    }
  }
}));
var stepperTheme = defineMultiStyleConfig$p({
  baseStyle: baseStyle$F,
  sizes: {
    xs: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.4",
        [$iconSize.variable]: "sizes.3",
        [$titleFontSize.variable]: "fontSizes.xs",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    sm: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.6",
        [$iconSize.variable]: "sizes.4",
        [$titleFontSize.variable]: "fontSizes.sm",
        [$descFontSize.variable]: "fontSizes.xs"
      }
    }),
    md: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.8",
        [$iconSize.variable]: "sizes.5",
        [$titleFontSize.variable]: "fontSizes.md",
        [$descFontSize.variable]: "fontSizes.sm"
      }
    }),
    lg: definePartsStyle$p({
      stepper: {
        [$size$4.variable]: "sizes.10",
        [$iconSize.variable]: "sizes.6",
        [$titleFontSize.variable]: "fontSizes.lg",
        [$descFontSize.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
function anatomy(name2, map = {}) {
  let called = false;
  function assert2() {
    if (!called) {
      called = true;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function parts(...values) {
    assert2();
    for (const part of values) {
      map[part] = toPart(part);
    }
    return anatomy(name2, map);
  }
  function extend2(...parts2) {
    for (const part of parts2) {
      if (part in map)
        continue;
      map[part] = toPart(part);
    }
    return anatomy(name2, map);
  }
  function selectors() {
    const value = Object.fromEntries(
      Object.entries(map).map(([key2, part]) => [key2, part.selector])
    );
    return value;
  }
  function classnames() {
    const value = Object.fromEntries(
      Object.entries(map).map(([key2, part]) => [key2, part.className])
    );
    return value;
  }
  function toPart(part) {
    const el2 = ["container", "root"].includes(part != null ? part : "") ? [name2] : [name2, part];
    const attr = el2.filter(Boolean).join("__");
    const className = `chakra-${attr}`;
    const partObj = {
      className,
      selector: `.${className}`,
      toString: () => part
    };
    return partObj;
  }
  const __type = {};
  return {
    parts,
    toPart,
    extend: extend2,
    selectors,
    classnames,
    get keys() {
      return Object.keys(map);
    },
    __type
  };
}
var accordionAnatomy = anatomy("accordion").parts("root", "container", "button", "panel").extend("icon");
var alertAnatomy = anatomy("alert").parts("title", "description", "container").extend("icon", "spinner");
var avatarAnatomy = anatomy("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
var breadcrumbAnatomy = anatomy("breadcrumb").parts("link", "item", "container").extend("separator");
anatomy("button").parts();
var checkboxAnatomy = anatomy("checkbox").parts("control", "icon", "container").extend("label");
anatomy("progress").parts("track", "filledTrack").extend("label");
var drawerAnatomy = anatomy("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var editableAnatomy = anatomy("editable").parts(
  "preview",
  "input",
  "textarea"
);
var formAnatomy = anatomy("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
);
var formErrorAnatomy = anatomy("formError").parts("text", "icon");
var inputAnatomy = anatomy("input").parts("addon", "field", "element");
var listAnatomy = anatomy("list").parts("container", "item", "icon");
var menuAnatomy = anatomy("menu").parts("button", "list", "item").extend("groupTitle", "command", "divider");
var modalAnatomy = anatomy("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
var numberInputAnatomy = anatomy("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
anatomy("pininput").parts("field");
var popoverAnatomy = anatomy("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
var progressAnatomy = anatomy("progress").parts(
  "label",
  "filledTrack",
  "track"
);
var radioAnatomy = anatomy("radio").parts(
  "container",
  "control",
  "label"
);
var selectAnatomy = anatomy("select").parts("field", "icon");
var sliderAnatomy = anatomy("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
);
var statAnatomy = anatomy("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
);
var switchAnatomy = anatomy("switch").parts(
  "container",
  "track",
  "thumb"
);
var tableAnatomy = anatomy("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
);
var tabsAnatomy = anatomy("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
);
var tagAnatomy = anatomy("tag").parts(
  "container",
  "label",
  "closeButton"
);
var cardAnatomy = anatomy("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color2) {
    super(`Failed to parse color: "${color2}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color2) {
  if (typeof color2 !== "string")
    throw new ColorError$1(color2);
  if (color2.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color2.trim();
  normalizedColor = namedColorRegex.test(color2) ? nameToHex(color2) : color2;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(r$1(x2, 2), 16)), parseInt(r$1(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x2) => parseInt(x2, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s2, l2, a2] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s2) !== s2)
      throw new ColorError$1(color2);
    if (guard(0, 100, l2) !== l2)
      throw new ColorError$1(color2);
    return [...hslToRgb(h2, s2, l2), Number.isNaN(a2) ? 1 : a2];
  }
  throw new ColorError$1(color2);
}
function hash$2(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i2);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x2) => parseInt(x2.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next2) => {
  const key2 = colorToInt(next2.substring(0, 3));
  const hex2 = colorToInt(next2.substring(3)).toString(16);
  let prefix2 = "";
  for (let i2 = 0; i2 < 6 - hex2.length; i2++) {
    prefix2 += "0";
  }
  acc[key2] = `${prefix2}${hex2}`;
  return acc;
}, {});
function nameToHex(color2) {
  const normalizedColorName = color2.toLowerCase().trim();
  const result = compressedColorMap[hash$2(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color2);
  return `#${result}`;
}
const r$1 = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r$1("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex = new RegExp(`^#${r$1("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r$1(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color2) => {
  return Math.round(color2 * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l2 = lightness / 100;
  if (saturation === 0) {
    return [l2, l2, l2].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l2 - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green2 = 0;
  let blue2 = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green2 = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green2 = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green2 = chroma;
    blue2 = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green2 = secondComponent;
    blue2 = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue2 = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue2 = secondComponent;
  }
  const lightnessModification = l2 - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green2 + lightnessModification;
  const finalBlue = blue2 + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function rgba$1(red, green2, blue2, alpha2) {
  return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green2).toFixed()}, ${guard(0, 255, blue2).toFixed()}, ${parseFloat(guard(0, 1, alpha2).toFixed(3))})`;
}
function transparentize$1(color2, amount) {
  const [r2, g2, b2, a2] = parseToRgba(color2);
  return rgba$1(r2, g2, b2, a2 - amount);
}
function toHex(color2) {
  const [r2, g2, b2, a2] = parseToRgba(color2);
  let hex2 = (x2) => {
    const h2 = guard(0, 255, x2).toString(16);
    return h2.length === 1 ? `0${h2}` : h2;
  };
  return `#${hex2(r2)}${hex2(g2)}${hex2(b2)}${a2 < 1 ? hex2(Math.round(a2 * 255)) : ""}`;
}
function dlv_es_default(t2, e2, l2, n2, r2) {
  for (e2 = e2.split ? e2.split(".") : e2, n2 = 0; n2 < e2.length; n2++)
    t2 = t2 ? t2[e2[n2]] : r2;
  return t2 === r2 ? l2 : t2;
}
var isEmptyObject = (obj) => Object.keys(obj).length === 0;
var getColor = (theme2, color2, fallback) => {
  const hex2 = dlv_es_default(theme2, `colors.${color2}`, color2);
  try {
    toHex(hex2);
    return hex2;
  } catch {
    return fallback != null ? fallback : "#000000";
  }
};
var getColorVar = (theme2, color2, fallback) => {
  var _a4;
  return (_a4 = getCSSVar(theme2, "colors", color2)) != null ? _a4 : fallback;
};
var getBrightness = (color2) => {
  const [r2, g2, b2] = parseToRgba(color2);
  return (r2 * 299 + g2 * 587 + b2 * 114) / 1e3;
};
var tone = (color2) => (theme2) => {
  const hex2 = getColor(theme2, color2);
  const brightness = getBrightness(hex2);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
var isDark = (color2) => (theme2) => tone(color2)(theme2) === "dark";
var transparentize = (color2, opacity) => (theme2) => {
  const raw2 = getColor(theme2, color2);
  return transparentize$1(raw2, 1 - opacity);
};
function generateStripe(size2 = "1rem", color2 = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${color2} 25%,
    transparent 25%,
    transparent 50%,
    ${color2} 50%,
    ${color2} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${size2} ${size2}`
  };
}
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function randomColor(opts) {
  const fallback = randomHex();
  if (!opts || isEmptyObject(opts)) {
    return fallback;
  }
  if (opts.string && opts.colors) {
    return randomColorFromList(opts.string, opts.colors);
  }
  if (opts.string && !opts.colors) {
    return randomColorFromString(opts.string);
  }
  if (opts.colors && !opts.string) {
    return randomFromList(opts.colors);
  }
  return fallback;
}
function randomColorFromString(str) {
  let hash2 = 0;
  if (str.length === 0)
    return hash2.toString();
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    hash2 = str.charCodeAt(i2) + ((hash2 << 5) - hash2);
    hash2 = hash2 & hash2;
  }
  let color2 = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash2 >> j * 8 & 255;
    color2 += `00${value.toString(16)}`.substr(-2);
  }
  return color2;
}
function randomColorFromList(str, list2) {
  let index2 = 0;
  if (str.length === 0)
    return list2[0];
  for (let i2 = 0; i2 < str.length; i2 += 1) {
    index2 = str.charCodeAt(i2) + ((index2 << 5) - index2);
    index2 = index2 & index2;
  }
  index2 = (index2 % list2.length + list2.length) % list2.length;
  return list2[index2];
}
function randomFromList(list2) {
  return list2[Math.floor(Math.random() * list2.length)];
}
function mode(light, dark) {
  return (props) => props.colorMode === "dark" ? dark : light;
}
function orient(options2) {
  const { orientation, vertical, horizontal } = options2;
  if (!orientation)
    return {};
  return orientation === "vertical" ? vertical : horizontal;
}
function toRef(operand) {
  if (isObject$1(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpr("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpr("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpr("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpr("/", ...operands)})`;
var negate = (x2) => {
  const value = toRef(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
function isDecimal(value) {
  return !Number.isInteger(parseFloat(value.toString()));
}
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape$1(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  if (valueStr.includes("\\."))
    return value;
  return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
}
function addPrefix(value, prefix2 = "") {
  return [prefix2, escape$1(value)].filter(Boolean).join("-");
}
function toVarRef(name2, fallback) {
  return `var(${escape$1(name2)}${fallback ? `, ${fallback}` : ""})`;
}
function toVar$1(value, prefix2 = "") {
  return `--${addPrefix(value, prefix2)}`;
}
function cssVar(name2, options2) {
  const cssVariable = toVar$1(name2, options2 == null ? void 0 : options2.prefix);
  return {
    variable: cssVariable,
    reference: toVarRef(cssVariable, getFallback(options2 == null ? void 0 : options2.fallback))
  };
}
function getFallback(fallback) {
  if (typeof fallback === "string")
    return fallback;
  return fallback == null ? void 0 : fallback.reference;
}
var { defineMultiStyleConfig: defineMultiStyleConfig$o, definePartsStyle: definePartsStyle$o } = createMultiStyleConfigHelpers(switchAnatomy.keys);
var $width = cssVar("switch-track-width");
var $height = cssVar("switch-track-height");
var $diff = cssVar("switch-track-diff");
var diffValue = calc.subtract($width, $height);
var $translateX = cssVar("switch-thumb-x");
var $bg$f = cssVar("switch-bg");
var baseStyleTrack$2 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [$width.reference],
    height: [$height.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [$bg$f.variable]: "colors.gray.300",
    _dark: {
      [$bg$f.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [$bg$f.variable]: `colors.${c2}.500`,
      _dark: {
        [$bg$f.variable]: `colors.${c2}.200`
      }
    },
    bg: $bg$f.reference
  };
});
var baseStyleThumb$1 = defineStyle({
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [$height.reference],
  height: [$height.reference],
  _checked: {
    transform: `translateX(${$translateX.reference})`
  }
});
var baseStyle$E = definePartsStyle$o((props) => ({
  container: {
    [$diff.variable]: diffValue,
    [$translateX.variable]: $diff.reference,
    _rtl: {
      [$translateX.variable]: calc($diff).negate().toString()
    }
  },
  track: baseStyleTrack$2(props),
  thumb: baseStyleThumb$1
}));
var sizes$l = {
  sm: definePartsStyle$o({
    container: {
      [$width.variable]: "1.375rem",
      [$height.variable]: "sizes.3"
    }
  }),
  md: definePartsStyle$o({
    container: {
      [$width.variable]: "1.875rem",
      [$height.variable]: "sizes.4"
    }
  }),
  lg: definePartsStyle$o({
    container: {
      [$width.variable]: "2.875rem",
      [$height.variable]: "sizes.6"
    }
  })
};
var switchTheme = defineMultiStyleConfig$o({
  baseStyle: baseStyle$E,
  sizes: sizes$l,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$n, definePartsStyle: definePartsStyle$n } = createMultiStyleConfigHelpers(tableAnatomy.keys);
var baseStyle$D = definePartsStyle$n({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
});
var numericStyles = defineStyle({
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
});
var variantSimple = definePartsStyle$n((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variantStripe = definePartsStyle$n((props) => {
  const { colorScheme: c2 } = props;
  return {
    th: {
      color: mode("gray.600", "gray.400")(props),
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    td: {
      borderBottom: "1px",
      borderColor: mode(`${c2}.100`, `${c2}.700`)(props),
      ...numericStyles
    },
    caption: {
      color: mode("gray.600", "gray.100")(props)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: mode(`${c2}.100`, `${c2}.700`)(props)
          },
          td: {
            background: mode(`${c2}.100`, `${c2}.700`)(props)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
});
var variants$b = {
  simple: variantSimple,
  striped: variantStripe,
  unstyled: defineStyle({})
};
var sizes$k = {
  sm: definePartsStyle$n({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: definePartsStyle$n({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: definePartsStyle$n({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
};
var tableTheme = defineMultiStyleConfig$n({
  baseStyle: baseStyle$D,
  variants: variants$b,
  sizes: sizes$k,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
});
var $fg$5 = cssVar$1("tabs-color");
var $bg$e = cssVar$1("tabs-bg");
var $border$3 = cssVar$1("tabs-border-color");
var { defineMultiStyleConfig: defineMultiStyleConfig$m, definePartsStyle: definePartsStyle$m } = createMultiStyleConfigHelpers(tabsAnatomy.keys);
var baseStyleRoot$1 = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: orientation === "vertical" ? "flex" : "block"
  };
});
var baseStyleTab = defineStyle((props) => {
  const { isFitted } = props;
  return {
    flex: isFitted ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
});
var baseStyleTablist = defineStyle((props) => {
  const { align = "start", orientation } = props;
  const alignments = {
    end: "flex-end",
    center: "center",
    start: "flex-start"
  };
  return {
    justifyContent: alignments[align],
    flexDirection: orientation === "vertical" ? "column" : "row"
  };
});
var baseStyleTabpanel = defineStyle({
  p: 4
});
var baseStyle$C = definePartsStyle$m((props) => ({
  root: baseStyleRoot$1(props),
  tab: baseStyleTab(props),
  tablist: baseStyleTablist(props),
  tabpanel: baseStyleTabpanel
}));
var sizes$j = {
  sm: definePartsStyle$m({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: definePartsStyle$m({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: definePartsStyle$m({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
};
var variantLine = definePartsStyle$m((props) => {
  const { colorScheme: c2, orientation } = props;
  const isVertical = orientation === "vertical";
  const borderProp = isVertical ? "borderStart" : "borderBottom";
  const marginProp = isVertical ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [borderProp]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [borderProp]: "2px solid",
      borderColor: "transparent",
      [marginProp]: "-2px",
      _selected: {
        [$fg$5.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg$5.variable]: `colors.${c2}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [$bg$e.variable]: "colors.gray.200",
        _dark: {
          [$bg$e.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    }
  };
});
var variantEnclosed = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [$border$3.variable]: "transparent",
      _selected: {
        [$fg$5.variable]: `colors.${c2}.600`,
        [$border$3.variable]: `colors.white`,
        _dark: {
          [$fg$5.variable]: `colors.${c2}.300`,
          [$border$3.variable]: `colors.gray.800`
        },
        borderColor: "inherit",
        borderBottomColor: $border$3.reference
      },
      color: $fg$5.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantEnclosedColored = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [$bg$e.variable]: "colors.gray.50",
      _dark: {
        [$bg$e.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [$bg$e.variable]: "colors.white",
        [$fg$5.variable]: `colors.${c2}.600`,
        _dark: {
          [$bg$e.variable]: "colors.gray.800",
          [$fg$5.variable]: `colors.${c2}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
});
var variantSoftRounded = definePartsStyle$m((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: getColor(theme2, `${c2}.700`),
        bg: getColor(theme2, `${c2}.100`)
      }
    }
  };
});
var variantSolidRounded = definePartsStyle$m((props) => {
  const { colorScheme: c2 } = props;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [$fg$5.variable]: "colors.gray.600",
      _dark: {
        [$fg$5.variable]: "inherit"
      },
      _selected: {
        [$fg$5.variable]: "colors.white",
        [$bg$e.variable]: `colors.${c2}.600`,
        _dark: {
          [$fg$5.variable]: "colors.gray.800",
          [$bg$e.variable]: `colors.${c2}.300`
        }
      },
      color: $fg$5.reference,
      bg: $bg$e.reference
    }
  };
});
var variantUnstyled$2 = definePartsStyle$m({});
var variants$a = {
  line: variantLine,
  enclosed: variantEnclosed,
  "enclosed-colored": variantEnclosedColored,
  "soft-rounded": variantSoftRounded,
  "solid-rounded": variantSolidRounded,
  unstyled: variantUnstyled$2
};
var tabsTheme = defineMultiStyleConfig$m({
  baseStyle: baseStyle$C,
  sizes: sizes$j,
  variants: variants$a,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
});
var vars = defineCssVars("badge", ["bg", "color", "shadow"]);
var baseStyle$B = defineStyle({
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var variantSolid$3 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const dark = transparentize(`${c2}.500`, 0.6)(theme2);
  return {
    [vars.bg.variable]: `colors.${c2}.500`,
    [vars.color.variable]: `colors.white`,
    _dark: {
      [vars.bg.variable]: dark,
      [vars.color.variable]: `colors.whiteAlpha.800`
    }
  };
});
var variantSubtle$1 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const darkBg = transparentize(`${c2}.200`, 0.16)(theme2);
  return {
    [vars.bg.variable]: `colors.${c2}.100`,
    [vars.color.variable]: `colors.${c2}.800`,
    _dark: {
      [vars.bg.variable]: darkBg,
      [vars.color.variable]: `colors.${c2}.200`
    }
  };
});
var variantOutline$2 = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  const darkColor = transparentize(`${c2}.200`, 0.8)(theme2);
  return {
    [vars.color.variable]: `colors.${c2}.500`,
    _dark: {
      [vars.color.variable]: darkColor
    },
    [vars.shadow.variable]: `inset 0 0 0px 1px ${vars.color.reference}`
  };
});
var variants$9 = {
  solid: variantSolid$3,
  subtle: variantSubtle$1,
  outline: variantOutline$2
};
var badgeTheme = defineStyleConfig({
  baseStyle: baseStyle$B,
  variants: variants$9,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$l, definePartsStyle: definePartsStyle$l } = createMultiStyleConfigHelpers(tagAnatomy.keys);
var $bg$d = cssVar$1("tag-bg");
var $color = cssVar$1("tag-color");
var $shadow$3 = cssVar$1("tag-shadow");
var $minH = cssVar$1("tag-min-height");
var $minW = cssVar$1("tag-min-width");
var $fontSize = cssVar$1("tag-font-size");
var $paddingX = cssVar$1("tag-padding-inline");
var baseStyleContainer$4 = defineStyle({
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [$color.variable]: vars.color.reference,
  [$bg$d.variable]: vars.bg.reference,
  [$shadow$3.variable]: vars.shadow.reference,
  color: $color.reference,
  bg: $bg$d.reference,
  boxShadow: $shadow$3.reference,
  borderRadius: "md",
  minH: $minH.reference,
  minW: $minW.reference,
  fontSize: $fontSize.reference,
  px: $paddingX.reference,
  _focusVisible: {
    [$shadow$3.variable]: "shadows.outline"
  }
});
var baseStyleLabel$4 = defineStyle({
  lineHeight: 1.2,
  overflow: "visible"
});
var baseStyleCloseButton$3 = defineStyle({
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
});
var baseStyle$A = definePartsStyle$l({
  container: baseStyleContainer$4,
  label: baseStyleLabel$4,
  closeButton: baseStyleCloseButton$3
});
var sizes$i = {
  sm: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.5",
      [$minW.variable]: "sizes.5",
      [$fontSize.variable]: "fontSizes.xs",
      [$paddingX.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.6",
      [$minW.variable]: "sizes.6",
      [$fontSize.variable]: "fontSizes.sm",
      [$paddingX.variable]: "space.2"
    }
  }),
  lg: definePartsStyle$l({
    container: {
      [$minH.variable]: "sizes.8",
      [$minW.variable]: "sizes.8",
      [$fontSize.variable]: "fontSizes.md",
      [$paddingX.variable]: "space.3"
    }
  })
};
var variants$8 = {
  subtle: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.subtle(props)
    };
  }),
  solid: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.solid(props)
    };
  }),
  outline: definePartsStyle$l((props) => {
    var _a4;
    return {
      container: (_a4 = badgeTheme.variants) == null ? void 0 : _a4.outline(props)
    };
  })
};
var tagTheme = defineMultiStyleConfig$l({
  variants: variants$8,
  baseStyle: baseStyle$A,
  sizes: sizes$i,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
});
var { definePartsStyle: definePartsStyle$k, defineMultiStyleConfig: defineMultiStyleConfig$k } = createMultiStyleConfigHelpers(inputAnatomy.keys);
var baseStyle$z = definePartsStyle$k({
  field: {
    width: "100%",
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
});
var size = {
  lg: defineStyle({
    fontSize: "lg",
    px: "4",
    h: "12",
    borderRadius: "md"
  }),
  md: defineStyle({
    fontSize: "md",
    px: "4",
    h: "10",
    borderRadius: "md"
  }),
  sm: defineStyle({
    fontSize: "sm",
    px: "3",
    h: "8",
    borderRadius: "sm"
  }),
  xs: defineStyle({
    fontSize: "xs",
    px: "2",
    h: "6",
    borderRadius: "sm"
  })
};
var sizes$h = {
  lg: definePartsStyle$k({
    field: size.lg,
    addon: size.lg
  }),
  md: definePartsStyle$k({
    field: size.md,
    addon: size.md
  }),
  sm: definePartsStyle$k({
    field: size.sm,
    addon: size.sm
  }),
  xs: definePartsStyle$k({
    field: size.xs,
    addon: size.xs
  })
};
function getDefaults(props) {
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = props;
  return {
    focusBorderColor: fc2 || mode("blue.500", "blue.300")(props),
    errorBorderColor: ec2 || mode("red.500", "red.300")(props)
  };
}
var variantOutline$1 = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: mode("gray.300", "whiteAlpha.400")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColorVar(theme2, ec2),
        boxShadow: `0 0 0 1px ${getColorVar(theme2, ec2)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: getColorVar(theme2, fc2),
        boxShadow: `0 0 0 1px ${getColorVar(theme2, fc2)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: mode("inherit", "whiteAlpha.50")(props),
      bg: mode("gray.100", "whiteAlpha.300")(props)
    }
  };
});
var variantFilled = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props),
      _hover: {
        bg: mode("gray.200", "whiteAlpha.100")(props)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColorVar(theme2, ec2)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: getColorVar(theme2, fc2)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: mode("gray.100", "whiteAlpha.50")(props)
    }
  };
});
var variantFlushed = definePartsStyle$k((props) => {
  const { theme: theme2 } = props;
  const { focusBorderColor: fc2, errorBorderColor: ec2 } = getDefaults(props);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: getColorVar(theme2, ec2),
        boxShadow: `0px 1px 0px 0px ${getColorVar(theme2, ec2)}`
      },
      _focusVisible: {
        borderColor: getColorVar(theme2, fc2),
        boxShadow: `0px 1px 0px 0px ${getColorVar(theme2, fc2)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
});
var variantUnstyled$1 = definePartsStyle$k({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
});
var variants$7 = {
  outline: variantOutline$1,
  filled: variantFilled,
  flushed: variantFlushed,
  unstyled: variantUnstyled$1
};
var inputTheme = defineMultiStyleConfig$k({
  baseStyle: baseStyle$z,
  sizes: sizes$h,
  variants: variants$7,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
var _a$3;
var baseStyle$y = defineStyle({
  ...(_a$3 = inputTheme.baseStyle) == null ? void 0 : _a$3.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
});
var _a2$2, _b$2;
var variants$6 = {
  outline: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.outline(props).field) != null ? _b3 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.flushed(props).field) != null ? _b3 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a4, _b3;
      return (_b3 = (_a4 = inputTheme.variants) == null ? void 0 : _a4.filled(props).field) != null ? _b3 : {};
    }
  ),
  unstyled: (_b$2 = (_a2$2 = inputTheme.variants) == null ? void 0 : _a2$2.unstyled.field) != null ? _b$2 : {}
};
var _a3, _b2, _c$1, _d$1, _e$1, _f$1, _g$1, _h$1;
var sizes$g = {
  xs: (_b2 = (_a3 = inputTheme.sizes) == null ? void 0 : _a3.xs.field) != null ? _b2 : {},
  sm: (_d$1 = (_c$1 = inputTheme.sizes) == null ? void 0 : _c$1.sm.field) != null ? _d$1 : {},
  md: (_f$1 = (_e$1 = inputTheme.sizes) == null ? void 0 : _e$1.md.field) != null ? _f$1 : {},
  lg: (_h$1 = (_g$1 = inputTheme.sizes) == null ? void 0 : _g$1.lg.field) != null ? _h$1 : {}
};
var textareaTheme = defineStyleConfig({
  baseStyle: baseStyle$y,
  sizes: sizes$g,
  variants: variants$6,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
});
var $bg$c = cssVar("tooltip-bg");
var $fg$4 = cssVar("tooltip-fg");
var $arrowBg$1 = cssVar("popper-arrow-bg");
var baseStyle$x = defineStyle({
  bg: $bg$c.reference,
  color: $fg$4.reference,
  [$bg$c.variable]: "colors.gray.700",
  [$fg$4.variable]: "colors.whiteAlpha.900",
  _dark: {
    [$bg$c.variable]: "colors.gray.300",
    [$fg$4.variable]: "colors.gray.900"
  },
  [$arrowBg$1.variable]: $bg$c.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
});
var tooltipTheme = defineStyleConfig({
  baseStyle: baseStyle$x
});
var { defineMultiStyleConfig: defineMultiStyleConfig$j, definePartsStyle: definePartsStyle$j } = createMultiStyleConfigHelpers(progressAnatomy.keys);
var filledStyle = defineStyle((props) => {
  const { colorScheme: c2, theme: t2, isIndeterminate, hasStripe } = props;
  const stripeStyle = mode(
    generateStripe(),
    generateStripe("1rem", "rgba(0,0,0,0.1)")
  )(props);
  const bgColor = mode(`${c2}.500`, `${c2}.200`)(props);
  const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${getColorVar(t2, bgColor)} 50%,
    transparent 100%
  )`;
  const addStripe = !isIndeterminate && hasStripe;
  return {
    ...addStripe && stripeStyle,
    ...isIndeterminate ? { bgImage: gradient } : { bgColor }
  };
});
var baseStyleLabel$3 = defineStyle({
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
});
var baseStyleTrack$1 = defineStyle((props) => {
  return {
    bg: mode("gray.100", "whiteAlpha.300")(props)
  };
});
var baseStyleFilledTrack$1 = defineStyle((props) => {
  return {
    transitionProperty: "common",
    transitionDuration: "slow",
    ...filledStyle(props)
  };
});
var baseStyle$w = definePartsStyle$j((props) => ({
  label: baseStyleLabel$3,
  filledTrack: baseStyleFilledTrack$1(props),
  track: baseStyleTrack$1(props)
}));
var sizes$f = {
  xs: definePartsStyle$j({
    track: { h: "1" }
  }),
  sm: definePartsStyle$j({
    track: { h: "2" }
  }),
  md: definePartsStyle$j({
    track: { h: "3" }
  }),
  lg: definePartsStyle$j({
    track: { h: "4" }
  })
};
var progressTheme = defineMultiStyleConfig$j({
  sizes: sizes$f,
  baseStyle: baseStyle$w,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var isFunction$3 = (value) => typeof value === "function";
function runIfFn$1(valueOrFn, ...args) {
  return isFunction$3(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
var { definePartsStyle: definePartsStyle$i, defineMultiStyleConfig: defineMultiStyleConfig$i } = createMultiStyleConfigHelpers(checkboxAnatomy.keys);
var $size$3 = cssVar$1("checkbox-size");
var baseStyleControl$1 = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    w: $size$3.reference,
    h: $size$3.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props),
      _hover: {
        bg: mode(`${c2}.600`, `${c2}.300`)(props),
        borderColor: mode(`${c2}.600`, `${c2}.300`)(props)
      },
      _disabled: {
        borderColor: mode("gray.200", "transparent")(props),
        bg: mode("gray.200", "whiteAlpha.300")(props),
        color: mode("gray.500", "whiteAlpha.500")(props)
      }
    },
    _indeterminate: {
      bg: mode(`${c2}.500`, `${c2}.200`)(props),
      borderColor: mode(`${c2}.500`, `${c2}.200`)(props),
      color: mode("white", "gray.900")(props)
    },
    _disabled: {
      bg: mode("gray.100", "whiteAlpha.100")(props),
      borderColor: mode("gray.100", "transparent")(props)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: mode("red.500", "red.300")(props)
    }
  };
});
var baseStyleContainer$3 = defineStyle({
  _disabled: { cursor: "not-allowed" }
});
var baseStyleLabel$2 = defineStyle({
  userSelect: "none",
  _disabled: { opacity: 0.4 }
});
var baseStyleIcon$5 = defineStyle({
  transitionProperty: "transform",
  transitionDuration: "normal"
});
var baseStyle$v = definePartsStyle$i((props) => ({
  icon: baseStyleIcon$5,
  container: baseStyleContainer$3,
  control: runIfFn$1(baseStyleControl$1, props),
  label: baseStyleLabel$2
}));
var sizes$e = {
  sm: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: definePartsStyle$i({
    control: { [$size$3.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
};
var checkboxTheme = defineMultiStyleConfig$i({
  baseStyle: baseStyle$v,
  sizes: sizes$e,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$h, definePartsStyle: definePartsStyle$h } = createMultiStyleConfigHelpers(radioAnatomy.keys);
var baseStyleControl = defineStyle((props) => {
  var _a4;
  const controlStyle = (_a4 = runIfFn$1(checkboxTheme.baseStyle, props)) == null ? void 0 : _a4.control;
  return {
    ...controlStyle,
    borderRadius: "full",
    _checked: {
      ...controlStyle == null ? void 0 : controlStyle["_checked"],
      _before: {
        content: `""`,
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
});
var baseStyle$u = definePartsStyle$h((props) => {
  var _a4, _b3, _c2, _d2;
  return {
    label: (_b3 = (_a4 = checkboxTheme).baseStyle) == null ? void 0 : _b3.call(_a4, props).label,
    container: (_d2 = (_c2 = checkboxTheme).baseStyle) == null ? void 0 : _d2.call(_c2, props).container,
    control: baseStyleControl(props)
  };
});
var sizes$d = {
  md: definePartsStyle$h({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: definePartsStyle$h({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: definePartsStyle$h({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
};
var radioTheme = defineMultiStyleConfig$h({
  baseStyle: baseStyle$u,
  sizes: sizes$d,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$g, definePartsStyle: definePartsStyle$g } = createMultiStyleConfigHelpers(selectAnatomy.keys);
var $bg$b = cssVar$1("select-bg");
var _a$2;
var baseStyleField$1 = defineStyle({
  ...(_a$2 = inputTheme.baseStyle) == null ? void 0 : _a$2.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: $bg$b.reference,
  [$bg$b.variable]: "colors.white",
  _dark: {
    [$bg$b.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: $bg$b.reference
  }
});
var baseStyleIcon$4 = defineStyle({
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
});
var baseStyle$t = definePartsStyle$g({
  field: baseStyleField$1,
  icon: baseStyleIcon$4
});
var iconSpacing = defineStyle({
  paddingInlineEnd: "8"
});
var _a2$1, _b$1, _c, _d, _e, _f, _g, _h;
var sizes$c = {
  lg: {
    ...(_a2$1 = inputTheme.sizes) == null ? void 0 : _a2$1.lg,
    field: {
      ...(_b$1 = inputTheme.sizes) == null ? void 0 : _b$1.lg.field,
      ...iconSpacing
    }
  },
  md: {
    ...(_c = inputTheme.sizes) == null ? void 0 : _c.md,
    field: {
      ...(_d = inputTheme.sizes) == null ? void 0 : _d.md.field,
      ...iconSpacing
    }
  },
  sm: {
    ...(_e = inputTheme.sizes) == null ? void 0 : _e.sm,
    field: {
      ...(_f = inputTheme.sizes) == null ? void 0 : _f.sm.field,
      ...iconSpacing
    }
  },
  xs: {
    ...(_g = inputTheme.sizes) == null ? void 0 : _g.xs,
    field: {
      ...(_h = inputTheme.sizes) == null ? void 0 : _h.xs.field,
      ...iconSpacing
    },
    icon: {
      insetEnd: "1"
    }
  }
};
var selectTheme = defineMultiStyleConfig$g({
  baseStyle: baseStyle$t,
  sizes: sizes$c,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});
var $startColor = cssVar$1("skeleton-start-color");
var $endColor = cssVar$1("skeleton-end-color");
var baseStyle$s = defineStyle({
  [$startColor.variable]: "colors.gray.100",
  [$endColor.variable]: "colors.gray.400",
  _dark: {
    [$startColor.variable]: "colors.gray.800",
    [$endColor.variable]: "colors.gray.600"
  },
  background: $startColor.reference,
  borderColor: $endColor.reference,
  opacity: 0.7,
  borderRadius: "sm"
});
var skeletonTheme = defineStyleConfig({
  baseStyle: baseStyle$s
});
var $bg$a = cssVar$1("skip-link-bg");
var baseStyle$r = defineStyle({
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [$bg$a.variable]: "colors.white",
    _dark: {
      [$bg$a.variable]: "colors.gray.700"
    },
    bg: $bg$a.reference
  }
});
var skipLinkTheme = defineStyleConfig({
  baseStyle: baseStyle$r
});
var { defineMultiStyleConfig: defineMultiStyleConfig$f, definePartsStyle: definePartsStyle$f } = createMultiStyleConfigHelpers(sliderAnatomy.keys);
var $thumbSize = cssVar$1("slider-thumb-size");
var $trackSize = cssVar$1("slider-track-size");
var $bg$9 = cssVar$1("slider-bg");
var baseStyleContainer$2 = defineStyle((props) => {
  const { orientation } = props;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...orient({
      orientation,
      vertical: { h: "100%" },
      horizontal: { w: "100%" }
    })
  };
});
var baseStyleTrack = defineStyle((props) => {
  const orientationStyles = orient({
    orientation: props.orientation,
    horizontal: { h: $trackSize.reference },
    vertical: { w: $trackSize.reference }
  });
  return {
    ...orientationStyles,
    overflow: "hidden",
    borderRadius: "sm",
    [$bg$9.variable]: "colors.gray.200",
    _dark: {
      [$bg$9.variable]: "colors.whiteAlpha.200"
    },
    _disabled: {
      [$bg$9.variable]: "colors.gray.300",
      _dark: {
        [$bg$9.variable]: "colors.whiteAlpha.300"
      }
    },
    bg: $bg$9.reference
  };
});
var baseStyleThumb = defineStyle((props) => {
  const { orientation } = props;
  const orientationStyle = orient({
    orientation,
    vertical: {
      left: "50%",
      transform: `translateX(-50%)`,
      _active: {
        transform: `translateX(-50%) scale(1.15)`
      }
    },
    horizontal: {
      top: "50%",
      transform: `translateY(-50%)`,
      _active: {
        transform: `translateY(-50%) scale(1.15)`
      }
    }
  });
  return {
    ...orientationStyle,
    w: $thumbSize.reference,
    h: $thumbSize.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
});
var baseStyleFilledTrack = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    width: "inherit",
    height: "inherit",
    [$bg$9.variable]: `colors.${c2}.500`,
    _dark: {
      [$bg$9.variable]: `colors.${c2}.200`
    },
    bg: $bg$9.reference
  };
});
var baseStyle$q = definePartsStyle$f((props) => ({
  container: baseStyleContainer$2(props),
  track: baseStyleTrack(props),
  thumb: baseStyleThumb(props),
  filledTrack: baseStyleFilledTrack(props)
}));
var sizeLg = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.4`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeMd = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.3.5`,
    [$trackSize.variable]: `sizes.1`
  }
});
var sizeSm = definePartsStyle$f({
  container: {
    [$thumbSize.variable]: `sizes.2.5`,
    [$trackSize.variable]: `sizes.0.5`
  }
});
var sizes$b = {
  lg: sizeLg,
  md: sizeMd,
  sm: sizeSm
};
var sliderTheme = defineMultiStyleConfig$f({
  baseStyle: baseStyle$q,
  sizes: sizes$b,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
});
var $size$2 = cssVar("spinner-size");
var baseStyle$p = defineStyle({
  width: [$size$2.reference],
  height: [$size$2.reference]
});
var sizes$a = {
  xs: defineStyle({
    [$size$2.variable]: "sizes.3"
  }),
  sm: defineStyle({
    [$size$2.variable]: "sizes.4"
  }),
  md: defineStyle({
    [$size$2.variable]: "sizes.6"
  }),
  lg: defineStyle({
    [$size$2.variable]: "sizes.8"
  }),
  xl: defineStyle({
    [$size$2.variable]: "sizes.12"
  })
};
var spinnerTheme = defineStyleConfig({
  baseStyle: baseStyle$p,
  sizes: sizes$a,
  defaultProps: {
    size: "md"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$e, definePartsStyle: definePartsStyle$e } = createMultiStyleConfigHelpers(statAnatomy.keys);
var baseStyleLabel$1 = defineStyle({
  fontWeight: "medium"
});
var baseStyleHelpText = defineStyle({
  opacity: 0.8,
  marginBottom: "2"
});
var baseStyleNumber = defineStyle({
  verticalAlign: "baseline",
  fontWeight: "semibold"
});
var baseStyleIcon$3 = defineStyle({
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
});
var baseStyle$o = definePartsStyle$e({
  container: {},
  label: baseStyleLabel$1,
  helpText: baseStyleHelpText,
  number: baseStyleNumber,
  icon: baseStyleIcon$3
});
var sizes$9 = {
  md: definePartsStyle$e({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
};
var statTheme = defineMultiStyleConfig$e({
  baseStyle: baseStyle$o,
  sizes: sizes$9,
  defaultProps: {
    size: "md"
  }
});
var $bg$8 = cssVar$1("kbd-bg");
var baseStyle$n = defineStyle({
  [$bg$8.variable]: "colors.gray.100",
  _dark: {
    [$bg$8.variable]: "colors.whiteAlpha.100"
  },
  bg: $bg$8.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
});
var kbdTheme = defineStyleConfig({
  baseStyle: baseStyle$n
});
var baseStyle$m = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
});
var linkTheme = defineStyleConfig({
  baseStyle: baseStyle$m
});
var { defineMultiStyleConfig: defineMultiStyleConfig$d, definePartsStyle: definePartsStyle$d } = createMultiStyleConfigHelpers(listAnatomy.keys);
var baseStyleIcon$2 = defineStyle({
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
});
var baseStyle$l = definePartsStyle$d({
  icon: baseStyleIcon$2
});
var listTheme = defineMultiStyleConfig$d({
  baseStyle: baseStyle$l
});
var { defineMultiStyleConfig: defineMultiStyleConfig$c, definePartsStyle: definePartsStyle$c } = createMultiStyleConfigHelpers(menuAnatomy.keys);
var $bg$7 = cssVar$1("menu-bg");
var $shadow$2 = cssVar$1("menu-shadow");
var baseStyleList = defineStyle({
  [$bg$7.variable]: "#fff",
  [$shadow$2.variable]: "shadows.sm",
  _dark: {
    [$bg$7.variable]: "colors.gray.700",
    [$shadow$2.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: 1,
  borderRadius: "md",
  borderWidth: "1px",
  bg: $bg$7.reference,
  boxShadow: $shadow$2.reference
});
var baseStyleItem = defineStyle({
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [$bg$7.variable]: "colors.gray.100",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg$7.variable]: "colors.gray.200",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [$bg$7.variable]: "colors.gray.100",
    _dark: {
      [$bg$7.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: $bg$7.reference
});
var baseStyleGroupTitle = defineStyle({
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
});
var baseStyleCommand = defineStyle({
  opacity: 0.6
});
var baseStyleDivider = defineStyle({
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
});
var baseStyleButton$1 = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyle$k = definePartsStyle$c({
  button: baseStyleButton$1,
  list: baseStyleList,
  item: baseStyleItem,
  groupTitle: baseStyleGroupTitle,
  command: baseStyleCommand,
  divider: baseStyleDivider
});
var menuTheme = defineMultiStyleConfig$c({
  baseStyle: baseStyle$k
});
var { defineMultiStyleConfig: defineMultiStyleConfig$b, definePartsStyle: definePartsStyle$b } = createMultiStyleConfigHelpers(modalAnatomy.keys);
var $bg$6 = cssVar$1("modal-bg");
var $shadow$1 = cssVar$1("modal-shadow");
var baseStyleOverlay$1 = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "modal"
});
var baseStyleDialogContainer$1 = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: isCentered ? "center" : "flex-start",
    overflow: scrollBehavior === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
});
var baseStyleDialog$1 = defineStyle((props) => {
  const { isCentered, scrollBehavior } = props;
  return {
    borderRadius: "md",
    color: "inherit",
    my: isCentered ? "auto" : "16",
    mx: isCentered ? "auto" : void 0,
    zIndex: "modal",
    maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [$bg$6.variable]: "colors.white",
    [$shadow$1.variable]: "shadows.lg",
    _dark: {
      [$bg$6.variable]: "colors.gray.700",
      [$shadow$1.variable]: "shadows.dark-lg"
    },
    bg: $bg$6.reference,
    boxShadow: $shadow$1.reference
  };
});
var baseStyleHeader$2 = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton$2 = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody$2 = defineStyle((props) => {
  const { scrollBehavior } = props;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: scrollBehavior === "inside" ? "auto" : void 0
  };
});
var baseStyleFooter$2 = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle$j = definePartsStyle$b((props) => ({
  overlay: baseStyleOverlay$1,
  dialogContainer: runIfFn$1(baseStyleDialogContainer$1, props),
  dialog: runIfFn$1(baseStyleDialog$1, props),
  header: baseStyleHeader$2,
  closeButton: baseStyleCloseButton$2,
  body: runIfFn$1(baseStyleBody$2, props),
  footer: baseStyleFooter$2
}));
function getSize$3(value) {
  if (value === "full") {
    return definePartsStyle$b({
      dialog: {
        maxW: "100vw",
        minH: "$100vh",
        my: "0",
        borderRadius: "0"
      }
    });
  }
  return definePartsStyle$b({
    dialog: { maxW: value }
  });
}
var sizes$8 = {
  xs: getSize$3("xs"),
  sm: getSize$3("sm"),
  md: getSize$3("md"),
  lg: getSize$3("lg"),
  xl: getSize$3("xl"),
  "2xl": getSize$3("2xl"),
  "3xl": getSize$3("3xl"),
  "4xl": getSize$3("4xl"),
  "5xl": getSize$3("5xl"),
  "6xl": getSize$3("6xl"),
  full: getSize$3("full")
};
var modalTheme = defineMultiStyleConfig$b({
  baseStyle: baseStyle$j,
  sizes: sizes$8,
  defaultProps: { size: "md" }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$a, definePartsStyle: definePartsStyle$a } = createMultiStyleConfigHelpers(numberInputAnatomy.keys);
var $stepperWidth = cssVar("number-input-stepper-width");
var $inputPadding = cssVar("number-input-input-padding");
var inputPaddingValue = calc($stepperWidth).add("0.5rem").toString();
var $bg$5 = cssVar("number-input-bg");
var $fg$3 = cssVar("number-input-color");
var $border$2 = cssVar("number-input-border-color");
var baseStyleRoot = defineStyle({
  [$stepperWidth.variable]: "sizes.6",
  [$inputPadding.variable]: inputPaddingValue
});
var baseStyleField = defineStyle(
  (props) => {
    var _a4, _b3;
    return (_b3 = (_a4 = runIfFn$1(inputTheme.baseStyle, props)) == null ? void 0 : _a4.field) != null ? _b3 : {};
  }
);
var baseStyleStepperGroup = defineStyle({
  width: $stepperWidth.reference
});
var baseStyleStepper = defineStyle({
  borderStart: "1px solid",
  borderStartColor: $border$2.reference,
  color: $fg$3.reference,
  bg: $bg$5.reference,
  [$fg$3.variable]: "colors.chakra-body-text",
  [$border$2.variable]: "colors.chakra-border-color",
  _dark: {
    [$fg$3.variable]: "colors.whiteAlpha.800",
    [$border$2.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [$bg$5.variable]: "colors.gray.200",
    _dark: {
      [$bg$5.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
});
var baseStyle$i = definePartsStyle$a((props) => {
  var _a4;
  return {
    root: baseStyleRoot,
    field: (_a4 = runIfFn$1(baseStyleField, props)) != null ? _a4 : {},
    stepperGroup: baseStyleStepperGroup,
    stepper: baseStyleStepper
  };
});
function getSize$2(size2) {
  var _a4, _b3, _c2;
  const sizeStyle = (_a4 = inputTheme.sizes) == null ? void 0 : _a4[size2];
  const radius2 = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  };
  const _fontSize = (_c2 = (_b3 = sizeStyle.field) == null ? void 0 : _b3.fontSize) != null ? _c2 : "md";
  const fontSize2 = typography_default.fontSizes[_fontSize];
  return definePartsStyle$a({
    field: {
      ...sizeStyle.field,
      paddingInlineEnd: $inputPadding.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: calc(fontSize2).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: radius2[size2]
      },
      _last: {
        borderBottomEndRadius: radius2[size2],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
var sizes$7 = {
  xs: getSize$2("xs"),
  sm: getSize$2("sm"),
  md: getSize$2("md"),
  lg: getSize$2("lg")
};
var numberInputTheme = defineMultiStyleConfig$a({
  baseStyle: baseStyle$i,
  sizes: sizes$7,
  variants: inputTheme.variants,
  defaultProps: inputTheme.defaultProps
});
var _a$1;
var baseStyle$h = defineStyle({
  ...(_a$1 = inputTheme.baseStyle) == null ? void 0 : _a$1.field,
  textAlign: "center"
});
var sizes$6 = {
  lg: defineStyle({
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  }),
  md: defineStyle({
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  }),
  sm: defineStyle({
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  }),
  xs: defineStyle({
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  })
};
var _a2, _b;
var variants$5 = {
  outline: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.outline, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  flushed: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.flushed, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  filled: defineStyle(
    (props) => {
      var _a32, _b22, _c2;
      return (_c2 = (_b22 = runIfFn$1((_a32 = inputTheme.variants) == null ? void 0 : _a32.filled, props)) == null ? void 0 : _b22.field) != null ? _c2 : {};
    }
  ),
  unstyled: (_b = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
};
var pinInputTheme = defineStyleConfig({
  baseStyle: baseStyle$h,
  sizes: sizes$6,
  variants: variants$5,
  defaultProps: inputTheme.defaultProps
});
var { defineMultiStyleConfig: defineMultiStyleConfig$9, definePartsStyle: definePartsStyle$9 } = createMultiStyleConfigHelpers(popoverAnatomy.keys);
var $popperBg = cssVar("popper-bg");
var $arrowBg = cssVar("popper-arrow-bg");
var $arrowShadowColor = cssVar("popper-arrow-shadow-color");
var baseStylePopper = defineStyle({ zIndex: 10 });
var baseStyleContent = defineStyle({
  [$popperBg.variable]: `colors.white`,
  bg: $popperBg.reference,
  [$arrowBg.variable]: $popperBg.reference,
  [$arrowShadowColor.variable]: `colors.gray.200`,
  _dark: {
    [$popperBg.variable]: `colors.gray.700`,
    [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
});
var baseStyleHeader$1 = defineStyle({
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
});
var baseStyleBody$1 = defineStyle({
  px: 3,
  py: 2
});
var baseStyleFooter$1 = defineStyle({
  px: 3,
  py: 2,
  borderTopWidth: "1px"
});
var baseStyleCloseButton$1 = defineStyle({
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
});
var baseStyle$g = definePartsStyle$9({
  popper: baseStylePopper,
  content: baseStyleContent,
  header: baseStyleHeader$1,
  body: baseStyleBody$1,
  footer: baseStyleFooter$1,
  closeButton: baseStyleCloseButton$1
});
var popoverTheme = defineMultiStyleConfig$9({
  baseStyle: baseStyle$g
});
var { definePartsStyle: definePartsStyle$8, defineMultiStyleConfig: defineMultiStyleConfig$8 } = createMultiStyleConfigHelpers(drawerAnatomy.keys);
var $bg$4 = cssVar$1("drawer-bg");
var $bs = cssVar$1("drawer-box-shadow");
function getSize$1(value) {
  if (value === "full") {
    return definePartsStyle$8({
      dialog: { maxW: "100vw", h: "100vh" }
    });
  }
  return definePartsStyle$8({
    dialog: { maxW: value }
  });
}
var baseStyleOverlay = defineStyle({
  bg: "blackAlpha.600",
  zIndex: "overlay"
});
var baseStyleDialogContainer = defineStyle({
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
});
var baseStyleDialog = defineStyle((props) => {
  const { isFullHeight } = props;
  return {
    ...isFullHeight && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [$bg$4.variable]: "colors.white",
    [$bs.variable]: "shadows.lg",
    _dark: {
      [$bg$4.variable]: "colors.gray.700",
      [$bs.variable]: "shadows.dark-lg"
    },
    bg: $bg$4.reference,
    boxShadow: $bs.reference
  };
});
var baseStyleHeader = defineStyle({
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
});
var baseStyleCloseButton = defineStyle({
  position: "absolute",
  top: "2",
  insetEnd: "3"
});
var baseStyleBody = defineStyle({
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
});
var baseStyleFooter = defineStyle({
  px: "6",
  py: "4"
});
var baseStyle$f = definePartsStyle$8((props) => ({
  overlay: baseStyleOverlay,
  dialogContainer: baseStyleDialogContainer,
  dialog: runIfFn$1(baseStyleDialog, props),
  header: baseStyleHeader,
  closeButton: baseStyleCloseButton,
  body: baseStyleBody,
  footer: baseStyleFooter
}));
var sizes$5 = {
  xs: getSize$1("xs"),
  sm: getSize$1("md"),
  md: getSize$1("lg"),
  lg: getSize$1("2xl"),
  xl: getSize$1("4xl"),
  full: getSize$1("full")
};
var drawerTheme = defineMultiStyleConfig$8({
  baseStyle: baseStyle$f,
  sizes: sizes$5,
  defaultProps: {
    size: "xs"
  }
});
var { definePartsStyle: definePartsStyle$7, defineMultiStyleConfig: defineMultiStyleConfig$7 } = createMultiStyleConfigHelpers(editableAnatomy.keys);
var baseStylePreview = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
});
var baseStyleInput = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyleTextarea = defineStyle({
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
});
var baseStyle$e = definePartsStyle$7({
  preview: baseStylePreview,
  input: baseStyleInput,
  textarea: baseStyleTextarea
});
var editableTheme = defineMultiStyleConfig$7({
  baseStyle: baseStyle$e
});
var { definePartsStyle: definePartsStyle$6, defineMultiStyleConfig: defineMultiStyleConfig$6 } = createMultiStyleConfigHelpers(formAnatomy.keys);
var $fg$2 = cssVar$1("form-control-color");
var baseStyleRequiredIndicator = defineStyle({
  marginStart: "1",
  [$fg$2.variable]: "colors.red.500",
  _dark: {
    [$fg$2.variable]: "colors.red.300"
  },
  color: $fg$2.reference
});
var baseStyleHelperText = defineStyle({
  mt: "2",
  [$fg$2.variable]: "colors.gray.600",
  _dark: {
    [$fg$2.variable]: "colors.whiteAlpha.600"
  },
  color: $fg$2.reference,
  lineHeight: "normal",
  fontSize: "sm"
});
var baseStyle$d = definePartsStyle$6({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: baseStyleRequiredIndicator,
  helperText: baseStyleHelperText
});
var formTheme = defineMultiStyleConfig$6({
  baseStyle: baseStyle$d
});
var { definePartsStyle: definePartsStyle$5, defineMultiStyleConfig: defineMultiStyleConfig$5 } = createMultiStyleConfigHelpers(formErrorAnatomy.keys);
var $fg$1 = cssVar$1("form-error-color");
var baseStyleText = defineStyle({
  [$fg$1.variable]: `colors.red.500`,
  _dark: {
    [$fg$1.variable]: `colors.red.300`
  },
  color: $fg$1.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
});
var baseStyleIcon$1 = defineStyle({
  marginEnd: "0.5em",
  [$fg$1.variable]: `colors.red.500`,
  _dark: {
    [$fg$1.variable]: `colors.red.300`
  },
  color: $fg$1.reference
});
var baseStyle$c = definePartsStyle$5({
  text: baseStyleText,
  icon: baseStyleIcon$1
});
var formErrorTheme = defineMultiStyleConfig$5({
  baseStyle: baseStyle$c
});
var baseStyle$b = defineStyle({
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
});
var formLabelTheme = defineStyleConfig({
  baseStyle: baseStyle$b
});
var baseStyle$a = defineStyle({
  fontFamily: "heading",
  fontWeight: "bold"
});
var sizes$4 = {
  "4xl": defineStyle({
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  }),
  "3xl": defineStyle({
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  }),
  "2xl": defineStyle({
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  }),
  xl: defineStyle({
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  lg: defineStyle({
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  }),
  md: defineStyle({
    fontSize: "xl",
    lineHeight: 1.2
  }),
  sm: defineStyle({
    fontSize: "md",
    lineHeight: 1.2
  }),
  xs: defineStyle({
    fontSize: "sm",
    lineHeight: 1.2
  })
};
var headingTheme = defineStyleConfig({
  baseStyle: baseStyle$a,
  sizes: sizes$4,
  defaultProps: {
    size: "xl"
  }
});
var { defineMultiStyleConfig: defineMultiStyleConfig$4, definePartsStyle: definePartsStyle$4 } = createMultiStyleConfigHelpers(breadcrumbAnatomy.keys);
var $decor = cssVar$1("breadcrumb-link-decor");
var baseStyleLink = defineStyle({
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: $decor.reference,
  [$decor.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [$decor.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
});
var baseStyle$9 = definePartsStyle$4({
  link: baseStyleLink
});
var breadcrumbTheme = defineMultiStyleConfig$4({
  baseStyle: baseStyle$9
});
var baseStyle$8 = defineStyle({
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
});
var variantGhost = defineStyle((props) => {
  const { colorScheme: c2, theme: theme2 } = props;
  if (c2 === "gray") {
    return {
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.100`, `whiteAlpha.200`)(props)
      },
      _active: { bg: mode(`gray.200`, `whiteAlpha.300`)(props) }
    };
  }
  const darkHoverBg = transparentize(`${c2}.200`, 0.12)(theme2);
  const darkActiveBg = transparentize(`${c2}.200`, 0.24)(theme2);
  return {
    color: mode(`${c2}.600`, `${c2}.200`)(props),
    bg: "transparent",
    _hover: {
      bg: mode(`${c2}.50`, darkHoverBg)(props)
    },
    _active: {
      bg: mode(`${c2}.100`, darkActiveBg)(props)
    }
  };
});
var variantOutline = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  const borderColor = mode(`gray.200`, `whiteAlpha.300`)(props);
  return {
    border: "1px solid",
    borderColor: c2 === "gray" ? borderColor : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...runIfFn$1(variantGhost, props)
  };
});
var accessibleColorMap = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
};
var variantSolid$2 = defineStyle((props) => {
  var _a4;
  const { colorScheme: c2 } = props;
  if (c2 === "gray") {
    const bg22 = mode(`gray.100`, `whiteAlpha.200`)(props);
    return {
      bg: bg22,
      color: mode(`gray.800`, `whiteAlpha.900`)(props),
      _hover: {
        bg: mode(`gray.200`, `whiteAlpha.300`)(props),
        _disabled: {
          bg: bg22
        }
      },
      _active: { bg: mode(`gray.300`, `whiteAlpha.400`)(props) }
    };
  }
  const {
    bg: bg2 = `${c2}.500`,
    color: color2 = "white",
    hoverBg = `${c2}.600`,
    activeBg = `${c2}.700`
  } = (_a4 = accessibleColorMap[c2]) != null ? _a4 : {};
  const background2 = mode(bg2, `${c2}.200`)(props);
  return {
    bg: background2,
    color: mode(color2, `gray.800`)(props),
    _hover: {
      bg: mode(hoverBg, `${c2}.300`)(props),
      _disabled: {
        bg: background2
      }
    },
    _active: { bg: mode(activeBg, `${c2}.400`)(props) }
  };
});
var variantLink = defineStyle((props) => {
  const { colorScheme: c2 } = props;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: mode(`${c2}.500`, `${c2}.200`)(props),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: mode(`${c2}.700`, `${c2}.500`)(props)
    }
  };
});
var variantUnstyled = defineStyle({
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
});
var variants$4 = {
  ghost: variantGhost,
  outline: variantOutline,
  solid: variantSolid$2,
  link: variantLink,
  unstyled: variantUnstyled
};
var sizes$3 = {
  lg: defineStyle({
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  }),
  md: defineStyle({
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  }),
  sm: defineStyle({
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  }),
  xs: defineStyle({
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  })
};
var buttonTheme = defineStyleConfig({
  baseStyle: baseStyle$8,
  variants: variants$4,
  sizes: sizes$3,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
});
var { definePartsStyle: definePartsStyle$3, defineMultiStyleConfig: defineMultiStyleConfig$3 } = createMultiStyleConfigHelpers(cardAnatomy.keys);
var $bg$3 = cssVar$1("card-bg");
var $padding = cssVar$1("card-padding");
var $shadow = cssVar$1("card-shadow");
var $radius = cssVar$1("card-radius");
var $border$1 = cssVar$1("card-border-width", "0");
var $borderColor = cssVar$1("card-border-color");
var baseStyle$7 = definePartsStyle$3({
  container: {
    [$bg$3.variable]: "colors.chakra-body-bg",
    backgroundColor: $bg$3.reference,
    boxShadow: $shadow.reference,
    borderRadius: $radius.reference,
    color: "chakra-body-text",
    borderWidth: $border$1.reference,
    borderColor: $borderColor.reference
  },
  body: {
    padding: $padding.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: $padding.reference
  },
  footer: {
    padding: $padding.reference
  }
});
var sizes$2 = {
  sm: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.base",
      [$padding.variable]: "space.3"
    }
  }),
  md: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.md",
      [$padding.variable]: "space.5"
    }
  }),
  lg: definePartsStyle$3({
    container: {
      [$radius.variable]: "radii.xl",
      [$padding.variable]: "space.7"
    }
  })
};
var variants$3 = {
  elevated: definePartsStyle$3({
    container: {
      [$shadow.variable]: "shadows.base",
      _dark: {
        [$bg$3.variable]: "colors.gray.700"
      }
    }
  }),
  outline: definePartsStyle$3({
    container: {
      [$border$1.variable]: "1px",
      [$borderColor.variable]: "colors.chakra-border-color"
    }
  }),
  filled: definePartsStyle$3({
    container: {
      [$bg$3.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [$padding.variable]: 0
    },
    header: {
      [$padding.variable]: 0
    },
    footer: {
      [$padding.variable]: 0
    }
  }
};
var cardTheme = defineMultiStyleConfig$3({
  baseStyle: baseStyle$7,
  variants: variants$3,
  sizes: sizes$2,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
});
var $size$1 = cssVar("close-button-size");
var $bg$2 = cssVar("close-button-bg");
var baseStyle$6 = defineStyle({
  w: [$size$1.reference],
  h: [$size$1.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [$bg$2.variable]: "colors.blackAlpha.100",
    _dark: {
      [$bg$2.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [$bg$2.variable]: "colors.blackAlpha.200",
    _dark: {
      [$bg$2.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: $bg$2.reference
});
var sizes$1 = {
  lg: defineStyle({
    [$size$1.variable]: "sizes.10",
    fontSize: "md"
  }),
  md: defineStyle({
    [$size$1.variable]: "sizes.8",
    fontSize: "xs"
  }),
  sm: defineStyle({
    [$size$1.variable]: "sizes.6",
    fontSize: "2xs"
  })
};
var closeButtonTheme = defineStyleConfig({
  baseStyle: baseStyle$6,
  sizes: sizes$1,
  defaultProps: {
    size: "md"
  }
});
var { variants: variants$2, defaultProps } = badgeTheme;
var baseStyle$5 = defineStyle({
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: vars.bg.reference,
  color: vars.color.reference,
  boxShadow: vars.shadow.reference
});
var codeTheme = defineStyleConfig({
  baseStyle: baseStyle$5,
  variants: variants$2,
  defaultProps
});
var baseStyle$4 = defineStyle({
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
});
var containerTheme = defineStyleConfig({
  baseStyle: baseStyle$4
});
var baseStyle$3 = defineStyle({
  opacity: 0.6,
  borderColor: "inherit"
});
var variantSolid$1 = defineStyle({
  borderStyle: "solid"
});
var variantDashed = defineStyle({
  borderStyle: "dashed"
});
var variants$1 = {
  solid: variantSolid$1,
  dashed: variantDashed
};
var dividerTheme = defineStyleConfig({
  baseStyle: baseStyle$3,
  variants: variants$1,
  defaultProps: {
    variant: "solid"
  }
});
var { definePartsStyle: definePartsStyle$2, defineMultiStyleConfig: defineMultiStyleConfig$2 } = createMultiStyleConfigHelpers(accordionAnatomy.keys);
var baseStyleContainer$1 = defineStyle({
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
});
var baseStyleButton = defineStyle({
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
});
var baseStylePanel = defineStyle({
  pt: "2",
  px: "4",
  pb: "5"
});
var baseStyleIcon = defineStyle({
  fontSize: "1.25em"
});
var baseStyle$2 = definePartsStyle$2({
  container: baseStyleContainer$1,
  button: baseStyleButton,
  panel: baseStylePanel,
  icon: baseStyleIcon
});
var accordionTheme = defineMultiStyleConfig$2({ baseStyle: baseStyle$2 });
var { definePartsStyle: definePartsStyle$1, defineMultiStyleConfig: defineMultiStyleConfig$1 } = createMultiStyleConfigHelpers(alertAnatomy.keys);
var $fg = cssVar$1("alert-fg");
var $bg$1 = cssVar$1("alert-bg");
var baseStyle$1 = definePartsStyle$1({
  container: {
    bg: $bg$1.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: $fg.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function getBg(props) {
  const { theme: theme2, colorScheme: c2 } = props;
  const darkBg = transparentize(`${c2}.200`, 0.16)(theme2);
  return {
    light: `colors.${c2}.100`,
    dark: darkBg
  };
}
var variantSubtle = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      }
    }
  };
});
var variantLeftAccent = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: $fg.reference
    }
  };
});
var variantTopAccent = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  const bg2 = getBg(props);
  return {
    container: {
      [$fg.variable]: `colors.${c2}.500`,
      [$bg$1.variable]: bg2.light,
      _dark: {
        [$fg.variable]: `colors.${c2}.200`,
        [$bg$1.variable]: bg2.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: $fg.reference
    }
  };
});
var variantSolid = definePartsStyle$1((props) => {
  const { colorScheme: c2 } = props;
  return {
    container: {
      [$fg.variable]: `colors.white`,
      [$bg$1.variable]: `colors.${c2}.500`,
      _dark: {
        [$fg.variable]: `colors.gray.900`,
        [$bg$1.variable]: `colors.${c2}.200`
      },
      color: $fg.reference
    }
  };
});
var variants = {
  subtle: variantSubtle,
  "left-accent": variantLeftAccent,
  "top-accent": variantTopAccent,
  solid: variantSolid
};
var alertTheme = defineMultiStyleConfig$1({
  baseStyle: baseStyle$1,
  variants,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
});
var { definePartsStyle, defineMultiStyleConfig } = createMultiStyleConfigHelpers(avatarAnatomy.keys);
var $border = cssVar$1("avatar-border-color");
var $bg = cssVar$1("avatar-bg");
var $fs = cssVar$1("avatar-font-size");
var $size = cssVar$1("avatar-size");
var baseStyleBadge = defineStyle({
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: $border.reference,
  [$border.variable]: "white",
  _dark: {
    [$border.variable]: "colors.gray.800"
  }
});
var baseStyleExcessLabel = defineStyle({
  bg: $bg.reference,
  fontSize: $fs.reference,
  width: $size.reference,
  height: $size.reference,
  lineHeight: "1",
  [$bg.variable]: "colors.gray.200",
  _dark: {
    [$bg.variable]: "colors.whiteAlpha.400"
  }
});
var baseStyleContainer = defineStyle((props) => {
  const { name: name2, theme: theme2 } = props;
  const bg2 = name2 ? randomColor({ string: name2 }) : "colors.gray.400";
  const isBgDark = isDark(bg2)(theme2);
  let color2 = "white";
  if (!isBgDark)
    color2 = "gray.800";
  return {
    bg: $bg.reference,
    fontSize: $fs.reference,
    color: color2,
    borderColor: $border.reference,
    verticalAlign: "top",
    width: $size.reference,
    height: $size.reference,
    "&:not([data-loaded])": {
      [$bg.variable]: bg2
    },
    [$border.variable]: "colors.white",
    _dark: {
      [$border.variable]: "colors.gray.800"
    }
  };
});
var baseStyleLabel = defineStyle({
  fontSize: $fs.reference,
  lineHeight: "1"
});
var baseStyle = definePartsStyle((props) => ({
  badge: runIfFn$1(baseStyleBadge, props),
  excessLabel: runIfFn$1(baseStyleExcessLabel, props),
  container: runIfFn$1(baseStyleContainer, props),
  label: baseStyleLabel
}));
function getSize(size2) {
  const themeSize = size2 !== "100%" ? sizes_default[size2] : void 0;
  return definePartsStyle({
    container: {
      [$size.variable]: themeSize != null ? themeSize : size2,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
    },
    excessLabel: {
      [$size.variable]: themeSize != null ? themeSize : size2,
      [$fs.variable]: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
    }
  });
}
var sizes = {
  "2xs": getSize(4),
  xs: getSize(6),
  sm: getSize(8),
  md: getSize(12),
  lg: getSize(16),
  xl: getSize(24),
  "2xl": getSize(32),
  full: getSize("100%")
};
var avatarTheme = defineMultiStyleConfig({
  baseStyle,
  sizes,
  defaultProps: {
    size: "md"
  }
});
var components = {
  Accordion: accordionTheme,
  Alert: alertTheme,
  Avatar: avatarTheme,
  Badge: badgeTheme,
  Breadcrumb: breadcrumbTheme,
  Button: buttonTheme,
  Checkbox: checkboxTheme,
  CloseButton: closeButtonTheme,
  Code: codeTheme,
  Container: containerTheme,
  Divider: dividerTheme,
  Drawer: drawerTheme,
  Editable: editableTheme,
  Form: formTheme,
  FormError: formErrorTheme,
  FormLabel: formLabelTheme,
  Heading: headingTheme,
  Input: inputTheme,
  Kbd: kbdTheme,
  Link: linkTheme,
  List: listTheme,
  Menu: menuTheme,
  Modal: modalTheme,
  NumberInput: numberInputTheme,
  PinInput: pinInputTheme,
  Popover: popoverTheme,
  Progress: progressTheme,
  Radio: radioTheme,
  Select: selectTheme,
  Skeleton: skeletonTheme,
  SkipLink: skipLinkTheme,
  Slider: sliderTheme,
  Spinner: spinnerTheme,
  Stat: statTheme,
  Switch: switchTheme,
  Table: tableTheme,
  Tabs: tabsTheme,
  Tag: tagTheme,
  Textarea: textareaTheme,
  Tooltip: tooltipTheme,
  Card: cardTheme,
  Stepper: stepperTheme
};
var semanticTokens = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
};
var styles = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
};
var direction = "ltr";
var config = {
  useSystemColorMode: false,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
};
var theme$1 = {
  semanticTokens,
  direction,
  ...foundations,
  components,
  styles,
  config
};
function isFunction$2(value) {
  return typeof value === "function";
}
function pipe$1(...fns) {
  return (v2) => fns.reduce((a2, b2) => b2(a2), v2);
}
var createExtendTheme = (theme2) => {
  return function extendTheme2(...extensions) {
    let overrides = [...extensions];
    let activeTheme = extensions[extensions.length - 1];
    if (isChakraTheme(activeTheme) && overrides.length > 1) {
      overrides = overrides.slice(0, overrides.length - 1);
    } else {
      activeTheme = theme2;
    }
    return pipe$1(
      ...overrides.map(
        (extension) => (prevTheme) => isFunction$2(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
      )
    )(activeTheme);
  };
};
var extendTheme = createExtendTheme(theme$1);
function mergeThemeOverride(...overrides) {
  return mergeWith({}, ...overrides, mergeThemeCustomizer);
}
function mergeThemeCustomizer(source, override, key2, object) {
  if ((isFunction$2(source) || isFunction$2(override)) && Object.prototype.hasOwnProperty.call(object, key2)) {
    return (...args) => {
      const sourceValue = isFunction$2(source) ? source(...args) : source;
      const overrideValue = isFunction$2(override) ? override(...args) : override;
      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer);
    };
  }
  return void 0;
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var isBrowser$1 = /* @__PURE__ */ canUseDOM();
function omit$1(object, keys2) {
  const result = {};
  Object.keys(object).forEach((key2) => {
    if (keys2.includes(key2))
      return;
    result[key2] = object[key2];
  });
  return result;
}
function get(obj, path, fallback, index2) {
  const key2 = typeof path === "string" ? path.split(".") : [path];
  for (index2 = 0; index2 < key2.length; index2 += 1) {
    if (!obj)
      break;
    obj = obj[key2[index2]];
  }
  return obj === void 0 ? fallback : obj;
}
var memoize = (fn2) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path, fallback, index2) => {
    if (typeof obj === "undefined") {
      return fn2(obj, path, fallback);
    }
    if (!cache.has(obj)) {
      cache.set(obj, /* @__PURE__ */ new Map());
    }
    const map = cache.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn2(obj, path, fallback, index2);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
var memoizedGet = memoize(get);
function objectFilter(object, fn2) {
  const result = {};
  Object.keys(object).forEach((key2) => {
    const value = object[key2];
    const shouldPass = fn2(value, key2, object);
    if (shouldPass) {
      result[key2] = value;
    }
  });
  return result;
}
var filterUndefined = (object) => objectFilter(object, (val) => val !== null && val !== void 0);
function isFunction$1(value) {
  return typeof value === "function";
}
function runIfFn(valueOrFn, ...args) {
  return isFunction$1(valueOrFn) ? valueOrFn(...args) : valueOrFn;
}
function callAllHandlers(...fns) {
  return function func(event) {
    fns.some((fn2) => {
      fn2 == null ? void 0 : fn2(event);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length2, i2, keys2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    var it;
    if (hasMap && a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size)
        return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!equal(i2.value[1], b2.get(i2.value[0])))
          return false;
      return true;
    }
    if (hasSet && a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size)
        return false;
      it = a2.entries();
      while (!(i2 = it.next()).done)
        if (!b2.has(i2.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function")
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function")
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    if (hasElementType && a2 instanceof Element)
      return false;
    for (i2 = length2; i2-- !== 0; ) {
      if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
        continue;
      }
      if (!equal(a2[keys2[i2]], b2[keys2[i2]]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function isEqual2(a2, b2) {
  try {
    return equal(a2, b2);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
function useStyleConfigImpl(themeKey, props = {}) {
  var _a4;
  const { styleConfig: styleConfigProp, ...rest } = props;
  const { theme: theme2, colorMode } = useChakra();
  const themeStyleConfig = themeKey ? memoizedGet(theme2, `components.${themeKey}`) : void 0;
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = mergeWith(
    { theme: theme2, colorMode },
    (_a4 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a4 : {},
    filterUndefined(omit$1(rest, ["children"]))
  );
  const stylesRef = reactExports.useRef({});
  if (styleConfig) {
    const getStyles2 = resolveStyleConfig(styleConfig);
    const styles2 = getStyles2(mergedProps);
    const isStyleEqual = isEqual(stylesRef.current, styles2);
    if (!isStyleEqual) {
      stylesRef.current = styles2;
    }
  }
  return stylesRef.current;
}
function useStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useMultiStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
var allPropNames = /* @__PURE__ */ new Set([
  ...propNames,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]);
var validHTMLProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function shouldForwardProp(prop) {
  return validHTMLProps.has(prop) || !allPropNames.has(prop);
}
function assignAfter(target, ...sources) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null)
      continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
        continue;
      if (nextKey in result)
        delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
}
function compact(object) {
  const clone2 = Object.assign({}, object);
  for (let key2 in clone2) {
    if (clone2[key2] === void 0)
      delete clone2[key2];
  }
  return clone2;
}
var _a;
var emotion_styled = (_a = newStyled.default) != null ? _a : newStyled;
var toCSSObject = ({ baseStyle: baseStyle2 }) => (props) => {
  const { theme: theme2, css: cssProp, __css, sx, ...rest } = props;
  const styleProps2 = objectFilter(rest, (_, prop) => isStyleProp(prop));
  const finalBaseStyle = runIfFn(baseStyle2, props);
  const finalStyles = assignAfter(
    {},
    __css,
    finalBaseStyle,
    filterUndefined(styleProps2),
    sx
  );
  const computedCSS = css(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options2) {
  const { baseStyle: baseStyle2, ...styledOptions } = options2 != null ? options2 : {};
  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }
  const styleObject = toCSSObject({ baseStyle: baseStyle2 });
  const Component = emotion_styled(
    component,
    styledOptions
  )(styleObject);
  const chakraComponent = React.forwardRef(function ChakraComponent(props, ref) {
    const { colorMode, forced } = useColorMode();
    return React.createElement(Component, {
      ref,
      "data-theme": forced ? colorMode : void 0,
      ...props
    });
  });
  return chakraComponent;
}
function factory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    apply(target, thisArg, argArray) {
      return styled(...argArray);
    },
    get(_, element) {
      if (!cache.has(element)) {
        cache.set(element, styled(element));
      }
      return cache.get(element);
    }
  });
}
var chakra = factory();
function forwardRef(component) {
  return reactExports.forwardRef(component);
}
function createContext(options2 = {}) {
  const {
    strict = true,
    errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name: name2
  } = options2;
  const Context = reactExports.createContext(void 0);
  Context.displayName = name2;
  function useContext() {
    var _a4;
    const context = reactExports.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a4 = Error.captureStackTrace) == null ? void 0 : _a4.call(Error, error, useContext);
      throw error;
    }
    return context;
  }
  return [
    Context.Provider,
    useContext,
    Context
  ];
}
function ThemeProvider(props) {
  const { cssVarsRoot, theme: theme2, children } = props;
  const computedTheme = reactExports.useMemo(() => toCSSVar(theme2), [theme2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider$1, { theme: computedTheme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CSSVars, { root: cssVarsRoot }),
    children
  ] });
}
function CSSVars({ root = ":host, :root" }) {
  const selector = [root, `[data-theme]`].join(",");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: (theme2) => ({ [selector]: theme2.__cssVars }) });
}
createContext({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function GlobalStyle() {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Global,
    {
      styles: (theme2) => {
        const styleObjectOrFn = memoizedGet(theme2, "styles.global");
        const globalStyles = runIfFn(styleObjectOrFn, { theme: theme2, colorMode });
        if (!globalStyles)
          return void 0;
        const styles2 = css(globalStyles)(theme2);
        return styles2;
      }
    }
  );
}
var EnvironmentContext = reactExports.createContext({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
EnvironmentContext.displayName = "EnvironmentContext";
function useEnvironment({ defer } = {}) {
  const [, forceUpdate] = reactExports.useReducer((c2) => c2 + 1, 0);
  useSafeLayoutEffect$2(() => {
    if (!defer)
      return;
    forceUpdate();
  }, [defer]);
  return reactExports.useContext(EnvironmentContext);
}
function EnvironmentProvider(props) {
  const { children, environment: environmentProp, disabled } = props;
  const ref = reactExports.useRef(null);
  const context = reactExports.useMemo(() => {
    if (environmentProp)
      return environmentProp;
    return {
      getDocument: () => {
        var _a4, _b3;
        return (_b3 = (_a4 = ref.current) == null ? void 0 : _a4.ownerDocument) != null ? _b3 : document;
      },
      getWindow: () => {
        var _a4, _b3;
        return (_b3 = (_a4 = ref.current) == null ? void 0 : _a4.ownerDocument.defaultView) != null ? _b3 : window;
      }
    };
  }, [environmentProp]);
  const showSpan = !disabled || !environmentProp;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(EnvironmentContext.Provider, { value: context, children: [
    children,
    showSpan && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { id: "__chakra_env", hidden: true, ref })
  ] });
}
EnvironmentProvider.displayName = "EnvironmentProvider";
var ChakraProvider$1 = (props) => {
  const {
    children,
    colorModeManager,
    portalZIndex,
    resetScope,
    resetCSS = true,
    theme: theme2 = {},
    environment,
    cssVarsRoot,
    disableEnvironment,
    disableGlobalStyle
  } = props;
  const _children = /* @__PURE__ */ jsxRuntimeExports.jsx(
    EnvironmentProvider,
    {
      environment,
      disabled: disableEnvironment,
      children
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { theme: theme2, cssVarsRoot, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ColorModeProvider,
    {
      colorModeManager,
      options: theme2.config,
      children: [
        resetCSS ? /* @__PURE__ */ jsxRuntimeExports.jsx(CSSReset, { scope: resetScope }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CSSPolyfill, {}),
        !disableGlobalStyle && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyle, {}),
        portalZIndex ? /* @__PURE__ */ jsxRuntimeExports.jsx(PortalManager, { zIndex: portalZIndex, children: _children }) : _children
      ]
    }
  ) });
};
var findById = (arr, id2) => arr.find((toast) => toast.id === id2);
function findToast(toasts, id2) {
  const position2 = getToastPosition(toasts, id2);
  const index2 = position2 ? toasts[position2].findIndex((toast) => toast.id === id2) : -1;
  return {
    position: position2,
    index: index2
  };
}
function getToastPosition(toasts, id2) {
  for (const [position2, values] of Object.entries(toasts)) {
    if (findById(values, id2)) {
      return position2;
    }
  }
}
function getToastStyle(position2) {
  const isRighty = position2.includes("right");
  const isLefty = position2.includes("left");
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}
function getToastListStyle(position2) {
  const isTopOrBottom = position2 === "top" || position2 === "bottom";
  const margin = isTopOrBottom ? "0 auto" : void 0;
  const top2 = position2.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
  const bottom2 = position2.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
  const right2 = !position2.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
  const left2 = !position2.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin,
    top: top2,
    bottom: bottom2,
    right: right2,
    left: left2
  };
}
function useCallbackRef$1(callback, deps = []) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useCallback((...args) => {
    var _a4;
    return (_a4 = callbackRef.current) == null ? void 0 : _a4.call(callbackRef, ...args);
  }, deps);
}
function useTimeout(callback, delay2) {
  const fn2 = useCallbackRef$1(callback);
  reactExports.useEffect(() => {
    if (delay2 == null)
      return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(() => {
      fn2();
    }, delay2);
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay2, fn2]);
}
function useUpdateEffect(callback, deps) {
  const renderCycleRef = reactExports.useRef(false);
  const effectCycleRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) {
      return callback();
    }
    effectCycleRef.current = true;
  }, deps);
  reactExports.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
const PresenceContext = reactExports.createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component, visualState, props, createVisualElement) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  reactExports.useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  useIsomorphicLayoutEffect(() => {
    visualElement && visualElement.render();
  });
  reactExports.useEffect(() => {
    visualElement && visualElement.updateFeatures();
  });
  const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect : reactExports.useEffect;
  useAnimateChangesEffect(() => {
    if (visualElement && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key2 in featureProps) {
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name2) => !!props[name2])
  };
}
function loadFeatures(features) {
  for (const key2 in features) {
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
  }
}
const LayoutGroupContext = reactExports.createContext({});
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      const isStrict = reactExports.useContext(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? reactExports.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom2(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom2;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (!componentCache.has(key2)) {
        componentCache.set(key2, custom2(key2));
      }
      return componentCache.get(key2);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate2) {
  let transformString = "";
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key2 = transformPropOrder[i2];
    if (transform2[key2] !== void 0) {
      const transformName = translateAlias[key2] || key2;
      transformString += `${transformName}(${transform2[key2]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform2.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate2) {
    transformString = transformTemplate2(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
const checkStringStartsWith = (token2) => (key2) => typeof key2 === "string" && key2.startsWith(token2);
const isCSSVariableName = checkStringStartsWith("--");
const isCSSVariableToken = checkStringStartsWith("var(--");
const cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp = (min2, max2, v2) => Math.min(Math.max(v2, min2), max2);
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString$1(v2) {
  return typeof v2 === "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString$1(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state2, latestValues, options2, transformTemplate2) {
  const { style, vars: vars2, transform: transform2, transformOrigin: transformOrigin2 } = state2;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (isCSSVariableName(key2)) {
      vars2[key2] = value;
      continue;
    }
    const valueType = numberValueTypes[key2];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      transform2[key2] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key2.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key2] = valueAsType;
    } else {
      style[key2] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate2) {
      style.transform = buildTransform(state2.transform, options2, transformIsNone, transformTemplate2);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate: transformTemplate2 }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state2 = createHtmlRenderState();
    buildHTMLStyles(state2, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
    return Object.assign({}, state2.vars, state2.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a4) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props) {
    if (key2 === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props[key2];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset2, size2) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size2 * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing2 = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing2);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state2, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options2, isSVGTag2, transformTemplate2) {
  buildHTMLStyles(state2, latest, options2, transformTemplate2);
  if (isSVGTag2) {
    if (state2.style.viewBox) {
      state2.attrs.viewBox = state2.style.viewBox;
    }
    return;
  }
  state2.attrs = state2.style;
  state2.style = {};
  const { attrs, style, dimensions } = state2;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state2 = createSvgRenderState();
    buildSVGAttrs(state2, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
    return {
      ...state2.attrs,
      style: { ...state2.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars: vars2 }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars2) {
    element.style.setProperty(key2, vars2[key2]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key2 in style) {
    if (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props)) {
      newValues[key2] = style[key2];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key2 in props) {
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom2, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function useConstant(init3) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init3();
  }
  return ref.current;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state2 = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state2.mount = (instance) => onMount(props, instance, state2);
  }
  return state2;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues) {
    values[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition: transition2, ...target } = resolved;
      for (const key2 in target) {
        let valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index2];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (const key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component
  };
}
function addDomEvent(target, eventName, handler, options2 = { passive: true }) {
  target.addEventListener(eventName, handler, options2);
  return () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options2) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options2);
}
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
class Feature {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
}
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const buffer2 = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer2.indexOf(callback) === -1) {
        buffer2.push(callback);
        if (addToCurrentFrame && isProcessing)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const frameData = {
  delta: 0,
  timestamp: 0,
  isProcessing: false
};
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key2) => {
  acc[key2] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frameData);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frameData.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed), 1);
  frameData.timestamp = timestamp;
  frameData.isProcessing = true;
  stepsOrder.forEach(processStep);
  frameData.isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    requestAnimationFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!frameData.isProcessing)
    requestAnimationFrame(processFrame);
};
const frame = stepsOrder.reduce((acc, key2) => {
  const step = steps[key2];
  acc[key2] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
function cancelFrame(process2) {
  stepsOrder.forEach((key2) => steps[key2].cancel(process2));
}
function addHoverEvent(node2, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave");
  const callbackName = "onHover" + (isActive ? "Start" : "End");
  const handleEvent = (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    const props = node2.getProps();
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", isActive);
    }
    if (props[callbackName]) {
      frame.update(() => props[callbackName](event, info));
    }
  };
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const noop$1 = (any) => any;
function fireSyntheticPointerEvent(name2, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name2);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop$1;
    this.removeEndListeners = noop$1;
    this.removeAccessibleListeners = noop$1;
    this.startPointerPress = (startEvent, startInfo) => {
      this.removeEndListeners();
      if (this.isPressing)
        return;
      const props = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel } = this.node.getProps();
        frame.update(() => {
          !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      };
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options2 }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options2);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options2 });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options2, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options2);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport: viewport2 = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport2;
    const options2 = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options2, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport: viewport2 = {} }, { viewport: prevViewport = {} } = {}) {
  return (name2) => viewport2[name2] !== prevViewport[name2];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev2[i2] !== next2[i2])
      return false;
  }
  return true;
}
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key2) => current[key2] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key2) => velocity[key2] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom2) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom2 !== void 0 ? custom2 : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
let warning = noop$1;
let invariant = noop$1;
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
const instantAnimationState = {
  current: false
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes3, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes3 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
const results = {};
const supports = {};
for (const key2 in featureTests) {
  supports[key2] = () => {
    if (results[key2] === void 0)
      results[key2] = featureTests[key2]();
    return results[key2];
  };
}
function getFinalKeyframe(keyframes3, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes3.length - 1;
  return keyframes3[index2];
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$1;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const easeIn = cubicBezier(0.42, 0, 1, 1);
const easeOut = cubicBezier(0, 0, 0.58, 1);
const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$1,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
const isColorString = (type, testProp) => (v2) => {
  return Boolean(isString$1(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString$1(v2))
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString$1(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red = green2 = blue2 = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green2 = hueToRgb(p2, q2, hue);
    blue2 = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
function test(v2) {
  var _a4, _b3;
  return isNaN(v2) && isString$1(v2) && (((_a4 = v2.match(floatRegex)) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) + (((_b3 = v2.match(colorRegex)) === null || _b3 === void 0 ? void 0 : _b3.length) || 0) > 0;
}
const cssVarTokeniser = {
  regex: cssVariableRegex,
  countKey: "Vars",
  token: "${v}",
  parse: noop$1
};
const colorTokeniser = {
  regex: colorRegex,
  countKey: "Colors",
  token: "${c}",
  parse: color.parse
};
const numberTokeniser = {
  regex: floatRegex,
  countKey: "Numbers",
  token: "${n}",
  parse: number.parse
};
function tokenise(info, { regex, countKey, token: token2, parse: parse2 }) {
  const matches = info.tokenised.match(regex);
  if (!matches)
    return;
  info["num" + countKey] = matches.length;
  info.tokenised = info.tokenised.replace(regex, token2);
  info.values.push(...matches.map(parse2));
}
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const info = {
    value: originalValue,
    tokenised: originalValue,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  if (info.value.includes("var(--"))
    tokenise(info, cssVarTokeniser);
  tokenise(info, colorTokeniser);
  tokenise(info, numberTokeniser);
  return info;
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { values, numColors, numVars, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      if (i2 < numVars) {
        output = output.replace(cssVarTokeniser.token, v2[i2]);
      } else if (i2 < numVars + numColors) {
        output = output.replace(colorTokeniser.token, color.transform(v2[i2]));
      } else {
        output = output.replace(numberTokeniser.token, sanitize(v2[i2]));
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const mixImmediate = (origin, target) => (p2) => `${p2 > 0 ? target : origin}`;
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
  }
}
const mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i2) => getMixer(fromThis, to[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](v2);
    }
    return output;
  };
};
const mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key2 in output) {
    if (origin[key2] !== void 0 && target[key2] !== void 0) {
      blendValue[key2] = getMixer(origin[key2], target[key2]);
    }
  }
  return (v2) => {
    for (const key2 in blendValue) {
      output[key2] = blendValue[key2](v2);
    }
    return output;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
const progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
const mixNumber = (from2, to) => (p2) => mix(from2, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    return color.test(v2) ? mixColor : mixComplex;
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset2.push(mix(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o2) => o2 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state2 = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state2.value = mapTimeToKeyframe(t2);
      state2.done = t2 >= duration;
      return state2;
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration$1 = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration$1));
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options2, keys2) {
  return keys2.some((key2) => options2[key2] !== void 0);
}
function getSpringOptions(options2) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options2
  };
  if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
    const derived = findSpring(options2);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes3, restDelta, restSpeed, ...options2 }) {
  const origin = keyframes3[0];
  const target = keyframes3[keyframes3.length - 1];
  const state2 = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options2);
  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state2.done = t2 >= duration;
      }
      state2.value = state2.done ? target : current;
      return state2;
    }
  };
}
function inertia({ keyframes: keyframes3, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes3[0];
  const state2 = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state2.done = Math.abs(delta) <= restDelta;
    state2.value = state2.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state2.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state2.value, nearestBoundary(state2.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state2.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 > timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state2;
      }
    }
  };
}
const frameloopDriver = (update5) => {
  const passTimestamp = ({ timestamp }) => update5(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state2 = generator.next(duration);
  while (!state2.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state2 = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
const types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$12, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options2 }) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    resolveFinishedPromise && resolveFinishedPromise();
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes && typeof keyframes$12[0] !== "number") {
    mapNumbersToKeyframes = interpolate([0, 100], keyframes$12, {
      clamp: false
    });
    keyframes$12 = [0, 100];
  }
  const generator = generatorFactory({ ...options2, keyframes: keyframes$12 });
  let mirroredGenerator;
  if (repeatType === "mirror") {
    mirroredGenerator = generatorFactory({
      ...options2,
      keyframes: [...keyframes$12].reverse(),
      velocity: -(options2.velocity || 0)
    });
  }
  let playState = "idle";
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator);
  }
  const { calculatedDuration } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp) => {
    if (startTime === null)
      return;
    if (speed > 0)
      startTime = Math.min(startTime, timestamp);
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = (timestamp - startTime) * speed;
    }
    const timeWithoutDelay = currentTime - delay2;
    const isInDelayPhase = timeWithoutDelay < 0;
    currentTime = Math.max(timeWithoutDelay, 0);
    if (playState === "finished" && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = currentTime / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const iterationIsOdd = Boolean(currentIteration % 2);
      if (iterationIsOdd) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      let p2 = clamp(0, 1, iterationProgress);
      if (currentTime > totalDuration) {
        p2 = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
      }
      elapsed = p2 * resolvedDuration;
    }
    const state2 = isInDelayPhase ? { done: false, value: keyframes$12[0] } : frameGenerator.next(elapsed);
    if (mapNumbersToKeyframes) {
      state2.value = mapNumbersToKeyframes(state2.value);
    }
    let { done } = state2;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = currentTime >= totalDuration;
    }
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done || speed < 0 && currentTime <= 0);
    if (onUpdate) {
      onUpdate(state2.value);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state2;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = "idle";
    stopAnimationDriver();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = "finished";
    onComplete && onComplete();
    stopAnimationDriver();
    updateFinishedPromise();
  };
  const play = () => {
    if (hasStopped)
      return;
    if (!animationDriver)
      animationDriver = driver(tick);
    const now2 = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now2 - holdTime;
    } else if (!startTime || playState === "finished") {
      startTime = now2;
    }
    cancelTime = startTime;
    holdTime = null;
    playState = "running";
    animationDriver.start();
  };
  if (autoplay) {
    play();
  }
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      if (newSpeed === speed || !animationDriver)
        return;
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime);
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused";
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === "idle")
        return;
      playState = "idle";
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null)
        tick(cancelTime);
      cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => {
      startTime = 0;
      return tick(elapsed);
    }
  };
  return controls;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]);
const sampleDelta = 10;
const maxDuration = 2e4;
const requiresPregeneratedKeyframes = (valueName, options2) => options2.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options2.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options2 }) {
  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options2.repeatDelay && options2.repeatType !== "mirror" && options2.damping !== 0 && options2.type !== "inertia";
  if (!canAccelerateAnimation)
    return false;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes3, duration = 300, ease: ease2, times } = options2;
  if (requiresPregeneratedKeyframes(valueName, options2)) {
    const sampleAnimation = animateValue({
      ...options2,
      repeat: 0,
      delay: 0
    });
    let state2 = { done: false, value: keyframes3[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state2.done && t2 < maxDuration) {
      state2 = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state2.value);
      t2 += sampleDelta;
    }
    times = void 0;
    keyframes3 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease2 = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes3, {
    ...options2,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times
  });
  const cancelAnimation = () => animation.cancel();
  const safeCancel = () => {
    frame.update(cancelAnimation);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes3, options2));
    onComplete && onComplete();
    safeCancel();
  };
  return {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(animation.currentTime || 0);
    },
    set time(newTime) {
      animation.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation.playbackRate;
    },
    set speed(newSpeed) {
      animation.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      if (hasStopped)
        return;
      animation.play();
      cancelFrame(cancelAnimation);
    },
    pause: () => animation.pause(),
    stop: () => {
      hasStopped = true;
      if (animation.playState === "idle")
        return;
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options2,
          autoplay: false
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation.finish(),
    cancel: safeCancel
  };
}
function createInstantAnimation({ keyframes: keyframes3, delay: delay2, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes3[keyframes3.length - 1]);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop$1,
      pause: noop$1,
      stop: noop$1,
      then: (resolve) => {
        resolve();
        return Promise.resolve();
      },
      cancel: noop$1,
      complete: noop$1
    };
  };
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes3 }) => {
  if (keyframes3.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes3[1]) : underDampedSpring;
  }
  return ease;
};
const isAnimatable = (key2, value) => {
  if (key2 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name2, value] = v2.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  }
}
function getKeyframes(value, valueName, target, transition2) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let keyframes3;
  if (Array.isArray(target)) {
    keyframes3 = [...target];
  } else {
    keyframes3 = [null, target];
  }
  const defaultOrigin = transition2.from !== void 0 ? transition2.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i2 = 0; i2 < keyframes3.length; i2++) {
    if (keyframes3[i2] === null) {
      keyframes3[i2] = i2 === 0 ? defaultOrigin : keyframes3[i2 - 1];
    }
    if (isNone(keyframes3[i2])) {
      noneKeyframeIndexes.push(i2);
    }
    if (typeof keyframes3[i2] === "string" && keyframes3[i2] !== "none" && keyframes3[i2] !== "0") {
      animatableTemplateValue = keyframes3[i2];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i2 = 0; i2 < noneKeyframeIndexes.length; i2++) {
      const index2 = noneKeyframeIndexes[i2];
      keyframes3[index2] = getAnimatableNone(valueName, animatableTemplateValue);
    }
  }
  return keyframes3;
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition2 }) {
  return !!Object.keys(transition2).length;
}
function getValueTransition(transition2, key2) {
  return transition2[key2] || transition2["default"] || transition2;
}
const animateMotionValue = (valueName, value, target, transition2 = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition2, valueName) || {};
    const delay2 = valueTransition.delay || transition2.delay || 0;
    let { elapsed = 0 } = transition2;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes3 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes3[0];
    const targetKeyframe = keyframes3[keyframes3.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options2 = {
      keyframes: keyframes3,
      velocity: value.getVelocity(),
      ease: "easeOut",
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isTransitionDefined(valueTransition)) {
      options2 = {
        ...options2,
        ...getDefaultTransition(valueName, options2)
      };
    }
    if (options2.duration) {
      options2.duration = secondsToMilliseconds(options2.duration);
    }
    if (options2.repeatDelay) {
      options2.repeatDelay = secondsToMilliseconds(options2.repeatDelay);
    }
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options2);
    }
    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options2);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animateValue(options2);
  };
};
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init3, options2 = {}) {
    this.version = "10.12.16";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        frame.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init3;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options2.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = prev2;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init3, options2) {
  return new MotionValue(init3, options2);
}
const testValueType = (v2) => (type) => type.test(v2);
const auto$1 = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto$1];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition: transition2 = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a4, _b3;
  const newValueKeys = Object.keys(target).filter((key2) => !visualElement.hasValue(key2));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i2 = 0; i2 < numNewValues; i2++) {
    const key2 = newValueKeys[i2];
    const targetValue = target[key2];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b3 = (_a4 = origin[key2]) !== null && _a4 !== void 0 ? _a4 : visualElement.readValue(key2)) !== null && _b3 !== void 0 ? _b3 : target[key2];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key2, targetValue);
    }
    visualElement.addValue(key2, motionValue(value, { owner: visualElement }));
    if (origin[key2] === void 0) {
      origin[key2] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key2, value);
  }
}
function getOriginFromTransition(key2, transition2) {
  if (!transition2)
    return;
  const valueTransition = transition2[key2] || transition2["default"] || transition2;
  return valueTransition.from;
}
function getOrigin(target, transition2, visualElement) {
  const origin = {};
  for (const key2 in target) {
    const transitionOrigin = getOriginFromTransition(key2, transition2);
    if (transitionOrigin !== void 0) {
      origin[key2] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key2);
      if (value) {
        origin[key2] = value.get();
      }
    }
  }
  return origin;
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition: transition2 = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition2 = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2);
    const valueTarget = target[key2];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition2 };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key2, value, frame);
      }
    }
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: false } : valueTransition));
    const animation = value.animation;
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key2);
      animation.then(() => willChange.remove(key2));
    }
    animations2.push(animation);
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options2 = {}) {
  const resolved = resolveVariant(visualElement, variant, options2.custom);
  let { transition: transition2 = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options2.transitionOverride) {
    transition2 = options2.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options2)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition2;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options2);
  } : () => Promise.resolve();
  const { when } = transition2;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options2.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options2) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options2,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options2 = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options2));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options2);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options2.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options2));
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options: options2 }) => animateVisualElement(visualElement, animation, options2)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state2 = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition: transition2, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options2, changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state2[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (const key2 in allKeys) {
        const next2 = resolvedValues[key2];
        const prev2 = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        if (next2 !== prev2) {
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            if (!shallowCompare(next2, prev2) || variantDidChange) {
              markToAnimate(key2);
            } else {
              typeState.protectedKeys[key2] = true;
            }
          } else if (next2 !== void 0) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next2 !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options2 }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key2] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options2) {
    var _a4;
    if (state2[type].isActive === isActive)
      return Promise.resolve();
    (_a4 = visualElement.variantChildren) === null || _a4 === void 0 ? void 0 : _a4.forEach((child) => {
      var _a5;
      return (_a5 = child.animationState) === null || _a5 === void 0 ? void 0 : _a5.setActive(type, isActive);
    });
    state2[type].isActive = isActive;
    const animations2 = animateChanges(options2, type);
    for (const key2 in state2) {
      state2[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state2
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate)) {
      this.unmount = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: isPresent2, onExitComplete, custom: custom2 } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent2 === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent2, { custom: custom2 !== null && custom2 !== void 0 ? custom2 : this.node.getProps().custom });
    if (onExitComplete && !isPresent2) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point4 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point4, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point3 } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point3, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point3 }, history) {
  return {
    point: point3,
    delta: subtractPoint(point3, lastDevicePoint(history)),
    offset: subtractPoint(point3, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point3, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point3 < min2) {
    point3 = elastic ? mix(min2, point3, elastic.min) : Math.max(point3, min2);
  } else if (max2 !== void 0 && point3 > max2) {
    point3 = elastic ? mix(max2, point3, elastic.max) : Math.min(point3, max2);
  }
  return point3;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top: top2, left: left2, bottom: bottom2, right: right2 }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left2, right2),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top: top2, left: left2, right: right2, bottom: bottom2 }) {
  return {
    x: { min: left2, max: right2 },
    y: { min: top2, max: bottom2 }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point3, transformPoint2) {
  if (!transformPoint2)
    return point3;
  const topLeft = transformPoint2({ x: point3.left, y: point3.top });
  const bottomRight = transformPoint2({ x: point3.right, y: point3.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point3, scale2, originPoint) {
  const distanceFromOrigin = point3 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point3, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point3 = scalePoint(point3, boxScale, originPoint);
  }
  return scalePoint(point3, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2];
    delta = node2.projectionDelta;
    const instance = node2.instance;
    if (instance && instance.style && instance.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms2, [key2, scaleKey, originKey]) {
  const axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key2], transforms2[scaleKey], originPoint, transforms2.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys$1);
  transformAxis(box.y, transform2, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.update(() => onDragStart(event, info), false, true);
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout: layout2 } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition2 = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition2 = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition2
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition2) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition2));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase();
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point3) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point3[axis] - mix(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate: transformTemplate2 } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mix(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction2, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction2) && (currentDirection === null || currentDirection === direction2);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction2 = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction2 = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction2 = "x";
  }
  return direction2;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop$1;
    this.removeListeners = noop$1;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$1;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.update(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$1;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
function usePresence() {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent: isPresent2, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent(reactExports.useContext(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow2 = complex.parse(latest);
    if (shadow2.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow2[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow2[0 + offset2] /= xScale;
    shadow2[1 + offset2] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow2[2 + offset2] === "number")
      shadow2[2 + offset2] /= averageScale;
    if (typeof shadow2[3 + offset2] === "number")
      shadow2[3 + offset2] /= averageScale;
    return template(shadow2);
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      queueMicrotask(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent2, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$1);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point3, translate, scale2, originPoint, boxScale) {
  point3 -= translate;
  point3 = scalePoint(point3, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point3 = scalePoint(point3, 1 / boxScale, originPoint);
  }
  return point3;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms2[key2], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms2, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options: options2, resumingFrom } = node2;
      options2.onExitComplete && options2.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform2 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start2 = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes3, options2) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes3, options2));
  return motionValue$1.animation;
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate2 = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = performance.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        queueMicrotask(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      frame.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate2 = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate2 ? transformTemplate2(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x);
        translateAxis(box.y, scroll2.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        const { scroll: scroll2, options: options2 } = node2;
        if (node2 !== this.root && scroll2 && options2.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options2) {
      this.options = {
        ...this.options,
        ...options2,
        crossfade: options2.crossfade !== void 0 ? options2.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a4;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a4;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a4 = this.parent) === null || _a4 === void 0 ? void 0 : _a4.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options2) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options2,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options2.onUpdate && options2.onUpdate(latest);
          },
          onComplete: () => {
            options2.onComplete && options2.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config2 = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? ((_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.lead) || this : this;
    }
    getPrevLead() {
      var _a4;
      const { layoutId } = this.options;
      return layoutId ? (_a4 = this.getStack()) === null || _a4 === void 0 ? void 0 : _a4.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition: transition2, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition2)
        this.setOptions({ transition: transition2 });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        const key2 = "rotate" + transformAxes[i2];
        if (latestValues[key2]) {
          resetValues[key2] = latestValues[key2];
          visualElement.setStaticValue(key2, 0);
        }
      }
      visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a4, _b3;
      const styles2 = {};
      if (!this.instance || this.isSVG)
        return styles2;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles2.visibility = "";
      }
      const transformTemplate2 = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate2 ? transformTemplate2(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate2) {
        styles2.transform = transformTemplate2(valuesToRender, styles2.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles2.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_b3 = (_a4 = valuesToRender.opacity) !== null && _a4 !== void 0 ? _a4 : this.latestValues.opacity) !== null && _b3 !== void 0 ? _b3 : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key2];
        const corrected = styles2.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles2[applyTo[i2]] = corrected;
          }
        } else {
          styles2[key2] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a4;
        return (_a4 = node2.currentAnimation) === null || _a4 === void 0 ? void 0 : _a4.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a4;
  const snapshot = ((_a4 = node2.resumeFrom) === null || _a4 === void 0 ? void 0 : _a4.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  projectionFrameData.totalNodes++;
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetRotation(node2) {
  node2.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mix(delta.translate, 0, p2);
  output.scale = mix(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p2) {
  output.min = mix(from2.min, to.min, p2);
  output.max = mix(from2.max, to.max, p2);
}
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token2, fallback] = match2;
  return [token2, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariableToken(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key2 in target) {
    const current = target[key2];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key2] = resolved;
    if (!transitionEnd)
      transitionEnd = {};
    if (transitionEnd[key2] === void 0) {
      transitionEnd[key2] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
const isPositionalKey = (key2) => positionalKeys.has(key2);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top2 }) => parseFloat(top2),
  left: (_bbox, { left: left2 }) => parseFloat(left2),
  bottom: ({ y: y2 }, { top: top2 }) => parseFloat(top2) + (y2.max - y2.min),
  right: ({ x: x2 }, { left: left2 }) => parseFloat(left2) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key2) => {
    origin[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value && value.jump(origin[key2]);
    target[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from2 = origin[key2];
    let fromType = findDimensionValueType(from2);
    const to = target[key2];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {
        if (to[i2] === null)
          break;
        if (!toType) {
          toType = findDimensionValueType(to[i2]);
        } else {
          invariant(findDimensionValueType(to[i2]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key2] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key2] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key2] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key2);
        transitionEnd[key2] = transitionEnd[key2] !== void 0 ? transitionEnd[key2] : target[key2];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key2, value]) => {
        visualElement.getValue(key2).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next2, prev2) {
  const { willChange } = next2;
  for (const key2 in next2) {
    const nextValue = next2[key2];
    const prevValue = prev2[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key2);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key2);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev2) {
    if (next2[key2] === void 0)
      element.removeValue(key2);
  }
  return next2;
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
const numVariantProps = variantProps.length;
class VisualElement {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options2 = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options2;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key2);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    for (const key2 in this.features) {
      this.features[key2].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    const valueIsTransform = transformProps.has(key2);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    for (let i2 = 0; i2 < numFeatures; i2++) {
      const name2 = featureNames[i2];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name2];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled(renderedProps)) {
        if (!this.features[name2] && FeatureConstructor) {
          this.features[name2] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key2 in this.features) {
      const feature = this.features[key2];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key2 = propEventHandlers[i2];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listener = props["on" + key2];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    return this.props.variants ? this.props.variants[name2] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i2 = 0; i2 < numVariantProps; i2++) {
      const name2 = variantProps[i2];
      const prop = this.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context[name2] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    if (value !== this.values.get(key2)) {
      this.removeValue(key2);
      this.bindToMotionValue(key2, value);
    }
    this.values.set(key2, value);
    this.latestValues[key2] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key2);
    }
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2) {
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.readValueFromInstance(this.current, key2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a4;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a4 = resolveVariantFromProps(this.props, initial)) === null || _a4 === void 0 ? void 0 : _a4[key2] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars: vars2, style }) {
    delete vars2[key2];
    delete style[key2];
  }
  makeTargetAnimatableFromInstance({ transition: transition2, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition2 || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition: transition2,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options2, props) {
    buildHTMLStyles(renderState, latestValues, options2, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options2, props) {
    buildSVGAttrs(renderState, latestValues, options2, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options2) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options2, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options2, { enableHardwareAcceleration: true });
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config2) => createDomMotionConfig(Component, config2, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent: isPresent2 }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size2 = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  reactExports.useInsertionEffect(() => {
    const { width, height, top: top2, left: left2 } = size2.current;
    if (isPresent2 || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top2}px !important;
            left: ${left2}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent2]);
  return reactExports.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size2 }, reactExports.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom: custom2, presenceAffectsLayout, mode: mode2 }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent: isPresent2,
      custom: custom2,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_, key2) => presenceChildren.set(key2, false));
  }, [isPresent2]);
  reactExports.useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2]);
  if (mode2 === "popLayout") {
    children = reactExports.createElement(PopChild, { isPresent: isPresent2 }, children);
  }
  return reactExports.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function useUnmountEffect$1(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom: custom2, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode: mode2 = "sync" }) => {
  const forceRender = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect$1(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map((child) => reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode: mode2 }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i2 = 0; i2 < numPresent; i2++) {
    const key2 = presentKeys[i2];
    if (targetKeys.indexOf(key2) === -1 && !exitingChildren.has(key2)) {
      exitingChildren.set(key2, void 0);
    }
  }
  if (mode2 === "wait" && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    const child = allChildren.get(key2);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key2);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        allChildren.delete(key2);
        exitingChildren.delete(key2);
        const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key2);
        presentChildren.current.splice(removeIndex, 1);
        if (!exitingChildren.size) {
          presentChildren.current = filteredChildren;
          if (isMounted.current === false)
            return;
          forceRender();
          onExitComplete && onExitComplete();
        }
      };
      exitingComponent = reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom2, presenceAffectsLayout, mode: mode2 }, child);
      exitingChildren.set(key2, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  });
  childrenToRender = childrenToRender.map((child) => {
    const key2 = child.key;
    return exitingChildren.has(key2) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode: mode2 }, child);
  });
  return reactExports.createElement(reactExports.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)));
};
var toastMotionVariants = {
  initial: (props) => {
    const { position: position2 } = props;
    const dir2 = ["top", "bottom"].includes(position2) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position2) ? 1 : -1;
    if (position2 === "bottom")
      factor = 1;
    return {
      opacity: 0,
      [dir2]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = reactExports.memo((props) => {
  const {
    id: id2,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position: position2 = "bottom",
    duration = 5e3,
    containerStyle,
    motionVariants: motionVariants2 = toastMotionVariants,
    toastSpacing = "0.5rem"
  } = props;
  const [delay2, setDelay] = reactExports.useState(duration);
  const isPresent2 = useIsPresent();
  useUpdateEffect(() => {
    if (!isPresent2) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent2]);
  useUpdateEffect(() => {
    setDelay(duration);
  }, [duration]);
  const onMouseEnter = () => setDelay(null);
  const onMouseLeave = () => setDelay(duration);
  const close = () => {
    if (isPresent2)
      onRequestRemove();
  };
  reactExports.useEffect(() => {
    if (isPresent2 && requestClose) {
      onRequestRemove();
    }
  }, [isPresent2, requestClose, onRequestRemove]);
  useTimeout(close, delay2);
  const containerStyles = reactExports.useMemo(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing,
      ...containerStyle
    }),
    [containerStyle, toastSpacing]
  );
  const toastStyle = reactExports.useMemo(() => getToastStyle(position2), [position2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      layout: true,
      className: "chakra-toast",
      variants: motionVariants2,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: onMouseEnter,
      onHoverEnd: onMouseLeave,
      custom: { position: position2 },
      style: toastStyle,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        chakra.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: containerStyles,
          children: runIfFn$2(message, { id: id2, onClose: close })
        }
      )
    }
  );
});
ToastComponent.displayName = "ToastComponent";
function getToastPlacement(position2, dir2) {
  var _a4;
  const computedPosition = position2 != null ? position2 : "bottom";
  const logicals2 = {
    "top-start": { ltr: "top-left", rtl: "top-right" },
    "top-end": { ltr: "top-right", rtl: "top-left" },
    "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
    "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
  };
  const logical2 = logicals2[computedPosition];
  return (_a4 = logical2 == null ? void 0 : logical2[dir2]) != null ? _a4 : computedPosition;
}
var fallbackIcon = {
  path: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
};
var Icon = forwardRef((props, ref) => {
  const {
    as: element,
    viewBox,
    color: color2 = "currentColor",
    focusable = false,
    children,
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-icon", className);
  const customStyles = useStyleConfig("Icon", props);
  const styles2 = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: color2,
    ...__css,
    ...customStyles
  };
  const shared = {
    ref,
    focusable,
    className: _className,
    __css: styles2
  };
  const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
  if (element && typeof element !== "string") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { as: element, ...shared, ...rest });
  }
  const _path = children != null ? children : fallbackIcon.path;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
});
Icon.displayName = "Icon";
function CheckIcon$1(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function InfoIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function WarningIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
var spin = keyframes$1({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Spinner", props);
  const {
    label = "Loading...",
    thickness = "2px",
    speed = "0.45s",
    emptyColor = "transparent",
    className,
    ...rest
  } = omitThemingProps(props);
  const _className = cx("chakra-spinner", className);
  const spinnerStyles = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: thickness,
    borderBottomColor: emptyColor,
    borderLeftColor: emptyColor,
    animation: `${spin} ${speed} linear infinite`,
    ...styles2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ref,
      __css: spinnerStyles,
      className: _className,
      ...rest,
      children: label && /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { srOnly: true, children: label })
    }
  );
});
Spinner.displayName = "Spinner";
var [AlertProvider, useAlertContext] = createContext$1({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
});
var [AlertStylesProvider, useAlertStyles] = createContext$1({
  name: `AlertStylesContext`,
  hookName: `useAlertStyles`,
  providerName: "<Alert />"
});
var STATUSES = {
  info: { icon: InfoIcon, colorScheme: "blue" },
  warning: { icon: WarningIcon, colorScheme: "orange" },
  success: { icon: CheckIcon$1, colorScheme: "green" },
  error: { icon: WarningIcon, colorScheme: "red" },
  loading: { icon: Spinner, colorScheme: "blue" }
};
function getStatusColorScheme(status) {
  return STATUSES[status].colorScheme;
}
function getStatusIcon(status) {
  return STATUSES[status].icon;
}
var AlertDescription = forwardRef(
  function AlertDescription2(props, ref) {
    const styles2 = useAlertStyles();
    const { status } = useAlertContext();
    const descriptionStyles = {
      display: "inline",
      ...styles2.description
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__desc", props.className),
        __css: descriptionStyles
      }
    );
  }
);
AlertDescription.displayName = "AlertDescription";
function AlertIcon(props) {
  const { status } = useAlertContext();
  const BaseIcon = getStatusIcon(status);
  const styles2 = useAlertStyles();
  const css2 = status === "loading" ? styles2.spinner : styles2.icon;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      display: "inherit",
      "data-status": status,
      ...props,
      className: cx("chakra-alert__icon", props.className),
      __css: css2,
      children: props.children || /* @__PURE__ */ jsxRuntimeExports.jsx(BaseIcon, { h: "100%", w: "100%" })
    }
  );
}
AlertIcon.displayName = "AlertIcon";
var AlertTitle = forwardRef(
  function AlertTitle2(props, ref) {
    const styles2 = useAlertStyles();
    const { status } = useAlertContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__title", props.className),
        __css: styles2.title
      }
    );
  }
);
AlertTitle.displayName = "AlertTitle";
var Alert = forwardRef(function Alert2(props, ref) {
  var _a4;
  const { status = "info", addRole = true, ...rest } = omitThemingProps(props);
  const colorScheme = (_a4 = props.colorScheme) != null ? _a4 : getStatusColorScheme(status);
  const styles2 = useMultiStyleConfig("Alert", { ...props, colorScheme });
  const alertStyles = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...styles2.container
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AlertProvider, { value: { status }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertStylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      "data-status": status,
      role: addRole ? "alert" : void 0,
      ref,
      ...rest,
      className: cx("chakra-alert", props.className),
      __css: alertStyles
    }
  ) }) });
});
Alert.displayName = "Alert";
function CloseIcon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { focusable: "false", "aria-hidden": true, ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
var CloseButton = forwardRef(
  function CloseButton2(props, ref) {
    const styles2 = useStyleConfig("CloseButton", props);
    const { children, isDisabled: isDisabled2, __css, ...rest } = omitThemingProps(props);
    const baseStyle2 = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.button,
      {
        type: "button",
        "aria-label": "Close",
        ref,
        disabled: isDisabled2,
        __css: {
          ...baseStyle2,
          ...styles2,
          ...__css
        },
        ...rest,
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { width: "1em", height: "1em" })
      }
    );
  }
);
CloseButton.displayName = "CloseButton";
var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
var toastStore = createStore$1(initialState);
function createStore$1(initialState2) {
  let state2 = initialState2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (setStateFn) => {
    state2 = setStateFn(state2);
    listeners.forEach((l2) => l2());
  };
  return {
    getState: () => state2,
    subscribe: (listener) => {
      listeners.add(listener);
      return () => {
        setState(() => initialState2);
        listeners.delete(listener);
      };
    },
    removeToast: (id2, position2) => {
      setState((prevState) => ({
        ...prevState,
        [position2]: prevState[position2].filter((toast) => toast.id != id2)
      }));
    },
    notify: (message, options2) => {
      const toast = createToast(message, options2);
      const { position: position2, id: id2 } = toast;
      setState((prevToasts) => {
        var _a4, _b3;
        const isTop = position2.includes("top");
        const toasts = isTop ? [toast, ...(_a4 = prevToasts[position2]) != null ? _a4 : []] : [...(_b3 = prevToasts[position2]) != null ? _b3 : [], toast];
        return {
          ...prevToasts,
          [position2]: toasts
        };
      });
      return id2;
    },
    update: (id2, options2) => {
      if (!id2)
        return;
      setState((prevState) => {
        const nextState = { ...prevState };
        const { position: position2, index: index2 } = findToast(nextState, id2);
        if (position2 && index2 !== -1) {
          nextState[position2][index2] = {
            ...nextState[position2][index2],
            ...options2,
            message: createRenderToast(options2)
          };
        }
        return nextState;
      });
    },
    closeAll: ({ positions } = {}) => {
      setState((prev2) => {
        const allPositions = [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ];
        const positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce(
          (acc, position2) => {
            acc[position2] = prev2[position2].map((toast) => ({
              ...toast,
              requestClose: true
            }));
            return acc;
          },
          { ...prev2 }
        );
      });
    },
    close: (id2) => {
      setState((prevState) => {
        const position2 = getToastPosition(prevState, id2);
        if (!position2)
          return prevState;
        return {
          ...prevState,
          [position2]: prevState[position2].map((toast) => {
            if (toast.id == id2) {
              return {
                ...toast,
                requestClose: true
              };
            }
            return toast;
          })
        };
      });
    },
    isActive: (id2) => Boolean(findToast(toastStore.getState(), id2).position)
  };
}
var counter = 0;
function createToast(message, options2 = {}) {
  var _a4, _b3;
  counter += 1;
  const id2 = (_a4 = options2.id) != null ? _a4 : counter;
  const position2 = (_b3 = options2.position) != null ? _b3 : "bottom";
  return {
    id: id2,
    message,
    position: position2,
    duration: options2.duration,
    onCloseComplete: options2.onCloseComplete,
    onRequestRemove: () => toastStore.removeToast(String(id2), position2),
    status: options2.status,
    requestClose: false,
    containerStyle: options2.containerStyle
  };
}
var Toast = (props) => {
  const {
    status,
    variant = "solid",
    id: id2,
    title,
    isClosable,
    onClose,
    description,
    colorScheme,
    icon
  } = props;
  const ids = id2 ? {
    root: `toast-${id2}`,
    title: `toast-${id2}-title`,
    description: `toast-${id2}-description`
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Alert,
    {
      addRole: false,
      status,
      variant,
      id: ids == null ? void 0 : ids.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, { children: icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(chakra.div, { flex: "1", maxWidth: "100%", children: [
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
          description && /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description })
        ] }),
        isClosable && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CloseButton,
          {
            size: "sm",
            onClick: onClose,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function createRenderToast(options2 = {}) {
  const { render, toastComponent: ToastComponent2 = Toast } = options2;
  const renderToast = (props) => {
    if (typeof render === "function") {
      return render({ ...props, ...options2 });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastComponent2, { ...props, ...options2 });
  };
  return renderToast;
}
function createToastFn(dir2, defaultOptions2) {
  const normalizeToastOptions = (options2) => {
    var _a4;
    return {
      ...defaultOptions2,
      ...options2,
      position: getToastPlacement(
        (_a4 = options2 == null ? void 0 : options2.position) != null ? _a4 : defaultOptions2 == null ? void 0 : defaultOptions2.position,
        dir2
      )
    };
  };
  const toast = (options2) => {
    const normalizedToastOptions = normalizeToastOptions(options2);
    const Message = createRenderToast(normalizedToastOptions);
    return toastStore.notify(Message, normalizedToastOptions);
  };
  toast.update = (id2, options2) => {
    toastStore.update(id2, normalizeToastOptions(options2));
  };
  toast.promise = (promise, options2) => {
    const id2 = toast({
      ...options2.loading,
      status: "loading",
      duration: null
    });
    promise.then(
      (data) => toast.update(id2, {
        status: "success",
        duration: 5e3,
        ...runIfFn$2(options2.success, data)
      })
    ).catch(
      (error) => toast.update(id2, {
        status: "error",
        duration: 5e3,
        ...runIfFn$2(options2.error, error)
      })
    );
  };
  toast.closeAll = toastStore.closeAll;
  toast.close = toastStore.close;
  toast.isActive = toastStore.isActive;
  return toast;
}
var [ToastOptionProvider, useToastOptionContext] = createContext$1({
  name: `ToastOptionsContext`,
  strict: false
});
var ToastProvider = (props) => {
  const state2 = reactExports.useSyncExternalStore(
    toastStore.subscribe,
    toastStore.getState,
    toastStore.getState
  );
  const {
    motionVariants: motionVariants2,
    component: Component = ToastComponent,
    portalProps
  } = props;
  const stateKeys = Object.keys(state2);
  const toastList = stateKeys.map((position2) => {
    const toasts = state2[position2];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        id: `chakra-toast-manager-${position2}`,
        style: getToastListStyle(position2),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { initial: false, children: toasts.map((toast) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Component,
          {
            motionVariants: motionVariants2,
            ...toast
          },
          toast.id
        )) })
      },
      position2
    );
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { ...portalProps, children: toastList });
};
function useToast(options2) {
  const { theme: theme2 } = useChakra();
  const defaultOptions2 = useToastOptionContext();
  return reactExports.useMemo(
    () => createToastFn(theme2.direction, {
      ...defaultOptions2,
      ...options2
    }),
    [options2, theme2.direction, defaultOptions2]
  );
}
var createChakraProvider = (providerTheme) => {
  return function ChakraProvider2({
    children,
    theme: theme2 = providerTheme,
    toastOptions,
    ...restProps
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChakraProvider$1, { theme: theme2, ...restProps, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { ...toastOptions })
    ] });
  };
};
var ChakraProvider = createChakraProvider(theme$1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
function sortNodes(nodes) {
  return nodes.sort((a2, b2) => {
    const compare2 = a2.compareDocumentPosition(b2);
    if (compare2 & Node.DOCUMENT_POSITION_FOLLOWING || compare2 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (compare2 & Node.DOCUMENT_POSITION_PRECEDING || compare2 & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    if (compare2 & Node.DOCUMENT_POSITION_DISCONNECTED || compare2 & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
var isElement$3 = (el2) => typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
function getNextIndex(current, max2, loop) {
  let next2 = current + 1;
  if (loop && next2 >= max2)
    next2 = 0;
  return next2;
}
function getPrevIndex(current, max2, loop) {
  let next2 = current - 1;
  if (loop && next2 < 0)
    next2 = max2;
  return next2;
}
var useSafeLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var cast = (value) => value;
var DescendantsManager = class {
  constructor() {
    __publicField(this, "descendants", /* @__PURE__ */ new Map());
    __publicField(this, "register", (nodeOrOptions) => {
      if (nodeOrOptions == null)
        return;
      if (isElement$3(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }
      return (node2) => {
        this.registerNode(node2, nodeOrOptions);
      };
    });
    __publicField(this, "unregister", (node2) => {
      this.descendants.delete(node2);
      const sorted = sortNodes(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    });
    __publicField(this, "destroy", () => {
      this.descendants.clear();
    });
    __publicField(this, "assignIndex", (descendants) => {
      this.descendants.forEach((descendant) => {
        const index2 = descendants.indexOf(descendant.node);
        descendant.index = index2;
        descendant.node.dataset["index"] = descendant.index.toString();
      });
    });
    __publicField(this, "count", () => this.descendants.size);
    __publicField(this, "enabledCount", () => this.enabledValues().length);
    __publicField(this, "values", () => {
      const values = Array.from(this.descendants.values());
      return values.sort((a2, b2) => a2.index - b2.index);
    });
    __publicField(this, "enabledValues", () => {
      return this.values().filter((descendant) => !descendant.disabled);
    });
    __publicField(this, "item", (index2) => {
      if (this.count() === 0)
        return void 0;
      return this.values()[index2];
    });
    __publicField(this, "enabledItem", (index2) => {
      if (this.enabledCount() === 0)
        return void 0;
      return this.enabledValues()[index2];
    });
    __publicField(this, "first", () => this.item(0));
    __publicField(this, "firstEnabled", () => this.enabledItem(0));
    __publicField(this, "last", () => this.item(this.descendants.size - 1));
    __publicField(this, "lastEnabled", () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    });
    __publicField(this, "indexOf", (node2) => {
      var _a4, _b3;
      if (!node2)
        return -1;
      return (_b3 = (_a4 = this.descendants.get(node2)) == null ? void 0 : _a4.index) != null ? _b3 : -1;
    });
    __publicField(this, "enabledIndexOf", (node2) => {
      if (node2 == null)
        return -1;
      return this.enabledValues().findIndex((i2) => i2.node.isSameNode(node2));
    });
    __publicField(this, "next", (index2, loop = true) => {
      const next2 = getNextIndex(index2, this.count(), loop);
      return this.item(next2);
    });
    __publicField(this, "nextEnabled", (index2, loop = true) => {
      const item = this.item(index2);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = getNextIndex(
        enabledIndex,
        this.enabledCount(),
        loop
      );
      return this.enabledItem(nextEnabledIndex);
    });
    __publicField(this, "prev", (index2, loop = true) => {
      const prev2 = getPrevIndex(index2, this.count() - 1, loop);
      return this.item(prev2);
    });
    __publicField(this, "prevEnabled", (index2, loop = true) => {
      const item = this.item(index2);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = getPrevIndex(
        enabledIndex,
        this.enabledCount() - 1,
        loop
      );
      return this.enabledItem(prevEnabledIndex);
    });
    __publicField(this, "registerNode", (node2, options2) => {
      if (!node2 || this.descendants.has(node2))
        return;
      const keys2 = Array.from(this.descendants.keys()).concat(node2);
      const sorted = sortNodes(keys2);
      if (options2 == null ? void 0 : options2.disabled) {
        options2.disabled = !!options2.disabled;
      }
      const descendant = { node: node2, index: -1, ...options2 };
      this.descendants.set(node2, descendant);
      this.assignIndex(sorted);
    });
  }
};
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref) => {
      assignRef(ref, node2);
    });
  };
}
function useMergeRefs(...refs) {
  return reactExports.useMemo(() => mergeRefs(...refs), refs);
}
function useDescendants() {
  const descendants = reactExports.useRef(new DescendantsManager());
  useSafeLayoutEffect$1(() => {
    return () => descendants.current.destroy();
  });
  return descendants.current;
}
var [DescendantsContextProvider, useDescendantsContext] = createContext$1({
  name: "DescendantsProvider",
  errorMessage: "useDescendantsContext must be used within DescendantsProvider"
});
function useDescendant(options2) {
  const descendants = useDescendantsContext();
  const [index2, setIndex] = reactExports.useState(-1);
  const ref = reactExports.useRef(null);
  useSafeLayoutEffect$1(() => {
    return () => {
      if (!ref.current)
        return;
      descendants.unregister(ref.current);
    };
  }, []);
  useSafeLayoutEffect$1(() => {
    if (!ref.current)
      return;
    const dataIndex = Number(ref.current.dataset["index"]);
    if (index2 != dataIndex && !Number.isNaN(dataIndex)) {
      setIndex(dataIndex);
    }
  });
  const refCallback = options2 ? cast(descendants.register(options2)) : cast(descendants.register);
  return {
    descendants,
    index: index2,
    enabledIndex: descendants.enabledIndexOf(ref.current),
    register: mergeRefs(refCallback, ref)
  };
}
function createDescendantContext() {
  const ContextProvider = cast(DescendantsContextProvider);
  const _useDescendantsContext = () => cast(useDescendantsContext());
  const _useDescendant = (options2) => useDescendant(options2);
  const _useDescendants = () => useDescendants();
  return [
    ContextProvider,
    _useDescendantsContext,
    _useDescendants,
    _useDescendant
  ];
}
var NativeImage = forwardRef(function NativeImage2(props, ref) {
  const { htmlWidth, htmlHeight, alt, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { width: htmlWidth, height: htmlHeight, ref, alt, ...rest });
});
NativeImage.displayName = "NativeImage";
function useImage(props) {
  const {
    loading,
    src: src2,
    srcSet,
    onLoad,
    onError,
    crossOrigin,
    sizes: sizes2,
    ignoreFallback
  } = props;
  const [status, setStatus] = reactExports.useState("pending");
  reactExports.useEffect(() => {
    setStatus(src2 ? "loading" : "pending");
  }, [src2]);
  const imageRef = reactExports.useRef();
  const load = reactExports.useCallback(() => {
    if (!src2)
      return;
    flush();
    const img = new Image();
    img.src = src2;
    if (crossOrigin)
      img.crossOrigin = crossOrigin;
    if (srcSet)
      img.srcset = srcSet;
    if (sizes2)
      img.sizes = sizes2;
    if (loading)
      img.loading = loading;
    img.onload = (event) => {
      flush();
      setStatus("loaded");
      onLoad == null ? void 0 : onLoad(event);
    };
    img.onerror = (error) => {
      flush();
      setStatus("failed");
      onError == null ? void 0 : onError(error);
    };
    imageRef.current = img;
  }, [src2, crossOrigin, srcSet, sizes2, onLoad, onError, loading]);
  const flush = () => {
    if (imageRef.current) {
      imageRef.current.onload = null;
      imageRef.current.onerror = null;
      imageRef.current = null;
    }
  };
  useSafeLayoutEffect$2(() => {
    if (ignoreFallback)
      return void 0;
    if (status === "loading") {
      load();
    }
    return () => {
      flush();
    };
  }, [status, load, ignoreFallback]);
  return ignoreFallback ? "loaded" : status;
}
var shouldShowFallbackImage = (status, fallbackStrategy) => status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
function omit(object, keysToOmit = []) {
  const clone2 = Object.assign({}, object);
  for (const key2 of keysToOmit) {
    if (key2 in clone2) {
      delete clone2[key2];
    }
  }
  return clone2;
}
var Image$1 = forwardRef(function Image2(props, ref) {
  const {
    fallbackSrc,
    fallback,
    src: src2,
    srcSet,
    align,
    fit,
    loading,
    ignoreFallback,
    crossOrigin,
    fallbackStrategy = "beforeLoadOrError",
    referrerPolicy,
    ...rest
  } = props;
  const providedFallback = fallbackSrc !== void 0 || fallback !== void 0;
  const shouldIgnoreFallbackImage = loading != null || ignoreFallback || !providedFallback;
  const status = useImage({
    ...props,
    crossOrigin,
    ignoreFallback: shouldIgnoreFallbackImage
  });
  const showFallbackImage = shouldShowFallbackImage(status, fallbackStrategy);
  const shared = {
    ref,
    objectFit: fit,
    objectPosition: align,
    ...shouldIgnoreFallbackImage ? rest : omit(rest, ["onError", "onLoad"])
  };
  if (showFallbackImage) {
    if (fallback)
      return fallback;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.img,
      {
        as: NativeImage,
        className: "chakra-image__placeholder",
        src: fallbackSrc,
        ...shared
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.img,
    {
      as: NativeImage,
      src: src2,
      srcSet,
      crossOrigin,
      loading,
      referrerPolicy,
      className: "chakra-image",
      ...shared
    }
  );
});
Image$1.displayName = "Image";
var [ButtonGroupProvider, useButtonGroup] = createContext$1({
  strict: false,
  name: "ButtonGroupContext"
});
function useButtonType(value) {
  const [isButton, setIsButton] = reactExports.useState(!value);
  const refCallback = reactExports.useCallback((node2) => {
    if (!node2)
      return;
    setIsButton(node2.tagName === "BUTTON");
  }, []);
  const type = isButton ? "button" : void 0;
  return { ref: refCallback, type };
}
function ButtonIcon(props) {
  const { children, className, ...rest } = props;
  const _children = reactExports.isValidElement(children) ? reactExports.cloneElement(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;
  const _className = cx("chakra-button__icon", className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...rest,
      className: _className,
      children: _children
    }
  );
}
ButtonIcon.displayName = "ButtonIcon";
function ButtonSpinner(props) {
  const {
    label,
    placement,
    spacing: spacing2 = "0.5rem",
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-button__spinner", className);
  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = reactExports.useMemo(
    () => ({
      display: "flex",
      alignItems: "center",
      position: label ? "relative" : "absolute",
      [marginProp]: label ? spacing2 : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...__css
    }),
    [__css, label, marginProp, spacing2]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
}
ButtonSpinner.displayName = "ButtonSpinner";
var Button = forwardRef((props, ref) => {
  const group = useButtonGroup();
  const styles2 = useStyleConfig("Button", { ...group, ...props });
  const {
    isDisabled: isDisabled2 = group == null ? void 0 : group.isDisabled,
    isLoading,
    isActive,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing: iconSpacing2 = "0.5rem",
    type,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    ...rest
  } = omitThemingProps(props);
  const buttonStyles = reactExports.useMemo(() => {
    const _focus = { ...styles2 == null ? void 0 : styles2["_focus"], zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...styles2,
      ...!!group && { _focus }
    };
  }, [styles2, group]);
  const { ref: _ref, type: defaultType } = useButtonType(as);
  const contentProps = { rightIcon, leftIcon, iconSpacing: iconSpacing2, children };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    chakra.button,
    {
      ref: useMergeRefs(ref, _ref),
      as,
      type: type != null ? type : defaultType,
      "data-active": dataAttr(isActive),
      "data-loading": dataAttr(isLoading),
      __css: buttonStyles,
      className: cx("chakra-button", className),
      ...rest,
      disabled: isDisabled2 || isLoading,
      children: [
        isLoading && spinnerPlacement === "start" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--start",
            label: loadingText,
            placement: "start",
            spacing: iconSpacing2,
            children: spinner
          }
        ),
        isLoading ? loadingText || /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { opacity: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonContent, { ...contentProps }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonContent, { ...contentProps }),
        isLoading && spinnerPlacement === "end" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--end",
            label: loadingText,
            placement: "end",
            spacing: iconSpacing2,
            children: spinner
          }
        )
      ]
    }
  );
});
Button.displayName = "Button";
function ButtonContent(props) {
  const { leftIcon, rightIcon, children, iconSpacing: iconSpacing2 } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonIcon, { marginEnd: iconSpacing2, children: leftIcon }),
    children,
    rightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonIcon, { marginStart: iconSpacing2, children: rightIcon })
  ] });
}
var IconButton = forwardRef(
  (props, ref) => {
    const { icon, children, isRound, "aria-label": ariaLabel, ...rest } = props;
    const element = icon || children;
    const _children = reactExports.isValidElement(element) ? reactExports.cloneElement(element, {
      "aria-hidden": true,
      focusable: false
    }) : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        padding: "0",
        borderRadius: isRound ? "full" : void 0,
        ref,
        "aria-label": ariaLabel,
        ...rest,
        children: _children
      }
    );
  }
);
IconButton.displayName = "IconButton";
function useEventListener(target, event, handler, options2) {
  const listener = useCallbackRef$1(handler);
  reactExports.useEffect(() => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    if (!handler || !node2)
      return;
    node2.addEventListener(event, listener, options2);
    return () => {
      node2.removeEventListener(event, listener, options2);
    };
  }, [event, target, options2, listener, handler]);
  return () => {
    const node2 = typeof target === "function" ? target() : target != null ? target : document;
    node2 == null ? void 0 : node2.removeEventListener(event, listener, options2);
  };
}
function isElement$2(el2) {
  return el2 != null && typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement$2(el2) {
  var _a4;
  if (!isElement$2(el2))
    return false;
  const win = (_a4 = el2.ownerDocument.defaultView) != null ? _a4 : window;
  return el2 instanceof win.HTMLElement;
}
function getOwnerWindow(node2) {
  var _a4, _b3;
  return (_b3 = (_a4 = getOwnerDocument$2(node2)) == null ? void 0 : _a4.defaultView) != null ? _b3 : window;
}
function getOwnerDocument$2(node2) {
  return isElement$2(node2) ? node2.ownerDocument : document;
}
function getActiveElement(node2) {
  return getOwnerDocument$2(node2).activeElement;
}
var hasTabIndex = (element) => element.hasAttribute("tabindex");
var hasNegativeTabIndex = (element) => hasTabIndex(element) && element.tabIndex === -1;
function isDisabled(element) {
  return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
}
function isHidden(element) {
  if (element.parentElement && isHidden(element.parentElement))
    return true;
  return element.hidden;
}
function isContentEditable(element) {
  const value = element.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isFocusable(element) {
  if (!isHTMLElement$2(element) || isHidden(element) || isDisabled(element)) {
    return false;
  }
  const { localName } = element;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0)
    return true;
  const others2 = {
    a: () => element.hasAttribute("href"),
    audio: () => element.hasAttribute("controls"),
    video: () => element.hasAttribute("controls")
  };
  if (localName in others2) {
    return others2[localName]();
  }
  if (isContentEditable(element))
    return true;
  return hasTabIndex(element);
}
function isTabbable(element) {
  if (!element)
    return false;
  return isHTMLElement$2(element) && isFocusable(element) && !hasNegativeTabIndex(element);
}
var useSafeLayoutEffect = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
function useCallbackRef(fn2, deps = []) {
  const ref = reactExports.useRef(fn2);
  useSafeLayoutEffect(() => {
    ref.current = fn2;
  });
  return reactExports.useCallback((...args) => {
    var _a4;
    return (_a4 = ref.current) == null ? void 0 : _a4.call(ref, ...args);
  }, deps);
}
function useId(idProp, prefix2) {
  const id2 = reactExports.useId();
  return reactExports.useMemo(
    () => idProp || [prefix2, id2].filter(Boolean).join("-"),
    [idProp, prefix2, id2]
  );
}
function useControllableProp(prop, state2) {
  const isControlled = prop !== void 0;
  const value = isControlled && typeof prop !== "undefined" ? prop : state2;
  return [isControlled, value];
}
function useDisclosure$1(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const onOpenPropCallbackRef = useCallbackRef(onOpenProp);
  const onClosePropCallbackRef = useCallbackRef(onCloseProp);
  const [isOpenState, setIsOpen] = reactExports.useState(props.defaultIsOpen || false);
  const [isControlled, isOpen] = useControllableProp(isOpenProp, isOpenState);
  const id2 = useId(idProp, "disclosure");
  const onClose = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
  }, [isControlled, onClosePropCallbackRef]);
  const onOpen = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
  }, [isControlled, onOpenPropCallbackRef]);
  const onToggle = reactExports.useCallback(() => {
    const action = isOpen ? onClose : onOpen;
    action();
  }, [isOpen, onOpen, onClose]);
  return {
    isOpen: !!isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps: (props2 = {}) => ({
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick: callAllHandlers(props2.onClick, onToggle)
    }),
    getDisclosureProps: (props2 = {}) => ({
      ...props2,
      hidden: !isOpen,
      id: id2
    })
  };
}
var Link = forwardRef(function Link2(props, ref) {
  const styles2 = useStyleConfig("Link", props);
  const { className, isExternal, ...rest } = omitThemingProps(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.a,
    {
      target: isExternal ? "_blank" : void 0,
      rel: isExternal ? "noopener" : void 0,
      ref,
      className: cx("chakra-link", className),
      ...rest,
      __css: styles2
    }
  );
});
Link.displayName = "Link";
var Text = forwardRef(function Text2(props, ref) {
  const styles2 = useStyleConfig("Text", props);
  const { className, align, decoration, casing, ...rest } = omitThemingProps(props);
  const aliasedProps = compact({
    textAlign: props.align,
    textDecoration: props.decoration,
    textTransform: props.casing
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.p,
    {
      ref,
      className: cx("chakra-text", props.className),
      ...aliasedProps,
      ...rest,
      __css: styles2
    }
  );
});
Text.displayName = "Text";
var Flex = forwardRef(function Flex2(props, ref) {
  const { direction: direction2, align, justify, wrap: wrap2, basis, grow, shrink, ...rest } = props;
  const styles2 = {
    display: "flex",
    flexDirection: direction2,
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap2,
    flexBasis: basis,
    flexGrow: grow,
    flexShrink: shrink
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.div, { ref, __css: styles2, ...rest });
});
Flex.displayName = "Flex";
function useMediaQuery(query, options2 = {}) {
  const { ssr = true, fallback } = options2;
  const { getWindow: getWindow2 } = useEnvironment();
  const queries = Array.isArray(query) ? query : [query];
  let fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
  fallbackValues = fallbackValues.filter((v2) => v2 != null);
  const [value, setValue] = reactExports.useState(() => {
    return queries.map((query2, index2) => ({
      media: query2,
      matches: ssr ? !!fallbackValues[index2] : getWindow2().matchMedia(query2).matches
    }));
  });
  reactExports.useEffect(() => {
    const win = getWindow2();
    setValue(
      queries.map((query2) => ({
        media: query2,
        matches: win.matchMedia(query2).matches
      }))
    );
    const mql = queries.map((query2) => win.matchMedia(query2));
    const handler = (evt) => {
      setValue((prev2) => {
        return prev2.slice().map((item) => {
          if (item.media === evt.media)
            return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    mql.forEach((mql2) => {
      if (typeof mql2.addListener === "function") {
        mql2.addListener(handler);
      } else {
        mql2.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach((mql2) => {
        if (typeof mql2.removeListener === "function") {
          mql2.removeListener(handler);
        } else {
          mql2.removeEventListener("change", handler);
        }
      });
    };
  }, [getWindow2]);
  return value.map((item) => item.matches);
}
function isPrintableCharacter(event) {
  const { key: key2 } = event;
  return key2.length === 1 || key2.length > 1 && /[^a-zA-Z0-9]/.test(key2);
}
function useShortcut(props = {}) {
  const { timeout = 300, preventDefault = () => true } = props;
  const [keys2, setKeys] = reactExports.useState([]);
  const timeoutRef = reactExports.useRef();
  const flush = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  const clearKeysAfterDelay = () => {
    flush();
    timeoutRef.current = setTimeout(() => {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  reactExports.useEffect(() => flush, []);
  function onKeyDown(fn2) {
    return (event) => {
      if (event.key === "Backspace") {
        const keysCopy = [...keys2];
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        const keysCopy = keys2.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(keysCopy);
        fn2(keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(
      (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
    );
    return foundItem;
  }
  const matchingItems = items.filter(
    (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
  );
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}
function useEventListeners() {
  const listeners = reactExports.useRef(/* @__PURE__ */ new Map());
  const currentListeners = listeners.current;
  const add4 = reactExports.useCallback((el2, type, listener, options2) => {
    listeners.current.set(listener, { type, el: el2, options: options2 });
    el2.addEventListener(type, listener, options2);
  }, []);
  const remove = reactExports.useCallback(
    (el2, type, listener, options2) => {
      el2.removeEventListener(type, listener, options2);
      listeners.current.delete(listener);
    },
    []
  );
  reactExports.useEffect(
    () => () => {
      currentListeners.forEach((value, key2) => {
        remove(value.el, value.type, key2, value.options);
      });
    },
    [remove, currentListeners]
  );
  return { add: add4, remove };
}
function isValidElement(event) {
  const element = event.target;
  const { tagName, isContentEditable: isContentEditable2 } = element;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable2 !== true;
}
function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  const [isButton, setIsButton] = reactExports.useState(true);
  const [isPressed, setIsPressed] = reactExports.useState(false);
  const listeners = useEventListeners();
  const refCallback = (node2) => {
    if (!node2)
      return;
    if (node2.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };
  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  const handleClick = reactExports.useCallback(
    (event) => {
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      const self2 = event.currentTarget;
      self2.focus();
      onClick == null ? void 0 : onClick(event);
    },
    [isDisabled2, onClick]
  );
  const onDocumentKeyUp = reactExports.useCallback(
    (e2) => {
      if (isPressed && isValidElement(e2)) {
        e2.preventDefault();
        e2.stopPropagation();
        setIsPressed(false);
        listeners.remove(document, "keyup", onDocumentKeyUp, false);
      }
    },
    [isPressed, listeners]
  );
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey) {
        return;
      }
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(true);
      }
      if (shouldClickOnEnter) {
        event.preventDefault();
        const self2 = event.currentTarget;
        self2.click();
      }
      listeners.add(document, "keyup", onDocumentKeyUp, false);
    },
    [
      isDisabled2,
      isButton,
      onKeyDown,
      clickOnEnter,
      clickOnSpace,
      listeners,
      onDocumentKeyUp
    ]
  );
  const handleKeyUp = reactExports.useCallback(
    (event) => {
      onKeyUp == null ? void 0 : onKeyUp(event);
      if (isDisabled2 || event.defaultPrevented || event.metaKey)
        return;
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(false);
        const self2 = event.currentTarget;
        self2.click();
      }
    },
    [clickOnSpace, isButton, isDisabled2, onKeyUp]
  );
  const onDocumentMouseUp = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      setIsPressed(false);
      listeners.remove(document, "mouseup", onDocumentMouseUp, false);
    },
    [listeners]
  );
  const handleMouseDown = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (isDisabled2) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      if (!isButton) {
        setIsPressed(true);
      }
      const target = event.currentTarget;
      target.focus({ preventScroll: true });
      listeners.add(document, "mouseup", onDocumentMouseUp, false);
      onMouseDown == null ? void 0 : onMouseDown(event);
    },
    [isDisabled2, isButton, onMouseDown, listeners, onDocumentMouseUp]
  );
  const handleMouseUp = reactExports.useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (!isButton) {
        setIsPressed(false);
      }
      onMouseUp == null ? void 0 : onMouseUp(event);
    },
    [onMouseUp, isButton]
  );
  const handleMouseOver = reactExports.useCallback(
    (event) => {
      if (isDisabled2) {
        event.preventDefault();
        return;
      }
      onMouseOver == null ? void 0 : onMouseOver(event);
    },
    [isDisabled2, onMouseOver]
  );
  const handleMouseLeave = reactExports.useCallback(
    (event) => {
      if (isPressed) {
        event.preventDefault();
        setIsPressed(false);
      }
      onMouseLeave == null ? void 0 : onMouseLeave(event);
    },
    [isPressed, onMouseLeave]
  );
  const ref = mergeRefs(htmlRef, refCallback);
  if (isButton) {
    return {
      ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled2,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }
  return {
    ...htmlProps,
    ref,
    role: "button",
    "data-active": dataAttr(isPressed),
    "aria-disabled": isDisabled2 ? "true" : void 0,
    tabIndex: trulyDisabled ? void 0 : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}
function preventReturnFocus(containerRef) {
  const el2 = containerRef.current;
  if (!el2)
    return false;
  const activeElement = getActiveElement(el2);
  if (!activeElement)
    return false;
  if (el2.contains(activeElement))
    return false;
  if (isTabbable(activeElement))
    return true;
  return false;
}
function useFocusOnHide(containerRef, options2) {
  const { shouldFocus: shouldFocusProp, visible, focusRef } = options2;
  const shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(() => {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el2 = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    let rafId;
    if (el2) {
      rafId = requestAnimationFrame(() => {
        el2.focus({ preventScroll: true });
      });
      return () => {
        cancelAnimationFrame(rafId);
      };
    }
  }, [shouldFocus, containerRef, focusRef]);
}
var toVar = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});
var cssVars = {
  arrowShadowColor: toVar("--popper-arrow-shadow-color"),
  arrowSize: toVar("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar("--popper-arrow-size-half"),
  arrowBg: toVar("--popper-arrow-bg"),
  transformOrigin: toVar("--popper-transform-origin"),
  arrowOffset: toVar("--popper-arrow-offset")
};
function getBoxShadow(placement) {
  if (placement.includes("top"))
    return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom"))
    return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right"))
    return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left"))
    return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
}
var transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var toTransformOrigin = (placement) => transforms[placement];
var defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners2;
  if (typeof value === "object") {
    eventListeners2 = {
      enabled: true,
      options: { ...defaultEventListeners, ...value }
    };
  } else {
    eventListeners2 = {
      enabled: value,
      options: defaultEventListeners
    };
  }
  return eventListeners2;
}
var matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: state2 }) => {
    state2.styles.popper.width = `${state2.rects.reference.width}px`;
  },
  effect: ({ state: state2 }) => () => {
    const reference2 = state2.elements.reference;
    state2.elements.popper.style.width = `${reference2.offsetWidth}px`;
  }
};
var transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({ state: state2 }) => {
    setTransformOrigin(state2);
  },
  effect: ({ state: state2 }) => () => {
    setTransformOrigin(state2);
  }
};
var setTransformOrigin = (state2) => {
  state2.elements.popper.style.setProperty(
    cssVars.transformOrigin.var,
    toTransformOrigin(state2.placement)
  );
};
var positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({ state: state2 }) => {
    setArrowStyles(state2);
  }
};
var setArrowStyles = (state2) => {
  var _a4;
  if (!state2.placement)
    return;
  const overrides = getArrowStyle$1(state2.placement);
  if (((_a4 = state2.elements) == null ? void 0 : _a4.arrow) && overrides) {
    Object.assign(state2.elements.arrow.style, {
      [overrides.property]: overrides.value,
      width: cssVars.arrowSize.varRef,
      height: cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars2 = {
      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
    };
    for (const property in vars2) {
      state2.elements.arrow.style.setProperty(property, vars2[property]);
    }
  }
};
var getArrowStyle$1 = (placement) => {
  if (placement.startsWith("top")) {
    return { property: "bottom", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("bottom")) {
    return { property: "top", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("left")) {
    return { property: "right", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("right")) {
    return { property: "left", value: cssVars.arrowOffset.varRef };
  }
};
var innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: state2 }) => {
    setInnerArrowStyles(state2);
  },
  effect: ({ state: state2 }) => () => {
    setInnerArrowStyles(state2);
  }
};
var setInnerArrowStyles = (state2) => {
  if (!state2.elements.arrow)
    return;
  const inner = state2.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!inner)
    return;
  const boxShadow = getBoxShadow(state2.placement);
  if (boxShadow) {
    inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
  }
  Object.assign(inner.style, {
    transform: "rotate(45deg)",
    background: cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
  });
};
var logicals = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
var opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir2 = "ltr") {
  var _a4, _b3;
  const value = ((_a4 = logicals[placement]) == null ? void 0 : _a4[dir2]) || placement;
  if (dir2 === "ltr")
    return value;
  return (_b3 = opposites[placement]) != null ? _b3 : value;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}
function isElement$1(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name2) {
    var style = state2.styles[name2] || {};
    var attributes = state2.attributes[name2] || {};
    var element = state2.elements[name2];
    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name2) {
      var element = state2.elements[name2];
      var attributes = state2.attributes[name2] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state2) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name2 = _ref.name, options2 = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len2 = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len2] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len2];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len2] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len2] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$1(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len2 = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len2] / 2 - element[len2] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len2] / 2 - element[len2] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply2 = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply2;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options2 = _ref.options, name2 = _ref.name;
  if (state2.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding2 = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len2 = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len2] > popperRect[len2]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name2]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options, name2 = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x2;
    state2.modifiersData.popperOffsets.y += y2;
  }
  state2.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  state2.modifiersData[name2] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options2 = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding2 = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len2 = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len2] / 2 : 0;
    var minLen = variation === start ? referenceRect[len2] : popperRect[len2];
    var maxLen = variation === start ? -popperRect[len2] : -referenceRect[len2];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len2], arrowRect[len2]);
    var minOffset = isBasePlacement ? referenceRect[len2] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len2] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options3);
        state2.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name: name2,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state3) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name: name2,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners: eventListeners2 = true,
    offset: offset2,
    gutter = 8,
    flip: flip2 = true,
    boundary = "clippingParents",
    preventOverflow: preventOverflow2 = true,
    matchWidth: matchWidth2,
    direction: direction2 = "ltr"
  } = props;
  const reference2 = reactExports.useRef(null);
  const popper2 = reactExports.useRef(null);
  const instance = reactExports.useRef(null);
  const placement = getPopperPlacement(placementProp, direction2);
  const cleanup = reactExports.useRef(() => {
  });
  const setupPopper = reactExports.useCallback(() => {
    var _a4;
    if (!enabled || !reference2.current || !popper2.current)
      return;
    (_a4 = cleanup.current) == null ? void 0 : _a4.call(cleanup);
    instance.current = createPopper(reference2.current, popper2.current, {
      placement,
      modifiers: [
        innerArrow,
        positionArrow,
        transformOrigin,
        {
          ...matchWidth,
          enabled: !!matchWidth2
        },
        {
          name: "eventListeners",
          ...getEventListenerOptions(eventListeners2)
        },
        {
          name: "arrow",
          options: { padding: arrowPadding }
        },
        {
          name: "offset",
          options: {
            offset: offset2 != null ? offset2 : [0, gutter]
          }
        },
        {
          name: "flip",
          enabled: !!flip2,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!preventOverflow2,
          options: { boundary }
        },
        ...modifiers != null ? modifiers : []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled,
    modifiers,
    matchWidth2,
    eventListeners2,
    arrowPadding,
    offset2,
    gutter,
    flip2,
    preventOverflow2,
    boundary,
    strategy
  ]);
  reactExports.useEffect(() => {
    return () => {
      var _a4;
      if (!reference2.current && !popper2.current) {
        (_a4 = instance.current) == null ? void 0 : _a4.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = reactExports.useCallback(
    (node2) => {
      reference2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = reactExports.useCallback(
    (node2) => {
      popper2.current = node2;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props2.style,
        position: strategy,
        minWidth: matchWidth2 ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth2]
  );
  const getArrowProps = reactExports.useCallback((props2 = {}, ref = null) => {
    const { size: size2, shadowColor, bg: bg2, style, ...rest } = props2;
    return {
      ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle(props2)
    };
  }, []);
  const getArrowInnerProps = reactExports.useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      var _a4;
      (_a4 = instance.current) == null ? void 0 : _a4.update();
    },
    forceUpdate() {
      var _a4;
      (_a4 = instance.current) == null ? void 0 : _a4.forceUpdate();
    },
    transformOrigin: cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}
function getArrowStyle(props) {
  const { size: size2, shadowColor, bg: bg2, style } = props;
  const computedStyle = { ...style, position: "absolute" };
  if (size2) {
    computedStyle["--popper-arrow-size"] = size2;
  }
  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }
  if (bg2) {
    computedStyle["--popper-arrow-bg"] = bg2;
  }
  return computedStyle;
}
function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const handleOpen = useCallbackRef$1(onOpenProp);
  const handleClose = useCallbackRef$1(onCloseProp);
  const [isOpenState, setIsOpen] = reactExports.useState(props.defaultIsOpen || false);
  const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
  const isControlled = isOpenProp !== void 0;
  const uid = reactExports.useId();
  const id2 = idProp != null ? idProp : `disclosure-${uid}`;
  const onClose = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = reactExports.useCallback(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = reactExports.useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      onOpen();
    }
  }, [isOpen, onOpen, onClose]);
  function getButtonProps(props2 = {}) {
    return {
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick(event) {
        var _a4;
        (_a4 = props2.onClick) == null ? void 0 : _a4.call(props2, event);
        onToggle();
      }
    };
  }
  function getDisclosureProps(props2 = {}) {
    return {
      ...props2,
      hidden: !isOpen,
      id: id2
    };
  }
  return {
    isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps,
    getDisclosureProps
  };
}
function useOutsideClick(props) {
  const { ref, handler, enabled = true } = props;
  const savedHandler = useCallbackRef$1(handler);
  const stateRef = reactExports.useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state2 = stateRef.current;
  reactExports.useEffect(() => {
    if (!enabled)
      return;
    const onPointerDown = (e2) => {
      if (isValidEvent(e2, ref)) {
        state2.isPointerDown = true;
      }
    };
    const onMouseUp = (event) => {
      if (state2.ignoreEmulatedMouseEvents) {
        state2.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state2.isPointerDown && handler && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = (event) => {
      state2.ignoreEmulatedMouseEvents = true;
      if (handler && state2.isPointerDown && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = getOwnerDocument$1(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state2, enabled]);
}
function isValidEvent(event, ref) {
  var _a4;
  const target = event.target;
  if (target) {
    const doc = getOwnerDocument$1(target);
    if (!doc.contains(target))
      return false;
  }
  return !((_a4 = ref.current) == null ? void 0 : _a4.contains(target));
}
function getOwnerDocument$1(node2) {
  var _a4;
  return (_a4 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a4 : document;
}
function useAnimationState(props) {
  const { isOpen, ref } = props;
  const [mounted, setMounted] = reactExports.useState(isOpen);
  const [once, setOnce] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!once) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once, mounted]);
  useEventListener(
    () => ref.current,
    "animationend",
    () => {
      setMounted(isOpen);
    }
  );
  const hidden2 = isOpen ? false : !mounted;
  return {
    present: !hidden2,
    onComplete() {
      var _a4;
      const win = getOwnerWindow(ref.current);
      const evt = new win.CustomEvent("animationend", { bubbles: true });
      (_a4 = ref.current) == null ? void 0 : _a4.dispatchEvent(evt);
    }
  };
}
function lazyDisclosure(options2) {
  const { wasSelected, enabled, isSelected, mode: mode2 = "unmount" } = options2;
  if (!enabled)
    return true;
  if (isSelected)
    return true;
  if (mode2 === "keepMounted" && wasSelected)
    return true;
  return false;
}
var [
  MenuDescendantsProvider,
  useMenuDescendantsContext,
  useMenuDescendants,
  useMenuDescendant
] = createDescendantContext();
var [MenuProvider, useMenuContext] = createContext$1({
  strict: false,
  name: "MenuContext"
});
function useIds(idProp, ...prefixes) {
  const reactId = reactExports.useId();
  const id2 = idProp || reactId;
  return reactExports.useMemo(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
function getOwnerDocument(node2) {
  var _a4;
  return (_a4 = node2 == null ? void 0 : node2.ownerDocument) != null ? _a4 : document;
}
function isActiveElement(element) {
  const doc = getOwnerDocument(element);
  return doc.activeElement === element;
}
function useMenu(props = {}) {
  const {
    id: id2,
    closeOnSelect = true,
    closeOnBlur = true,
    initialFocusRef,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction: direction2,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  const menuRef = reactExports.useRef(null);
  const buttonRef = reactExports.useRef(null);
  const descendants = useMenuDescendants();
  const focusMenu = reactExports.useCallback(() => {
    requestAnimationFrame(() => {
      var _a4;
      (_a4 = menuRef.current) == null ? void 0 : _a4.focus({ preventScroll: false });
    });
  }, []);
  const focusFirstItem = reactExports.useCallback(() => {
    const id22 = setTimeout(() => {
      var _a4;
      if (initialFocusRef) {
        (_a4 = initialFocusRef.current) == null ? void 0 : _a4.focus();
      } else {
        const first = descendants.firstEnabled();
        if (first)
          setFocusedIndex(first.index);
      }
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const focusLastItem = reactExports.useCallback(() => {
    const id22 = setTimeout(() => {
      const last = descendants.lastEnabled();
      if (last)
        setFocusedIndex(last.index);
    });
    timeoutIds.current.add(id22);
  }, [descendants]);
  const onOpenInternal = reactExports.useCallback(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  useOutsideClick({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: (event) => {
      var _a4;
      if (!((_a4 = buttonRef.current) == null ? void 0 : _a4.contains(event.target))) {
        onClose();
      }
    }
  });
  const popper2 = usePopper({
    ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction: direction2
  });
  const [focusedIndex, setFocusedIndex] = reactExports.useState(-1);
  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  const animationState = useAnimationState({ isOpen, ref: menuRef });
  const [buttonId, menuId] = useIds(id2, `menu-button`, `menu-list`);
  const openAndFocusMenu = reactExports.useCallback(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = reactExports.useRef(/* @__PURE__ */ new Set([]));
  useUnmountEffect(() => {
    timeoutIds.current.forEach((id22) => clearTimeout(id22));
    timeoutIds.current.clear();
  });
  const openAndFocusFirstItem = reactExports.useCallback(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = reactExports.useCallback(() => {
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = reactExports.useCallback(() => {
    var _a4, _b3;
    const doc = getOwnerDocument(menuRef.current);
    const hasFocusWithin = (_a4 = menuRef.current) == null ? void 0 : _a4.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus)
      return;
    const node2 = (_b3 = descendants.item(focusedIndex)) == null ? void 0 : _b3.node;
    node2 == null ? void 0 : node2.focus();
  }, [isOpen, focusedIndex, descendants]);
  const rafId = reactExports.useRef(null);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    unstable__animationState: animationState,
    descendants,
    popper: popper2,
    buttonId,
    menuId,
    forceUpdate: popper2.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior,
    initialFocusRef,
    rafId
  };
}
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const { onToggle, popper: popper2, openAndFocusFirstItem, openAndFocusLastItem } = menu;
  const onKeyDown = reactExports.useCallback(
    (event) => {
      const eventKey = event.key;
      const keyMap = {
        Enter: openAndFocusFirstItem,
        ArrowDown: openAndFocusFirstItem,
        ArrowUp: openAndFocusLastItem
      };
      const action = keyMap[eventKey];
      if (action) {
        event.preventDefault();
        event.stopPropagation();
        action(event);
      }
    },
    [openAndFocusFirstItem, openAndFocusLastItem]
  );
  return {
    ...props,
    ref: mergeRefs(menu.buttonRef, externalRef, popper2.referenceRef),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers$1(props.onClick, onToggle),
    onKeyDown: callAllHandlers$1(props.onKeyDown, onKeyDown)
  };
}
function isTargetMenuItem(target) {
  var _a4;
  return isHTMLElement(target) && !!((_a4 = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a4.startsWith("menuitem"));
}
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();
  if (!menu) {
    throw new Error(
      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`
    );
  }
  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior,
    unstable__animationState: animated
  } = menu;
  const descendants = useMenuDescendantsContext();
  const createTypeaheadHandler = useShortcut({
    preventDefault: (event) => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = reactExports.useCallback(
    (event) => {
      if (!event.currentTarget.contains(event.target))
        return;
      const eventKey = event.key;
      const keyMap = {
        Tab: (event2) => event2.preventDefault(),
        Escape: onClose,
        ArrowDown: () => {
          const next2 = descendants.nextEnabled(focusedIndex);
          if (next2)
            setFocusedIndex(next2.index);
        },
        ArrowUp: () => {
          const prev2 = descendants.prevEnabled(focusedIndex);
          if (prev2)
            setFocusedIndex(prev2.index);
        }
      };
      const fn2 = keyMap[eventKey];
      if (fn2) {
        event.preventDefault();
        fn2(event);
        return;
      }
      const onTypeahead = createTypeaheadHandler((character2) => {
        const nextItem = getNextItemFromSearch(
          descendants.values(),
          character2,
          (item) => {
            var _a4, _b3;
            return (_b3 = (_a4 = item == null ? void 0 : item.node) == null ? void 0 : _a4.textContent) != null ? _b3 : "";
          },
          descendants.item(focusedIndex)
        );
        if (nextItem) {
          const index2 = descendants.indexOf(nextItem.node);
          setFocusedIndex(index2);
        }
      });
      if (isTargetMenuItem(event.target)) {
        onTypeahead(event);
      }
    },
    [
      descendants,
      focusedIndex,
      createTypeaheadHandler,
      onClose,
      setFocusedIndex
    ]
  );
  const hasBeenOpened = reactExports.useRef(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const shouldRenderChildren = lazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  return {
    ...props,
    ref: mergeRefs(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: {
      ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers$1(props.onKeyDown, onKeyDown)
  };
}
function useMenuPositioner(props = {}) {
  const { popper: popper2, isOpen } = useMenuContext();
  return popper2.getPopperProps({
    ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    onFocus: onFocusProp,
    isDisabled: isDisabled2,
    isFocusable: isFocusable2,
    closeOnSelect,
    type: typeProp,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuRef,
    isOpen,
    menuId,
    rafId
  } = menu;
  const ref = reactExports.useRef(null);
  const id2 = `${menuId}-menuitem-${reactExports.useId()}`;
  const { index: index2, register } = useMenuDescendant({
    disabled: isDisabled2 && !isFocusable2
  });
  const onMouseEnter = reactExports.useCallback(
    (event) => {
      onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(index2);
    },
    [setFocusedIndex, index2, isDisabled2, onMouseEnterProp]
  );
  const onMouseMove = reactExports.useCallback(
    (event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (ref.current && !isActiveElement(ref.current)) {
        onMouseEnter(event);
      }
    },
    [onMouseEnter, onMouseMoveProp]
  );
  const onMouseLeave = reactExports.useCallback(
    (event) => {
      onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
      if (isDisabled2)
        return;
      setFocusedIndex(-1);
    },
    [setFocusedIndex, isDisabled2, onMouseLeaveProp]
  );
  const onClick = reactExports.useCallback(
    (event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (!isTargetMenuItem(event.currentTarget))
        return;
      if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {
        onClose();
      }
    },
    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]
  );
  const onFocus = reactExports.useCallback(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      setFocusedIndex(index2);
    },
    [setFocusedIndex, onFocusProp, index2]
  );
  const isFocused = index2 === focusedIndex;
  const trulyDisabled = isDisabled2 && !isFocusable2;
  useUpdateEffect(() => {
    if (!isOpen)
      return;
    if (isFocused && !trulyDisabled && ref.current) {
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
      rafId.current = requestAnimationFrame(() => {
        var _a4;
        (_a4 = ref.current) == null ? void 0 : _a4.focus();
        rafId.current = null;
      });
    } else if (menuRef.current && !isActiveElement(menuRef.current)) {
      menuRef.current.focus({ preventScroll: true });
    }
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  const clickableProps = useClickable({
    onClick,
    onFocus,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(register, ref, externalRef),
    isDisabled: isDisabled2,
    isFocusable: isFocusable2
  });
  return {
    ...htmlProps,
    ...clickableProps,
    type: typeProp != null ? typeProp : clickableProps.type,
    id: id2,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
function useMenuOption(props = {}, ref = null) {
  const { type = "radio", isChecked, ...rest } = props;
  const ownProps = useMenuItem(rest, ref);
  return {
    ...ownProps,
    role: `menuitem${type}`,
    "aria-checked": isChecked
  };
}
function isHTMLElement(el2) {
  var _a4;
  if (!isElement(el2))
    return false;
  const win = (_a4 = el2.ownerDocument.defaultView) != null ? _a4 : window;
  return el2 instanceof win.HTMLElement;
}
function isElement(el2) {
  return el2 != null && typeof el2 == "object" && "nodeType" in el2 && el2.nodeType === Node.ELEMENT_NODE;
}
function useUnmountEffect(fn2, deps = []) {
  return reactExports.useEffect(
    () => () => fn2(),
    deps
  );
}
var [MenuStylesProvider, useMenuStyles] = createContext$1({
  name: `MenuStylesContext`,
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
});
var Menu = (props) => {
  const { children } = props;
  const styles2 = useMultiStyleConfig("Menu", props);
  const ownProps = omitThemingProps(props);
  const { direction: direction2 } = useTheme();
  const { descendants, ...ctx } = useMenu({ ...ownProps, direction: direction2 });
  const context = reactExports.useMemo(() => ctx, [ctx]);
  const { isOpen, onClose, forceUpdate } = context;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDescendantsProvider, { value: descendants, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuStylesProvider, { value: styles2, children: runIfFn$2(children, { isOpen, onClose, forceUpdate }) }) }) });
};
Menu.displayName = "Menu";
var MenuCommand = forwardRef(
  (props, ref) => {
    const styles2 = useMenuStyles();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.span,
      {
        ref,
        ...props,
        __css: styles2.command,
        className: "chakra-menu__command"
      }
    );
  }
);
MenuCommand.displayName = "MenuCommand";
var StyledMenuItem = forwardRef(
  (props, ref) => {
    const { type, ...rest } = props;
    const styles2 = useMenuStyles();
    const btnType = rest.as || type ? type != null ? type : void 0 : "button";
    const buttonStyles = reactExports.useMemo(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...styles2.item
      }),
      [styles2.item]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.button, { ref, type: btnType, ...rest, __css: buttonStyles });
  }
);
var MenuIcon = (props) => {
  const { className, children, ...rest } = props;
  const child = reactExports.Children.only(children);
  const clone2 = reactExports.isValidElement(child) ? reactExports.cloneElement(child, {
    focusable: "false",
    "aria-hidden": true,
    className: cx("chakra-menu__icon", child.props.className)
  }) : null;
  const _className = cx("chakra-menu__icon-wrapper", className);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      className: _className,
      ...rest,
      __css: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0
      },
      children: clone2
    }
  );
};
MenuIcon.displayName = "MenuIcon";
var MenuItem = forwardRef((props, ref) => {
  const {
    icon,
    iconSpacing: iconSpacing2 = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = useMenuItem(rest, ref);
  const shouldWrap = icon || command;
  const _children = shouldWrap ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { pointerEvents: "none", flex: 1 }, children }) : children;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    StyledMenuItem,
    {
      ...menuitemProps,
      className: cx("chakra-menu__menuitem", menuitemProps.className),
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuIcon, { fontSize: "0.8em", marginEnd: iconSpacing2, children: icon }),
        _children,
        command && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuCommand, { marginStart: commandSpacing, children: command })
      ]
    }
  );
});
MenuItem.displayName = "MenuItem";
var motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
};
var MenuTransition = chakra(motion.div);
var MenuList = forwardRef(function MenuList2(props, ref) {
  var _a4, _b3;
  const { rootProps, motionProps, ...rest } = props;
  const {
    isOpen,
    onTransitionEnd,
    unstable__animationState: animated
  } = useMenuContext();
  const listProps = useMenuList(rest, ref);
  const positionerProps = useMenuPositioner(rootProps);
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.div,
    {
      ...positionerProps,
      __css: { zIndex: (_b3 = props.zIndex) != null ? _b3 : (_a4 = styles2.list) == null ? void 0 : _a4.zIndex },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuTransition,
        {
          variants: motionVariants,
          initial: false,
          animate: isOpen ? "enter" : "exit",
          __css: { outline: 0, ...styles2.list },
          ...motionProps,
          className: cx("chakra-menu__menu-list", listProps.className),
          ...listProps,
          onUpdate: onTransitionEnd,
          onAnimationComplete: callAll(
            animated.onComplete,
            listProps.onAnimationComplete
          )
        }
      )
    }
  );
});
MenuList.displayName = "MenuList";
var MenuGroup = forwardRef((props, ref) => {
  const { title, children, className, ...rest } = props;
  const _className = cx("chakra-menu__group__title", className);
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: "chakra-menu__group", role: "group", children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.p, { className: _className, ...rest, __css: styles2.groupTitle, children: title }),
    children
  ] });
});
MenuGroup.displayName = "MenuGroup";
var StyledMenuButton = forwardRef((props, ref) => {
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.button,
    {
      ref,
      ...props,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...styles2.button
      }
    }
  );
});
var MenuButton = forwardRef(
  (props, ref) => {
    const { children, as: As, ...rest } = props;
    const buttonProps = useMenuButton(rest, ref);
    const Element2 = As || StyledMenuButton;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Element2,
      {
        ...buttonProps,
        className: cx("chakra-menu__menu-button", props.className),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          chakra.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: props.children
          }
        )
      }
    );
  }
);
MenuButton.displayName = "MenuButton";
var MenuDivider = (props) => {
  const { className, ...rest } = props;
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.hr,
    {
      "aria-orientation": "horizontal",
      className: cx("chakra-menu__divider", className),
      ...rest,
      __css: styles2.divider
    }
  );
};
MenuDivider.displayName = "MenuDivider";
var CheckIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) });
var MenuItemOption = forwardRef(
  (props, ref) => {
    const { icon, iconSpacing: iconSpacing2 = "0.75rem", ...rest } = props;
    const optionProps = useMenuOption(rest, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      StyledMenuItem,
      {
        ...optionProps,
        className: cx("chakra-menu__menuitem-option", rest.className),
        children: [
          icon !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
            MenuIcon,
            {
              fontSize: "0.8em",
              marginEnd: iconSpacing2,
              opacity: props.isChecked ? 1 : 0,
              children: icon || /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flex: 1 }, children: optionProps.children })
        ]
      }
    );
  }
);
MenuItemOption.id = "MenuItemOption";
MenuItemOption.displayName = "MenuItemOption";
const createStoreImpl = (createState2) => {
  let state2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state2) : partial;
    if (!Object.is(nextState, state2)) {
      const previousState = state2;
      state2 = (replace2 != null ? replace2 : typeof nextState !== "object") ? nextState : Object.assign({}, state2, nextState);
      listeners.forEach((listener) => listener(state2, previousState));
    }
  };
  const getState = () => state2;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if (({ "VITE_ASSETS_PATH": "/creator/", "VITE_CHAIN_ID": "Mumbai", "VITE_PAINTER_CONTRACT": "0xFE6Ef6E969Cc39B72B22F9A126b798C7d51c5b6c", "VITE_AI_CONTRACT": "0x82F30530571Ed6f99399F5a10aE934Cc5f6f68b9", "VITE_MARKETPLACE_CONTRACT": "0xf647Ae7b9d70C49504120e2ED03Ec30054e72fEf", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } && "production") !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, subscribe, destroy };
  state2 = createState2(setState, getState, api);
  return api;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = reactExports, n = shimExports;
function p(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q = "function" === typeof Object.is ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r(a2, c2[0], c2[1]);
  u(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
function useStore(api, selector = api.getState, equalityFn) {
  const slice2 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  reactExports.useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState2) => {
  if (({ "VITE_ASSETS_PATH": "/creator/", "VITE_CHAIN_ID": "Mumbai", "VITE_PAINTER_CONTRACT": "0xFE6Ef6E969Cc39B72B22F9A126b798C7d51c5b6c", "VITE_AI_CONTRACT": "0x82F30530571Ed6f99399F5a10aE934Cc5f6f68b9", "VITE_MARKETPLACE_CONTRACT": "0xf647Ae7b9d70C49504120e2ED03Ec30054e72fEf", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } && "production") !== "production" && typeof createState2 !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState2) => createState2 ? createImpl(createState2) : createImpl;
var react = (createState2) => {
  if (({ "VITE_ASSETS_PATH": "/creator/", "VITE_CHAIN_ID": "Mumbai", "VITE_PAINTER_CONTRACT": "0xFE6Ef6E969Cc39B72B22F9A126b798C7d51c5b6c", "VITE_AI_CONTRACT": "0x82F30530571Ed6f99399F5a10aE934Cc5f6f68b9", "VITE_MARKETPLACE_CONTRACT": "0xf647Ae7b9d70C49504120e2ED03Ec30054e72fEf", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } && "production") !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create(createState2);
};
const usePainterStore = react((set, get2) => ({
  gameStart: false,
  gameFinished: false,
  paintingImage: null,
  paintBrush: {
    color: [0.94, 0.43, 0.06, 1],
    colorRGB: [241, 112, 19, 100],
    brushSize: 5
  },
  painter: null,
  timerOptions: {
    timeSlots: [
      // "time" property is in minutes, the timer useEffect takes care of conversions
      { title: "1min", time: 1, text: "01:00" },
      { title: "3min", time: 3, text: "03:00" },
      { title: "5min", time: 5, text: "05:00" },
      { title: "10min", time: 10, text: "10:00" }
    ],
    selected: { title: "5min", time: 5, text: "05:00" },
    timeLeft: 60 * 5
  },
  timerPaused: false,
  paintOptions: {
    phrase: [
      "2023",
      "House by the lake",
      "Sunset at the beach",
      "Basketballs on the moon",
      "FAANGS",
      "Hello Web3",
      "My IDEAs"
    ],
    remixOptions: [
      { title: "painting1", fileName: "1586467002.jpg" },
      {
        title: "painting2",
        fileName: "pop-culture-characters-parody-thrift-store-paintings-dave-pollot-3-5a97ba737ac25__880.jpg"
      },
      {
        title: "painting3",
        fileName: "pop-culture-characters-thrift-store-paintings-dave-pollot-6.jpg"
      },
      {
        title: "painting4",
        fileName: "pop-culture-characters-thrift-store-paintings-dave-pollot-7.jpg"
      },
      {
        title: "painting5",
        fileName: "pop-culture-characters-thrift-store-paintings-dave-pollot-11.jpg"
      },
      {
        title: "painting6",
        fileName: "pop-culture-characters-thrift-store-paintings-dave-pollot-20.jpg"
      },
      {
        title: "painting7",
        fileName: "pop-culture-characters-thrift-store-paintings-dave-pollot-28.jpg"
      },
      {
        title: "painting8",
        fileName: "re-directed-thrift-store-paintings-gnarled-branch-david-irvine-321.jpg"
      },
      { title: "painting9", fileName: "repaintings1.jpg" },
      { title: "painting10", fileName: "repaintings2.jpg" },
      { title: "painting11", fileName: "repaintings3.jpg" },
      { title: "painting12", fileName: "repaintings4.jpg" },
      { title: "painting13", fileName: "repaintings6.jpg" },
      { title: "painting14", fileName: "repaintings7.jpg" },
      { title: "painting15", fileName: "repaintings9.jpg" },
      { title: "painting16", fileName: "repaintings12.jpg" },
      { title: "painting17", fileName: "repaintings14.jpg" },
      { title: "painting18", fileName: "repaintings15.jpg" },
      { title: "painting19", fileName: "repaintings16.jpg" },
      { title: "painting20", fileName: "repaintings17.jpg" },
      { title: "painting21", fileName: "repaintings18.jpg" },
      { title: "painting22", fileName: "repaintings20.jpg" },
      { title: "painting23", fileName: "repaintings22.jpg" },
      { title: "painting24", fileName: "repaintings23.jpg" },
      { title: "painting25", fileName: "thriftstore-5.jpg" }
    ],
    selected: null
  },
  generatedRemixOptions: [],
  projectDetails: {
    projectName: "",
    projectDescription: ""
  },
  showRemix: false,
  pickerVisible: false,
  sliderVisible: false,
  optionsView: "OPTIONS",
  currentPage: "PAINTER",
  ideaView: "INVISIBLY",
  alertOptions: {
    type: "error",
    message: "Failed to save draft",
    showAlert: false
  },
  handleSideMenus: (option) => {
    if (option === "picker") {
      set((state2) => ({
        pickerVisible: !state2.pickerVisible,
        sliderVisible: false
      }));
    } else if (option === "slider") {
      set((state2) => ({
        pickerVisible: false,
        sliderVisible: !state2.sliderVisible
      }));
    } else {
      set(() => ({
        pickerVisible: false,
        sliderVisible: false
      }));
    }
  },
  useUndo: void 0,
  useRedo: void 0
}));
const Snackbar = () => {
  const { alertOptions } = usePainterStore();
  reactExports.useEffect(() => {
    setTimeout(() => {
      usePainterStore.setState({
        alertOptions: { ...alertOptions, showAlert: false }
      });
    }, 5e3);
  }, [alertOptions?.showAlert]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: alertOptions?.showAlert && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Alert,
    {
      position: "absolute",
      top: 0,
      variant: "solid",
      zIndex: 10,
      status: alertOptions.type,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {}),
        alertOptions.message
      ]
    }
  ) });
};
const Snackbar$1 = reactExports.memo(Snackbar);
const SVG_Icon = (props) => {
  const { fileName, alt, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Image$1,
    {
      src: "/creator//svgs/" + fileName,
      alt,
      ...rest
    }
  );
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node2, i2) {
    return React.createElement(node2.tag, __assign({
      key: i2
    }, node2.attr), Tree2Element(node2.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size2 = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function AiOutlineBulb(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M632 888H392c-4.4 0-8 3.6-8 8v32c0 17.7 14.3 32 32 32h192c17.7 0 32-14.3 32-32v-32c0-4.4-3.6-8-8-8zM512 64c-181.1 0-328 146.9-328 328 0 121.4 66 227.4 164 284.1V792c0 17.7 14.3 32 32 32h264c17.7 0 32-14.3 32-32V676.1c98-56.7 164-162.7 164-284.1 0-181.1-146.9-328-328-328zm127.9 549.8L604 634.6V752H420V634.6l-35.9-20.8C305.4 568.3 256 484.5 256 392c0-141.4 114.6-256 256-256s256 114.6 256 256c0 92.5-49.4 176.3-128.1 221.8z" } }] })(props);
}
function AiOutlineShareAlt(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M752 664c-28.5 0-54.8 10-75.4 26.7L469.4 540.8a160.68 160.68 0 0 0 0-57.6l207.2-149.9C697.2 350 723.5 360 752 360c66.2 0 120-53.8 120-120s-53.8-120-120-120-120 53.8-120 120c0 11.6 1.6 22.7 4.7 33.3L439.9 415.8C410.7 377.1 364.3 352 312 352c-88.4 0-160 71.6-160 160s71.6 160 160 160c52.3 0 98.7-25.1 127.9-63.8l196.8 142.5c-3.1 10.6-4.7 21.8-4.7 33.3 0 66.2 53.8 120 120 120s120-53.8 120-120-53.8-120-120-120zm0-476c28.7 0 52 23.3 52 52s-23.3 52-52 52-52-23.3-52-52 23.3-52 52-52zM312 600c-48.5 0-88-39.5-88-88s39.5-88 88-88 88 39.5 88 88-39.5 88-88 88zm440 236c-28.7 0-52-23.3-52-52s23.3-52 52-52 52 23.3 52 52-23.3 52-52 52z" } }] })(props);
}
function AiOutlineTwitter(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M928 254.3c-30.6 13.2-63.9 22.7-98.2 26.4a170.1 170.1 0 0 0 75-94 336.64 336.64 0 0 1-108.2 41.2A170.1 170.1 0 0 0 672 174c-94.5 0-170.5 76.6-170.5 170.6 0 13.2 1.6 26.4 4.2 39.1-141.5-7.4-267.7-75-351.6-178.5a169.32 169.32 0 0 0-23.2 86.1c0 59.2 30.1 111.4 76 142.1a172 172 0 0 1-77.1-21.7v2.1c0 82.9 58.6 151.6 136.7 167.4a180.6 180.6 0 0 1-44.9 5.8c-11.1 0-21.6-1.1-32.2-2.6C211 652 273.9 701.1 348.8 702.7c-58.6 45.9-132 72.9-211.7 72.9-14.3 0-27.5-.5-41.2-2.1C171.5 822 261.2 850 357.8 850 671.4 850 843 590.2 843 364.7c0-7.4 0-14.8-.5-22.2 33.2-24.3 62.3-54.4 85.5-88.2z" } }] })(props);
}
function FaDiscord(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 640 512" }, "child": [{ "tag": "path", "attr": { "d": "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z" } }] })(props);
}
function FaFacebookF(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 320 512" }, "child": [{ "tag": "path", "attr": { "d": "M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z" } }] })(props);
}
function FaLinkedinIn(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z" } }] })(props);
}
function FaRedditAlien(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M440.3 203.5c-15 0-28.2 6.2-37.9 15.9-35.7-24.7-83.8-40.6-137.1-42.3L293 52.3l88.2 19.8c0 21.6 17.6 39.2 39.2 39.2 22 0 39.7-18.1 39.7-39.7s-17.6-39.7-39.7-39.7c-15.4 0-28.7 9.3-35.3 22l-97.4-21.6c-4.9-1.3-9.7 2.2-11 7.1L246.3 177c-52.9 2.2-100.5 18.1-136.3 42.8-9.7-10.1-23.4-16.3-38.4-16.3-55.6 0-73.8 74.6-22.9 100.1-1.8 7.9-2.6 16.3-2.6 24.7 0 83.8 94.4 151.7 210.3 151.7 116.4 0 210.8-67.9 210.8-151.7 0-8.4-.9-17.2-3.1-25.1 49.9-25.6 31.5-99.7-23.8-99.7zM129.4 308.9c0-22 17.6-39.7 39.7-39.7 21.6 0 39.2 17.6 39.2 39.7 0 21.6-17.6 39.2-39.2 39.2-22 .1-39.7-17.6-39.7-39.2zm214.3 93.5c-36.4 36.4-139.1 36.4-175.5 0-4-3.5-4-9.7 0-13.7 3.5-3.5 9.7-3.5 13.2 0 27.8 28.5 120 29 149 0 3.5-3.5 9.7-3.5 13.2 0 4.1 4 4.1 10.2.1 13.7zm-.8-54.2c-21.6 0-39.2-17.6-39.2-39.2 0-22 17.6-39.7 39.2-39.7 22 0 39.7 17.6 39.7 39.7-.1 21.5-17.7 39.2-39.7 39.2z" } }] })(props);
}
function FaTwitter(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" } }] })(props);
}
const userUserInfoStore = react((set, get2) => ({
  user: null,
  Paper: null,
  paperUserDetails: null,
  setPaperUserDetails: (input) => {
    set((state2) => ({ paperUserDetails: { ...input } }));
  }
}));
const useSettingsStore = react((set, get2) => ({
  acceptCookies: localStorage.getItem("acceptCookies"),
  audioPlayedOnce: false
}));
const useCreateToast = () => {
  const toast = useToast();
  const createToast2 = (title, status, description = "") => {
    return toast({
      title,
      description,
      status,
      duration: 9e3,
      isCloasable: true
    });
  };
  return createToast2;
};
function bind(fn2, thisArg) {
  return function wrap2() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len2 = keys2.length;
    let key2;
    for (i2 = 0; i2 < len2; i2++) {
      key2 = keys2[i2];
      fn2.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : _global$1;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key2) => {
    if (thisArg && isFunction(val)) {
      a2[key2] = bind(val, thisArg);
    } else {
      a2[key2] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet2;
  while (size2--) {
    str += alphabet2[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key2) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key2) {
  return utils.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path, key2, dots) {
  if (!path)
    return key2;
  return path.concat(key2).map(function each(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options2) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options2 = utils.toFlatObject(options2, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options2.metaTokens;
  const visitor = options2.visitor || defaultVisitor;
  const dots = options2.dots;
  const indexes = options2.indexes;
  const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : buffer.Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key2, "[]")) && (arr = utils.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el2, index2) {
          !(utils.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el2, key2) {
      const result = !(utils.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils.isString(key2) ? key2.trim() : key2,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options2) {
  this._pairs = [];
  params && toFormData(params, this, options2);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode3 = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode3(pair[0]) + "=" + _encode3(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options2) {
  if (!params) {
    return url;
  }
  const _encode3 = options2 && options2.encode || encode;
  const serializeFn = options2 && options2.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options2);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode3);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options2) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options2 ? options2.synchronous : false,
      runWhen: options2 ? options2.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options2) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options2));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len2 = keys2.length;
  let key2;
  for (i2 = 0; i2 < len2; i2++) {
    key2 = keys2[i2];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key2 = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens2 = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens2[match2[1]] = match2[2];
  }
  return tokens2;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils.findKey(this, header);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils.findKey(this, header);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key2 = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key2 = utils.findKey(headers, header);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform2(fn2) {
    data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name2, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes3 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes3[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes3[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request.timeout = config2.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils.isUndefined(config2.withCredentials)) {
      request.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters2[i2];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const VERSION = "1.4.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options2, schema, allowUnknown) {
  if (typeof options2 !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options2);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options2[opt];
      const result = value === void 0 || validator2(value, opt, options2);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len2;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len2 = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len2) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len2 = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len2) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len2 = responseInterceptorChain.length;
    while (i2 < len2) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key2, value]) => {
  HttpStatusCode[value] = key2;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
var f = ((t2) => (t2.USER_MANAGED = "USER_MANAGED", t2.AWS_MANAGED = "AWS_MANAGED", t2))(f || {}), K = ((n2) => (n2.PAPER_EMAIL_OTP = "PaperEmailOTP", n2.GOOGLE = "Google", n2.TWITTER = "Twitter", n2.COGNITO = "Cognito", n2.AUTH0 = "Auth0", n2.CUSTOM_JWT = "CustomJWT", n2))(K || {});
var F = ((t2) => (t2.LOGGED_OUT = "Logged Out", t2.LOGGED_IN_WALLET_INITIALIZED = "Logged In, Wallet Initialized", t2))(F || {}), P = ((a2) => (a2.LOGGED_OUT = "Logged Out", a2.LOGGED_IN_WALLET_UNINITIALIZED = "Logged In, Wallet Uninitialized", a2.LOGGED_IN_NEW_DEVICE = "Logged In, New Device", a2.LOGGED_IN_WALLET_INITIALIZED = "Logged In, Wallet Initialized", a2))(P || {});
const MobileIdeaOptions = reactExports.lazy(() => __vitePreload(() => import("./MobileIdeaOptions-0a439d78.js"), true ? ["creator/assets/MobileIdeaOptions-0a439d78.js","creator/assets/CustomDrawer-234721d4.js","creator/assets/chunk-IWVFML3N-9ab5bf28.js"] : void 0));
const MobileNav = reactExports.lazy(() => __vitePreload(() => import("./MobileNav-399685e6.js"), true ? ["creator/assets/MobileNav-399685e6.js","creator/assets/CustomDrawer-234721d4.js","creator/assets/chunk-XY72533R-563ee611.js"] : void 0));
const NavBar = () => {
  const { optionsView, currentPage } = usePainterStore();
  const [isLargerThan1000] = useMediaQuery("(min-width: 1000px)");
  const { isOpen, onClose, onOpen } = useDisclosure$1();
  const {
    isOpen: ideaIsOpen,
    onClose: ideaOnClose,
    onOpen: ideaOnOpen
  } = useDisclosure$1();
  const [cookies2, setCookie, removeCookie] = useCookies(["token"]);
  const { user, Paper, paperUserDetails, setPaperUserDetails } = userUserInfoStore();
  const navigate = useNavigate();
  const address = useAddress();
  const disconnect = useDisconnect();
  const createToast2 = useCreateToast();
  const connectWithMetamask = useMetamask();
  const connectWithWalletConnect = useWalletConnect();
  const connectWithCoinbase = useCoinbaseWallet();
  const logout = async () => {
    try {
      await axios$1.post(
        "/api/logout",
        {},
        {
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            Authorization: `Bearer ${cookies2.token}`
          }
        }
      );
    } catch (err) {
      console.log(err);
    }
    removeCookie("token");
    localStorage.removeItem("user");
    window.location.reload();
  };
  reactExports.useEffect(() => {
    if (address) {
      createToast2("EVM Wallet Connected", "success");
    }
  }, [address]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Flex,
    {
      position: "absolute",
      width: "100%",
      zIndex: 2,
      paddingX: "4.25rem",
      height: "5.5rem",
      justifyContent: "space-between",
      alignItems: "center",
      background: "#fff",
      borderBottom: "1px solid black",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            padding: 0,
            onClick: () => {
              if (optionsView === "IDEA") {
                if (isLargerThan1000) {
                  navigate("/");
                  return usePainterStore.setState({
                    optionsView: "OPTIONS",
                    currentPage: "PAINTER"
                  });
                }
                ideaOnOpen();
                return navigate("/");
              }
              useSettingsStore.setState({ audioPlayedOnce: false });
              usePainterStore.setState({
                optionsView: "IDEA"
              });
              navigate("/idea");
            },
            background: "transparent",
            _active: { background: "transparent" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SVG_Icon, { fileName: "logoV2.svg", width: "10rem" })
          }
        ),
        isLargerThan1000 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { justifyContent: "center", alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link,
            {
              onClick: () => {
                navigate("/");
                return usePainterStore.setState({
                  optionsView: "OPTIONS",
                  currentPage: "PAINTER"
                });
              },
              marginRight: 10,
              children: "Play"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "/about", marginRight: 10, children: "About" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "/leaderboard", marginRight: 10, children: "Leaderboard" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "/marketplace", marginRight: 10, children: "Marketplace" }),
          user ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
              "Credits: ",
              user.credits
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                MenuButton,
                {
                  marginX: 4,
                  as: IconButton,
                  borderRadius: "50%",
                  borderWidth: "1px",
                  borderColor: "#000",
                  padding: 0,
                  height: "1.5rem",
                  minWidth: "1.5rem",
                  "aria-label": "Options",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SVG_Icon, { fileName: "person_outline.svg" }),
                  _hover: { background: "green" },
                  _active: { background: "green" },
                  variant: "outline"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuList, { borderColor: "#000", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MenuItem,
                  {
                    onClick: () => {
                      navigate("/user");
                    },
                    children: "Profile"
                  }
                ),
                !address && /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuGroup, { defaultValue: "asc", title: "Wallet Connection", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MenuItemOption,
                    {
                      value: "metamask",
                      isChecked: false,
                      onClick: connectWithMetamask,
                      children: "Metamask"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MenuItemOption,
                    {
                      isChecked: false,
                      value: "walletConnect",
                      onClick: connectWithWalletConnect,
                      children: "Wallet Connect"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MenuItemOption,
                    {
                      isChecked: false,
                      value: "coinbase",
                      onClick: connectWithCoinbase,
                      children: "Coinbase"
                    }
                  )
                ] }),
                address && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MenuItem,
                  {
                    onClick: async () => {
                      await disconnect();
                      createToast2("EVM Wallet Disconnected", "warning");
                    },
                    children: "Disconnect Wallet"
                  }
                ),
                paperUserDetails?.status === F.LOGGED_IN_NEW_DEVICE && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MenuItem,
                  {
                    onClick: async () => {
                      await Paper.initializeUser();
                      const userStatus = await Paper.getUserStatus();
                      setPaperUserDetails(userStatus);
                      createToast2("Paper wallet initialized", "success");
                    },
                    children: "initialize Paper Wallet"
                  }
                ),
                (paperUserDetails?.status === F.LOGGED_IN_WALLET_INITIALIZED || paperUserDetails?.status === F.LOGGED_IN_NEW_DEVICE) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MenuItem,
                  {
                    onClick: async () => {
                      await Paper.auth.logout();
                      setPaperUserDetails(null);
                      createToast2("Disconnected Paper Wallet", "warning");
                    },
                    children: "Disconnect Wallet"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDivider, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { onClick: logout, children: "Logout" })
              ] })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              fontWeight: "normal",
              padding: 0,
              marginRight: 10,
              background: "transparent",
              onClick: () => navigate("/auth/login"),
              children: "Login|Signup"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              _hover: { background: "#1DA1F2" },
              variant: "roundOutline",
              onClick: () => {
                window.open("https://twitter.com/IDEA_NFTs", "_blank").focus();
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(AiOutlineTwitter, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              _hover: { background: "#7289DA" },
              variant: "roundOutline",
              marginX: 4,
              onClick: () => window.open("https://discord.gg/TtGm2vWw", "_blank").focus(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaDiscord, {})
            }
          ),
          paperUserDetails?.status === F.LOGGED_IN_WALLET_INITIALIZED && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
            paperUserDetails?.data?.walletAddress?.slice(0, 15),
            "..."
          ] }),
          address && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
            address.slice(0, 15),
            "..."
          ] })
        ] }) : currentPage !== "IDEA" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              _active: { background: "transparent" },
              background: "transparent",
              onClick: onOpen,
              children: "Menu"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MobileNav, { isOpen, onClose })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              border: "solid",
              padding: 0,
              marginRight: "1rem",
              borderWidth: "1px",
              borderRadius: "50%",
              position: "relative",
              height: 8,
              minWidth: 8,
              onClick: () => usePainterStore.setState({
                optionsView: "OPTIONS",
                currentPage: "PAINTER"
              }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(SVG_Icon, { fileName: "closeButton.svg" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MobileIdeaOptions, { isOpen: ideaIsOpen, onClose: ideaOnClose })
        ] })
      ]
    }
  );
};
const theme = extendTheme({
  fonts: {
    heading: `'Raleway', sans-serif`,
    body: `'Raleway', sans-serif`
  },
  colors: {
    blue: {
      discord: "#5865F2",
      twitter: "#55ACEE",
      dark: "#2745E2",
      light: "#E3FAFF"
    },
    black: {
      body: "#373737",
      bodyLight: "#AAAAAA",
      borderColor: "#E3E3E3",
      dark: "#000000",
      tableHeader: "#707070",
      tabHeader: "#3A3A3A"
    },
    gold: {
      save: "#9E7008"
    },
    green: {
      success: "#3BBC66"
    },
    orange: {
      warning: "#EB9541"
    },
    pink: {
      dark: "#EF3291",
      light: "#F8E3FF"
    },
    purple: {
      dark: "#6B13E5",
      light: "rgba(151, 71, 255, 1)"
    },
    red: {
      error: "#DC4537"
    },
    white: {
      offWhite: "#FFF7E3"
    },
    gray: {
      icon: "#E3E3E3"
    }
  },
  components: {
    Button: {
      variants: {
        talkToMe: {
          backgroundSize: "cover",
          backgroundRepeat: "no-repeat",
          display: ["none", "none", "none", "flex"],
          color: "white",
          fontSize: "0.65em",
          height: "4.5rem",
          width: "4.5rem",
          position: "absolute",
          bottom: "25vh",
          left: ["", "", "", "2.5rem"],
          right: ["2rem", "2.5rem", "2.5rem", "2.5rem", 0],
          _hover: {
            opacity: 0.8
          },
          _active: { opacity: 0.65 }
        },
        timeOutline: {
          padding: "0 0.5rem 0 0.5rem",
          borderRadius: 10,
          border: "1px",
          borderStyle: "solid",
          borderColor: "#000",
          height: 7
        },
        roundOutline: {
          borderRadius: "50%",
          minWidth: "1.5rem",
          height: "1.5rem",
          borderColor: "black",
          borderStyle: "solid",
          borderWidth: "1px",
          padding: 0
        },
        iconBtn: {
          _hover: {
            opacity: 0.35
          },
          _active: {
            opacity: 1
          }
        },
        audioBtn: {
          background: "white",
          borderRadius: "15px",
          display: "flex",
          justifyItems: "center",
          alignItems: "center"
        },
        ideaButton: {
          fontSize: "14px",
          fontWeight: 500,
          background: "#F3BA2F",
          boxShadow: "3px 3px 0px #1A1A1A",
          borderRadius: 24,
          border: "1px",
          borderStyle: "solid",
          borderColor: "#000",
          paddingX: "2.5rem",
          paddingY: "1.5rem",
          _hover: {
            opacity: 0.85
          },
          _active: {
            boxShadow: "0px 0px 0px #9E7008"
          }
        },
        socialButton: {
          height: "3rem",
          width: "3.25rem",
          fontSize: "14px",
          fontWeight: 500,
          background: "#F3BA2F",
          boxShadow: "3px 3px 0px #1A1A1A",
          borderRadius: 16,
          border: "1px",
          borderStyle: "solid",
          borderColor: "#000",
          _hover: {
            opacity: 0.85
          },
          _active: {
            boxShadow: "0px 0px 0px #9E7008"
          }
        },
        mintButton: {
          borderRadius: 16,
          fontSize: "14px",
          fontWeight: 400,
          background: "transparent",
          paddingX: 10,
          _hover: {
            background: "white"
          },
          _active: {
            background: "#FFF7E3"
          }
        },
        authButton: {
          width: "100%",
          background: "transparent",
          borderRadius: 0,
          fontSize: "20px",
          fontWeight: "normal",
          padding: 8,
          fontFamily: "Sequel"
        },
        trackButton: {
          borderTop: "1px",
          borderRadius: 0,
          borderColor: "gray.icon",
          textAlign: "left",
          justifyContent: "start",
          fontWeight: 400,
          width: "100%",
          background: "transparent",
          _hover: {
            background: "gray.200"
          }
        }
      }
    },
    Heading: {
      variants: {
        rarityHeading: {
          fontSize: "md",
          fontWeight: 600,
          marginBottom: 1.5
        }
      }
    },
    Text: {
      variants: {
        rarityText: {
          fontSize: "12px",
          fontWeight: 400,
          color: "black.body"
        }
      }
    },
    CustomMenu: {
      baseStyle: ({ colorMode }) => ({
        background: "white",
        borderRadius: "24",
        flexDir: "column",
        justifyContent: "center"
      }),
      variants: {
        customisation: () => ({
          position: "fixed",
          top: "25rem",
          left: "30rem",
          minHeight: "11rem",
          minWidth: "15rem",
          padding: 4,
          border: "1px",
          borderColor: "black",
          background: "transparent"
        }),
        rarityMenu: () => ({
          position: "fixed",
          left: 36,
          top: "12.5rem",
          width: "10.5rem",
          outlineColor: "black",
          outlineOffset: 3,
          outlineStyle: "solid",
          outlineWidth: "1px"
        })
      }
    }
  }
});
const paint = "";
const PainterDemo = reactExports.lazy(() => __vitePreload(() => import("./Painter-5a8151f5.js"), true ? ["creator/assets/Painter-5a8151f5.js","creator/assets/CustomDrawer-234721d4.js","creator/assets/chunk-XY72533R-563ee611.js","creator/assets/chunk-IWVFML3N-9ab5bf28.js"] : void 0));
const App = () => {
  const { pathname } = useLocation();
  reactExports.useEffect(() => {
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ThirdwebProvider,
    {
      desiredChainId: ChainId.Mumbai,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { theme, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CookiesProvider$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Snackbar$1, {}),
        !pathname.includes("/humanity") && !pathname.includes("/painter") && /* @__PURE__ */ jsxRuntimeExports.jsx(NavBar, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(PainterDemo, {}), path: "/painter" }) })
      ] }) })
    }
  ) });
};
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
);
export {
  propTypesExports as $,
  AnimatePresence as A,
  Button as B,
  hexZeroPad as C,
  arrayify as D,
  buffer as E,
  Flex as F,
  v4 as G,
  hexlify as H,
  toUtf8Bytes as I,
  JsonRpcBatchProvider as J,
  getDefaultProvider as K,
  deepCopy as L,
  fetchJson as M,
  react as N,
  useSettingsStore as O,
  SVG_Icon as P,
  usePainterStore as Q,
  Image$1 as R,
  StaticJsonRpcProvider as S,
  Text as T,
  GenIcon as U,
  axios$1 as V,
  WebSocketProvider as W,
  useMediaQuery as X,
  create as Y,
  React as Z,
  PropTypes as _,
  createContext$1 as a,
  buildTransactionFunction as a$,
  useCreateToast as a0,
  FaTwitter as a1,
  FaDiscord as a2,
  FaLinkedinIn as a3,
  FaRedditAlien as a4,
  FaFacebookF as a5,
  useDisclosure$1 as a6,
  AiOutlineBulb as a7,
  AiOutlineShareAlt as a8,
  createCache as a9,
  F as aA,
  AiOutlineTwitter as aB,
  CloseButton as aC,
  createMedium as aD,
  createSidecarMedium as aE,
  useMergeRefs$1 as aF,
  isFocusable as aG,
  hideOthers as aH,
  Portal as aI,
  fullWidthClassName as aJ,
  zeroRightClassName as aK,
  styleSingleton as aL,
  RemoveScrollBar as aM,
  exportSidecar as aN,
  usePresence as aO,
  AbstractClientWallet as aP,
  _classPrivateMethodInitSpec as aQ,
  _classPrivateFieldInitSpec$1 as aR,
  _defineProperty$1 as aS,
  _classPrivateFieldSet$1 as aT,
  _classPrivateFieldGet$1 as aU,
  _classPrivateMethodGet as aV,
  __vitePreload as aW,
  WagmiAdapter as aX,
  walletIds as aY,
  _defineProperty as aZ,
  ContractWrapper as a_,
  getRegisteredStyles as aa,
  serializeStyles as ab,
  insertStyles as ac,
  useToast as ad,
  useCookies as ae,
  userUserInfoStore as af,
  useAddress as ag,
  useMetamask as ah,
  useWalletConnect as ai,
  useCoinbaseWallet as aj,
  useNetworkMismatch as ak,
  useDisconnect as al,
  useNetwork as am,
  useSDK as an,
  useContract as ao,
  ChainId as ap,
  useLocation as aq,
  getDefaultExportFromCjs as ar,
  _extends$2 as as,
  _global$1 as at,
  keyframes$1 as au,
  Snackbar$1 as av,
  Link as aw,
  isObject$1 as ax,
  compact as ay,
  useNavigate as az,
  useMultiStyleConfig as b,
  AddressOrEnsSchema as b$,
  AbiSchema as b0,
  ContractMetadata as b1,
  DropErc1155ContractSchema as b2,
  ContractAppURI as b3,
  ContractRoles as b4,
  ContractRoyalty as b5,
  ContractPrimarySale as b6,
  DropErc1155ClaimConditions as b7,
  ContractEvents as b8,
  ContractEncoder as b9,
  Erc721Abi as bA,
  Erc1155Abi as bB,
  fetchCurrencyMetadata as bC,
  formatUnits as bD,
  isWinningBid as bE,
  MaxUint256$1 as bF,
  AuctionAlreadyStartedError as bG,
  AuctionHasNotEndedError as bH,
  MarketplaceContractSchema as bI,
  DEFAULT_QUERY_ALL_COUNT as bJ,
  NATIVE_TOKENS as bK,
  assertEnabled as bL,
  detectContractFeature as bM,
  MarketplaceV3DirectListings as bN,
  MarketplaceV3EnglishAuctions as bO,
  MarketplaceV3Offers as bP,
  FEATURE_DIRECT_LISTINGS as bQ,
  FEATURE_ENGLISH_AUCTIONS as bR,
  FEATURE_OFFERS as bS,
  MultiwrapContractSchema as bT,
  uploadOrExtractURI as bU,
  TokenErc721ContractSchema as bV,
  Erc721WithQuantitySignatureMintable as bW,
  DropErc721ContractSchema as bX,
  DropClaimConditions as bY,
  DelayedReveal as bZ,
  FEATURE_NFT_REVEALABLE as b_,
  GasCostEstimator as ba,
  ContractPlatformFee as bb,
  ContractInterceptor as bc,
  ContractOwner as bd,
  getRoleHash as be,
  Transaction as bf,
  TokenErc1155ContractSchema as bg,
  Erc1155SignatureMintable as bh,
  validateNewListingParam as bi,
  resolveAddress as bj,
  handleTokenApproval as bk,
  normalizePriceValue as bl,
  cleanCurrencyAddress as bm,
  isNativeToken as bn,
  setErc20Allowance as bo,
  ListingNotFoundError as bp,
  WrongListingTypeError as bq,
  invariant$1 as br,
  mapOffer as bs,
  fetchCurrencyValue as bt,
  fetchTokenMetadataForContract as bu,
  isTokenApprovedForTransfer as bv,
  Contract as bw,
  ERC165Abi as bx,
  InterfaceId_IERC721 as by,
  InterfaceId_IERC1155 as bz,
  cx as c,
  AmountSchema as c0,
  BigNumberishSchema as c1,
  NFTInputOrUriSchema as c2,
  RawDateSchema as c3,
  PackContractSchema as c4,
  IPackVRFAbi as c5,
  FEATURE_PACK_VRF as c6,
  LINK_TOKEN_ADDRESS as c7,
  Erc20 as c8,
  Erc1155 as c9,
  toString$1 as cA,
  concat$1 as cB,
  ERC20Abi as ca,
  Erc721 as cb,
  SplitsContractSchema as cc,
  DropErc20ContractSchema as cd,
  TokenErc20ContractSchema as ce,
  Erc20SignatureMintable as cf,
  VoteContractSchema as cg,
  id$2 as ch,
  ContractFactory$1 as ci,
  Interface as cj,
  utils$1 as ck,
  Web3Provider as cl,
  EventEmitter$1 as cm,
  defaultChains as cn,
  getAddress as co,
  hexValue as cp,
  assertWindowEthereum as cq,
  process$1 as cr,
  getAugmentedNamespace as cs,
  bnExports as ct,
  inherits_browserExports as cu,
  detect as cv,
  fetch$1 as cw,
  minimalisticAssert$1 as cx,
  hash$5 as cy,
  fromString as cz,
  chakra as d,
  mergeRefs as e,
  forwardRef as f,
  dataAttr as g,
  ariaAttr as h,
  callAllHandlers$1 as i,
  jsxRuntimeExports as j,
  useSafeLayoutEffect$2 as k,
  useUpdateEffect as l,
  motion as m,
  useTheme as n,
  omitThemingProps as o,
  getToken as p,
  useStyleConfig as q,
  reactExports as r,
  commonjsGlobal as s,
  BigNumber as t,
  useCallbackRef$1 as u,
  BN$1 as v,
  warn as w,
  isAddress as x,
  AddressZero$1 as y,
  z$2 as z
};
