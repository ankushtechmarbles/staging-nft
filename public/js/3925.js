"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3925],{89050:(t,r,e)=>{e.d(r,{D:()=>m,F:()=>d,I:()=>c,a:()=>p,b:()=>h,c:()=>u,f:()=>l,g:()=>f,u:()=>g});var a=e(41518),n=e(16441),i=e(2593),s=e(64146),o=e(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),d={name:"Failed to load NFT metadata"};async function l(t,r,e){if(r.startsWith("data:application/json;base64")&&void 0!==o){const e=r.split(",")[1],n=JSON.parse(o.from(e,"base64").toString("utf-8"));return a.C.parse({...n,id:i.O$.from(t).toString(),uri:r})}const s=r.replace("{id}",n.hexZeroPad(i.O$.from(t).toHexString(),32).slice(2));let c;try{c=await e.downloadJSON(s)}catch(a){const n=r.replace("{id}",i.O$.from(t).toString());try{c=await e.downloadJSON(n)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:r})} -- falling back to default metadata`),c=d}}return a.C.parse({...c,id:i.O$.from(t).toString(),uri:r})}async function u(t,r,n,o){let u;const h=(await e.e(5025).then(e.t.bind(e,25025,19))).default,g=new s.CH(t,h,r),[f,m]=await Promise.all([g.supportsInterface(c),g.supportsInterface(p)]);if(f){const a=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,i=new s.CH(t,a,r);u=await i.tokenURI(n)}else{if(!m)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,i=new s.CH(t,a,r);u=await i.uri(n)}}return u?l(n,u,o):a.C.parse({...d,id:i.O$.from(n).toString(),uri:""})}async function h(t,r){return"string"==typeof t?t:await r.upload(a.a.parse(t))}async function g(t,r,e,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await r.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function f(t){const r=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const a=t[e].substring(0,t[e].lastIndexOf("/"));if(r!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${r}' but got '${a}'`)}return r.replace(/\/$/,"")+"/"}const m=100},15070:(t,r,e)=>{e.d(r,{c:()=>i});var a=e(7860),n=e(68828);function i(t){return(0,n.i)(t)?a.aZ:t}},89536:(t,r,e)=>{e.d(r,{C:()=>p,G:()=>l,a:()=>d,b:()=>u,d:()=>o,h:()=>c});var a=e(7860),n=e(19578),i=e(61744),s=e(40721);function o(t,r){return(0,a.am)(a.bn.parse(t.abi),r)}function c(t,r){return t in r.readContract.functions}class p{featureName=a.d1.name;constructor(t,r,e){this.contractWrapper=t,this.schema=r,this.storage=e}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const r=await this.contractWrapper.read("contractURI",[]);r&&r.includes("://")&&(t=await this.storage.downloadJSON(r))}if(!t)try{let r,e,n;try{c("name",this.contractWrapper)&&(r=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(e=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:r||n?.name,symbol:e,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const r=await this._parseAndUploadMetadata(t),e=this.contractWrapper;if(this.supportsContractMetadata(e))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[r],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const r=await this.parseInputMetadata(t);return this.storage.upload(r)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class d{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,r){const e=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(e)]},n=t=>{const e=this.contractWrapper.readContract.interface.parseLog(t);r(this.toContractEvent(e.eventFragment,e.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const r={address:this.contractWrapper.address},e=r=>{try{const e=this.contractWrapper.readContract.interface.parseLog(r);t(this.toContractEvent(e.eventFragment,e.args,r))}catch(t){console.error("Could not parse event:",r,t)}};return this.contractWrapper.getProvider().on(r,e),()=>{this.contractWrapper.getProvider().off(r,e)}}removeEventListener(t,r){const e=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(e.name,r)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((r,e)=>"desc"===t.order?e.blockNumber-r.blockNumber:r.blockNumber-e.blockNumber));return this.parseEvents(r)}async getEvents(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=this.contractWrapper.readContract.interface.getEvent(t),a=r.filters?e.inputs.map((t=>r.filters[t.name])):[],n=this.contractWrapper.readContract.filters[e.name](...a),i=(await this.contractWrapper.readContract.queryFilter(n,r.fromBlock,r.toBlock)).sort(((t,e)=>"desc"===r.order?e.blockNumber-t.blockNumber:t.blockNumber-e.blockNumber));return this.parseEvents(i)}parseEvents(t){return t.map((t=>{const r=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const e=Object.entries(t.args),a=e.slice(e.length/2,e.length),n={};for(const[t,r]of a)n[t]=r;return{eventName:t.event||"",data:n,transaction:r}}return{eventName:t.event||"",data:{},transaction:r}}))}toContractEvent(t,r,e){const a=Object.fromEntries(Object.entries(e).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,e)=>{if(Array.isArray(r[e])){const a=t.components;if(a){const i=r[e];if("tuple[]"===t.type){const r=[];for(let t=0;t<i.length;t++){const e=i[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=e[t]}r.push(n)}n[t.name]=r}else{const r={};for(let t=0;t<a.length;t++){r[a[t].name]=i[t]}n[t.name]=r}}}else n[t.name]=r[e]})),{eventName:t.name,data:n,transaction:a}}}class l{constructor(t){this.contractWrapper=t}async gasCostOf(t,r){const[e,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,r)]);return i.formatEther(a.mul(e))}async gasLimitOf(t,r){return this.contractWrapper.estimateGas(t,r)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return i.formatUnits(t,"gwei")}}class u{featureName=a.d2.name;constructor(t,r,e){this.contractWrapper=t,this.metadata=r,this.storage=e}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,s.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>o(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,r,e)=>{e.d(r,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},5995:(t,r,e)=>{e.d(r,{C:()=>i});var a=e(19578),n=e(7860);class i{featureName=n.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,r]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:r})}set=(0,a.c)((async t=>{const r=await n.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[r.platform_fee_recipient,r.platform_fee_basis_points]})}))}},74935:(t,r,e)=>{e.d(r,{C:()=>c});var a=e(38776),n=e(7860),i=e(89536),s=e(19578),o=e(68828);class c{featureName=n.d3.name;constructor(t,r){this.contractWrapper=t,this.roles=r}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},r=Object.entries(this.roles);return(await Promise.all(r.map((t=>{let[,r]=t;return this.get(r)})))).forEach(((e,a)=>t[r[a][1]]=e)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=this.contractWrapper;if((0,i.h)("getRoleMemberCount",r)&&(0,i.h)("getRoleMember",r)){const e=(0,n.H)(t),a=(await r.read("getRoleMemberCount",[e])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>r.read("getRoleMember",[e,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,s.c)((async t=>{const r=new o.C(this.contractWrapper),e=Object.keys(t);(0,a.Z)(e.length,"you must provide at least one role to set"),(0,a.Z)(e.every((t=>this.roles.includes(t))),"this contract does not support the given role");const i=await this.getAll(),c=[],p=e.sort((t=>"admin"===t?1:-1));for(let e=0;e<p.length;e++){const a=p[e],[s,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(i[a]?.map((t=>(0,n.aP)(t)))||[])]),d=s.filter((t=>!o.includes(t))),l=o.filter((t=>!s.includes(t)));if(d.length&&d.forEach((t=>{c.push(r.encode("grantRole",[(0,n.H)(a),t]))})),l.length){(await Promise.all(l.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,e)=>c.push(r.encode(t,[(0,n.H)(a),l[e]]))))}}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,r){await Promise.all(t.map((async t=>{const[e,a]=await Promise.all([this.get(t),(0,n.aP)(r)]);if(!e.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,s.c)((async(t,r)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=await(0,n.aP)(r);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),e]})}));revoke=(0,s.c)((async(t,r)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=await(0,n.aP)(r),i=await this.getRevokeRoleFunctionName(e);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:i,args:[(0,n.H)(t),e]})}));async getRevokeRoleFunctionName(t){const[r,e]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return e.toLowerCase()===r.toLowerCase()?"renounceRole":"revokeRole"}}},43925:(t,r,e)=>{e.r(r),e.d(r,{Marketplace:()=>k});var a=e(9279),n=e(2593),i=e(38776),s=e(89050),o=e(68828),c=e(7860),p=e(48109),d=e(19578),l=e(89536),u=e(52153),h=e(5995),g=e(74935),f=e(19485),m=e(21046),w=e(64146),y=e(61744),W=e(15070),v=e(19824),C=e(41518);let A=function(t){return t[t.Direct=0]="Direct",t[t.Auction=1]="Auction",t}({});class P{constructor(t,r){this.contractWrapper=t,this.storage=r}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===a.d)throw new c.L(this.getAddress(),t.toString());if(r.listingType!==A.Direct)throw new c.W(this.getAddress(),t.toString(),"Auction","Direct");return await this.mapListing(r)}async getActiveOffer(t,r){await this.validateListing(n.O$.from(t)),(0,i.Z)(f.isAddress(r),"Address must be a valid address");const e=await this.contractWrapper.read("offers",[t,await(0,c.aP)(r)]);if(e.offeror!==a.d)return await(0,p.m)(this.contractWrapper.getProvider(),n.O$.from(t),e)}createListing=(0,d.c)((async t=>{(0,p.v)(t);const r=await(0,c.aP)(t.assetContractAddress),e=await(0,c.aP)(t.currencyContractAddress);await(0,p.h)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());const a=await(0,v.n)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e);let i=Math.floor(t.startTimestamp.getTime()/1e3);const s=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return i<s&&(i=s),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:a,currencyToAccept:(0,W.c)(e),listingType:A.Direct,quantityToList:t.quantity,reservePricePerToken:a,secondsUntilEndTime:t.listingDurationInSeconds,startTime:n.O$.from(i)}],parse:t=>({id:this.contractWrapper.parseLogs("ListingAdded",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,d.c)((async t=>{const r=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode()));return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("ListingAdded",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))})}));makeOffer=(0,d.c)((async(t,r,e,a,i)=>{if((0,o.i)(e))throw new Error("You must use the wrapped native token address when making an offer with a native token");const s=await(0,v.n)(this.contractWrapper.getProvider(),a,e);try{await this.getListing(t)}catch(r){throw console.error("Failed to get listing, err =",r),new Error(`Error getting the listing with id ${t}`)}const c=n.O$.from(r),p=n.O$.from(s).mul(c),l=await this.contractWrapper.getCallOverrides()||{};await(0,C.s)(this.contractWrapper,p,e,l);let u=m.Bz;return i&&(u=n.O$.from(Math.floor(i.getTime()/1e3))),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,r,e,s,u],overrides:l})}));acceptOffer=(0,d.c)((async(t,r)=>{await this.validateListing(n.O$.from(t));const e=await(0,c.aP)(r),a=await this.contractWrapper.read("offers",[t,e]);return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t,e,a.currency,a.pricePerToken]})}));buyoutListing=(0,d.c)((async(t,r,e)=>{const a=await this.validateListing(n.O$.from(t)),{valid:i,error:s}=await this.isStillValidListing(a,r);if(!i)throw new Error(`Listing ${t} is no longer valid. ${s}`);const o=e||await this.contractWrapper.getSignerAddress(),c=n.O$.from(r),p=n.O$.from(a.buyoutPrice).mul(c),l=await this.contractWrapper.getCallOverrides()||{};return await(0,C.s)(this.contractWrapper,p,a.currencyContractAddress,l),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buy",args:[t,o,c,a.currencyContractAddress,p],overrides:l})}));updateListing=(0,d.c)((async t=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.buyoutPrice,t.buyoutPrice,await(0,c.aP)(t.currencyContractAddress),t.startTimeInSeconds,t.secondsUntilEnd]})));cancelListing=(0,d.c)((async t=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelDirectListing",args:[t]})));async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:n.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await(0,o.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInSeconds:t.startTime,asset:await(0,s.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),secondsUntilEnd:t.endTime,sellerAddress:t.tokenOwner,type:A.Direct}}async isStillValidListing(t,r){if(!await(0,p.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.sellerAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),n=(await e.e(5025).then(e.t.bind(e,25025,19))).default,i=new w.CH(t.assetContractAddress,n,a),o=await i.supportsInterface(s.I),c=await i.supportsInterface(s.a);if(o){const r=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,n=new w.CH(t.assetContractAddress,r,a);let i;try{i=await n.ownerOf(t.tokenId)}catch(t){}const s=i?.toLowerCase()===t.sellerAddress.toLowerCase();return{valid:s,error:s?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(c){const n=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,i=new w.CH(t.assetContractAddress,n,a),s=(await i.balanceOf(t.sellerAddress,t.tokenId)).gte(r||t.quantity);return{valid:s,error:s?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}}class b{constructor(t,r){this.contractWrapper=t,this.storage=r,this.encoder=new o.C(t)}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.listingId.toString()!==t.toString())throw new c.L(this.getAddress(),t.toString());if(r.listingType!==A.Auction)throw new c.W(this.getAddress(),t.toString(),"Direct","Auction");return await this.mapListing(r)}async getWinningBid(t){await this.validateListing(n.O$.from(t));const r=await this.contractWrapper.read("winningBid",[t]);if(r.offeror!==a.d)return await(0,p.m)(this.contractWrapper.getProvider(),n.O$.from(t),r)}async getWinner(t){const r=await this.validateListing(n.O$.from(t)),e=await this.contractWrapper.read("winningBid",[t]),i=n.O$.from(Math.floor(Date.now()/1e3)),s=n.O$.from(r.endTimeInEpochSeconds);if(i.gt(s)&&e.offeror!==a.d)return e.offeror;const o=new l.a(this.contractWrapper),c=(await o.getEvents("AuctionClosed")).find((r=>r.data.listingId.eq(n.O$.from(t))));if(!c)throw new Error(`Could not find auction with listingId ${t} in closed auctions`);return c.data.winningBidder}createListing=(0,d.c)((async t=>{(0,p.v)(t);const r=await(0,c.aP)(t.assetContractAddress),e=await(0,c.aP)(t.currencyContractAddress);await(0,p.h)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());const a=await(0,v.n)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e),i=await(0,v.n)(this.contractWrapper.getProvider(),t.reservePricePerToken,e);let s=Math.floor(t.startTimestamp.getTime()/1e3);const o=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return s<o&&(s=o),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:a,currencyToAccept:(0,W.c)(e),listingType:A.Auction,quantityToList:t.quantity,reservePricePerToken:i,secondsUntilEndTime:t.listingDurationInSeconds,startTime:n.O$.from(s)}],parse:t=>({id:this.contractWrapper.parseLogs("ListingAdded",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,d.c)((async t=>{const r=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode()));return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("ListingAdded",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))})}));buyoutListing=(0,d.c)((async t=>{const r=await this.validateListing(n.O$.from(t)),e=await(0,o.f)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,y.formatUnits(r.buyoutPrice,e.decimals))}));makeBid=(0,d.c)((async(t,r)=>{const e=await this.validateListing(n.O$.from(t)),a=await(0,v.n)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(n.O$.from(0)))throw new Error("Cannot make a bid with 0 value");const s=await this.contractWrapper.read("bidBufferBps",[]),o=await this.getWinningBid(t);if(o){const t=(0,p.a)(o.pricePerToken,a,s);(0,i.Z)(t,"Bid price is too low based on the current winning bid and the bid buffer")}else{const t=a,r=n.O$.from(e.reservePrice);(0,i.Z)(t.gte(r),"Bid price is too low based on reserve price")}const c=n.O$.from(e.quantity),l=a.mul(c),u=await this.contractWrapper.getCallOverrides()||{};return await(0,C.s)(this.contractWrapper,l,e.currencyContractAddress,u),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,e.quantity,e.currencyContractAddress,a,m.Bz],overrides:u})}));cancelListing=(0,d.c)((async t=>{const r=await this.validateListing(n.O$.from(t)),e=n.O$.from(Math.floor(Date.now()/1e3)),i=n.O$.from(r.startTimeInEpochSeconds),s=await this.contractWrapper.read("winningBid",[t]);if(e.gt(i)&&s.offeror!==a.d)throw new c.t(t.toString());return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[n.O$.from(t),await this.contractWrapper.getSignerAddress()]})}));closeListing=(0,d.c)((async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateListing(n.O$.from(t));try{return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[n.O$.from(t),r]})}catch(r){throw r.message.includes("cannot close auction before it has ended")?new c.w(t.toString(),e.endTimeInEpochSeconds.toString()):r}}));executeSale=(0,d.c)((async t=>{const r=await this.validateListing(n.O$.from(t));try{const e=await this.getWinningBid(t);(0,i.Z)(e,"No winning bid found");const a=this.encoder.encode("closeAuction",[t,r.sellerAddress]),n=this.encoder.encode("closeAuction",[t,e.buyerAddress]);return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a,n]})}catch(e){throw e.message.includes("cannot close auction before it has ended")?new c.w(t.toString(),r.endTimeInEpochSeconds.toString()):e}}));updateListing=(0,d.c)((async t=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.reservePrice,t.buyoutPrice,t.currencyContractAddress,t.startTimeInEpochSeconds,t.endTimeInEpochSeconds]})));async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getMinimumNextBid(t){const[r,e,a]=await Promise.all([this.getBidBufferBps(),this.getWinningBid(t),this.validateListing(n.O$.from(t))]),i=e?e.currencyValue.value:a.reservePrice,s=i.add(i.mul(r).div(1e4));return(0,o.a)(this.contractWrapper.getProvider(),a.currencyContractAddress,s)}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:n.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await(0,o.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInEpochSeconds:t.startTime,asset:await(0,s.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),reservePriceCurrencyValuePerToken:await(0,o.a)(this.contractWrapper.getProvider(),t.currency,t.reservePricePerToken),reservePrice:n.O$.from(t.reservePricePerToken),endTimeInEpochSeconds:t.endTime,sellerAddress:t.tokenOwner,type:A.Auction}}}e(13550),e(77191),e(54146);class k{static contractRoles=c.dA;get chainId(){return this._chainId}constructor(t,r,e){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new c.cu(t,r,n,a,e);this._chainId=i,this.abi=c.bn.parse(n||[]),this.contractWrapper=s,this.storage=e,this.metadata=new l.C(this.contractWrapper,c.c1,this.storage),this.app=new l.b(this.contractWrapper,this.metadata,this.storage),this.roles=new g.C(this.contractWrapper,k.contractRoles),this.encoder=new o.C(this.contractWrapper),this.estimator=new l.G(this.contractWrapper),this.direct=new P(this.contractWrapper,this.storage),this.auction=new b(this.contractWrapper,this.storage),this.events=new l.a(this.contractWrapper),this.platformFees=new h.C(this.contractWrapper),this.interceptor=new u.C(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===a.d)throw new c.L(this.getAddress(),t.toString());switch(r.listingType){case A.Auction:return await this.auction.mapListing(r);case A.Direct:return await this.direct.mapListing(r);default:throw new Error(`Unknown listing type: ${r.listingType}`)}}async getActiveListings(t){const r=await this.getAllListingsNoFilter(!0),e=this.applyFilter(r,t),a=n.O$.from(Math.floor(Date.now()/1e3));return e.filter((t=>t.type===A.Auction&&n.O$.from(t.endTimeInEpochSeconds).gt(a)&&n.O$.from(t.startTimeInEpochSeconds).lte(a)||t.type===A.Direct&&n.O$.from(t.quantity).gt(0)))}async getAllListings(t){const r=await this.getAllListingsNoFilter(!1);return this.applyFilter(r,t)}getAll=this.getAllListings;async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async isRestrictedToListerRoleOnly(){return!await this.contractWrapper.read("hasRole",[(0,c.H)("lister"),a.d])}async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getTimeBufferInSeconds(){return this.contractWrapper.read("timeBuffer",[])}async getOffers(t){const r=await this.events.getEvents("NewOffer",{order:"desc",filters:{listingId:t}});return await Promise.all(r.map((r=>(0,p.m)(this.contractWrapper.getProvider(),n.O$.from(t),{quantityWanted:r.data.quantityWanted,pricePerToken:r.data.quantityWanted.gt(0)?r.data.totalOfferAmount.div(r.data.quantityWanted):r.data.totalOfferAmount,currency:r.data.currency,offeror:r.data.offeror}))))}buyoutListing=(0,d.c)((async(t,r,e)=>{const a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new c.L(this.getAddress(),t.toString());switch(a.listingType){case A.Direct:return(0,i.Z)(void 0!==r,"quantityDesired is required when buying out a direct listing"),await this.direct.buyoutListing.prepare(t,r,e);case A.Auction:return await this.auction.buyoutListing.prepare(t);default:throw Error(`Unknown listing type: ${a.listingType}`)}}));makeOffer=(0,d.c)((async(t,r,e)=>{const a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new c.L(this.getAddress(),t.toString());const n=await this.contractWrapper.getChainID();switch(a.listingType){case A.Direct:return(0,i.Z)(e,"quantity is required when making an offer on a direct listing"),await this.direct.makeOffer.prepare(t,e,(0,o.i)(a.currency)?c.a_[n].wrapped.address:a.currency,r);case A.Auction:return await this.auction.makeBid.prepare(t,r);default:throw Error(`Unknown listing type: ${a.listingType}`)}}));setBidBufferBps=(0,d.c)((async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());const r=await this.getTimeBufferInSeconds();return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[r,n.O$.from(t)]})}));setTimeBufferInSeconds=(0,d.c)((async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());const r=await this.getBidBufferBps();return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[n.O$.from(t),r]})}));allowListingFromSpecificAssetOnly=(0,d.c)((async t=>{const r=[];return(await this.roles.get("asset")).includes(a.d)&&r.push(this.encoder.encode("revokeRole",[(0,c.H)("asset"),a.d])),r.push(this.encoder.encode("grantRole",[(0,c.H)("asset"),t])),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));allowListingFromAnyAsset=(0,d.c)((async()=>{const t=[],r=await this.roles.get("asset");for(const e in r)t.push(this.encoder.encode("revokeRole",[(0,c.H)("asset"),e]));return t.push(this.encoder.encode("grantRole",[(0,c.H)("asset"),a.d])),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[t]})}));async getAllListingsNoFilter(t){return(await Promise.all(Array.from(Array((await this.contractWrapper.read("totalListings",[])).toNumber()).keys()).map((async r=>{let e;try{e=await this.getListing(r)}catch(t){return t instanceof c.L?void 0:void console.warn(`Failed to get listing ${r}' - skipping. Try 'marketplace.getListing(${r})' to get the underlying error.`)}if(e.type===A.Auction)return e;if(t){const{valid:t}=await this.direct.isStillValidListing(e);if(!t)return}return e})))).filter((t=>void 0!==t))}applyFilter(t,r){let e=[...t];const a=n.O$.from(r?.start||0).toNumber(),i=n.O$.from(r?.count||s.D).toNumber();return r&&(r.seller&&(e=e.filter((t=>t.sellerAddress.toString().toLowerCase()===r?.seller?.toString().toLowerCase()))),r.tokenContract&&(e=e.filter((t=>t.assetContractAddress.toString().toLowerCase()===r?.tokenContract?.toString().toLowerCase()))),void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString()))),e=e.filter(((t,r)=>r>=a)),e=e.slice(0,i)),e}async prepare(t,r,e){return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:r,overrides:e})}async call(t,r,e){return this.contractWrapper.call(t,r,e)}}},48109:(t,r,e)=>{e.d(r,{a:()=>h,g:()=>g,h:()=>d,i:()=>p,m:()=>u,v:()=>l});var a=e(64146),n=e(2593),i=e(38776),s=e(89050),o=e(7860),c=e(68828);async function p(t,r,n,i,o){try{const c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,p=new a.CH(n,c,t),[d,l]=await Promise.all([p.supportsInterface(s.I),p.supportsInterface(s.a)]);if(d){const s=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,c=new a.CH(n,s,t);if(await c.isApprovedForAll(o,r))return!0;let p;try{p=await c.getApproved(i)}catch(t){}return p?.toLowerCase()===r.toLowerCase()}if(l){const i=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,s=new a.CH(n,i,t);return await s.isApprovedForAll(o,r)}return console.error("Contract does not implement ERC 1155 or ERC 721."),!1}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function d(t,r,a,n,i){const c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,p=new o.cu(t.getSignerOrProvider(),a,c,t.options,t.storage),[d,l]=await Promise.all([p.read("supportsInterface",[s.I]),p.read("supportsInterface",[s.a])]);if(d){const s=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,c=new o.cu(t.getSignerOrProvider(),a,s,t.options,t.storage);if(!await c.read("isApprovedForAll",[i,r])){(await c.read("getApproved",[n])).toLowerCase()===r.toLowerCase()||await c.sendTransaction("setApprovalForAll",[r,!0])}}else{if(!l)throw Error("Contract must implement ERC 1155 or ERC 721.");{const n=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,s=new o.cu(t.getSignerOrProvider(),a,n,t.options,t.storage);await s.read("isApprovedForAll",[i,r])||await s.sendTransaction("setApprovalForAll",[r,!0])}}}function l(t){if((0,i.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,i.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,i.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,i.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,i.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,i.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type)(0,i.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function u(t,r,e){return{quantity:e.quantityDesired,pricePerToken:e.pricePerToken,currencyContractAddress:e.currency,buyerAddress:e.offeror,quantityDesired:e.quantityWanted,currencyValue:await(0,c.a)(t,e.currency,e.quantityWanted.mul(e.pricePerToken)),listingId:r}}function h(t,r,e){if(e=n.O$.from(e),t=n.O$.from(t),r=n.O$.from(r),t.eq(n.O$.from(0)))return!1;return r.sub(t).mul(o.dy).div(t).gte(e)}async function g(t,r,e){const a=[];for(;r-t>s.D;)a.push(e(t,t+s.D-1)),t+=s.D;return a.push(e(t,r-1)),await Promise.all(a)}},41518:(t,r,e)=>{e.d(r,{B:()=>c,C:()=>l,N:()=>d,a:()=>p,s:()=>u});var a=e(7860),n=e(1604),i=e(68828);const s=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(s),s]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),p=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cA,n.z.unknown()])))(),d=(()=>n.z.union([p,n.z.string()]))(),l=(()=>p.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function u(t,r,n,s){if(!(0,i.i)(n)){const i=(await Promise.resolve().then(e.t.bind(e,49242,19))).default,o=t.getSigner(),c=t.getProvider(),p=new a.cu(o||c,n,i,t.options,t.storage),d=await t.getSignerAddress(),l=t.address;return(await p.read("allowance",[d,l])).lt(r)&&await p.sendTransaction("approve",[l,r]),s}s.value=r}}}]);
//# sourceMappingURL=3925.js.map