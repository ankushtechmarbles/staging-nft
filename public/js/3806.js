(self.webpackChunk=self.webpackChunk||[]).push([[3806],{89208:(t,e,r)=>{"use strict";r.d(e,{E:()=>c,R:()=>n,S:()=>o,a:()=>l});var a=r(2593),s=r(1604),i=r(7860);const n=(()=>s.z.union([s.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),s.z.number().transform((t=>a.O$.from(t)))]))(),o=(()=>n.default(new Date(0)))(),c=(()=>n.default(new Date(Date.now()+31536e7)))();function l(t,e){if(!t)throw new i.x(e);return t}},89536:(t,e,r)=>{"use strict";r.d(e,{C:()=>l,G:()=>h,a:()=>p,b:()=>u,d:()=>o,h:()=>c});var a=r(7860),s=r(19578),i=r(61744),n=r(40721);function o(t,e){return(0,a.am)(a.bn.parse(t.abi),e)}function c(t,e){return t in e.readContract.functions}class l{featureName=a.d1.name;constructor(t,e,r){this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const e=await this.contractWrapper.read("contractURI",[]);e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let e,r,s;try{c("name",this.contractWrapper)&&(e=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(r=await this.contractWrapper.read("symbol",[]))}catch(t){}try{s=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:e||s?.name,symbol:r,description:s?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,s.c)((async t=>{const e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,s.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class p{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},s=t=>{const r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(a,s),()=>{this.contractWrapper.getProvider().off(a,s)}}listenToAllEvents(t){const e={address:this.contractWrapper.address},r=e=>{try{const r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(t){console.error("Could not parse event:",e,t)}};return this.contractWrapper.getProvider().on(e,r),()=>{this.contractWrapper.getProvider().off(e,r)}}removeEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber));return this.parseEvents(e)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=this.contractWrapper.readContract.interface.getEvent(t),a=e.filters?r.inputs.map((t=>e.filters[t.name])):[],s=this.contractWrapper.readContract.filters[r.name](...a),i=(await this.contractWrapper.readContract.queryFilter(s,e.fromBlock,e.toBlock)).sort(((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber));return this.parseEvents(i)}parseEvents(t){return t.map((t=>{const e=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const r=Object.entries(t.args),a=r.slice(r.length/2,r.length),s={};for(const[t,e]of a)s[t]=e;return{eventName:t.event||"",data:s,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}}))}toContractEvent(t,e,r){const a=Object.fromEntries(Object.entries(r).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),s={};return t.inputs.forEach(((t,r)=>{if(Array.isArray(e[r])){const a=t.components;if(a){const i=e[r];if("tuple[]"===t.type){const e=[];for(let t=0;t<i.length;t++){const r=i[t],s={};for(let t=0;t<a.length;t++){s[a[t].name]=r[t]}e.push(s)}s[t.name]=e}else{const e={};for(let t=0;t<a.length;t++){e[a[t].name]=i[t]}s[t.name]=e}}}else s[t.name]=e[r]})),{eventName:t.name,data:s,transaction:a}}}class h{constructor(t){this.contractWrapper=t}async gasCostOf(t,e){const[r,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,e)]);return i.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return i.formatUnits(t,"gwei")}}class u{featureName=a.d2.name;constructor(t,e,r){this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,n.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,s.c)((async t=>o(this.contractWrapper,"AppURI")?s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,e,r)=>{"use strict";r.d(e,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},5995:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),s=r(7860);class i{featureName=s.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,e]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return s.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:e})}set=(0,a.c)((async t=>{const e=await s.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[e.platform_fee_recipient,e.platform_fee_basis_points]})}))}},74935:(t,e,r)=>{"use strict";r.d(e,{C:()=>c});var a=r(38776),s=r(7860),i=r(89536),n=r(19578),o=r(68828);class c{featureName=s.d3.name;constructor(t,e){this.contractWrapper=t,this.roles=e}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},e=Object.entries(this.roles);return(await Promise.all(e.map((t=>{let[,e]=t;return this.get(e)})))).forEach(((r,a)=>t[e[a][1]]=r)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=this.contractWrapper;if((0,i.h)("getRoleMemberCount",e)&&(0,i.h)("getRoleMember",e)){const r=(0,s.H)(t),a=(await e.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>e.read("getRoleMember",[r,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,n.c)((async t=>{const e=new o.C(this.contractWrapper),r=Object.keys(t);(0,a.Z)(r.length,"you must provide at least one role to set"),(0,a.Z)(r.every((t=>this.roles.includes(t))),"this contract does not support the given role");const i=await this.getAll(),c=[],l=r.sort((t=>"admin"===t?1:-1));for(let r=0;r<l.length;r++){const a=l[r],[n,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,s.aP)(t)))||[]),Promise.all(i[a]?.map((t=>(0,s.aP)(t)))||[])]),p=n.filter((t=>!o.includes(t))),h=o.filter((t=>!n.includes(t)));if(p.length&&p.forEach((t=>{c.push(e.encode("grantRole",[(0,s.H)(a),t]))})),h.length){(await Promise.all(h.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,r)=>c.push(e.encode(t,[(0,s.H)(a),h[r]]))))}}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,e){await Promise.all(t.map((async t=>{const[r,a]=await Promise.all([this.get(t),(0,s.aP)(e)]);if(!r.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new s.o(a,t)})))}grant=(0,n.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,s.aP)(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,s.H)(t),r]})}));revoke=(0,n.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,s.aP)(e),i=await this.getRevokeRoleFunctionName(r);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:i,args:[(0,s.H)(t),r]})}));async getRevokeRoleFunctionName(t){const[e,r]=await Promise.all([(0,s.aP)(t),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}},82714:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),s=r(7860);class i{featureName=s.d6.name;constructor(t){this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.read("primarySaleRecipient",[])}setRecipient=(0,a.c)((async t=>a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPrimarySaleRecipient",args:[t]})))}},62245:(t,e,r)=>{"use strict";r.d(e,{D:()=>g});var a=r(61744),s=r(16441),i=r(2593),n=r(21046),o=r(9279),c=r(29251),l=r(64063),p=r.n(l),h=r(7860),u=r(58179),m=r(68828),d=r(89536),f=r(19578);class g{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){const[e,r,a]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await(0,u.v)(e,a,this.contractWrapper.getProvider(),r.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,u.w)(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,u.w)(r)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,u.x)(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,u.x)(r)}throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,r]=await this.contractWrapper.read("claimCondition",[]),a=e.toNumber(),s=r.toNumber(),i=[];for(let t=a;t<a+s;t++)i.push(this.get(t));const[n,o,...c]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...i]);return Promise.all(c.map((e=>(0,u.v)(e,o,this.contractWrapper.getProvider(),n.merkle,this.storage,t?.withAllowList||!1))))}return[await this.getActive(t)]}async canClaim(t,e){return e&&(e=await(0,h.aP)(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){const o=[];let c,l;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!e)return[u.C.NoWallet];const[p,d]=await Promise.all([(0,h.aP)(e),this.getTokenDecimals()]),f=a.parseUnits(h.cz.parse(t),d);try{l=await this.getActive()}catch(t){return(0,h.B)(t,"!CONDITION")||(0,h.B)(t,"no active mint condition")?(o.push(u.C.NoClaimConditionSet),o):(console.warn("failed to get active claim condition",t),o.push(u.C.Unknown),o)}if("unlimited"!==l.availableSupply){if(a.parseUnits(l.availableSupply,d).lt(f))return o.push(u.C.NotEnoughSupply),o}const g=s.stripZeros(l.merkleRootHash).length>0;let y=null;if(g){if(y=await this.getClaimerProofs(p),!y&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(u.C.AddressNotAllowed),o;if(y)try{const e=await this.prepareClaim(t,!1,d,p);let r;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[r]=await this.contractWrapper.read("verifyClaimMerkleProof",[c,p,t,e.proofs,e.maxClaimable]),!r)return o.push(u.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([r]=await this.contractWrapper.read("verifyClaimMerkleProof",[p,t,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable}]),!r)return o.push(u.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[c,p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(u.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(u.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(u.C.NotEnoughSupply);break;case"cant claim yet":o.push(u.C.ClaimPhaseNotStarted);break;default:o.push(u.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=i.O$.from(0),e=(0,u.y)(l.maxClaimablePerWallet,d);try{t=await this.getSupplyClaimedByWallet(p)}catch(t){}if(y&&(e=(0,u.y)(y.maxClaimable,d)),e.gt(0)&&e.lt(t.add(f)))return o.push(u.C.OverMaxClaimablePerWallet),o;if((!g||g&&!y)&&(e.lte(t)||e.eq(0)))return o.push(u.C.AddressNotAllowed),o}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,e]=[i.O$.from(0),i.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,e]=await this.contractWrapper.read("getClaimTimestamp",[c,p])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,e]=await this.contractWrapper.read("getClaimTimestamp",[p]));const r=i.O$.from(Date.now()).div(1e3);if(t.gt(0)&&r.lt(e))return e.eq(n.Bz)?o.push(u.C.AlreadyClaimed):o.push(u.C.WaitBeforeNextClaimTransaction),o}if(l.price.gt(0)&&(0,h.d7)()){const e=l.price.mul(i.O$.from(t)),a=this.contractWrapper.getProvider();if((0,m.i)(l.currencyAddress)){(await a.getBalance(p)).lt(e)&&o.push(u.C.NotEnoughTokens)}else{const t=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,s=new h.cu(a,l.currencyAddress,t,{},this.storage);(await s.read("balanceOf",[p])).lt(e)&&o.push(u.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e){const r=(await this.get(e)).merkleRoot;if(s.stripZeros(r).length>0){const[e,a]=await Promise.all([this.metadata.get(),(0,h.aP)(t)]);return await(0,u.f)(a,r.toString(),e.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const e=await(0,h.aP)(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,f.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=e;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(r=!0,0===e.length)a=[{startTime:new Date(0),currencyAddress:o.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:s.hexZeroPad([0],32),snapshot:[]}];else if(e.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&a.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:i,sortedConditions:n}=await(0,u.D)(a,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),c={};i.forEach((t=>{c[t.merkleRoot]=t.snapshotUri}));const l=await t.metadata.get(),h=[];if(!p()(l.merkle,c)){const e=await t.metadata.parseInputMetadata({...l,merkle:c}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,d.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new m.C(t.contractWrapper);h.push(e.encode("setContractURI",[r]))}}const g=t.contractWrapper,y=new m.C(g);if(t.isLegacySinglePhaseDrop(g)){const t=new m.C(g);h.push(t.encode("setClaimConditions",[(0,u.E)(n[0]),r]))}else if(t.isLegacyMultiPhaseDrop(g))h.push(y.encode("setClaimConditions",[n.map(u.E),r]));else if(t.isNewSinglePhaseDrop(g))h.push(y.encode("setClaimConditions",[(0,u.F)(n[0]),r]));else{if(!t.isNewMultiphaseDrop(g))throw new Error("Contract does not support claim conditions");h.push(y.encode("setClaimConditions",[n.map(u.F),r]))}if((0,d.h)("multicall",t.contractWrapper))return f.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[h]});throw new Error("Contract does not support multicall")}})());update=(0,f.c)((async(t,e)=>{const r=await this.getAll(),a=await(0,u.H)(t,e,r);return await this.set.prepare(a)}));async getTokenDecimals(){return(0,d.d)(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3?arguments[3]:void 0;const[s,i]=await Promise.all([a||this.contractWrapper.getSignerAddress(),this.getActive()]);return(0,u.z)(s,t,i,(async()=>(await this.metadata.get()).merkle),r,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r){const a=await(0,h.aP)(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,r.proofs,r.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable},c.Y0("")]:[a,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,pricePerToken:r.priceInProof,currency:r.currencyAddressInProof},c.Y0("")]}async getClaimTransaction(t,e,r){if(r?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const a=await this.prepareClaim(e,void 0===r?.checkERC20Allowance||r.checkERC20Allowance,await this.getTokenDecimals());return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,a),overrides:a.overrides})}isNewSinglePhaseDrop(t){return(0,d.d)(t,"ERC721ClaimConditionsV2")||(0,d.d)(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,d.d)(t,"ERC721ClaimPhasesV2")||(0,d.d)(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,d.d)(t,"ERC721ClaimConditionsV1")||(0,d.d)(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,d.d)(t,"ERC721ClaimPhasesV1")||(0,d.d)(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?u.A.V1:u.A.V2}}},11846:(t,e,r)=>{"use strict";r.d(e,{e:()=>C,f:()=>W});var a=r(2593),s=r(61744),i=r(68828),n=r(7860),o=r(89208),c=r(89536),l=r(19578),p=r(62245),h=r(38776),u=r(19824),m=r(41518),d=r(58179);class f{featureName=n.cG.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}to=(0,l.c)((async t=>{const e=new i.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([(0,n.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[r,a]=t;return e.encode("mintTo",[r,a])}));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}))}class g{featureName=n.cH.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}tokens=(0,l.c)((async t=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})));from=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,n.aP)(t),this.erc20.normalizeAmount(e)])})))}class y{featureName=n.cI.name;constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r;const a=new c.C(this.contractWrapper,n.bk,this.storage);this.conditions=new p.D(this.contractWrapper,a,this.storage)}to=(0,l.c)((async(t,e,r)=>{const a=await this.erc20.normalizeAmount(e);return await this.conditions.getClaimTransaction(t,a,r)}))}class w{constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r,this.claim=new y(this.erc20,this.contractWrapper,this.storage)}}class b{featureName=n.cJ.name;constructor(t,e){this.erc20=t,this.contractWrapper=e,this.batch=this.detectErc20BatchMintable()}to=(0,l.c)((async(t,e)=>await this.getMintTransaction(t,e)));async getMintTransaction(t,e){return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,n.aP)(t),this.erc20.normalizeAmount(e)])})}detectErc20BatchMintable(){if((0,c.d)(this.contractWrapper,"ERC20BatchMintable"))return new f(this.erc20,this.contractWrapper)}}class C{featureName=n.cK.name;constructor(t,e){this.contractWrapper=t,this.roles=e}mint=(0,l.c)((async t=>{const e=t.payload,r=t.signature,[s,i]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,m.s)(this.contractWrapper,a.O$.from(s.price),e.currencyAddress,i),l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[s,r],overrides:i})}));mintBatch=(0,l.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const s=e[r],i=t.signature,n=t.payload.price;if(a.O$.from(n).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:s,signature:i}})),s=new i.C(this.contractWrapper),n=r.map((t=>s.encode("mintWithSignature",[t.message,t.signature])));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n]})}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await(this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[e,r,a]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>d.S.parseAsync(t))))]),s=this.contractWrapper.getSigner();(0,h.Z)(s,"No signer available");const i=await Promise.all(a.map((t=>d.k.parseAsync(t)))),n=await Promise.all(i.map((t=>this.mapPayloadToContractStruct(t)))),o=await Promise.all(n.map((t=>this.contractWrapper.signTypedData(s,{name:r,version:"1",chainId:e,verifyingContract:this.contractWrapper.address},{MintRequest:d.M},t))));return a.map(((t,e)=>({payload:i[e],signature:o[e].toString()})))}async mapPayloadToContractStruct(t){const[e,r]=await Promise.all([(0,u.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),a=s.parseUnits(t.quantity,r);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:a,price:e,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class W{featureName=n.cL.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await(0,i.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await(0,n.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[e,r]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,n.aP)(t)]);return await this.allowanceOf(e,r)}async allowanceOf(t,e){const r=await Promise.all([(0,n.aP)(t),(0,n.aP)(e)]);return await this.getValue(await this.contractWrapper.read("allowance",r))}transfer=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,n.aP)(t),this.normalizeAmount(e)])})));transferFrom=(0,l.c)((async(t,e,r)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,n.aP)(t),(0,n.aP)(e),this.normalizeAmount(r)])})));setAllowance=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,n.aP)(t),this.normalizeAmount(e)])})));transferBatch=(0,l.c)((async t=>{const e=new i.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),(0,n.aP)(t.toAddress)]))))).map((t=>{let[r,a]=t;return e.encode("transfer",[a,r])}));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));mint=(0,l.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,l.c)((async(t,e)=>(0,o.a)(this.mintable,n.cJ).to.prepare(t,e)));async getMintTransaction(t,e){return(0,o.a)(this.mintable,n.cJ).getMintTransaction(t,e)}mintBatchTo=(0,l.c)((async t=>(0,o.a)(this.mintable?.batch,n.cG).to.prepare(t)));burn=(0,l.c)((async t=>(0,o.a)(this.burnable,n.cH).tokens.prepare(t)));burnFrom=(0,l.c)((async(t,e)=>(0,o.a)(this.burnable,n.cH).from.prepare(t,e)));claim=(0,l.c)((async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));claimTo=(0,l.c)((async(t,e,r)=>(0,o.a)(this.droppable?.claim,n.cI).to.prepare(t,e,r)));get claimConditions(){return(0,o.a)(this.droppable?.claim,n.cI).conditions}get signature(){return(0,o.a)(this.signatureMintable,n.cK)}async normalizeAmount(t){return async function(t,e){const r=await t.read("decimals",[]);return s.parseUnits(n.cz.parse(e),r)}(this.contractWrapper,t)}async getValue(t){return await(0,i.a)(this.contractWrapper.getProvider(),this.getAddress(),a.O$.from(t))}detectErc20Mintable(){if((0,c.d)(this.contractWrapper,"ERC20"))return new b(this,this.contractWrapper)}detectErc20Burnable(){if((0,c.d)(this.contractWrapper,"ERC20Burnable"))return new g(this,this.contractWrapper)}detectErc20Droppable(){if((0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new w(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,c.d)(this.contractWrapper,"ERC20SignatureMintable"))return new C(this.contractWrapper)}}},78012:(t,e,r)=>{"use strict";r.d(e,{S:()=>i});var a=r(19578),s=r(11846);class i{get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.erc20=new s.f(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return this.erc20.get()}async balance(){return await this.erc20.balance()}async balanceOf(t){return this.erc20.balanceOf(t)}async totalSupply(){return await this.erc20.totalSupply()}async allowance(t){return await this.erc20.allowance(t)}async allowanceOf(t,e){return await this.erc20.allowanceOf(t,e)}transfer=(0,a.c)((async(t,e)=>this.erc20.transfer.prepare(t,e)));transferFrom=(0,a.c)((async(t,e,r)=>this.erc20.transferFrom.prepare(t,e,r)));setAllowance=(0,a.c)((async(t,e)=>this.erc20.setAllowance.prepare(t,e)));transferBatch=(0,a.c)((async t=>this.erc20.transferBatch.prepare(t)))}},41518:(t,e,r)=>{"use strict";r.d(e,{B:()=>c,C:()=>h,N:()=>p,a:()=>l,s:()=>u});var a=r(7860),s=r(1604),i=r(68828);const n=(()=>s.z.object({}).catchall(s.z.union([a.cA,s.z.unknown()])))(),o=(()=>s.z.union([s.z.array(n),n]).optional().nullable())(),c=(()=>s.z.object({name:s.z.union([s.z.string(),s.z.number()]).optional().nullable(),description:s.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),l=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(s.z.union([a.cA,s.z.unknown()])))(),p=(()=>s.z.union([l,s.z.string()]))(),h=(()=>l.extend({id:s.z.string(),uri:s.z.string(),image:s.z.string().nullable().optional(),external_url:s.z.string().nullable().optional(),animation_url:s.z.string().nullable().optional()}))();async function u(t,e,s,n){if(!(0,i.i)(s)){const i=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=t.getSigner(),c=t.getProvider(),l=new a.cu(o||c,s,i,t.options,t.storage),p=await t.getSignerAddress(),h=t.address;return(await l.read("allowance",[p,h])).lt(e)&&await l.sendTransaction("approve",[h,e]),n}n.value=e}},58179:(t,e,r)=>{"use strict";r.d(e,{A:()=>N,B:()=>K,C:()=>Q,D:()=>q,E:()=>x,F:()=>k,H:()=>G,I:()=>Y,M:()=>ct,S:()=>X,a:()=>M,f:()=>R,k:()=>tt,o:()=>st,p:()=>it,q:()=>nt,r:()=>ot,s:()=>lt,t:()=>pt,u:()=>ht,v:()=>J,w:()=>L,x:()=>I,y:()=>B,z:()=>D});var a=r(21046),s=r(61744),i=r(31886),n=r(9279),o=r(38197),c=r(2593),l=r(16441),p=r(29251),h=r(7860),u=r(68828),m=r(19824),d=r(48764),f=r(56351),g=r.n(f),y=r(99269);class w{print(){w.print(this)}bufferIndexOf(t,e){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(t,e,d.Buffer.compare);return this.linearSearch(t,e,((t,e)=>t.equals(e)))}static binarySearch(t,e,r){let a=0,s=t.length-1;for(;a<=s;){const i=Math.floor((a+s)/2),n=r(t[i],e);if(0===n){for(let a=i-1;a>=0;a--)if(0!==r(t[a],e))return a+1;return 0}n<0?a=i+1:s=i-1}return-1}binarySearch(t,e,r){return w.binarySearch(t,e,r)}static linearSearch(t,e,r){for(let a=0;a<t.length;a++)if(r(t[a],e))return a;return-1}linearSearch(t,e,r){return w.linearSearch(t,e,r)}static bufferify(t){if(!d.Buffer.isBuffer(t)){if("object"==typeof t&&t.words)return d.Buffer.from(t.toString(C),"hex");if(w.isHexString(t))return d.Buffer.from(t.replace(/^0x/,""),"hex");if("string"==typeof t)return d.Buffer.from(t);if("bigint"==typeof t)return d.Buffer.from(t.toString(16),"hex");if(t instanceof Uint8Array)return d.Buffer.from(t.buffer);if("number"==typeof t){let e=t.toString();return e.length%2&&(e=`0${e}`),d.Buffer.from(e,"hex")}if(ArrayBuffer.isView(t))return d.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}return t}bigNumberify(t){return w.bigNumberify(t)}static bigNumberify(t){if("bigint"==typeof t)return t;if("string"==typeof t)return t.startsWith("0x")&&w.isHexString(t)?BigInt("0x"+t.replace("0x","").toString()):BigInt(t);if(d.Buffer.isBuffer(t))return BigInt("0x"+t.toString("hex"));if(t instanceof Uint8Array)return function(t){const e=Array.from(t).map((t=>t.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${e}`)}(t);if("number"==typeof t)return BigInt(t);throw new Error("cannot bigNumberify")}static isHexString(t){return"string"==typeof t&&/^(0x)?[0-9A-Fa-f]*$/.test(t)}static print(t){console.log(t.toString())}bufferToHex(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(t,e)}static bufferToHex(t){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(t||d.Buffer.alloc(0)).toString("hex")}`}bufferify(t){return w.bufferify(t)}bufferifyFn(t){return e=>{const r=t(e);if(d.Buffer.isBuffer(r))return r;if(this.isHexString(r))return d.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return d.Buffer.from(r);if("bigint"==typeof r)return d.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(r))return d.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e.buffer}(e.toString("hex")),s=function(t){const e=new Uint8Array(t);return Array.from(e).map((t=>t.toString(16).padStart(2,"0"))).join("")}(t(a));return d.Buffer.from(s,"hex")}}isHexString(t){return w.isHexString(t)}log2(t){return 1===t?0:1+this.log2(t/2|0)}zip(t,e){return t.map(((t,r)=>[t,e[r]]))}static hexZeroPad(t,e){return"0x"+t.replace("0x","").padStart(e,"0")}}var b=w;function C(t){const e=t.words,r=new ArrayBuffer(4*e.length),a=new Uint8Array(r);for(let t=0;t<e.length;t++)a[4*t]=e[t]>>24&255,a[4*t+1]=e[t]>>16&255,a[4*t+2]=e[t]>>8&255,a[4*t+3]=255&e[t];return r}class W extends b{duplicateOdd=!1;concatenator=d.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!d.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(t,e)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(e),this.processLeaves(t)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(t){if(this.hashLeaves&&(t=t.map(this.hashFn)),this.leaves=t.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(t){for(this.layers=[t];t.length>1;){const e=this.layers.length;this.layers.push([]);const r=this.complete&&1===e&&!Number.isInteger(Math.log2(t.length))?2*t.length-2**Math.ceil(Math.log2(t.length)):t.length;for(let a=0;a<t.length;a+=2){if(a>=r){this.layers[e].push(...t.slice(r));break}if(a+1===t.length&&t.length%2==1){const r=t[t.length-1];let s=r;if(this.isBitcoinTree){s=this.hashFn(this.concatenator([g()(r),g()(r)])),s=g()(this.hashFn(s)),this.layers[e].push(s);continue}if(!this.duplicateOdd){this.layers[e].push(t[a]);continue}}const s=t[a],i=a+1===t.length?s:t[a+1];let n=null;n=this.isBitcoinTree?[g()(s),g()(i)]:[s,i],this.sortPairs&&n.sort(d.Buffer.compare);let o=this.hashFn(this.concatenator(n));this.isBitcoinTree&&(o=g()(this.hashFn(o))),this.layers[e].push(o)}t=this.layers[e]}}addLeaf(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=this.hashFn(t)),this.processLeaves(this.leaves.concat(t))}addLeaves(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=t.map(this.hashFn)),this.processLeaves(this.leaves.concat(t))}getLeaves(t){return Array.isArray(t)?(this.hashLeaves&&(t=t.map(this.hashFn),this.sortLeaves&&(t=t.sort(d.Buffer.compare))),this.leaves.filter((e=>-1!==this.bufferIndexOf(t,e,this.sortLeaves)))):this.leaves}getLeaf(t){return t<0||t>this.leaves.length-1?d.Buffer.from([]):this.leaves[t]}getLeafIndex(t){t=this.bufferify(t);const e=this.getLeaves();for(let r=0;r<e.length;r++){if(e[r].equals(t))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((t=>this.bufferToHex(t)))}static marshalLeaves(t){return JSON.stringify(t.map((t=>W.bufferToHex(t))),null,2)}static unmarshalLeaves(t){let e=null;if("string"==typeof t)e=JSON.parse(t);else{if(!(t instanceof Object))throw new Error("Expected type of string or object");e=t}if(!e)return[];if(!Array.isArray(e))throw new Error("Expected JSON string to be array");return e.map(W.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((t,e)=>(Array.isArray(e)?t.push(e.map((t=>this.bufferToHex(t)))):t.push(e),t)),[])}getLayersFlat(){const t=this.layers.reduce(((t,e)=>(Array.isArray(e)?t.unshift(...e):t.unshift(e),t)),[]);return t.unshift(d.Buffer.from([0])),t}getHexLayersFlat(){return this.getLayersFlat().map((t=>this.bufferToHex(t)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?d.Buffer.from([]):this.layers[this.layers.length-1][0]||d.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(t,e){if(void 0===t)throw new Error("leaf is required");t=this.bufferify(t);const r=[];if(!Number.isInteger(e)){e=-1;for(let r=0;r<this.leaves.length;r++)0===d.Buffer.compare(t,this.leaves[r])&&(e=r)}if(e<=-1)return[];for(let t=0;t<this.layers.length;t++){const a=this.layers[t],s=e%2,i=s?e-1:this.isBitcoinTree&&e===a.length-1&&t<this.layers.length-1?e:e+1;i<a.length&&r.push({position:s?"left":"right",data:a[i]}),e=e/2|0}return r}getHexProof(t,e){return this.getProof(t,e).map((t=>this.bufferToHex(t.data)))}getProofs(){const t=[];return this.getProofsDFS(this.layers.length-1,0,[],t),t}getProofsDFS(t,e,r,a){const s=e%2;if(-1===t)return void(s||a.push([...r].reverse()));if(e>=this.layers[t].length)return;const i=this.layers[t],n=s?e-1:e+1;let o=!1;n<i.length&&(o=!0,r.push({position:s?"left":"right",data:i[n]}));const c=2*e,l=2*e+1;this.getProofsDFS(t-1,c,r,a),this.getProofsDFS(t-1,l,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((t=>this.bufferToHex(t.data)))}getPositionalHexProof(t,e){return this.getProof(t,e).map((t=>["left"===t.position?0:1,this.bufferToHex(t.data)]))}getProofIndices(t,e){const r=2**e;let a=new Set;for(const e of t){let t=r+e;for(;t>1;)a.add(1^t),t=t/2|0}const s=t.map((t=>r+t)),i=Array.from(a).sort(((t,e)=>t-e)).reverse();a=s.concat(i);const n=new Set,o=[];for(let t of a)if(!n.has(t))for(o.push(t);t>1&&(n.add(t),n.has(1^t));)t=t/2|0;return o.filter((e=>!t.includes(e-r)))}getProofIndicesForUnevenTree(t,e){const r=Math.ceil(Math.log2(e)),a=[];for(let t=0;t<r;t++){e%2!=0&&a.push({index:t,leavesCount:e}),e=Math.ceil(e/2)}const s=[];let i=t;for(let t=0;t<r;t++){let e=i.map((t=>t%2==0?t+1:t-1)).filter((t=>!i.includes(t)));const r=a.find((e=>{let{index:r}=e;return r===t}));r&&i.includes(r.leavesCount-1)&&(e=e.slice(0,-1)),s.push(e),i=[...new Set(i.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))]}return s}getMultiProof(t,e){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),e||(e=t,t=this.getLayersFlat());if(this.isUnevenTree()&&e.every(Number.isInteger))return this.getMultiProofForUnevenTree(e);if(!e.every(Number.isInteger)){let t=e;this.sortPairs&&(t=t.sort(d.Buffer.compare));let r=t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1));if(!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=[],s=[];let i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const n=r[t],o=this.getPairNode(e,n);a.push(e[n]),o&&s.push(o),i.push(n/2|0)}r=i.filter(((t,e,r)=>r.indexOf(t)===e)),i=[]}return s.filter((t=>!a.includes(t)))}return this.getProofIndices(e,Math.log2(t.length/2|0)).map((e=>t[e]))}getMultiProofForUnevenTree(t,e){e||(e=t,t=this.getLayers());let r=[],a=e;for(const e of t){const t=[];for(const r of a){if(r%2==0){const s=r+1;if(!a.includes(s)&&e[s]){t.push(e[s]);continue}}const s=r-1;a.includes(s)||!e[s]||t.push(e[s])}r=r.concat(t);const s=new Set;for(const t of a)t%2!=0?t%2!=0?s.add((t-1)/2):s.add((t+1)/2):s.add(t/2);a=Array.from(s)}return r}getHexMultiProof(t,e){return this.getMultiProof(t,e).map((t=>this.bufferToHex(t)))}getProofFlags(t,e){if(!Array.isArray(t)||t.length<=0)throw new Error("Invalid Inputs!");let r;if(r=t.every(Number.isInteger)?[...t].sort(((t,e)=>t===e?0:t>e?1:-1)):t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1)),!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=e.map((t=>this.bufferify(t))),s=[],i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];r=r.reduce(((t,r)=>{if(!s.includes(e[r])){const t=this.getPairNode(e,r),n=a.includes(e[r])||a.includes(t);t&&i.push(!n),s.push(e[r]),s.push(t)}return t.push(r/2|0),t}),[])}return i}verify(t,e,r){let a=this.bufferify(e);if(r=this.bufferify(r),!Array.isArray(t)||!e||!r)return!1;for(let e=0;e<t.length;e++){const r=t[e];let s=null,i=null;if("string"==typeof r)s=this.bufferify(r),i=!0;else if(Array.isArray(r))i=0===r[0],s=this.bufferify(r[1]);else if(d.Buffer.isBuffer(r))s=r,i=!0;else{if(!(r instanceof Object))throw new Error("Expected node to be of type string or object");s=this.bufferify(r.data),i="left"===r.position}const n=[];this.isBitcoinTree?(n.push(g()(a)),n[i?"unshift":"push"](g()(s)),a=this.hashFn(this.concatenator(n)),a=g()(this.hashFn(a))):this.sortPairs?-1===d.Buffer.compare(a,s)?(n.push(a,s),a=this.hashFn(this.concatenator(n))):(n.push(s,a),a=this.hashFn(this.concatenator(n))):(n.push(a),n[i?"unshift":"push"](s),a=this.hashFn(this.concatenator(n)))}return 0===d.Buffer.compare(a,r)}verifyMultiProof(t,e,r,a,s){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(t,e,r,a,s);const i=Math.ceil(Math.log2(a));t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),s=s.map((t=>this.bufferify(t)));const n={};for(const[t,a]of this.zip(e,r))n[2**i+t]=a;for(const[t,r]of this.zip(this.getProofIndices(e,i),s))n[t]=r;let o=Object.keys(n).map((t=>Number(t))).sort(((t,e)=>t-e));o=o.slice(0,o.length-1);let c=0;for(;c<o.length;){const t=o[c];if(t>=2&&{}.hasOwnProperty.call(n,1^t)){let e=[n[t-t%2],n[t-t%2+1]];this.sortPairs&&(e=e.sort(d.Buffer.compare));const r=e[1]?this.hashFn(this.concatenator(e)):e[0];n[t/2|0]=r,o.push(t/2|0)}c+=1}return!e.length||{}.hasOwnProperty.call(n,1)&&n[1].equals(t)}verifyMultiProofWithFlags(t,e,r,a){t=this.bufferify(t),e=e.map(this.bufferify),r=r.map(this.bufferify);const s=e.length,i=a.length,n=[];let o=0,c=0,l=0;for(let t=0;t<i;t++){const i=[a[t]?o<s?e[o++]:n[c++]:r[l++],o<s?e[o++]:n[c++]].sort(d.Buffer.compare);n[t]=this.hashFn(this.concatenator(i))}return 0===d.Buffer.compare(n[i-1],t)}verifyMultiProofForUnevenTree(t,e,r,a,s){t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),s=s.map((t=>this.bufferify(t)));const i=this.calculateRootForUnevenTree(e,r,a,s);return t.equals(i)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const t=this.getLayers().map((t=>t.map((t=>this.bufferToHex(t,!1))))),e=[];for(let r=0;r<t.length;r++){const a=[];for(let s=0;s<t[r].length;s++){const i={[t[r][s]]:null};if(e.length){i[t[r][s]]={};const a=e.shift(),n=Object.keys(a)[0];if(i[t[r][s]][n]=a[n],e.length){const a=e.shift(),n=Object.keys(a)[0];i[t[r][s]][n]=a[n]}}a.push(i)}e.push(...a)}return e[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(t,e){const r=e%2==0?e+1:e-1;return r<t.length?t[r]:null}toTreeString(){const t=this.getLayersAsObject();return(0,y.asTree)(t,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(t){const e=t?.length||this.getDepth();return!this.isPowOf2(e)}isPowOf2(t){return t&&!(t&t-1)}calculateRootForUnevenTree(t,e,r,a){const s=this.zip(t,e).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})),i=s.map((t=>{let[e]=t;return e})),n=this.getProofIndicesForUnevenTree(i,r);let o=0;const c=[];for(let t=0;t<n.length;t++){const e=n[t],r=o;o+=e.length,c[t]=this.zip(e,a.slice(r,o))}const l=[s];for(let t=0;t<c.length;t++){const e=c[t].concat(l[t]).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})).map((t=>{let[,e]=t;return e})),r=l[t].map((t=>{let[e]=t;return e})),a=[...new Set(r.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))],s=[];for(let t=0;t<a.length;t++){const r=a[t],i=e[2*t],n=e[2*t+1],o=n?this.hashFn(this.concatenator([i,n])):i;s.push([r,o])}l.push(s)}return l[l.length-1][0][1]}}var v=r(89208),P=r(1604),S=r(41518),T=r(57632),A=r(48764).Buffer;function x(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function k(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function B(t,e){return"unlimited"===t?a.Bz:s.parseUnits(t,e)}async function E(t){const e=25e3,r=Array.from({length:Math.ceil(t.length/e)},((r,a)=>t.slice(a*e,a*e+e))),a=[],s=await Promise.all(r.map((t=>h.bO.parseAsync(t))));for(const t of s)a.push(...t);return a}let N=function(t){return t[t.V1=1]="V1",t[t.V2=2]="V2",t}({});class O{constructor(t,e,r,a,s){this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(t,e){try{const r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return O.fromShardedMerkleTreeInfo(r,e)}catch(t){return}}static async fromShardedMerkleTreeInfo(t,e){return new O(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case N.V1:return i.keccak256(["address","uint256"],[t.address,B(t.maxClaimable,e)]);case N.V2:return i.keccak256(["address","uint256","uint256","address"],[t.address,B(t.maxClaimable,e),B(t.price||"unlimited",r),t.currencyAddress||n.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){a=(await(0,u.f)(e,r)).decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,s){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const n=await E(t),c={};for(const t of n){const e=t.address.slice(2,2+i).toLowerCase();void 0===c[e]&&(c[e]=[]),c[e].push(t)}const l={},p=await Promise.all(Object.entries(c).map((async t=>{let[a,i]=t;return[a,new W(await Promise.all(i.map((async t=>{const a=await O.fetchAndCacheDecimals(l,r,t.currencyAddress);return O.hashEntry(t,e,a,s)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),h=Object.fromEntries(p),u=new W(Object.values(h),o.keccak256,{sort:!0}),m=[];for(const[t,e]of Object.entries(c)){const r={proofs:u.getProof(h[t]).map((t=>"0x"+t.data.toString("hex"))),entries:e};m.push({data:JSON.stringify(r),name:`${t}.json`})}const d=await a.uploadBatch(m),f=d[0].slice(0,d[0].lastIndexOf("/")),g=await a.upload(n),y={merkleRoot:u.getHexRoot(),baseUri:f,originalEntriesUri:g,shardNybbles:i,tokenDecimals:e,isShardedMerkleTree:!0};return{shardedMerkleInfo:y,uri:await a.upload(y)}}async getProof(t,e,r){const a=t.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[a];const i={};if(void 0===s)try{const t=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[a]=await this.storage.downloadJSON(`${t}${a}.json`);const n=await Promise.all(s.entries.map((async t=>{const a=await O.fetchAndCacheDecimals(i,e,t.currencyAddress);return O.hashEntry(t,this.tokenDecimals,a,r)})));this.trees[a]=new W(n,o.keccak256,{sort:!0})}catch(t){return null}const n=s.entries.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!n)return null;const c=await O.fetchAndCacheDecimals(i,e,n.currencyAddress),l=O.hashEntry(n,this.tokenDecimals,c,r),p=this.trees[a].getProof(l).map((t=>"0x"+t.data.toString("hex")));return h.bP.parseAsync({...n,proof:p.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function R(t,e,r,a,s,i){if(!r)return null;const n=r[e];if(n){const r=await s.downloadJSON(n);if(r.isShardedMerkleTree&&r.merkleRoot===e){const e=await O.fromShardedMerkleTreeInfo(r,s);return await e.getProof(t,a,i)}const o=await h.bQ.parseAsync(r);if(e===o.merkleRoot)return o.claims.find((e=>e.address.toLowerCase()===t.toLowerCase()))||null}return null}function L(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function I(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function M(t,e,a,i,n){const o=t.getSigner(),l=t.getProvider(),p=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,u=new h.cu(o||l,e,p,t.options,t.storage),m=await t.getSignerAddress(),d=t.address,f=await u.read("allowance",[m,d]),g=c.O$.from(a).mul(c.O$.from(i)).div(s.parseUnits("1",n));f.lt(g)&&await u.sendTransaction("approve",[d,f.add(g)])}async function D(t,e,r,i,o,p,h,d,f){let g=B(r.maxClaimablePerWallet,o),y=[l.hexZeroPad([0],32)],w=r.price,b=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(n.d)){const e=await R(t,r.merkleRootHash.toString(),await i(),p.getProvider(),h,f);if(e)y=e.proof,g="unlimited"===e.maxClaimable?a.Bz:s.parseUnits(e.maxClaimable,o),w=void 0===e.price||"unlimited"===e.price?a.Bz:await(0,m.n)(p.getProvider(),e.price,e.currencyAddress||n.d),b=e.currencyAddress||n.d;else if(f===N.V1)throw new Error("No claim found for this address")}}catch(t){if("No claim found for this address"===t?.message)throw t;console.warn("failed to check claim condition merkle root hash, continuing anyways",t)}const C=await p.getCallOverrides()||{},W=w.toString()!==a.Bz.toString()?w:r.price,v=b!==n.d?b:r.currencyAddress;return W.gt(0)&&((0,u.i)(v)?C.value=c.O$.from(W).mul(e).div(s.parseUnits("1",o)):d&&await M(p,v,W,e,o)),{overrides:C,proofs:y,maxClaimable:g,price:W,currencyAddress:v,priceInProof:w,currencyAddressInProof:b}}const z=(()=>P.z.object({name:P.z.string(),symbol:P.z.string(),decimals:P.z.number()}))(),F=(()=>z.extend({value:h.b9,displayValue:P.z.string()}))(),H=(()=>P.z.object({name:P.z.string().optional()}).catchall(P.z.unknown()))(),U=(()=>P.z.object({startTime:v.S,currencyAddress:P.z.string().default(h.aZ),price:h.cz.default(0),maxClaimableSupply:h.cD,maxClaimablePerWallet:h.cD,waitInSeconds:h.ba.default(0),merkleRootHash:h.cE.default(l.hexZeroPad([0],32)),snapshot:P.z.optional(h.bO).nullable(),metadata:H.optional()}))(),V=(()=>P.z.array(U))(),j=(()=>U.extend({availableSupply:h.cD,currentMintSupply:h.cD,currencyMetadata:F.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h.b9,waitInSeconds:h.b9,startTime:h.b9.transform((t=>new Date(1e3*t.toNumber()))),snapshot:h.bO.optional().nullable()}))();async function $(t,e,r,a,s){const i=[],n=await Promise.all(t.map((async t=>{if(t.snapshot&&t.snapshot.length>0){const n=await async function(t,e,r,a,s){const i=await E(t),n=i.map((t=>t.address));if(new Set(n).size<n.length)throw new h.s;const o=await O.buildAndUpload(i,e,r,a,s);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(t.snapshot,e,r,a,s);i.push(n),t.merkleRootHash=n.merkleRoot}else t.merkleRootHash=l.hexZeroPad([0],32);return t})));return{inputsWithSnapshots:n,snapshotInfos:i}}async function q(t,e,r,a,s){const{inputsWithSnapshots:i,snapshotInfos:o}=await $(t,e,r,a,s),l=await V.parseAsync(i),p=(await Promise.all(l.map((t=>async function(t,e,r,a){const s=t.currencyAddress===n.d?h.aZ:t.currencyAddress,i=B(t.maxClaimableSupply,e),o=B(t.maxClaimablePerWallet,e);let c;return t.metadata&&(c="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:i,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,m.n)(r,t.price,s),currency:s,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:c}}(t,e,r,a))))).sort(((t,e)=>function(t,e){const r=c.O$.from(t),a=c.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1}(t.startTimestamp,e.startTimestamp)));return{snapshotInfos:o,sortedConditions:p}}async function _(t,e,r){if(!e)return null;const a=e[t];if(a){const e=await r.downloadJSON(a);if(e.isShardedMerkleTree&&e.merkleRoot===t){const t=await O.fromUri(a,r);return t?.getAllEntries()||null}{const r=await h.bQ.parseAsync(e);if(t===r.merkleRoot)return r.claims.map((t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress})))}}return null}function Z(t,e){return t.toString()===a.Bz.toString()?"unlimited":s.formatUnits(t,e)}async function J(t,e,r,a,s,i){const n=await(0,u.a)(r,t.currency,t.pricePerToken),o=Z(t.maxClaimableSupply,e),l=Z(t.maxClaimablePerWallet,e),p=Z(c.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),h=Z(t.supplyClaimed,e);let m;return t.metadata&&(m=await s.downloadJSON(t.metadata)),j.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:l,currentMintSupply:h,availableSupply:p,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:c.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:n,merkleRootHash:t.merkleRoot,snapshot:i?await _(t.merkleRoot,a,s):void 0,metadata:m})}async function G(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);const a=r[t].currencyMetadata.decimals,i=r[t].price,n=s.formatUnits(i,a),o=await U.parseAsync({...r[t],price:n,...e}),c=await j.parseAsync({...o,price:i});return r.map(((e,r)=>{let i;i=r===t?c:e;const n=s.formatUnits(i.price,a);return{...i,price:n}}))}let Q=function(t){return t.NotEnoughSupply="There is not enough supply to claim.",t.AddressNotAllowed="This address is not on the allowlist.",t.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",t.ClaimPhaseNotStarted="Claim phase has not started yet.",t.AlreadyClaimed="You have already claimed the token.",t.WrongPriceOrCurrency="Incorrect price or currency.",t.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",t.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",t.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",t.NoClaimConditionSet="There is no claim condition set.",t.NoWallet="No wallet connected.",t.Unknown="No claim conditions found.",t}({});function Y(t){if(void 0===t){const t=A.alloc(16);return(0,T.Z)({},t),l.hexlify(p.Y0(t.toString("hex")))}return l.hexlify(t)}const K=(()=>P.z.object({to:h.bd.refine((t=>t.toLowerCase()!==n.d),{message:"Cannot create payload to mint to zero address"}),price:h.cz.default(0),currencyAddress:h.bc.default(h.aZ),mintStartTime:v.S,mintEndTime:v.E,uid:P.z.string().optional().transform((t=>Y(t))),primarySaleRecipient:h.bd.default(n.d)}))(),X=(()=>K.extend({quantity:h.cz}))(),tt=(()=>X.extend({mintStartTime:h.b9,mintEndTime:h.b9}))(),et=(()=>K.extend({metadata:S.N,royaltyRecipient:P.z.string().default(n.d),royaltyBps:h.cF.default(0)}))(),rt=(()=>et.extend({metadata:S.N.default(""),uri:P.z.string(),royaltyBps:h.b9,mintStartTime:h.b9,mintEndTime:h.b9}))(),at=(()=>et.extend({metadata:S.N.default(""),quantity:h.ba}))(),st=(()=>at.extend({tokenId:h.ba}))(),it=(()=>rt.extend({tokenId:h.b9,quantity:h.b9}))(),nt=(()=>et.extend({metadata:S.N.default(""),quantity:h.b9.default(1)}))(),ot=(()=>rt.extend({quantity:h.b9.default(1)}))(),ct=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ht=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},73806:(t,e,r)=>{"use strict";r.r(e),r.d(e,{TokenDrop:()=>d});var a=r(9279),s=r(7860),i=r(19578),n=r(89536),o=r(68828),c=r(52153),l=r(5995),p=r(74935),h=r(82714),u=r(62245),m=r(78012);r(13550),r(77191),r(54146),r(64063);class d extends m.S{static contractRoles=s.dG;constructor(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4?arguments[4]:void 0,m=arguments.length>5?arguments[5]:void 0;super(arguments.length>6&&void 0!==arguments[6]?arguments[6]:new s.cu(t,e,i,a,r),r,m),this.abi=s.bn.parse(i||[]),this.metadata=new n.C(this.contractWrapper,s.dH,this.storage),this.app=new n.b(this.contractWrapper,this.metadata,this.storage),this.roles=new p.C(this.contractWrapper,d.contractRoles),this.encoder=new o.C(this.contractWrapper),this.estimator=new n.G(this.contractWrapper),this.events=new n.a(this.contractWrapper),this.sales=new h.C(this.contractWrapper),this.platformFees=new l.C(this.contractWrapper),this.interceptor=new c.C(this.contractWrapper),this.claimConditions=new u.D(this.contractWrapper,this.metadata,this.storage)}async getVoteBalance(){return await this.getVoteBalanceOf(await this.contractWrapper.getSignerAddress())}async getVoteBalanceOf(t){return await this.erc20.getValue(await this.contractWrapper.read("getVotes",[await(0,s.aP)(t)]))}async getDelegation(){return await this.getDelegationOf(await this.contractWrapper.getSignerAddress())}async getDelegationOf(t){return await this.contractWrapper.read("delegates",[await(0,s.aP)(t)])}async isTransferRestricted(){return!await this.contractWrapper.read("hasRole",[(0,s.H)("transfer"),a.d])}claim=(0,i.c)((()=>{var t=this;return async function(e){let r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return t.claimTo.prepare(await t.contractWrapper.getSignerAddress(),e,r)}})());claimTo=(0,i.c)((()=>{var t=this;return async function(e,r){let a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return t.erc20.claimTo.prepare(e,r,{checkERC20Allowance:a})}})());delegateTo=(0,i.c)((async t=>i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"delegate",args:[await(0,s.aP)(t)]})));burnTokens=(0,i.c)((async t=>this.erc20.burn.prepare(t)));burnFrom=(0,i.c)((async(t,e)=>this.erc20.burnFrom.prepare(t,e)));async prepare(t,e,r){return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}}},56351:(t,e,r)=>{var a=r(48764).Buffer;t.exports=function(t){for(var e=new a(t.length),r=0,s=t.length-1;r<=s;++r,--s)e[r]=t[s],e[s]=t[r];return e}},99269:function(t){t.exports=function(){function t(t,e){var r=e?"":"";return r+=t?" ":""}function e(t,e){var r=[];for(var a in t)t.hasOwnProperty(a)&&(e&&"function"==typeof t[a]||r.push(a));return r}function r(a,s,i,n,o,c,l){var p,h,u="",m=0,d=n.slice(0);if(d.push([s,i])&&n.length>0&&(n.forEach((function(t,e){e>0&&(u+=(t[1]?" ":"")+"  "),h||t[0]!==s||(h=!0)})),u+=t(a,i)+a,o&&("object"!=typeof s||s instanceof Date)&&(u+=": "+s),h&&(u+=" (circular ref.)"),l(u)),!h&&"object"==typeof s){var f=e(s,c);f.forEach((function(t){p=++m===f.length,r(t,s[t],p,d,o,c,l)}))}}var a={asLines:function(t,e,a,s){r(".",t,!1,[],e,"function"!=typeof a&&a,s||a)},asTree:function(t,e,a){var s="";return r(".",t,!1,[],e,a,(function(t){s+=t+"\n"})),s}};return a}()}}]);
//# sourceMappingURL=3806.js.map