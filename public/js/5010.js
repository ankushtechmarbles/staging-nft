(self.webpackChunk=self.webpackChunk||[]).push([[5010],{89050:(t,e,r)=>{"use strict";r.d(e,{D:()=>y,F:()=>p,I:()=>c,a:()=>l,b:()=>d,c:()=>u,f:()=>h,g:()=>f,u:()=>m});var a=r(41518),n=r(16441),i=r(2593),s=r(64146),o=r(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),l=(()=>n.arrayify("0xd9b67a26"))(),p={name:"Failed to load NFT metadata"};async function h(t,e,r){if(e.startsWith("data:application/json;base64")&&void 0!==o){const r=e.split(",")[1],n=JSON.parse(o.from(r,"base64").toString("utf-8"));return a.C.parse({...n,id:i.O$.from(t).toString(),uri:e})}const s=e.replace("{id}",n.hexZeroPad(i.O$.from(t).toHexString(),32).slice(2));let c;try{c=await r.downloadJSON(s)}catch(a){const n=e.replace("{id}",i.O$.from(t).toString());try{c=await r.downloadJSON(n)}catch(r){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),c=p}}return a.C.parse({...c,id:i.O$.from(t).toString(),uri:e})}async function u(t,e,n,o){let u;const d=(await r.e(5025).then(r.t.bind(r,25025,19))).default,m=new s.CH(t,d,e),[f,y]=await Promise.all([m.supportsInterface(c),m.supportsInterface(l)]);if(f){const a=(await Promise.resolve().then(r.t.bind(r,34161,19))).default,i=new s.CH(t,a,e);u=await i.tokenURI(n)}else{if(!y)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(r.t.bind(r,50266,19))).default,i=new s.CH(t,a,e);u=await i.uri(n)}}return u?h(n,u,o):a.C.parse({...p,id:i.O$.from(n).toString(),uri:""})}async function d(t,e){return"string"==typeof t?t:await e.upload(a.a.parse(t))}async function m(t,e,r,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await e.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:r||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function f(t){const e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){const a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}const y=100},89208:(t,e,r)=>{"use strict";r.d(e,{E:()=>c,R:()=>s,S:()=>o,a:()=>l});var a=r(2593),n=r(1604),i=r(7860);const s=(()=>n.z.union([n.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),n.z.number().transform((t=>a.O$.from(t)))]))(),o=(()=>s.default(new Date(0)))(),c=(()=>s.default(new Date(Date.now()+31536e7)))();function l(t,e){if(!t)throw new i.x(e);return t}},89536:(t,e,r)=>{"use strict";r.d(e,{C:()=>l,G:()=>h,a:()=>p,b:()=>u,d:()=>o,h:()=>c});var a=r(7860),n=r(19578),i=r(61744),s=r(40721);function o(t,e){return(0,a.am)(a.bn.parse(t.abi),e)}function c(t,e){return t in e.readContract.functions}class l{featureName=a.d1.name;constructor(t,e,r){this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const e=await this.contractWrapper.read("contractURI",[]);e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let e,r,n;try{c("name",this.contractWrapper)&&(e=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(r=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:e||n?.name,symbol:r,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class p{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},n=t=>{const r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const e={address:this.contractWrapper.address},r=e=>{try{const r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(t){console.error("Could not parse event:",e,t)}};return this.contractWrapper.getProvider().on(e,r),()=>{this.contractWrapper.getProvider().off(e,r)}}removeEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber));return this.parseEvents(e)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=this.contractWrapper.readContract.interface.getEvent(t),a=e.filters?r.inputs.map((t=>e.filters[t.name])):[],n=this.contractWrapper.readContract.filters[r.name](...a),i=(await this.contractWrapper.readContract.queryFilter(n,e.fromBlock,e.toBlock)).sort(((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber));return this.parseEvents(i)}parseEvents(t){return t.map((t=>{const e=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const r=Object.entries(t.args),a=r.slice(r.length/2,r.length),n={};for(const[t,e]of a)n[t]=e;return{eventName:t.event||"",data:n,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}}))}toContractEvent(t,e,r){const a=Object.fromEntries(Object.entries(r).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,r)=>{if(Array.isArray(e[r])){const a=t.components;if(a){const i=e[r];if("tuple[]"===t.type){const e=[];for(let t=0;t<i.length;t++){const r=i[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=r[t]}e.push(n)}n[t.name]=e}else{const e={};for(let t=0;t<a.length;t++){e[a[t].name]=i[t]}n[t.name]=e}}}else n[t.name]=e[r]})),{eventName:t.name,data:n,transaction:a}}}class h{constructor(t){this.contractWrapper=t}async gasCostOf(t,e){const[r,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,e)]);return i.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return i.formatUnits(t,"gwei")}}class u{featureName=a.d2.name;constructor(t,e,r){this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,s.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>o(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,e,r)=>{"use strict";r.d(e,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},83833:(t,e,r)=>{"use strict";r.d(e,{C:()=>g,D:()=>w,a:()=>W,c:()=>b});var a=r(89536),n=r(19578),i=r(7860),s=r(68828),o=r(29251),c=r(31886),l=r(84243),p=r(16441),h=r(2593),u=r(64146),d=r(41518),m=r(89050),f=r(58179),y=r(19824);class g{featureName=i.d4.name;constructor(t,e){this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){const[t,e]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return i.bH.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){const[e,r]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return i.bH.parseAsync({fee_recipient:e,seller_fee_basis_points:r})}setDefaultRoyaltyInfo=(0,n.c)((async t=>{const e=await this.metadata.get(),r=await this.metadata.parseInputMetadata({...e,...t}),i=await this.metadata._parseAndUploadMetadata(r);if((0,a.h)("setContractURI",this.contractWrapper)){const t=new s.C(this.contractWrapper),e=[t.encode("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),t.encode("setContractURI",[i])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.c)((async(t,e)=>{const r=i.bH.parse(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class w{constructor(t,e,r,a){this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}createDelayedRevealBatch=(0,n.c)((async(t,e,r,a)=>{if(!r)throw new Error("Password is required");const i=await this.storage.uploadBatch([d.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),s=(0,m.g)(i),p=await this.nextTokenIdToMintFn(),h=await this.storage.uploadBatch(e.map((t=>d.a.parse(t))),{onProgress:a?.onProgress,rewriteFileNames:{fileStartNumber:p.toNumber()}}),u=(0,m.g)(h),f=await this.contractWrapper.read("getBaseURICount",[]),y=await this.hashDelayRevealPassword(f,r),g=await this.contractWrapper.read("encryptDecrypt",[o.Y0(u),y]);let w;if(await this.isLegacyContract())w=g;else{const t=await this.contractWrapper.getChainID(),e=c.keccak256(["bytes","bytes","uint256"],[o.Y0(u),y,t]);w=l.$.encode(["bytes","bytes32"],[g,e])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[h.length,s.endsWith("/")?s:`${s}/`,w],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t});return n}})}));reveal=(0,n.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.hashDelayRevealPassword(t,e);try{const e=await this.contractWrapper.callStatic().reveal(t,r);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map((t=>{if((0,a.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,a.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=r.slice(0,r.length-1),i=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),s=await this.isLegacyContract(),o=(await Promise.all(Array.from([...r]).map((t=>s?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(p.hexDataLength(t)>0){if(s)return t;return l.$.decode(["bytes","bytes32"],t)[0]}return t}));return i.map(((t,e)=>({batchId:h.O$.from(e),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,e)=>p.hexDataLength(o[e])>0))}async hashDelayRevealPassword(t,e){const r=await this.contractWrapper.getChainID(),a=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return(0,m.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,a.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const e=(await r.e(8839).then(r.t.bind(r,98839,19))).default,a=new u.CH(this.contractWrapper.address,e,this.contractWrapper.getProvider()),n=await a.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function b(t,e,r,a,n){let s={};const o=a||i.aZ,c=(await(0,y.n)(t.getProvider(),e,o)).mul(r);return c.gt(0)&&(o===i.aZ?s={value:c}:o!==i.aZ&&n&&await(0,f.a)(t,o,c,r,0)),s}class W{featureName=i.d5.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.c)((async t=>{const e=await(0,i.aP)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})}))}},5995:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),n=r(7860);class i{featureName=n.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,e]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:e})}set=(0,a.c)((async t=>{const e=await n.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[e.platform_fee_recipient,e.platform_fee_basis_points]})}))}},74935:(t,e,r)=>{"use strict";r.d(e,{C:()=>c});var a=r(38776),n=r(7860),i=r(89536),s=r(19578),o=r(68828);class c{featureName=n.d3.name;constructor(t,e){this.contractWrapper=t,this.roles=e}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},e=Object.entries(this.roles);return(await Promise.all(e.map((t=>{let[,e]=t;return this.get(e)})))).forEach(((r,a)=>t[e[a][1]]=r)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=this.contractWrapper;if((0,i.h)("getRoleMemberCount",e)&&(0,i.h)("getRoleMember",e)){const r=(0,n.H)(t),a=(await e.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>e.read("getRoleMember",[r,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,s.c)((async t=>{const e=new o.C(this.contractWrapper),r=Object.keys(t);(0,a.Z)(r.length,"you must provide at least one role to set"),(0,a.Z)(r.every((t=>this.roles.includes(t))),"this contract does not support the given role");const i=await this.getAll(),c=[],l=r.sort((t=>"admin"===t?1:-1));for(let r=0;r<l.length;r++){const a=l[r],[s,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(i[a]?.map((t=>(0,n.aP)(t)))||[])]),p=s.filter((t=>!o.includes(t))),h=o.filter((t=>!s.includes(t)));if(p.length&&p.forEach((t=>{c.push(e.encode("grantRole",[(0,n.H)(a),t]))})),h.length){(await Promise.all(h.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,r)=>c.push(e.encode(t,[(0,n.H)(a),h[r]]))))}}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,e){await Promise.all(t.map((async t=>{const[r,a]=await Promise.all([this.get(t),(0,n.aP)(e)]);if(!r.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,s.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),r]})}));revoke=(0,s.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e),i=await this.getRevokeRoleFunctionName(r);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:i,args:[(0,n.H)(t),r]})}));async getRevokeRoleFunctionName(t){const[e,r]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}},82714:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),n=r(7860);class i{featureName=n.d6.name;constructor(t){this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.read("primarySaleRecipient",[])}setRecipient=(0,a.c)((async t=>a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPrimarySaleRecipient",args:[t]})))}},35010:(t,e,r)=>{"use strict";r.r(e),r.d(e,{Edition:()=>f});var a=r(9279),n=r(7860),i=r(19578),s=r(89536),o=r(68828),c=r(52153),l=r(83833),p=r(5995),h=r(74935),u=r(82714),d=r(40795),m=r(71358);r(13550),r(77191),r(54146),r(64063);class f extends m.S{static contractRoles=n.dz;constructor(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4?arguments[4]:void 0,m=arguments.length>5?arguments[5]:void 0;super(arguments.length>6&&void 0!==arguments[6]?arguments[6]:new n.cu(t,e,i,a,r),r,m),this.abi=n.bn.parse(i||[]),this.metadata=new s.C(this.contractWrapper,n.cl,this.storage),this.app=new s.b(this.contractWrapper,this.metadata,this.storage),this.roles=new h.C(this.contractWrapper,f.contractRoles),this.royalties=new l.C(this.contractWrapper,this.metadata),this.sales=new u.C(this.contractWrapper),this.encoder=new o.C(this.contractWrapper),this.estimator=new s.G(this.contractWrapper),this.events=new s.a(this.contractWrapper),this.platformFees=new p.C(this.contractWrapper),this.interceptor=new c.C(this.contractWrapper),this.signature=new d.f(this.contractWrapper,this.storage,this.roles),this.owner=new l.a(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async getAll(t){return this.erc1155.getAll(t)}async getOwned(t,e){return this.erc1155.getOwned(t,e)}async getTotalCount(){return this.erc1155.totalCount()}async isTransferRestricted(){return!await this.contractWrapper.read("hasRole",[(0,n.H)("transfer"),a.d])}mint=(0,i.c)((async t=>this.erc1155.mint.prepare(t)));mintTo=(0,i.c)((async(t,e)=>this.erc1155.mintTo.prepare(t,e)));async getMintTransaction(t,e){return this.erc1155.getMintTransaction(t,e)}mintAdditionalSupply=(0,i.c)((async(t,e)=>this.erc1155.mintAdditionalSupply.prepare(t,e)));mintAdditionalSupplyTo=(0,i.c)((async(t,e,r)=>this.erc1155.mintAdditionalSupplyTo.prepare(t,e,r)));mintBatch=(0,i.c)((async t=>this.erc1155.mintBatch.prepare(t)));mintBatchTo=(0,i.c)((async(t,e)=>this.erc1155.mintBatchTo.prepare(t,e)));burn=(0,i.c)((async(t,e)=>this.erc1155.burn.prepare(t,e)));async prepare(t,e,r){return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}}},40795:(t,e,r)=>{"use strict";r.d(e,{D:()=>v,e:()=>N,f:()=>M});var a=r(2593),n=r(16441),i=r(21046),s=r(9279),o=r(29251),c=r(7860),l=r(89208),p=r(89536),h=r(89050),u=r(19578),d=r(1604),m=r(83833),f=r(64063),y=r.n(f),g=r(58179),w=r(68828),b=r(38776),W=r(19824),C=r(41518);class v{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t,e){const r=await this.get(t),a=await this.metadata.get();return await(0,g.v)(r,0,this.contractWrapper.getProvider(),a.merkle,this.storage,e?.withAllowList||!1)}async get(t,e){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,g.w)(e)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,g.w)(a)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,g.x)(e)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,g.x)(a)}throw new Error("Contract does not support claim conditions")}async getAll(t,e){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]),a=r.currentStartId.toNumber(),n=r.count.toNumber(),i=[];for(let e=a;e<a+n;e++)i.push(await this.get(t,e));const s=await this.metadata.get();return Promise.all(i.map((t=>(0,g.v)(t,0,this.contractWrapper.getProvider(),s.merkle,this.storage,e?.withAllowList||!1))))}return[await this.getActive(t,e)]}async canClaim(t,e,r){return r&&(r=await(0,c.aP)(r)),0===(await this.getClaimIneligibilityReasons(t,e,r)).length}async getClaimIneligibilityReasons(t,e,s){const o=[];let l,p;if(void 0===s)try{s=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!s)return[g.C.NoWallet];const h=await(0,c.aP)(s);try{p=await this.getActive(t)}catch(t){return(0,c.B)(t,"!CONDITION")||(0,c.B)(t,"no active mint condition")?(o.push(g.C.NoClaimConditionSet),o):(o.push(g.C.Unknown),o)}if("unlimited"!==p.availableSupply&&a.O$.from(p.availableSupply).lt(e))return o.push(g.C.NotEnoughSupply),o;const u=n.stripZeros(p.merkleRootHash).length>0;let d=null;if(u){if(d=await this.getClaimerProofs(t,h),!d&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(g.C.AddressNotAllowed),o;if(d)try{const r=await this.prepareClaim(t,e,!1,h);let a;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[a]=await this.contractWrapper.read("verifyClaimMerkleProof",[l,h,t,e,r.proofs,r.maxClaimable]),!a)return o.push(g.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([a]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,h,e,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable}]),!a)return o.push(g.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,h,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[l,h,t,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(g.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(g.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(g.C.NotEnoughSupply);break;case"cant claim yet":o.push(g.C.ClaimPhaseNotStarted);break;default:o.push(g.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let r=a.O$.from(0),n=(0,g.y)(p.maxClaimablePerWallet,0);try{r=await this.getSupplyClaimedByWallet(t,h)}catch(t){}if(d&&(n=(0,g.y)(d.maxClaimable,0)),n.gt(0)&&n.lt(r.add(e)))return o.push(g.C.OverMaxClaimablePerWallet),o;if((!u||u&&!d)&&(n.lte(r)||n.eq(0)))return o.push(g.C.AddressNotAllowed),o}let[m,f]=[a.O$.from(0),a.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[m,f]=await this.contractWrapper.read("getClaimTimestamp",[t,l,h])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([m,f]=await this.contractWrapper.read("getClaimTimestamp",[t,h]));const y=a.O$.from(Date.now()).div(1e3);if(m.gt(0)&&y.lt(f))return f.eq(i.Bz)?o.push(g.C.AlreadyClaimed):o.push(g.C.WaitBeforeNextClaimTransaction),o;if(p.price.gt(0)&&(0,c.d7)()){const t=p.price.mul(e),a=this.contractWrapper.getProvider();if((0,w.i)(p.currencyAddress)){(await a.getBalance(h)).lt(t)&&o.push(g.C.NotEnoughTokens)}else{const e=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new c.cu(a,p.currencyAddress,e,{},this.storage);(await n.read("balanceOf",[h])).lt(t)&&o.push(g.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e,r){const a=(await this.get(t,r)).merkleRoot;if(n.stripZeros(a).length>0){const t=await this.metadata.get(),r=await(0,c.aP)(e);return await(0,g.f)(r,a.toString(),t.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t,e){const r=await(0,c.aP)(e);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,u.c)((()=>{var t=this;return async function(e,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t.setBatch.prepare([{tokenId:e,claimConditions:r}],a)}})());setBatch=(0,u.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a={},i=await Promise.all(e.map((async e=>{let{tokenId:i,claimConditions:o}=e,c=o;if(t.isLegacySinglePhaseDrop(t.contractWrapper))if(r=!0,0===o.length)c=[{startTime:new Date(0),currencyAddress:s.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(o.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&c.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:l,sortedConditions:p}=await(0,g.D)(c,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return l.forEach((t=>{a[t.merkleRoot]=t.snapshotUri})),{tokenId:i,sortedConditions:p}}))),o=await t.metadata.get(),c=[];for(const t of Object.keys(o.merkle||{}))a[t]=o.merkle[t];if(!y()(o.merkle,a)){const e=await t.metadata.parseInputMetadata({...o,merkle:a}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,p.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new w.C(t.contractWrapper);c.push(e.encode("setContractURI",[r]))}}if(i.forEach((e=>{let{tokenId:a,sortedConditions:n}=e;const i=new w.C(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const e=new w.C(t.contractWrapper);c.push(e.encode("setClaimConditions",[a,(0,g.E)(n[0]),r]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(i.encode("setClaimConditions",[a,n.map(g.E),r]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(i.encode("setClaimConditions",[a,(0,g.F)(n[0]),r]));else{if(!t.isNewMultiphaseDrop(t.contractWrapper))throw new Error("Contract does not support claim conditions");c.push(i.encode("setClaimConditions",[a,n.map(g.F),r]))}})),(0,p.h)("multicall",t.contractWrapper))return u.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})());update=(0,u.c)((async(t,e,r)=>{const a=await this.getAll(t),n=await(0,g.H)(e,r,a);return await this.set.prepare(t,n)}));async prepareClaim(t,e,r,a){const n=await(0,c.aP)(a||await this.contractWrapper.getSignerAddress());return(0,g.z)(n,e,await this.getActive(t),(async()=>(await this.metadata.get()).merkle),0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r,a){const n=await(0,c.aP)(e);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},o.Y0("")]:[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},o.Y0("")]}async getClaimTransaction(t,e,r,a){if(a?.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const n=await this.prepareClaim(e,r,a?.checkERC20Allowance||!0);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(e,t,r,n),overrides:n.overrides})}isNewSinglePhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,p.d)(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?g.A.V1:g.A.V2}}class P{featureName=c.d8.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r}to=(0,u.c)((async(t,e)=>{const r=e.map((t=>t.metadata)),a=e.map((t=>t.supply)),n=await(0,h.u)(r,this.storage),s=await(0,c.aP)(t),o=new w.C(this.contractWrapper),l=await Promise.all(n.map((async(t,e)=>o.encode("mintTo",[s,i.Bz,t,a[e]]))));return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[l],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===e.length||e.length<r.length)throw new Error("TokenMinted event not found, minting failed");return e.map((e=>{const r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}))}})}))}class T{featureName=c.d9.name;constructor(t){this.contractWrapper=t}tokens=(0,u.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,e)}));from=(0,u.c)((async(t,e,r)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await(0,c.aP)(t),e,r]})));batch=(0,u.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,e)}));batchFrom=(0,u.c)((async(t,e,r)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await(0,c.aP)(t),e,r]})))}class S{featureName=c.da.name;constructor(t,e){this.erc1155=t,this.contractWrapper=e}async all(t){const e=a.O$.from(t?.start||0).toNumber(),r=a.O$.from(t?.count||h.D).toNumber(),n=Math.min((await this.totalCount()).toNumber(),e+r);return await Promise.all([...Array(n-e).keys()].map((t=>this.erc1155.get((e+t).toString()))))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,e){const[r,a]=await Promise.all([(0,c.aP)(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let n=(await this.contractWrapper.read("balanceOfBatch",[Array(a.toNumber()).fill(r),Array.from(Array(a.toNumber()).keys())])).map(((t,e)=>({tokenId:e,balance:t}))).filter((t=>t.balance.gt(0)));if(e){const t=e?.start||0,r=e?.count||h.D;n=n.slice(t,t+r)}return(await Promise.all(n.map((t=>this.erc1155.get(t.tokenId.toString()))))).map(((t,e)=>({...t,owner:r,quantityOwned:n[e].balance.toString()})))}}class k{featureName=c.db.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc1155Revealable()}lazyMint=(0,u.c)((async(t,e)=>{const r=await this.erc1155.nextTokenIdToMint(),a=await(0,h.u)(t,this.storage,r.toNumber(),e),n=a[0].substring(0,a[0].lastIndexOf("/"));for(let t=0;t<a.length;t++){const e=a[t].substring(0,a[t].lastIndexOf("/"));if(n!==e)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${e}'`)}const i=t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc1155.getTokenMetadata(e)});return n},s=await(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,s)?u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`],parse:i}):u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`,o.Y0("")],parse:i})}));detectErc1155Revealable(){if((0,p.d)(this.contractWrapper,"ERC1155Revealable"))return new m.D(this.contractWrapper,this.storage,c.dc.name,(()=>this.erc1155.nextTokenIdToMint()))}isLegacyEditionDropContract(t,e){return e&&"DropERC1155"===e.type&&e.version<3||!1}}class A{featureName=c.de.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc1155BatchMintable()}to=(0,u.c)((async(t,e)=>{const r=await this.getMintTransaction(t,e);return r.setParse((t=>{const e=this.contractWrapper.parseLogs("TransferSingle",t?.logs);if(0===e.length)throw new Error("TransferSingleEvent event not found");const r=e[0].args.id;return{id:r,receipt:t,data:()=>this.erc1155.get(r.toString())}})),r}));async getMintTransaction(t,e){const r=await(0,h.b)(e.metadata,this.storage);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),i.Bz,r,e.supply]})}additionalSupplyTo=(0,u.c)((async(t,e,r)=>{const n=await this.erc1155.getTokenMetadata(e);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),e,n.uri,r],parse:t=>({id:a.O$.from(e),receipt:t,data:()=>this.erc1155.get(e)})})}));detectErc1155BatchMintable(){if((0,p.d)(this.contractWrapper,"ERC1155BatchMintable"))return new P(this.erc1155,this.contractWrapper,this.storage)}}const x=(()=>d.z.object({address:c.bd,quantity:c.cz.default(1)}))(),I=(()=>d.z.union([d.z.array(d.z.string()).transform((async t=>await Promise.all(t.map((t=>x.parseAsync({address:t})))))),d.z.array(x)]))();class E{featureName=c.df.name;constructor(t){this.contractWrapper=t}async getClaimTransaction(t,e,r,a){let n={};return a&&a.pricePerToken&&(n=await(0,m.c)(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await(0,c.aP)(t),e,r],overrides:n})}to=(0,u.c)((async(t,e,r,a)=>await this.getClaimTransaction(t,e,r,a)))}class B{featureName=c.dg.name;constructor(t,e){this.contractWrapper=t,this.storage=e;const r=new p.C(this.contractWrapper,c.bk,this.storage);this.conditions=new v(t,r,this.storage)}to=(0,u.c)((async(t,e,r,a)=>await this.conditions.getClaimTransaction(t,e,r,a)))}class M{featureName=c.dh.name;constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.roles=r}mint=(0,u.c)((async t=>{const e=t.payload,r=t.signature,[a,n]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,C.s)(this.contractWrapper,a.pricePerToken.mul(a.quantity),e.currencyAddress,n),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,r],overrides:n,parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return{id:e[0].args.tokenIdMinted,receipt:t}}})}));mintBatch=(0,u.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const n=e[r],i=t.signature,s=t.payload.price;if(a.O$.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:i}})),n=new w.C(this.contractWrapper),i=r.map((t=>n.encode("mintWithSignature",[t.message,t.signature])));if((0,p.h)("multicall",this.contractWrapper))return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return e.map((e=>({id:e.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not supported on this contract!")}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){const e={...t,tokenId:i.Bz};return this.generateFromTokenId(e)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const e=t.map((t=>({...t,tokenId:i.Bz})));return this.generateBatchFromTokenIds(e)}async generateBatchFromTokenIds(t){const e=this.contractWrapper.getSigner();(0,b.Z)(e,"No signer available"),await(this.roles?.verify(["minter"],await e.getAddress()));const r=await Promise.all(t.map((t=>g.o.parseAsync(t)))),a=r.map((t=>t.metadata)),[n,i,s]=await Promise.all([(0,h.u)(a,this.storage),this.contractWrapper.getChainID(),(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider())]),o=await Promise.all(r.map(((t,e)=>g.p.parseAsync({...t,uri:n[e]})))),l=await Promise.all(o.map((t=>this.mapPayloadToContractStruct(t)))),p="TokenERC1155"===s?.type;return(await Promise.all(l.map((t=>this.contractWrapper.signTypedData(e,{name:p?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.address},{MintRequest:g.t},t))))).map(((t,e)=>({payload:o[e],signature:t.toString()})))}async mapPayloadToContractStruct(t){const e=await(0,W.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class N{featureName=c.di.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,r]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch((()=>a.O$.from(0))),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...h.F})))]);return{owner:s.d,metadata:r,type:"ERC1155",supply:e.toString()}}async totalSupply(t){if((0,p.d)(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new c.x(c.dj)}async balanceOf(t,e){return await this.contractWrapper.read("balanceOf",[await(0,c.aP)(t),e])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,e){return await this.contractWrapper.read("isApprovedForAll",[await(0,c.aP)(t),await(0,c.aP)(e)])}transfer=(0,u.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const i=await t.contractWrapper.getSignerAddress();return u.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[i,await(0,c.aP)(e),r,a,n]})}})());transferFrom=(0,u.c)((()=>{var t=this;return async function(e,r,a,n){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[0];return u.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await(0,c.aP)(e),await(0,c.aP)(r),a,n,i]})}})());setApprovalForAll=(0,u.c)((async(t,e)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,e]})));airdrop=(0,u.c)((()=>{var t=this;return async function(e,r,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const s=n?await(0,c.aP)(n):await t.contractWrapper.getSignerAddress(),o=await t.balanceOf(s,e),l=await I.parseAsync(r),p=l.reduce(((t,e)=>a.O$.from(t).add(a.O$.from(e?.quantity||1))),a.O$.from(0));if(o.lt(a.O$.from(p)))throw new Error(`The caller owns ${o.toString()} NFTs, but wants to airdrop ${p.toString()} NFTs.`);const h=new w.C(t.contractWrapper),d=l.map((t=>{let{address:r,quantity:a}=t;return h.encode("safeTransferFrom",[s,r,e,a,i])}));return u.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[d]})}})());async nextTokenIdToMint(){if((0,p.h)("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return(0,l.a)(this.query,c.da).all(t)}async totalCount(){return(0,l.a)(this.query,c.da).totalCount()}async totalCirculatingSupply(t){return(0,l.a)(this.query,c.da).totalCirculatingSupply(t)}async getOwned(t,e){return t&&(t=await(0,c.aP)(t)),(0,l.a)(this.query,c.da).owned(t,e)}mint=(0,u.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,u.c)((async(t,e)=>(0,l.a)(this.mintable,c.de).to.prepare(t,e)));async getMintTransaction(t,e){return(0,l.a)(this.mintable,c.de).getMintTransaction(t,e)}mintAdditionalSupply=(0,u.c)((async(t,e)=>(0,l.a)(this.mintable,c.de).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));mintAdditionalSupplyTo=(0,u.c)((async(t,e,r)=>(0,l.a)(this.mintable,c.de).additionalSupplyTo.prepare(t,e,r)));mintBatch=(0,u.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=(0,u.c)((async(t,e)=>(0,l.a)(this.mintable?.batch,c.d8).to.prepare(t,e)));burn=(0,u.c)((async(t,e)=>(0,l.a)(this.burnable,c.d9).tokens.prepare(t,e)));burnFrom=(0,u.c)((async(t,e,r)=>(0,l.a)(this.burnable,c.d9).from.prepare(t,e,r)));burnBatch=(0,u.c)((async(t,e)=>(0,l.a)(this.burnable,c.d9).batch.prepare(t,e)));burnBatchFrom=(0,u.c)((async(t,e,r)=>(0,l.a)(this.burnable,c.d9).batchFrom.prepare(t,e,r)));lazyMint=(0,u.c)((async(t,e)=>(0,l.a)(this.lazyMintable,c.db).lazyMint.prepare(t,e)));async getClaimTransaction(t,e,r,a){const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,e,r,a);if(i)return i.getClaimTransaction(t,e,r,a);throw new c.x(c.df)}claim=(0,u.c)((async(t,e,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e,r)));claimTo=(0,u.c)((async(t,e,r,a)=>{const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.to.prepare(t,e,r,a);if(i)return i.to.prepare(t,e,r,a);throw new c.x(c.df)}));get claimConditions(){return(0,l.a)(this.claimWithConditions,c.dg).conditions}get signature(){return(0,l.a)(this.signatureMintable,c.dh)}get revealer(){return(0,l.a)(this.lazyMintable?.revealer,c.dc)}async getTokenMetadata(t){const e=await this.contractWrapper.read("uri",[t]);if(!e)throw new c.n;return(0,h.f)(t,e,this.storage)}detectErc1155Enumerable(){if((0,p.d)(this.contractWrapper,"ERC1155Enumerable"))return new S(this,this.contractWrapper)}detectErc1155Mintable(){if((0,p.d)(this.contractWrapper,"ERC1155Mintable"))return new A(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if((0,p.d)(this.contractWrapper,"ERC1155Burnable"))return new T(this.contractWrapper)}detectErc1155LazyMintable(){if((0,p.d)(this.contractWrapper,"ERC1155LazyMintableV1")||(0,p.d)(this.contractWrapper,"ERC1155LazyMintableV2"))return new k(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if((0,p.d)(this.contractWrapper,"ERC1155SignatureMintable"))return new M(this.contractWrapper,this.storage)}detectErc1155Claimable(){if((0,p.d)(this.contractWrapper,"ERC1155ClaimCustom"))return new E(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if((0,p.d)(this.contractWrapper,"ERC1155ClaimConditionsV1")||(0,p.d)(this.contractWrapper,"ERC1155ClaimConditionsV2")||(0,p.d)(this.contractWrapper,"ERC1155ClaimPhasesV1")||(0,p.d)(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new B(this.contractWrapper,this.storage)}}},71358:(t,e,r)=>{"use strict";r.d(e,{S:()=>i});var a=r(19578),n=r(40795);class i{get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.erc1155=new n.e(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){return this.erc1155.get(t)}async totalSupply(t){return this.erc1155.totalSupply(t)}async balanceOf(t,e){return this.erc1155.balanceOf(t,e)}async balance(t){return this.erc1155.balance(t)}async isApproved(t,e){return this.erc1155.isApproved(t,e)}transfer=(0,a.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];return t.erc1155.transfer.prepare(e,r,a,n)}})());setApprovalForAll=(0,a.c)((async(t,e)=>this.erc1155.setApprovalForAll.prepare(t,e)));airdrop=(0,a.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];return t.erc1155.airdrop.prepare(e,r,a,n)}})())}},41518:(t,e,r)=>{"use strict";r.d(e,{B:()=>c,C:()=>h,N:()=>p,a:()=>l,s:()=>u});var a=r(7860),n=r(1604),i=r(68828);const s=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(s),s]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),l=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cA,n.z.unknown()])))(),p=(()=>n.z.union([l,n.z.string()]))(),h=(()=>l.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function u(t,e,n,s){if(!(0,i.i)(n)){const i=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=t.getSigner(),c=t.getProvider(),l=new a.cu(o||c,n,i,t.options,t.storage),p=await t.getSignerAddress(),h=t.address;return(await l.read("allowance",[p,h])).lt(e)&&await l.sendTransaction("approve",[h,e]),s}s.value=e}},58179:(t,e,r)=>{"use strict";r.d(e,{A:()=>B,B:()=>K,C:()=>Y,D:()=>j,E:()=>A,F:()=>x,H:()=>G,I:()=>Q,M:()=>ct,S:()=>X,a:()=>L,f:()=>N,k:()=>tt,o:()=>nt,p:()=>it,q:()=>st,r:()=>ot,s:()=>lt,t:()=>pt,u:()=>ht,v:()=>J,w:()=>R,x:()=>O,y:()=>I,z:()=>D});var a=r(21046),n=r(61744),i=r(31886),s=r(9279),o=r(38197),c=r(2593),l=r(16441),p=r(29251),h=r(7860),u=r(68828),d=r(19824),m=r(48764),f=r(56351),y=r.n(f),g=r(99269);class w{print(){w.print(this)}bufferIndexOf(t,e){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(t,e,m.Buffer.compare);return this.linearSearch(t,e,((t,e)=>t.equals(e)))}static binarySearch(t,e,r){let a=0,n=t.length-1;for(;a<=n;){const i=Math.floor((a+n)/2),s=r(t[i],e);if(0===s){for(let a=i-1;a>=0;a--)if(0!==r(t[a],e))return a+1;return 0}s<0?a=i+1:n=i-1}return-1}binarySearch(t,e,r){return w.binarySearch(t,e,r)}static linearSearch(t,e,r){for(let a=0;a<t.length;a++)if(r(t[a],e))return a;return-1}linearSearch(t,e,r){return w.linearSearch(t,e,r)}static bufferify(t){if(!m.Buffer.isBuffer(t)){if("object"==typeof t&&t.words)return m.Buffer.from(t.toString(W),"hex");if(w.isHexString(t))return m.Buffer.from(t.replace(/^0x/,""),"hex");if("string"==typeof t)return m.Buffer.from(t);if("bigint"==typeof t)return m.Buffer.from(t.toString(16),"hex");if(t instanceof Uint8Array)return m.Buffer.from(t.buffer);if("number"==typeof t){let e=t.toString();return e.length%2&&(e=`0${e}`),m.Buffer.from(e,"hex")}if(ArrayBuffer.isView(t))return m.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}return t}bigNumberify(t){return w.bigNumberify(t)}static bigNumberify(t){if("bigint"==typeof t)return t;if("string"==typeof t)return t.startsWith("0x")&&w.isHexString(t)?BigInt("0x"+t.replace("0x","").toString()):BigInt(t);if(m.Buffer.isBuffer(t))return BigInt("0x"+t.toString("hex"));if(t instanceof Uint8Array)return function(t){const e=Array.from(t).map((t=>t.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${e}`)}(t);if("number"==typeof t)return BigInt(t);throw new Error("cannot bigNumberify")}static isHexString(t){return"string"==typeof t&&/^(0x)?[0-9A-Fa-f]*$/.test(t)}static print(t){console.log(t.toString())}bufferToHex(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(t,e)}static bufferToHex(t){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(t||m.Buffer.alloc(0)).toString("hex")}`}bufferify(t){return w.bufferify(t)}bufferifyFn(t){return e=>{const r=t(e);if(m.Buffer.isBuffer(r))return r;if(this.isHexString(r))return m.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return m.Buffer.from(r);if("bigint"==typeof r)return m.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(r))return m.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e.buffer}(e.toString("hex")),n=function(t){const e=new Uint8Array(t);return Array.from(e).map((t=>t.toString(16).padStart(2,"0"))).join("")}(t(a));return m.Buffer.from(n,"hex")}}isHexString(t){return w.isHexString(t)}log2(t){return 1===t?0:1+this.log2(t/2|0)}zip(t,e){return t.map(((t,r)=>[t,e[r]]))}static hexZeroPad(t,e){return"0x"+t.replace("0x","").padStart(e,"0")}}var b=w;function W(t){const e=t.words,r=new ArrayBuffer(4*e.length),a=new Uint8Array(r);for(let t=0;t<e.length;t++)a[4*t]=e[t]>>24&255,a[4*t+1]=e[t]>>16&255,a[4*t+2]=e[t]>>8&255,a[4*t+3]=255&e[t];return r}class C extends b{duplicateOdd=!1;concatenator=m.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!m.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(t,e)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(e),this.processLeaves(t)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(t){if(this.hashLeaves&&(t=t.map(this.hashFn)),this.leaves=t.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(m.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(t){for(this.layers=[t];t.length>1;){const e=this.layers.length;this.layers.push([]);const r=this.complete&&1===e&&!Number.isInteger(Math.log2(t.length))?2*t.length-2**Math.ceil(Math.log2(t.length)):t.length;for(let a=0;a<t.length;a+=2){if(a>=r){this.layers[e].push(...t.slice(r));break}if(a+1===t.length&&t.length%2==1){const r=t[t.length-1];let n=r;if(this.isBitcoinTree){n=this.hashFn(this.concatenator([y()(r),y()(r)])),n=y()(this.hashFn(n)),this.layers[e].push(n);continue}if(!this.duplicateOdd){this.layers[e].push(t[a]);continue}}const n=t[a],i=a+1===t.length?n:t[a+1];let s=null;s=this.isBitcoinTree?[y()(n),y()(i)]:[n,i],this.sortPairs&&s.sort(m.Buffer.compare);let o=this.hashFn(this.concatenator(s));this.isBitcoinTree&&(o=y()(this.hashFn(o))),this.layers[e].push(o)}t=this.layers[e]}}addLeaf(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=this.hashFn(t)),this.processLeaves(this.leaves.concat(t))}addLeaves(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=t.map(this.hashFn)),this.processLeaves(this.leaves.concat(t))}getLeaves(t){return Array.isArray(t)?(this.hashLeaves&&(t=t.map(this.hashFn),this.sortLeaves&&(t=t.sort(m.Buffer.compare))),this.leaves.filter((e=>-1!==this.bufferIndexOf(t,e,this.sortLeaves)))):this.leaves}getLeaf(t){return t<0||t>this.leaves.length-1?m.Buffer.from([]):this.leaves[t]}getLeafIndex(t){t=this.bufferify(t);const e=this.getLeaves();for(let r=0;r<e.length;r++){if(e[r].equals(t))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((t=>this.bufferToHex(t)))}static marshalLeaves(t){return JSON.stringify(t.map((t=>C.bufferToHex(t))),null,2)}static unmarshalLeaves(t){let e=null;if("string"==typeof t)e=JSON.parse(t);else{if(!(t instanceof Object))throw new Error("Expected type of string or object");e=t}if(!e)return[];if(!Array.isArray(e))throw new Error("Expected JSON string to be array");return e.map(C.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((t,e)=>(Array.isArray(e)?t.push(e.map((t=>this.bufferToHex(t)))):t.push(e),t)),[])}getLayersFlat(){const t=this.layers.reduce(((t,e)=>(Array.isArray(e)?t.unshift(...e):t.unshift(e),t)),[]);return t.unshift(m.Buffer.from([0])),t}getHexLayersFlat(){return this.getLayersFlat().map((t=>this.bufferToHex(t)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?m.Buffer.from([]):this.layers[this.layers.length-1][0]||m.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(t,e){if(void 0===t)throw new Error("leaf is required");t=this.bufferify(t);const r=[];if(!Number.isInteger(e)){e=-1;for(let r=0;r<this.leaves.length;r++)0===m.Buffer.compare(t,this.leaves[r])&&(e=r)}if(e<=-1)return[];for(let t=0;t<this.layers.length;t++){const a=this.layers[t],n=e%2,i=n?e-1:this.isBitcoinTree&&e===a.length-1&&t<this.layers.length-1?e:e+1;i<a.length&&r.push({position:n?"left":"right",data:a[i]}),e=e/2|0}return r}getHexProof(t,e){return this.getProof(t,e).map((t=>this.bufferToHex(t.data)))}getProofs(){const t=[];return this.getProofsDFS(this.layers.length-1,0,[],t),t}getProofsDFS(t,e,r,a){const n=e%2;if(-1===t)return void(n||a.push([...r].reverse()));if(e>=this.layers[t].length)return;const i=this.layers[t],s=n?e-1:e+1;let o=!1;s<i.length&&(o=!0,r.push({position:n?"left":"right",data:i[s]}));const c=2*e,l=2*e+1;this.getProofsDFS(t-1,c,r,a),this.getProofsDFS(t-1,l,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((t=>this.bufferToHex(t.data)))}getPositionalHexProof(t,e){return this.getProof(t,e).map((t=>["left"===t.position?0:1,this.bufferToHex(t.data)]))}getProofIndices(t,e){const r=2**e;let a=new Set;for(const e of t){let t=r+e;for(;t>1;)a.add(1^t),t=t/2|0}const n=t.map((t=>r+t)),i=Array.from(a).sort(((t,e)=>t-e)).reverse();a=n.concat(i);const s=new Set,o=[];for(let t of a)if(!s.has(t))for(o.push(t);t>1&&(s.add(t),s.has(1^t));)t=t/2|0;return o.filter((e=>!t.includes(e-r)))}getProofIndicesForUnevenTree(t,e){const r=Math.ceil(Math.log2(e)),a=[];for(let t=0;t<r;t++){e%2!=0&&a.push({index:t,leavesCount:e}),e=Math.ceil(e/2)}const n=[];let i=t;for(let t=0;t<r;t++){let e=i.map((t=>t%2==0?t+1:t-1)).filter((t=>!i.includes(t)));const r=a.find((e=>{let{index:r}=e;return r===t}));r&&i.includes(r.leavesCount-1)&&(e=e.slice(0,-1)),n.push(e),i=[...new Set(i.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))]}return n}getMultiProof(t,e){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),e||(e=t,t=this.getLayersFlat());if(this.isUnevenTree()&&e.every(Number.isInteger))return this.getMultiProofForUnevenTree(e);if(!e.every(Number.isInteger)){let t=e;this.sortPairs&&(t=t.sort(m.Buffer.compare));let r=t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1));if(!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=[],n=[];let i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const s=r[t],o=this.getPairNode(e,s);a.push(e[s]),o&&n.push(o),i.push(s/2|0)}r=i.filter(((t,e,r)=>r.indexOf(t)===e)),i=[]}return n.filter((t=>!a.includes(t)))}return this.getProofIndices(e,Math.log2(t.length/2|0)).map((e=>t[e]))}getMultiProofForUnevenTree(t,e){e||(e=t,t=this.getLayers());let r=[],a=e;for(const e of t){const t=[];for(const r of a){if(r%2==0){const n=r+1;if(!a.includes(n)&&e[n]){t.push(e[n]);continue}}const n=r-1;a.includes(n)||!e[n]||t.push(e[n])}r=r.concat(t);const n=new Set;for(const t of a)t%2!=0?t%2!=0?n.add((t-1)/2):n.add((t+1)/2):n.add(t/2);a=Array.from(n)}return r}getHexMultiProof(t,e){return this.getMultiProof(t,e).map((t=>this.bufferToHex(t)))}getProofFlags(t,e){if(!Array.isArray(t)||t.length<=0)throw new Error("Invalid Inputs!");let r;if(r=t.every(Number.isInteger)?[...t].sort(((t,e)=>t===e?0:t>e?1:-1)):t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1)),!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=e.map((t=>this.bufferify(t))),n=[],i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];r=r.reduce(((t,r)=>{if(!n.includes(e[r])){const t=this.getPairNode(e,r),s=a.includes(e[r])||a.includes(t);t&&i.push(!s),n.push(e[r]),n.push(t)}return t.push(r/2|0),t}),[])}return i}verify(t,e,r){let a=this.bufferify(e);if(r=this.bufferify(r),!Array.isArray(t)||!e||!r)return!1;for(let e=0;e<t.length;e++){const r=t[e];let n=null,i=null;if("string"==typeof r)n=this.bufferify(r),i=!0;else if(Array.isArray(r))i=0===r[0],n=this.bufferify(r[1]);else if(m.Buffer.isBuffer(r))n=r,i=!0;else{if(!(r instanceof Object))throw new Error("Expected node to be of type string or object");n=this.bufferify(r.data),i="left"===r.position}const s=[];this.isBitcoinTree?(s.push(y()(a)),s[i?"unshift":"push"](y()(n)),a=this.hashFn(this.concatenator(s)),a=y()(this.hashFn(a))):this.sortPairs?-1===m.Buffer.compare(a,n)?(s.push(a,n),a=this.hashFn(this.concatenator(s))):(s.push(n,a),a=this.hashFn(this.concatenator(s))):(s.push(a),s[i?"unshift":"push"](n),a=this.hashFn(this.concatenator(s)))}return 0===m.Buffer.compare(a,r)}verifyMultiProof(t,e,r,a,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(t,e,r,a,n);const i=Math.ceil(Math.log2(a));t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const s={};for(const[t,a]of this.zip(e,r))s[2**i+t]=a;for(const[t,r]of this.zip(this.getProofIndices(e,i),n))s[t]=r;let o=Object.keys(s).map((t=>Number(t))).sort(((t,e)=>t-e));o=o.slice(0,o.length-1);let c=0;for(;c<o.length;){const t=o[c];if(t>=2&&{}.hasOwnProperty.call(s,1^t)){let e=[s[t-t%2],s[t-t%2+1]];this.sortPairs&&(e=e.sort(m.Buffer.compare));const r=e[1]?this.hashFn(this.concatenator(e)):e[0];s[t/2|0]=r,o.push(t/2|0)}c+=1}return!e.length||{}.hasOwnProperty.call(s,1)&&s[1].equals(t)}verifyMultiProofWithFlags(t,e,r,a){t=this.bufferify(t),e=e.map(this.bufferify),r=r.map(this.bufferify);const n=e.length,i=a.length,s=[];let o=0,c=0,l=0;for(let t=0;t<i;t++){const i=[a[t]?o<n?e[o++]:s[c++]:r[l++],o<n?e[o++]:s[c++]].sort(m.Buffer.compare);s[t]=this.hashFn(this.concatenator(i))}return 0===m.Buffer.compare(s[i-1],t)}verifyMultiProofForUnevenTree(t,e,r,a,n){t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const i=this.calculateRootForUnevenTree(e,r,a,n);return t.equals(i)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const t=this.getLayers().map((t=>t.map((t=>this.bufferToHex(t,!1))))),e=[];for(let r=0;r<t.length;r++){const a=[];for(let n=0;n<t[r].length;n++){const i={[t[r][n]]:null};if(e.length){i[t[r][n]]={};const a=e.shift(),s=Object.keys(a)[0];if(i[t[r][n]][s]=a[s],e.length){const a=e.shift(),s=Object.keys(a)[0];i[t[r][n]][s]=a[s]}}a.push(i)}e.push(...a)}return e[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(t,e){const r=e%2==0?e+1:e-1;return r<t.length?t[r]:null}toTreeString(){const t=this.getLayersAsObject();return(0,g.asTree)(t,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(t){const e=t?.length||this.getDepth();return!this.isPowOf2(e)}isPowOf2(t){return t&&!(t&t-1)}calculateRootForUnevenTree(t,e,r,a){const n=this.zip(t,e).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})),i=n.map((t=>{let[e]=t;return e})),s=this.getProofIndicesForUnevenTree(i,r);let o=0;const c=[];for(let t=0;t<s.length;t++){const e=s[t],r=o;o+=e.length,c[t]=this.zip(e,a.slice(r,o))}const l=[n];for(let t=0;t<c.length;t++){const e=c[t].concat(l[t]).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})).map((t=>{let[,e]=t;return e})),r=l[t].map((t=>{let[e]=t;return e})),a=[...new Set(r.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))],n=[];for(let t=0;t<a.length;t++){const r=a[t],i=e[2*t],s=e[2*t+1],o=s?this.hashFn(this.concatenator([i,s])):i;n.push([r,o])}l.push(n)}return l[l.length-1][0][1]}}var v=r(89208),P=r(1604),T=r(41518),S=r(57632),k=r(48764).Buffer;function A(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function x(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function I(t,e){return"unlimited"===t?a.Bz:n.parseUnits(t,e)}async function E(t){const e=25e3,r=Array.from({length:Math.ceil(t.length/e)},((r,a)=>t.slice(a*e,a*e+e))),a=[],n=await Promise.all(r.map((t=>h.bO.parseAsync(t))));for(const t of n)a.push(...t);return a}let B=function(t){return t[t.V1=1]="V1",t[t.V2=2]="V2",t}({});class M{constructor(t,e,r,a,n){this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(t,e){try{const r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return M.fromShardedMerkleTreeInfo(r,e)}catch(t){return}}static async fromShardedMerkleTreeInfo(t,e){return new M(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case B.V1:return i.keccak256(["address","uint256"],[t.address,I(t.maxClaimable,e)]);case B.V2:return i.keccak256(["address","uint256","uint256","address"],[t.address,I(t.maxClaimable,e),I(t.price||"unlimited",r),t.currencyAddress||s.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){a=(await(0,u.f)(e,r)).decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,n){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const s=await E(t),c={};for(const t of s){const e=t.address.slice(2,2+i).toLowerCase();void 0===c[e]&&(c[e]=[]),c[e].push(t)}const l={},p=await Promise.all(Object.entries(c).map((async t=>{let[a,i]=t;return[a,new C(await Promise.all(i.map((async t=>{const a=await M.fetchAndCacheDecimals(l,r,t.currencyAddress);return M.hashEntry(t,e,a,n)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),h=Object.fromEntries(p),u=new C(Object.values(h),o.keccak256,{sort:!0}),d=[];for(const[t,e]of Object.entries(c)){const r={proofs:u.getProof(h[t]).map((t=>"0x"+t.data.toString("hex"))),entries:e};d.push({data:JSON.stringify(r),name:`${t}.json`})}const m=await a.uploadBatch(d),f=m[0].slice(0,m[0].lastIndexOf("/")),y=await a.upload(s),g={merkleRoot:u.getHexRoot(),baseUri:f,originalEntriesUri:y,shardNybbles:i,tokenDecimals:e,isShardedMerkleTree:!0};return{shardedMerkleInfo:g,uri:await a.upload(g)}}async getProof(t,e,r){const a=t.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[a];const i={};if(void 0===n)try{const t=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;n=this.shards[a]=await this.storage.downloadJSON(`${t}${a}.json`);const s=await Promise.all(n.entries.map((async t=>{const a=await M.fetchAndCacheDecimals(i,e,t.currencyAddress);return M.hashEntry(t,this.tokenDecimals,a,r)})));this.trees[a]=new C(s,o.keccak256,{sort:!0})}catch(t){return null}const s=n.entries.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!s)return null;const c=await M.fetchAndCacheDecimals(i,e,s.currencyAddress),l=M.hashEntry(s,this.tokenDecimals,c,r),p=this.trees[a].getProof(l).map((t=>"0x"+t.data.toString("hex")));return h.bP.parseAsync({...s,proof:p.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function N(t,e,r,a,n,i){if(!r)return null;const s=r[e];if(s){const r=await n.downloadJSON(s);if(r.isShardedMerkleTree&&r.merkleRoot===e){const e=await M.fromShardedMerkleTreeInfo(r,n);return await e.getProof(t,a,i)}const o=await h.bQ.parseAsync(r);if(e===o.merkleRoot)return o.claims.find((e=>e.address.toLowerCase()===t.toLowerCase()))||null}return null}function R(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function O(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function L(t,e,a,i,s){const o=t.getSigner(),l=t.getProvider(),p=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,u=new h.cu(o||l,e,p,t.options,t.storage),d=await t.getSignerAddress(),m=t.address,f=await u.read("allowance",[d,m]),y=c.O$.from(a).mul(c.O$.from(i)).div(n.parseUnits("1",s));f.lt(y)&&await u.sendTransaction("approve",[m,f.add(y)])}async function D(t,e,r,i,o,p,h,m,f){let y=I(r.maxClaimablePerWallet,o),g=[l.hexZeroPad([0],32)],w=r.price,b=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(s.d)){const e=await N(t,r.merkleRootHash.toString(),await i(),p.getProvider(),h,f);if(e)g=e.proof,y="unlimited"===e.maxClaimable?a.Bz:n.parseUnits(e.maxClaimable,o),w=void 0===e.price||"unlimited"===e.price?a.Bz:await(0,d.n)(p.getProvider(),e.price,e.currencyAddress||s.d),b=e.currencyAddress||s.d;else if(f===B.V1)throw new Error("No claim found for this address")}}catch(t){if("No claim found for this address"===t?.message)throw t;console.warn("failed to check claim condition merkle root hash, continuing anyways",t)}const W=await p.getCallOverrides()||{},C=w.toString()!==a.Bz.toString()?w:r.price,v=b!==s.d?b:r.currencyAddress;return C.gt(0)&&((0,u.i)(v)?W.value=c.O$.from(C).mul(e).div(n.parseUnits("1",o)):m&&await L(p,v,C,e,o)),{overrides:W,proofs:g,maxClaimable:y,price:C,currencyAddress:v,priceInProof:w,currencyAddressInProof:b}}const F=(()=>P.z.object({name:P.z.string(),symbol:P.z.string(),decimals:P.z.number()}))(),z=(()=>F.extend({value:h.b9,displayValue:P.z.string()}))(),U=(()=>P.z.object({name:P.z.string().optional()}).catchall(P.z.unknown()))(),H=(()=>P.z.object({startTime:v.S,currencyAddress:P.z.string().default(h.aZ),price:h.cz.default(0),maxClaimableSupply:h.cD,maxClaimablePerWallet:h.cD,waitInSeconds:h.ba.default(0),merkleRootHash:h.cE.default(l.hexZeroPad([0],32)),snapshot:P.z.optional(h.bO).nullable(),metadata:U.optional()}))(),$=(()=>P.z.array(H))(),q=(()=>H.extend({availableSupply:h.cD,currentMintSupply:h.cD,currencyMetadata:z.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h.b9,waitInSeconds:h.b9,startTime:h.b9.transform((t=>new Date(1e3*t.toNumber()))),snapshot:h.bO.optional().nullable()}))();async function _(t,e,r,a,n){const i=[],s=await Promise.all(t.map((async t=>{if(t.snapshot&&t.snapshot.length>0){const s=await async function(t,e,r,a,n){const i=await E(t),s=i.map((t=>t.address));if(new Set(s).size<s.length)throw new h.s;const o=await M.buildAndUpload(i,e,r,a,n);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(t.snapshot,e,r,a,n);i.push(s),t.merkleRootHash=s.merkleRoot}else t.merkleRootHash=l.hexZeroPad([0],32);return t})));return{inputsWithSnapshots:s,snapshotInfos:i}}async function j(t,e,r,a,n){const{inputsWithSnapshots:i,snapshotInfos:o}=await _(t,e,r,a,n),l=await $.parseAsync(i),p=(await Promise.all(l.map((t=>async function(t,e,r,a){const n=t.currencyAddress===s.d?h.aZ:t.currencyAddress,i=I(t.maxClaimableSupply,e),o=I(t.maxClaimablePerWallet,e);let c;return t.metadata&&(c="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:i,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,d.n)(r,t.price,n),currency:n,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:c}}(t,e,r,a))))).sort(((t,e)=>function(t,e){const r=c.O$.from(t),a=c.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1}(t.startTimestamp,e.startTimestamp)));return{snapshotInfos:o,sortedConditions:p}}async function V(t,e,r){if(!e)return null;const a=e[t];if(a){const e=await r.downloadJSON(a);if(e.isShardedMerkleTree&&e.merkleRoot===t){const t=await M.fromUri(a,r);return t?.getAllEntries()||null}{const r=await h.bQ.parseAsync(e);if(t===r.merkleRoot)return r.claims.map((t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress})))}}return null}function Z(t,e){return t.toString()===a.Bz.toString()?"unlimited":n.formatUnits(t,e)}async function J(t,e,r,a,n,i){const s=await(0,u.a)(r,t.currency,t.pricePerToken),o=Z(t.maxClaimableSupply,e),l=Z(t.maxClaimablePerWallet,e),p=Z(c.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),h=Z(t.supplyClaimed,e);let d;return t.metadata&&(d=await n.downloadJSON(t.metadata)),q.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:l,currentMintSupply:h,availableSupply:p,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:c.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:s,merkleRootHash:t.merkleRoot,snapshot:i?await V(t.merkleRoot,a,n):void 0,metadata:d})}async function G(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);const a=r[t].currencyMetadata.decimals,i=r[t].price,s=n.formatUnits(i,a),o=await H.parseAsync({...r[t],price:s,...e}),c=await q.parseAsync({...o,price:i});return r.map(((e,r)=>{let i;i=r===t?c:e;const s=n.formatUnits(i.price,a);return{...i,price:s}}))}let Y=function(t){return t.NotEnoughSupply="There is not enough supply to claim.",t.AddressNotAllowed="This address is not on the allowlist.",t.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",t.ClaimPhaseNotStarted="Claim phase has not started yet.",t.AlreadyClaimed="You have already claimed the token.",t.WrongPriceOrCurrency="Incorrect price or currency.",t.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",t.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",t.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",t.NoClaimConditionSet="There is no claim condition set.",t.NoWallet="No wallet connected.",t.Unknown="No claim conditions found.",t}({});function Q(t){if(void 0===t){const t=k.alloc(16);return(0,S.Z)({},t),l.hexlify(p.Y0(t.toString("hex")))}return l.hexlify(t)}const K=(()=>P.z.object({to:h.bd.refine((t=>t.toLowerCase()!==s.d),{message:"Cannot create payload to mint to zero address"}),price:h.cz.default(0),currencyAddress:h.bc.default(h.aZ),mintStartTime:v.S,mintEndTime:v.E,uid:P.z.string().optional().transform((t=>Q(t))),primarySaleRecipient:h.bd.default(s.d)}))(),X=(()=>K.extend({quantity:h.cz}))(),tt=(()=>X.extend({mintStartTime:h.b9,mintEndTime:h.b9}))(),et=(()=>K.extend({metadata:T.N,royaltyRecipient:P.z.string().default(s.d),royaltyBps:h.cF.default(0)}))(),rt=(()=>et.extend({metadata:T.N.default(""),uri:P.z.string(),royaltyBps:h.b9,mintStartTime:h.b9,mintEndTime:h.b9}))(),at=(()=>et.extend({metadata:T.N.default(""),quantity:h.ba}))(),nt=(()=>at.extend({tokenId:h.ba}))(),it=(()=>rt.extend({tokenId:h.b9,quantity:h.b9}))(),st=(()=>et.extend({metadata:T.N.default(""),quantity:h.b9.default(1)}))(),ot=(()=>rt.extend({quantity:h.b9.default(1)}))(),ct=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ht=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},56351:(t,e,r)=>{var a=r(48764).Buffer;t.exports=function(t){for(var e=new a(t.length),r=0,n=t.length-1;r<=n;++r,--n)e[r]=t[n],e[n]=t[r];return e}},99269:function(t){t.exports=function(){function t(t,e){var r=e?"":"";return r+=t?" ":""}function e(t,e){var r=[];for(var a in t)t.hasOwnProperty(a)&&(e&&"function"==typeof t[a]||r.push(a));return r}function r(a,n,i,s,o,c,l){var p,h,u="",d=0,m=s.slice(0);if(m.push([n,i])&&s.length>0&&(s.forEach((function(t,e){e>0&&(u+=(t[1]?" ":"")+"  "),h||t[0]!==n||(h=!0)})),u+=t(a,i)+a,o&&("object"!=typeof n||n instanceof Date)&&(u+=": "+n),h&&(u+=" (circular ref.)"),l(u)),!h&&"object"==typeof n){var f=e(n,c);f.forEach((function(t){p=++d===f.length,r(t,n[t],p,m,o,c,l)}))}}var a={asLines:function(t,e,a,n){r(".",t,!1,[],e,"function"!=typeof a&&a,n||a)},asTree:function(t,e,a){var n="";return r(".",t,!1,[],e,a,(function(t){n+=t+"\n"})),n}};return a}()}}]);
//# sourceMappingURL=5010.js.map