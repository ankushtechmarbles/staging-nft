(self.webpackChunk=self.webpackChunk||[]).push([[5132],{89050:(t,e,r)=>{"use strict";r.d(e,{D:()=>g,F:()=>p,I:()=>c,a:()=>l,b:()=>u,c:()=>d,f:()=>h,g:()=>f,u:()=>m});var a=r(41518),n=r(16441),s=r(2593),i=r(64146),o=r(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),l=(()=>n.arrayify("0xd9b67a26"))(),p={name:"Failed to load NFT metadata"};async function h(t,e,r){if(e.startsWith("data:application/json;base64")&&void 0!==o){const r=e.split(",")[1],n=JSON.parse(o.from(r,"base64").toString("utf-8"));return a.C.parse({...n,id:s.O$.from(t).toString(),uri:e})}const i=e.replace("{id}",n.hexZeroPad(s.O$.from(t).toHexString(),32).slice(2));let c;try{c=await r.downloadJSON(i)}catch(a){const n=e.replace("{id}",s.O$.from(t).toString());try{c=await r.downloadJSON(n)}catch(r){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),c=p}}return a.C.parse({...c,id:s.O$.from(t).toString(),uri:e})}async function d(t,e,n,o){let d;const u=(await r.e(5025).then(r.t.bind(r,25025,19))).default,m=new i.CH(t,u,e),[f,g]=await Promise.all([m.supportsInterface(c),m.supportsInterface(l)]);if(f){const a=(await Promise.resolve().then(r.t.bind(r,34161,19))).default,s=new i.CH(t,a,e);d=await s.tokenURI(n)}else{if(!g)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(r.t.bind(r,50266,19))).default,s=new i.CH(t,a,e);d=await s.uri(n)}}return d?h(n,d,o):a.C.parse({...p,id:s.O$.from(n).toString(),uri:""})}async function u(t,e){return"string"==typeof t?t:await e.upload(a.a.parse(t))}async function m(t,e,r,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await e.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:r||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function f(t){const e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){const a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}const g=100},89208:(t,e,r)=>{"use strict";r.d(e,{E:()=>c,R:()=>i,S:()=>o,a:()=>l});var a=r(2593),n=r(1604),s=r(7860);const i=(()=>n.z.union([n.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),n.z.number().transform((t=>a.O$.from(t)))]))(),o=(()=>i.default(new Date(0)))(),c=(()=>i.default(new Date(Date.now()+31536e7)))();function l(t,e){if(!t)throw new s.x(e);return t}},89536:(t,e,r)=>{"use strict";r.d(e,{C:()=>l,G:()=>h,a:()=>p,b:()=>d,d:()=>o,h:()=>c});var a=r(7860),n=r(19578),s=r(61744),i=r(40721);function o(t,e){return(0,a.am)(a.bn.parse(t.abi),e)}function c(t,e){return t in e.readContract.functions}class l{featureName=a.d1.name;constructor(t,e,r){this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const e=await this.contractWrapper.read("contractURI",[]);e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let e,r,n;try{c("name",this.contractWrapper)&&(e=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(r=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:e||n?.name,symbol:r,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class p{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},n=t=>{const r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const e={address:this.contractWrapper.address},r=e=>{try{const r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(t){console.error("Could not parse event:",e,t)}};return this.contractWrapper.getProvider().on(e,r),()=>{this.contractWrapper.getProvider().off(e,r)}}removeEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber));return this.parseEvents(e)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=this.contractWrapper.readContract.interface.getEvent(t),a=e.filters?r.inputs.map((t=>e.filters[t.name])):[],n=this.contractWrapper.readContract.filters[r.name](...a),s=(await this.contractWrapper.readContract.queryFilter(n,e.fromBlock,e.toBlock)).sort(((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber));return this.parseEvents(s)}parseEvents(t){return t.map((t=>{const e=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const r=Object.entries(t.args),a=r.slice(r.length/2,r.length),n={};for(const[t,e]of a)n[t]=e;return{eventName:t.event||"",data:n,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}}))}toContractEvent(t,e,r){const a=Object.fromEntries(Object.entries(r).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,r)=>{if(Array.isArray(e[r])){const a=t.components;if(a){const s=e[r];if("tuple[]"===t.type){const e=[];for(let t=0;t<s.length;t++){const r=s[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=r[t]}e.push(n)}n[t.name]=e}else{const e={};for(let t=0;t<a.length;t++){e[a[t].name]=s[t]}n[t.name]=e}}}else n[t.name]=e[r]})),{eventName:t.name,data:n,transaction:a}}}class h{constructor(t){this.contractWrapper=t}async gasCostOf(t,e){const[r,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,e)]);return s.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return s.formatUnits(t,"gwei")}}class d{featureName=a.d2.name;constructor(t,e,r){this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,i.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>o(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,e,r)=>{"use strict";r.d(e,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},83833:(t,e,r)=>{"use strict";r.d(e,{C:()=>y,D:()=>w,a:()=>W,c:()=>C});var a=r(89536),n=r(19578),s=r(7860),i=r(68828),o=r(29251),c=r(31886),l=r(84243),p=r(16441),h=r(2593),d=r(64146),u=r(41518),m=r(89050),f=r(58179),g=r(19824);class y{featureName=s.d4.name;constructor(t,e){this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){const[t,e]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return s.bH.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){const[e,r]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return s.bH.parseAsync({fee_recipient:e,seller_fee_basis_points:r})}setDefaultRoyaltyInfo=(0,n.c)((async t=>{const e=await this.metadata.get(),r=await this.metadata.parseInputMetadata({...e,...t}),s=await this.metadata._parseAndUploadMetadata(r);if((0,a.h)("setContractURI",this.contractWrapper)){const t=new i.C(this.contractWrapper),e=[t.encode("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),t.encode("setContractURI",[s])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.c)((async(t,e)=>{const r=s.bH.parse(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class w{constructor(t,e,r,a){this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}createDelayedRevealBatch=(0,n.c)((async(t,e,r,a)=>{if(!r)throw new Error("Password is required");const s=await this.storage.uploadBatch([u.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),i=(0,m.g)(s),p=await this.nextTokenIdToMintFn(),h=await this.storage.uploadBatch(e.map((t=>u.a.parse(t))),{onProgress:a?.onProgress,rewriteFileNames:{fileStartNumber:p.toNumber()}}),d=(0,m.g)(h),f=await this.contractWrapper.read("getBaseURICount",[]),g=await this.hashDelayRevealPassword(f,r),y=await this.contractWrapper.read("encryptDecrypt",[o.Y0(d),g]);let w;if(await this.isLegacyContract())w=y;else{const t=await this.contractWrapper.getChainID(),e=c.keccak256(["bytes","bytes","uint256"],[o.Y0(d),g,t]);w=l.$.encode(["bytes","bytes32"],[y,e])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[h.length,i.endsWith("/")?i:`${i}/`,w],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t});return n}})}));reveal=(0,n.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.hashDelayRevealPassword(t,e);try{const e=await this.contractWrapper.callStatic().reveal(t,r);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map((t=>{if((0,a.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,a.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=r.slice(0,r.length-1),s=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),i=await this.isLegacyContract(),o=(await Promise.all(Array.from([...r]).map((t=>i?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(p.hexDataLength(t)>0){if(i)return t;return l.$.decode(["bytes","bytes32"],t)[0]}return t}));return s.map(((t,e)=>({batchId:h.O$.from(e),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,e)=>p.hexDataLength(o[e])>0))}async hashDelayRevealPassword(t,e){const r=await this.contractWrapper.getChainID(),a=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return(0,m.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,a.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const e=(await r.e(8839).then(r.t.bind(r,98839,19))).default,a=new d.CH(this.contractWrapper.address,e,this.contractWrapper.getProvider()),n=await a.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function C(t,e,r,a,n){let i={};const o=a||s.aZ,c=(await(0,g.n)(t.getProvider(),e,o)).mul(r);return c.gt(0)&&(o===s.aZ?i={value:c}:o!==s.aZ&&n&&await(0,f.a)(t,o,c,r,0)),i}class W{featureName=s.d5.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.c)((async t=>{const e=await(0,s.aP)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})}))}},74935:(t,e,r)=>{"use strict";r.d(e,{C:()=>c});var a=r(38776),n=r(7860),s=r(89536),i=r(19578),o=r(68828);class c{featureName=n.d3.name;constructor(t,e){this.contractWrapper=t,this.roles=e}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},e=Object.entries(this.roles);return(await Promise.all(e.map((t=>{let[,e]=t;return this.get(e)})))).forEach(((r,a)=>t[e[a][1]]=r)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=this.contractWrapper;if((0,s.h)("getRoleMemberCount",e)&&(0,s.h)("getRoleMember",e)){const r=(0,n.H)(t),a=(await e.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>e.read("getRoleMember",[r,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,i.c)((async t=>{const e=new o.C(this.contractWrapper),r=Object.keys(t);(0,a.Z)(r.length,"you must provide at least one role to set"),(0,a.Z)(r.every((t=>this.roles.includes(t))),"this contract does not support the given role");const s=await this.getAll(),c=[],l=r.sort((t=>"admin"===t?1:-1));for(let r=0;r<l.length;r++){const a=l[r],[i,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(s[a]?.map((t=>(0,n.aP)(t)))||[])]),p=i.filter((t=>!o.includes(t))),h=o.filter((t=>!i.includes(t)));if(p.length&&p.forEach((t=>{c.push(e.encode("grantRole",[(0,n.H)(a),t]))})),h.length){(await Promise.all(h.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,r)=>c.push(e.encode(t,[(0,n.H)(a),h[r]]))))}}return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,e){await Promise.all(t.map((async t=>{const[r,a]=await Promise.all([this.get(t),(0,n.aP)(e)]);if(!r.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,i.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),r]})}));revoke=(0,i.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e),s=await this.getRevokeRoleFunctionName(r);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:s,args:[(0,n.H)(t),r]})}));async getRevokeRoleFunctionName(t){const[e,r]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}},62245:(t,e,r)=>{"use strict";r.d(e,{D:()=>g});var a=r(61744),n=r(16441),s=r(2593),i=r(21046),o=r(9279),c=r(29251),l=r(64063),p=r.n(l),h=r(7860),d=r(58179),u=r(68828),m=r(89536),f=r(19578);class g{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){const[e,r,a]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await(0,d.v)(e,a,this.contractWrapper.getProvider(),r.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,d.w)(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,d.w)(r)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,d.x)(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,d.x)(r)}throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,r]=await this.contractWrapper.read("claimCondition",[]),a=e.toNumber(),n=r.toNumber(),s=[];for(let t=a;t<a+n;t++)s.push(this.get(t));const[i,o,...c]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...s]);return Promise.all(c.map((e=>(0,d.v)(e,o,this.contractWrapper.getProvider(),i.merkle,this.storage,t?.withAllowList||!1))))}return[await this.getActive(t)]}async canClaim(t,e){return e&&(e=await(0,h.aP)(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){const o=[];let c,l;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!e)return[d.C.NoWallet];const[p,m]=await Promise.all([(0,h.aP)(e),this.getTokenDecimals()]),f=a.parseUnits(h.cz.parse(t),m);try{l=await this.getActive()}catch(t){return(0,h.B)(t,"!CONDITION")||(0,h.B)(t,"no active mint condition")?(o.push(d.C.NoClaimConditionSet),o):(console.warn("failed to get active claim condition",t),o.push(d.C.Unknown),o)}if("unlimited"!==l.availableSupply){if(a.parseUnits(l.availableSupply,m).lt(f))return o.push(d.C.NotEnoughSupply),o}const g=n.stripZeros(l.merkleRootHash).length>0;let y=null;if(g){if(y=await this.getClaimerProofs(p),!y&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(d.C.AddressNotAllowed),o;if(y)try{const e=await this.prepareClaim(t,!1,m,p);let r;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[r]=await this.contractWrapper.read("verifyClaimMerkleProof",[c,p,t,e.proofs,e.maxClaimable]),!r)return o.push(d.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([r]=await this.contractWrapper.read("verifyClaimMerkleProof",[p,t,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable}]),!r)return o.push(d.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[c,p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(d.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(d.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(d.C.NotEnoughSupply);break;case"cant claim yet":o.push(d.C.ClaimPhaseNotStarted);break;default:o.push(d.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=s.O$.from(0),e=(0,d.y)(l.maxClaimablePerWallet,m);try{t=await this.getSupplyClaimedByWallet(p)}catch(t){}if(y&&(e=(0,d.y)(y.maxClaimable,m)),e.gt(0)&&e.lt(t.add(f)))return o.push(d.C.OverMaxClaimablePerWallet),o;if((!g||g&&!y)&&(e.lte(t)||e.eq(0)))return o.push(d.C.AddressNotAllowed),o}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,e]=[s.O$.from(0),s.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,e]=await this.contractWrapper.read("getClaimTimestamp",[c,p])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,e]=await this.contractWrapper.read("getClaimTimestamp",[p]));const r=s.O$.from(Date.now()).div(1e3);if(t.gt(0)&&r.lt(e))return e.eq(i.Bz)?o.push(d.C.AlreadyClaimed):o.push(d.C.WaitBeforeNextClaimTransaction),o}if(l.price.gt(0)&&(0,h.d7)()){const e=l.price.mul(s.O$.from(t)),a=this.contractWrapper.getProvider();if((0,u.i)(l.currencyAddress)){(await a.getBalance(p)).lt(e)&&o.push(d.C.NotEnoughTokens)}else{const t=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new h.cu(a,l.currencyAddress,t,{},this.storage);(await n.read("balanceOf",[p])).lt(e)&&o.push(d.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e){const r=(await this.get(e)).merkleRoot;if(n.stripZeros(r).length>0){const[e,a]=await Promise.all([this.metadata.get(),(0,h.aP)(t)]);return await(0,d.f)(a,r.toString(),e.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const e=await(0,h.aP)(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,f.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=e;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(r=!0,0===e.length)a=[{startTime:new Date(0),currencyAddress:o.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(e.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&a.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:s,sortedConditions:i}=await(0,d.D)(a,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),c={};s.forEach((t=>{c[t.merkleRoot]=t.snapshotUri}));const l=await t.metadata.get(),h=[];if(!p()(l.merkle,c)){const e=await t.metadata.parseInputMetadata({...l,merkle:c}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,m.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new u.C(t.contractWrapper);h.push(e.encode("setContractURI",[r]))}}const g=t.contractWrapper,y=new u.C(g);if(t.isLegacySinglePhaseDrop(g)){const t=new u.C(g);h.push(t.encode("setClaimConditions",[(0,d.E)(i[0]),r]))}else if(t.isLegacyMultiPhaseDrop(g))h.push(y.encode("setClaimConditions",[i.map(d.E),r]));else if(t.isNewSinglePhaseDrop(g))h.push(y.encode("setClaimConditions",[(0,d.F)(i[0]),r]));else{if(!t.isNewMultiphaseDrop(g))throw new Error("Contract does not support claim conditions");h.push(y.encode("setClaimConditions",[i.map(d.F),r]))}if((0,m.h)("multicall",t.contractWrapper))return f.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[h]});throw new Error("Contract does not support multicall")}})());update=(0,f.c)((async(t,e)=>{const r=await this.getAll(),a=await(0,d.H)(t,e,r);return await this.set.prepare(a)}));async getTokenDecimals(){return(0,m.d)(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3?arguments[3]:void 0;const[n,s]=await Promise.all([a||this.contractWrapper.getSignerAddress(),this.getActive()]);return(0,d.z)(n,t,s,(async()=>(await this.metadata.get()).merkle),r,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r){const a=await(0,h.aP)(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,r.proofs,r.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable},c.Y0("")]:[a,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,pricePerToken:r.priceInProof,currency:r.currencyAddressInProof},c.Y0("")]}async getClaimTransaction(t,e,r){if(r?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const a=await this.prepareClaim(e,void 0===r?.checkERC20Allowance||r.checkERC20Allowance,await this.getTokenDecimals());return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,a),overrides:a.overrides})}isNewSinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV2")||(0,m.d)(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV2")||(0,m.d)(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV1")||(0,m.d)(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV1")||(0,m.d)(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?d.A.V1:d.A.V2}}},40795:(t,e,r)=>{"use strict";r.d(e,{D:()=>P,e:()=>M,f:()=>N});var a=r(2593),n=r(16441),s=r(21046),i=r(9279),o=r(29251),c=r(7860),l=r(89208),p=r(89536),h=r(89050),d=r(19578),u=r(1604),m=r(83833),f=r(64063),g=r.n(f),y=r(58179),w=r(68828),C=r(38776),W=r(19824),b=r(41518);class P{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t,e){const r=await this.get(t),a=await this.metadata.get();return await(0,y.v)(r,0,this.contractWrapper.getProvider(),a.merkle,this.storage,e?.withAllowList||!1)}async get(t,e){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,y.w)(e)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,y.w)(a)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,y.x)(e)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,y.x)(a)}throw new Error("Contract does not support claim conditions")}async getAll(t,e){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]),a=r.currentStartId.toNumber(),n=r.count.toNumber(),s=[];for(let e=a;e<a+n;e++)s.push(await this.get(t,e));const i=await this.metadata.get();return Promise.all(s.map((t=>(0,y.v)(t,0,this.contractWrapper.getProvider(),i.merkle,this.storage,e?.withAllowList||!1))))}return[await this.getActive(t,e)]}async canClaim(t,e,r){return r&&(r=await(0,c.aP)(r)),0===(await this.getClaimIneligibilityReasons(t,e,r)).length}async getClaimIneligibilityReasons(t,e,i){const o=[];let l,p;if(void 0===i)try{i=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!i)return[y.C.NoWallet];const h=await(0,c.aP)(i);try{p=await this.getActive(t)}catch(t){return(0,c.B)(t,"!CONDITION")||(0,c.B)(t,"no active mint condition")?(o.push(y.C.NoClaimConditionSet),o):(o.push(y.C.Unknown),o)}if("unlimited"!==p.availableSupply&&a.O$.from(p.availableSupply).lt(e))return o.push(y.C.NotEnoughSupply),o;const d=n.stripZeros(p.merkleRootHash).length>0;let u=null;if(d){if(u=await this.getClaimerProofs(t,h),!u&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(y.C.AddressNotAllowed),o;if(u)try{const r=await this.prepareClaim(t,e,!1,h);let a;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[a]=await this.contractWrapper.read("verifyClaimMerkleProof",[l,h,t,e,r.proofs,r.maxClaimable]),!a)return o.push(y.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([a]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,h,e,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable}]),!a)return o.push(y.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,h,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[l,h,t,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(y.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(y.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(y.C.NotEnoughSupply);break;case"cant claim yet":o.push(y.C.ClaimPhaseNotStarted);break;default:o.push(y.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let r=a.O$.from(0),n=(0,y.y)(p.maxClaimablePerWallet,0);try{r=await this.getSupplyClaimedByWallet(t,h)}catch(t){}if(u&&(n=(0,y.y)(u.maxClaimable,0)),n.gt(0)&&n.lt(r.add(e)))return o.push(y.C.OverMaxClaimablePerWallet),o;if((!d||d&&!u)&&(n.lte(r)||n.eq(0)))return o.push(y.C.AddressNotAllowed),o}let[m,f]=[a.O$.from(0),a.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(l=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[m,f]=await this.contractWrapper.read("getClaimTimestamp",[t,l,h])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([m,f]=await this.contractWrapper.read("getClaimTimestamp",[t,h]));const g=a.O$.from(Date.now()).div(1e3);if(m.gt(0)&&g.lt(f))return f.eq(s.Bz)?o.push(y.C.AlreadyClaimed):o.push(y.C.WaitBeforeNextClaimTransaction),o;if(p.price.gt(0)&&(0,c.d7)()){const t=p.price.mul(e),a=this.contractWrapper.getProvider();if((0,w.i)(p.currencyAddress)){(await a.getBalance(h)).lt(t)&&o.push(y.C.NotEnoughTokens)}else{const e=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new c.cu(a,p.currencyAddress,e,{},this.storage);(await n.read("balanceOf",[h])).lt(t)&&o.push(y.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e,r){const a=(await this.get(t,r)).merkleRoot;if(n.stripZeros(a).length>0){const t=await this.metadata.get(),r=await(0,c.aP)(e);return await(0,y.f)(r,a.toString(),t.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t,e){const r=await(0,c.aP)(e);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,d.c)((()=>{var t=this;return async function(e,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t.setBatch.prepare([{tokenId:e,claimConditions:r}],a)}})());setBatch=(0,d.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a={},s=await Promise.all(e.map((async e=>{let{tokenId:s,claimConditions:o}=e,c=o;if(t.isLegacySinglePhaseDrop(t.contractWrapper))if(r=!0,0===o.length)c=[{startTime:new Date(0),currencyAddress:i.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(o.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&c.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:l,sortedConditions:p}=await(0,y.D)(c,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return l.forEach((t=>{a[t.merkleRoot]=t.snapshotUri})),{tokenId:s,sortedConditions:p}}))),o=await t.metadata.get(),c=[];for(const t of Object.keys(o.merkle||{}))a[t]=o.merkle[t];if(!g()(o.merkle,a)){const e=await t.metadata.parseInputMetadata({...o,merkle:a}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,p.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new w.C(t.contractWrapper);c.push(e.encode("setContractURI",[r]))}}if(s.forEach((e=>{let{tokenId:a,sortedConditions:n}=e;const s=new w.C(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const e=new w.C(t.contractWrapper);c.push(e.encode("setClaimConditions",[a,(0,y.E)(n[0]),r]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(s.encode("setClaimConditions",[a,n.map(y.E),r]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(s.encode("setClaimConditions",[a,(0,y.F)(n[0]),r]));else{if(!t.isNewMultiphaseDrop(t.contractWrapper))throw new Error("Contract does not support claim conditions");c.push(s.encode("setClaimConditions",[a,n.map(y.F),r]))}})),(0,p.h)("multicall",t.contractWrapper))return d.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})());update=(0,d.c)((async(t,e,r)=>{const a=await this.getAll(t),n=await(0,y.H)(e,r,a);return await this.set.prepare(t,n)}));async prepareClaim(t,e,r,a){const n=await(0,c.aP)(a||await this.contractWrapper.getSignerAddress());return(0,y.z)(n,e,await this.getActive(t),(async()=>(await this.metadata.get()).merkle),0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r,a){const n=await(0,c.aP)(e);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},o.Y0("")]:[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},o.Y0("")]}async getClaimTransaction(t,e,r,a){if(a?.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const n=await this.prepareClaim(e,r,a?.checkERC20Allowance||!0);return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(e,t,r,n),overrides:n.overrides})}isNewSinglePhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,p.d)(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,p.d)(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?y.A.V1:y.A.V2}}class v{featureName=c.d8.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r}to=(0,d.c)((async(t,e)=>{const r=e.map((t=>t.metadata)),a=e.map((t=>t.supply)),n=await(0,h.u)(r,this.storage),i=await(0,c.aP)(t),o=new w.C(this.contractWrapper),l=await Promise.all(n.map((async(t,e)=>o.encode("mintTo",[i,s.Bz,t,a[e]]))));return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[l],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===e.length||e.length<r.length)throw new Error("TokenMinted event not found, minting failed");return e.map((e=>{const r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}))}})}))}class k{featureName=c.d9.name;constructor(t){this.contractWrapper=t}tokens=(0,d.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,e)}));from=(0,d.c)((async(t,e,r)=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await(0,c.aP)(t),e,r]})));batch=(0,d.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,e)}));batchFrom=(0,d.c)((async(t,e,r)=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await(0,c.aP)(t),e,r]})))}class S{featureName=c.da.name;constructor(t,e){this.erc1155=t,this.contractWrapper=e}async all(t){const e=a.O$.from(t?.start||0).toNumber(),r=a.O$.from(t?.count||h.D).toNumber(),n=Math.min((await this.totalCount()).toNumber(),e+r);return await Promise.all([...Array(n-e).keys()].map((t=>this.erc1155.get((e+t).toString()))))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,e){const[r,a]=await Promise.all([(0,c.aP)(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let n=(await this.contractWrapper.read("balanceOfBatch",[Array(a.toNumber()).fill(r),Array.from(Array(a.toNumber()).keys())])).map(((t,e)=>({tokenId:e,balance:t}))).filter((t=>t.balance.gt(0)));if(e){const t=e?.start||0,r=e?.count||h.D;n=n.slice(t,t+r)}return(await Promise.all(n.map((t=>this.erc1155.get(t.tokenId.toString()))))).map(((t,e)=>({...t,owner:r,quantityOwned:n[e].balance.toString()})))}}class A{featureName=c.db.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc1155Revealable()}lazyMint=(0,d.c)((async(t,e)=>{const r=await this.erc1155.nextTokenIdToMint(),a=await(0,h.u)(t,this.storage,r.toNumber(),e),n=a[0].substring(0,a[0].lastIndexOf("/"));for(let t=0;t<a.length;t++){const e=a[t].substring(0,a[t].lastIndexOf("/"));if(n!==e)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${e}'`)}const s=t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc1155.getTokenMetadata(e)});return n},i=await(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,i)?d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`],parse:s}):d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`,o.Y0("")],parse:s})}));detectErc1155Revealable(){if((0,p.d)(this.contractWrapper,"ERC1155Revealable"))return new m.D(this.contractWrapper,this.storage,c.dc.name,(()=>this.erc1155.nextTokenIdToMint()))}isLegacyEditionDropContract(t,e){return e&&"DropERC1155"===e.type&&e.version<3||!1}}class T{featureName=c.de.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc1155BatchMintable()}to=(0,d.c)((async(t,e)=>{const r=await this.getMintTransaction(t,e);return r.setParse((t=>{const e=this.contractWrapper.parseLogs("TransferSingle",t?.logs);if(0===e.length)throw new Error("TransferSingleEvent event not found");const r=e[0].args.id;return{id:r,receipt:t,data:()=>this.erc1155.get(r.toString())}})),r}));async getMintTransaction(t,e){const r=await(0,h.b)(e.metadata,this.storage);return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),s.Bz,r,e.supply]})}additionalSupplyTo=(0,d.c)((async(t,e,r)=>{const n=await this.erc1155.getTokenMetadata(e);return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),e,n.uri,r],parse:t=>({id:a.O$.from(e),receipt:t,data:()=>this.erc1155.get(e)})})}));detectErc1155BatchMintable(){if((0,p.d)(this.contractWrapper,"ERC1155BatchMintable"))return new v(this.erc1155,this.contractWrapper,this.storage)}}const I=(()=>u.z.object({address:c.bd,quantity:c.cz.default(1)}))(),x=(()=>u.z.union([u.z.array(u.z.string()).transform((async t=>await Promise.all(t.map((t=>I.parseAsync({address:t})))))),u.z.array(I)]))();class E{featureName=c.df.name;constructor(t){this.contractWrapper=t}async getClaimTransaction(t,e,r,a){let n={};return a&&a.pricePerToken&&(n=await(0,m.c)(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await(0,c.aP)(t),e,r],overrides:n})}to=(0,d.c)((async(t,e,r,a)=>await this.getClaimTransaction(t,e,r,a)))}class R{featureName=c.dg.name;constructor(t,e){this.contractWrapper=t,this.storage=e;const r=new p.C(this.contractWrapper,c.bk,this.storage);this.conditions=new P(t,r,this.storage)}to=(0,d.c)((async(t,e,r,a)=>await this.conditions.getClaimTransaction(t,e,r,a)))}class N{featureName=c.dh.name;constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.roles=r}mint=(0,d.c)((async t=>{const e=t.payload,r=t.signature,[a,n]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,b.s)(this.contractWrapper,a.pricePerToken.mul(a.quantity),e.currencyAddress,n),d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,r],overrides:n,parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return{id:e[0].args.tokenIdMinted,receipt:t}}})}));mintBatch=(0,d.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const n=e[r],s=t.signature,i=t.payload.price;if(a.O$.from(i).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:s}})),n=new w.C(this.contractWrapper),s=r.map((t=>n.encode("mintWithSignature",[t.message,t.signature])));if((0,p.h)("multicall",this.contractWrapper))return d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return e.map((e=>({id:e.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not supported on this contract!")}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){const e={...t,tokenId:s.Bz};return this.generateFromTokenId(e)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const e=t.map((t=>({...t,tokenId:s.Bz})));return this.generateBatchFromTokenIds(e)}async generateBatchFromTokenIds(t){const e=this.contractWrapper.getSigner();(0,C.Z)(e,"No signer available"),await(this.roles?.verify(["minter"],await e.getAddress()));const r=await Promise.all(t.map((t=>y.o.parseAsync(t)))),a=r.map((t=>t.metadata)),[n,s,i]=await Promise.all([(0,h.u)(a,this.storage),this.contractWrapper.getChainID(),(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider())]),o=await Promise.all(r.map(((t,e)=>y.p.parseAsync({...t,uri:n[e]})))),l=await Promise.all(o.map((t=>this.mapPayloadToContractStruct(t)))),p="TokenERC1155"===i?.type;return(await Promise.all(l.map((t=>this.contractWrapper.signTypedData(e,{name:p?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:s,verifyingContract:this.contractWrapper.address},{MintRequest:y.t},t))))).map(((t,e)=>({payload:o[e],signature:t.toString()})))}async mapPayloadToContractStruct(t){const e=await(0,W.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class M{featureName=c.di.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,r]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch((()=>a.O$.from(0))),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...h.F})))]);return{owner:i.d,metadata:r,type:"ERC1155",supply:e.toString()}}async totalSupply(t){if((0,p.d)(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new c.x(c.dj)}async balanceOf(t,e){return await this.contractWrapper.read("balanceOf",[await(0,c.aP)(t),e])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,e){return await this.contractWrapper.read("isApprovedForAll",[await(0,c.aP)(t),await(0,c.aP)(e)])}transfer=(0,d.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const s=await t.contractWrapper.getSignerAddress();return d.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[s,await(0,c.aP)(e),r,a,n]})}})());transferFrom=(0,d.c)((()=>{var t=this;return async function(e,r,a,n){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[0];return d.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await(0,c.aP)(e),await(0,c.aP)(r),a,n,s]})}})());setApprovalForAll=(0,d.c)((async(t,e)=>d.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,e]})));airdrop=(0,d.c)((()=>{var t=this;return async function(e,r,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const i=n?await(0,c.aP)(n):await t.contractWrapper.getSignerAddress(),o=await t.balanceOf(i,e),l=await x.parseAsync(r),p=l.reduce(((t,e)=>a.O$.from(t).add(a.O$.from(e?.quantity||1))),a.O$.from(0));if(o.lt(a.O$.from(p)))throw new Error(`The caller owns ${o.toString()} NFTs, but wants to airdrop ${p.toString()} NFTs.`);const h=new w.C(t.contractWrapper),u=l.map((t=>{let{address:r,quantity:a}=t;return h.encode("safeTransferFrom",[i,r,e,a,s])}));return d.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[u]})}})());async nextTokenIdToMint(){if((0,p.h)("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return(0,l.a)(this.query,c.da).all(t)}async totalCount(){return(0,l.a)(this.query,c.da).totalCount()}async totalCirculatingSupply(t){return(0,l.a)(this.query,c.da).totalCirculatingSupply(t)}async getOwned(t,e){return t&&(t=await(0,c.aP)(t)),(0,l.a)(this.query,c.da).owned(t,e)}mint=(0,d.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,d.c)((async(t,e)=>(0,l.a)(this.mintable,c.de).to.prepare(t,e)));async getMintTransaction(t,e){return(0,l.a)(this.mintable,c.de).getMintTransaction(t,e)}mintAdditionalSupply=(0,d.c)((async(t,e)=>(0,l.a)(this.mintable,c.de).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));mintAdditionalSupplyTo=(0,d.c)((async(t,e,r)=>(0,l.a)(this.mintable,c.de).additionalSupplyTo.prepare(t,e,r)));mintBatch=(0,d.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=(0,d.c)((async(t,e)=>(0,l.a)(this.mintable?.batch,c.d8).to.prepare(t,e)));burn=(0,d.c)((async(t,e)=>(0,l.a)(this.burnable,c.d9).tokens.prepare(t,e)));burnFrom=(0,d.c)((async(t,e,r)=>(0,l.a)(this.burnable,c.d9).from.prepare(t,e,r)));burnBatch=(0,d.c)((async(t,e)=>(0,l.a)(this.burnable,c.d9).batch.prepare(t,e)));burnBatchFrom=(0,d.c)((async(t,e,r)=>(0,l.a)(this.burnable,c.d9).batchFrom.prepare(t,e,r)));lazyMint=(0,d.c)((async(t,e)=>(0,l.a)(this.lazyMintable,c.db).lazyMint.prepare(t,e)));async getClaimTransaction(t,e,r,a){const n=this.claimWithConditions,s=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,e,r,a);if(s)return s.getClaimTransaction(t,e,r,a);throw new c.x(c.df)}claim=(0,d.c)((async(t,e,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e,r)));claimTo=(0,d.c)((async(t,e,r,a)=>{const n=this.claimWithConditions,s=this.claimCustom;if(n)return n.to.prepare(t,e,r,a);if(s)return s.to.prepare(t,e,r,a);throw new c.x(c.df)}));get claimConditions(){return(0,l.a)(this.claimWithConditions,c.dg).conditions}get signature(){return(0,l.a)(this.signatureMintable,c.dh)}get revealer(){return(0,l.a)(this.lazyMintable?.revealer,c.dc)}async getTokenMetadata(t){const e=await this.contractWrapper.read("uri",[t]);if(!e)throw new c.n;return(0,h.f)(t,e,this.storage)}detectErc1155Enumerable(){if((0,p.d)(this.contractWrapper,"ERC1155Enumerable"))return new S(this,this.contractWrapper)}detectErc1155Mintable(){if((0,p.d)(this.contractWrapper,"ERC1155Mintable"))return new T(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if((0,p.d)(this.contractWrapper,"ERC1155Burnable"))return new k(this.contractWrapper)}detectErc1155LazyMintable(){if((0,p.d)(this.contractWrapper,"ERC1155LazyMintableV1")||(0,p.d)(this.contractWrapper,"ERC1155LazyMintableV2"))return new A(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if((0,p.d)(this.contractWrapper,"ERC1155SignatureMintable"))return new N(this.contractWrapper,this.storage)}detectErc1155Claimable(){if((0,p.d)(this.contractWrapper,"ERC1155ClaimCustom"))return new E(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if((0,p.d)(this.contractWrapper,"ERC1155ClaimConditionsV1")||(0,p.d)(this.contractWrapper,"ERC1155ClaimConditionsV2")||(0,p.d)(this.contractWrapper,"ERC1155ClaimPhasesV1")||(0,p.d)(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new R(this.contractWrapper,this.storage)}}},71358:(t,e,r)=>{"use strict";r.d(e,{S:()=>s});var a=r(19578),n=r(40795);class s{get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.erc1155=new n.e(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){return this.erc1155.get(t)}async totalSupply(t){return this.erc1155.totalSupply(t)}async balanceOf(t,e){return this.erc1155.balanceOf(t,e)}async balance(t){return this.erc1155.balance(t)}async isApproved(t,e){return this.erc1155.isApproved(t,e)}transfer=(0,a.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];return t.erc1155.transfer.prepare(e,r,a,n)}})());setApprovalForAll=(0,a.c)((async(t,e)=>this.erc1155.setApprovalForAll.prepare(t,e)));airdrop=(0,a.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];return t.erc1155.airdrop.prepare(e,r,a,n)}})())}},11846:(t,e,r)=>{"use strict";r.d(e,{e:()=>W,f:()=>b});var a=r(2593),n=r(61744),s=r(68828),i=r(7860),o=r(89208),c=r(89536),l=r(19578),p=r(62245),h=r(38776),d=r(19824),u=r(41518),m=r(58179);class f{featureName=i.cG.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}to=(0,l.c)((async t=>{const e=new s.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([(0,i.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[r,a]=t;return e.encode("mintTo",[r,a])}));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}))}class g{featureName=i.cH.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}tokens=(0,l.c)((async t=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})));from=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(e)])})))}class y{featureName=i.cI.name;constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r;const a=new c.C(this.contractWrapper,i.bk,this.storage);this.conditions=new p.D(this.contractWrapper,a,this.storage)}to=(0,l.c)((async(t,e,r)=>{const a=await this.erc20.normalizeAmount(e);return await this.conditions.getClaimTransaction(t,a,r)}))}class w{constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r,this.claim=new y(this.erc20,this.contractWrapper,this.storage)}}class C{featureName=i.cJ.name;constructor(t,e){this.erc20=t,this.contractWrapper=e,this.batch=this.detectErc20BatchMintable()}to=(0,l.c)((async(t,e)=>await this.getMintTransaction(t,e)));async getMintTransaction(t,e){return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(e)])})}detectErc20BatchMintable(){if((0,c.d)(this.contractWrapper,"ERC20BatchMintable"))return new f(this.erc20,this.contractWrapper)}}class W{featureName=i.cK.name;constructor(t,e){this.contractWrapper=t,this.roles=e}mint=(0,l.c)((async t=>{const e=t.payload,r=t.signature,[n,s]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,u.s)(this.contractWrapper,a.O$.from(n.price),e.currencyAddress,s),l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,r],overrides:s})}));mintBatch=(0,l.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const n=e[r],s=t.signature,i=t.payload.price;if(a.O$.from(i).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:s}})),n=new s.C(this.contractWrapper),i=r.map((t=>n.encode("mintWithSignature",[t.message,t.signature])));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i]})}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await(this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[e,r,a]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>m.S.parseAsync(t))))]),n=this.contractWrapper.getSigner();(0,h.Z)(n,"No signer available");const s=await Promise.all(a.map((t=>m.k.parseAsync(t)))),i=await Promise.all(s.map((t=>this.mapPayloadToContractStruct(t)))),o=await Promise.all(i.map((t=>this.contractWrapper.signTypedData(n,{name:r,version:"1",chainId:e,verifyingContract:this.contractWrapper.address},{MintRequest:m.M},t))));return a.map(((t,e)=>({payload:s[e],signature:o[e].toString()})))}async mapPayloadToContractStruct(t){const[e,r]=await Promise.all([(0,d.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),a=n.parseUnits(t.quantity,r);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:a,price:e,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class b{featureName=i.cL.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await(0,s.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await(0,i.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[e,r]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,i.aP)(t)]);return await this.allowanceOf(e,r)}async allowanceOf(t,e){const r=await Promise.all([(0,i.aP)(t),(0,i.aP)(e)]);return await this.getValue(await this.contractWrapper.read("allowance",r))}transfer=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(e)])})));transferFrom=(0,l.c)((async(t,e,r)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,i.aP)(t),(0,i.aP)(e),this.normalizeAmount(r)])})));setAllowance=(0,l.c)((async(t,e)=>l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(e)])})));transferBatch=(0,l.c)((async t=>{const e=new s.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),(0,i.aP)(t.toAddress)]))))).map((t=>{let[r,a]=t;return e.encode("transfer",[a,r])}));return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));mint=(0,l.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,l.c)((async(t,e)=>(0,o.a)(this.mintable,i.cJ).to.prepare(t,e)));async getMintTransaction(t,e){return(0,o.a)(this.mintable,i.cJ).getMintTransaction(t,e)}mintBatchTo=(0,l.c)((async t=>(0,o.a)(this.mintable?.batch,i.cG).to.prepare(t)));burn=(0,l.c)((async t=>(0,o.a)(this.burnable,i.cH).tokens.prepare(t)));burnFrom=(0,l.c)((async(t,e)=>(0,o.a)(this.burnable,i.cH).from.prepare(t,e)));claim=(0,l.c)((async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));claimTo=(0,l.c)((async(t,e,r)=>(0,o.a)(this.droppable?.claim,i.cI).to.prepare(t,e,r)));get claimConditions(){return(0,o.a)(this.droppable?.claim,i.cI).conditions}get signature(){return(0,o.a)(this.signatureMintable,i.cK)}async normalizeAmount(t){return async function(t,e){const r=await t.read("decimals",[]);return n.parseUnits(i.cz.parse(e),r)}(this.contractWrapper,t)}async getValue(t){return await(0,s.a)(this.contractWrapper.getProvider(),this.getAddress(),a.O$.from(t))}detectErc20Mintable(){if((0,c.d)(this.contractWrapper,"ERC20"))return new C(this,this.contractWrapper)}detectErc20Burnable(){if((0,c.d)(this.contractWrapper,"ERC20Burnable"))return new g(this,this.contractWrapper)}detectErc20Droppable(){if((0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new w(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,c.d)(this.contractWrapper,"ERC20SignatureMintable"))return new W(this.contractWrapper)}}},6062:(t,e,r)=>{"use strict";r.d(e,{h:()=>n});var a=r(7860);async function n(t,e,n){const s=t.getProvider(),i=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=new a.cu(s,e,i,{},t.storage),c=await t.getSignerAddress(),l=t.address;return(await o.read("allowance",[c,l])).gte(n)}},48109:(t,e,r)=>{"use strict";r.d(e,{a:()=>u,g:()=>m,h:()=>p,i:()=>l,m:()=>d,v:()=>h});var a=r(64146),n=r(2593),s=r(38776),i=r(89050),o=r(7860),c=r(68828);async function l(t,e,n,s,o){try{const c=(await r.e(5025).then(r.t.bind(r,25025,19))).default,l=new a.CH(n,c,t),[p,h]=await Promise.all([l.supportsInterface(i.I),l.supportsInterface(i.a)]);if(p){const i=(await Promise.resolve().then(r.t.bind(r,70332,19))).default,c=new a.CH(n,i,t);if(await c.isApprovedForAll(o,e))return!0;let l;try{l=await c.getApproved(s)}catch(t){}return l?.toLowerCase()===e.toLowerCase()}if(h){const s=(await Promise.resolve().then(r.t.bind(r,8455,19))).default,i=new a.CH(n,s,t);return await i.isApprovedForAll(o,e)}return console.error("Contract does not implement ERC 1155 or ERC 721."),!1}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function p(t,e,a,n,s){const c=(await r.e(5025).then(r.t.bind(r,25025,19))).default,l=new o.cu(t.getSignerOrProvider(),a,c,t.options,t.storage),[p,h]=await Promise.all([l.read("supportsInterface",[i.I]),l.read("supportsInterface",[i.a])]);if(p){const i=(await Promise.resolve().then(r.t.bind(r,70332,19))).default,c=new o.cu(t.getSignerOrProvider(),a,i,t.options,t.storage);if(!await c.read("isApprovedForAll",[s,e])){(await c.read("getApproved",[n])).toLowerCase()===e.toLowerCase()||await c.sendTransaction("setApprovalForAll",[e,!0])}}else{if(!h)throw Error("Contract must implement ERC 1155 or ERC 721.");{const n=(await Promise.resolve().then(r.t.bind(r,8455,19))).default,i=new o.cu(t.getSignerOrProvider(),a,n,t.options,t.storage);await i.read("isApprovedForAll",[s,e])||await i.sendTransaction("setApprovalForAll",[e,!0])}}}function h(t){if((0,s.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,s.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,s.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,s.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,s.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,s.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type)(0,s.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function d(t,e,r){return{quantity:r.quantityDesired,pricePerToken:r.pricePerToken,currencyContractAddress:r.currency,buyerAddress:r.offeror,quantityDesired:r.quantityWanted,currencyValue:await(0,c.a)(t,r.currency,r.quantityWanted.mul(r.pricePerToken)),listingId:e}}function u(t,e,r){if(r=n.O$.from(r),t=n.O$.from(t),e=n.O$.from(e),t.eq(n.O$.from(0)))return!1;return e.sub(t).mul(o.dy).div(t).gte(r)}async function m(t,e,r){const a=[];for(;e-t>i.D;)a.push(r(t,t+i.D-1)),t+=i.D;return a.push(r(t,e-1)),await Promise.all(a)}},55132:(t,e,r)=>{"use strict";r.r(e),r.d(e,{Pack:()=>B});var a=r(2593),n=r(61744),s=r(9279),i=r(68828),o=r(6062),c=r(19824),l=r(7860),p=r(89208),h=r(89536),d=r(48109),u=r(89050),m=r(19578),f=r(52153),g=r(83833),y=r(74935),w=r(71358),C=r(27761),W=r(11846),b=r(41518),P=r(1604);const v=(()=>P.z.object({contractAddress:l.bd}))(),k=(()=>v.extend({quantity:l.cz}))(),S=(()=>v.extend({tokenId:l.ba}))(),A=(()=>v.extend({tokenId:l.ba,quantity:l.ba}))(),T=(()=>k.omit({quantity:!0}).extend({quantityPerReward:l.cz}))(),I=S,x=(()=>A.omit({quantity:!0}).extend({quantityPerReward:l.ba}))(),E=(()=>T.extend({totalRewards:l.ba.default("1")}))(),R=I,N=(()=>x.extend({totalRewards:l.ba.default("1")}))(),M=(()=>P.z.object({erc20Rewards:P.z.array(E).default([]),erc721Rewards:P.z.array(R).default([]),erc1155Rewards:P.z.array(N).default([])}))(),O=(()=>M.extend({packMetadata:b.N,rewardsPerPack:l.ba.default("1"),openStartTime:p.R.default(new Date)}))();r(13550),r(77191),r(54146),r(64063);class D{featureName=l.dD.name;constructor(t,e,r,a,n){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new l.cu(t,e,C,a,r);this.contractWrapper=s,this.storage=r,this.chainId=n,this.events=new h.a(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}open=(0,m.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5e5;return m.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"openPack",args:[e,r],overrides:{gasLimit:n},parse:e=>{let r=a.O$.from(0);try{r=t.contractWrapper.parseLogs("PackOpenRequested",e?.logs)[0].args.requestId}catch(t){}return{receipt:e,id:r}}})}})());claimRewards=(0,m.c)((()=>{var t=this;return async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5e5;return m.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"claimRewards",args:[],overrides:{gasLimit:e},parse:async e=>{const r=t.contractWrapper.parseLogs("PackOpened",e?.logs);if(0===r.length)throw new Error("PackOpened event not found");const a=r[0].args.rewardUnitsDistributed;return await t.parseRewards(a)}})}})());async parseRewards(t){const e=[],r=[],a=[];for(const s of t)switch(s.tokenType){case 0:{const t=await(0,i.f)(this.contractWrapper.getProvider(),s.assetContract);e.push({contractAddress:s.assetContract,quantityPerReward:n.formatUnits(s.totalAmount,t.decimals).toString()});break}case 1:r.push({contractAddress:s.assetContract,tokenId:s.tokenId.toString()});break;case 2:a.push({contractAddress:s.assetContract,tokenId:s.tokenId.toString(),quantityPerReward:s.totalAmount.toString()})}return{erc20Rewards:e,erc721Rewards:r,erc1155Rewards:a}}async addPackOpenEventListener(t){return this.events.addEventListener("PackOpened",(async e=>{t(e.data.packId.toString(),e.data.opener,await this.parseRewards(e.data.rewardUnitsDistributed))}))}async canClaimRewards(t){const e=await(0,l.aP)(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("canClaimRewards",[e])}async openAndClaim(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5e5;const n=await this.contractWrapper.sendTransaction("openPackAndClaimRewards",[t,e,r],{gasLimit:a.O$.from(5e5)});let s=a.O$.from(0);try{s=this.contractWrapper.parseLogs("PackOpenRequested",n?.logs)[0].args.requestId}catch(t){}return{receipt:n,id:s}}async getLinkBalance(){const t=(await Promise.resolve().then(r.t.bind(r,49242,19))).default;return this.getLinkContract(t).balanceOf(this.contractWrapper.address)}async transferLink(t){const e=(await Promise.resolve().then(r.t.bind(r,49242,19))).default;await this.getLinkContract(e).transfer(this.contractWrapper.address,t)}getLinkContract(t){const e=l.b0[this.chainId];if(!e)throw new Error(`No LINK token address found for chainId ${this.chainId}`);const r=new l.cu(this.contractWrapper.getSignerOrProvider(),e,t,this.contractWrapper.options,this.storage);return new W.f(r,this.storage,this.chainId)}}class B extends w.S{static contractRoles=l.dE;get vrf(){return(0,p.a)(this._vrf,l.dD)}constructor(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;super(arguments.length>6&&void 0!==arguments[6]?arguments[6]:new l.cu(t,e,n,a.gasless&&"openzeppelin"in a.gasless?{...a,gasless:{...a.gasless,openzeppelin:{...a.gasless.openzeppelin,useEOAForwarder:!0}}}:a,r),r,s),this.abi=l.bn.parse(n||[]),this.metadata=new h.C(this.contractWrapper,l.c5,this.storage),this.app=new h.b(this.contractWrapper,this.metadata,this.storage),this.roles=new y.C(this.contractWrapper,B.contractRoles),this.royalties=new g.C(this.contractWrapper,this.metadata),this.encoder=new i.C(this.contractWrapper),this.estimator=new h.G(this.contractWrapper),this.events=new h.a(this.contractWrapper),this.interceptor=new f.C(this.contractWrapper),this.owner=new g.a(this.contractWrapper),this._vrf=this.detectVrf()}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t),this._vrf?.onNetworkUpdated(t)}getAddress(){return this.contractWrapper.address}async get(t){return this.erc1155.get(t)}async getAll(t){return this.erc1155.getAll(t)}async getOwned(t){return this.erc1155.getOwned(t)}async getTotalCount(){return this.erc1155.totalCount()}async isTransferRestricted(){return!await this.contractWrapper.read("hasRole",[(0,l.H)("transfer"),s.d])}async getPackContents(t){const{contents:e,perUnitAmounts:r}=await this.contractWrapper.read("getPackContents",[t]),s=[],o=[],c=[];for(let t=0;t<e.length;t++){const l=e[t],p=r[t];switch(l.tokenType){case 0:{const t=await(0,i.f)(this.contractWrapper.getProvider(),l.assetContract),e=n.formatUnits(p,t.decimals),r=n.formatUnits(a.O$.from(l.totalAmount).div(p),t.decimals);s.push({contractAddress:l.assetContract,quantityPerReward:e,totalRewards:r});break}case 1:o.push({contractAddress:l.assetContract,tokenId:l.tokenId.toString()});break;case 2:c.push({contractAddress:l.assetContract,tokenId:l.tokenId.toString(),quantityPerReward:p.toString(),totalRewards:a.O$.from(l.totalAmount).div(p).toString()})}}return{erc20Rewards:s,erc721Rewards:o,erc1155Rewards:c}}create=(0,m.c)((async t=>{const e=await this.contractWrapper.getSignerAddress();return this.createTo.prepare(e,t)}));addPackContents=(0,m.c)((async(t,e)=>{const[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),M.parseAsync(e)]),{contents:n,numOfRewardUnits:s}=await this.toPackContentArgs(a);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"addPackContents",args:[t,n,s,r],parse:t=>{const e=this.contractWrapper.parseLogs("PackUpdated",t?.logs);if(0===e.length)throw new Error("PackUpdated event not found");const r=e[0].args.packId;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}})}));createTo=(0,m.c)((async(t,e)=>{const[r,a,n]=await Promise.all([(0,u.b)(e.packMetadata,this.storage),O.parseAsync(e),(0,l.aP)(t)]),{erc20Rewards:s,erc721Rewards:i,erc1155Rewards:o}=a,c={erc20Rewards:s,erc721Rewards:i,erc1155Rewards:o},{contents:p,numOfRewardUnits:h}=await this.toPackContentArgs(c);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createPack",args:[p,h,r,a.openStartTime,a.rewardsPerPack,n],parse:t=>{const e=this.contractWrapper.parseLogs("PackCreated",t?.logs);if(0===e.length)throw new Error("PackCreated event not found");const r=e[0].args.packId;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}})}));open=(0,m.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5e5;if(t._vrf)throw new Error("This contract is using Chainlink VRF, use `contract.vrf.open()` or `contract.vrf.openAndClaim()` instead");return m.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"openPack",args:[e,r],overrides:{gasLimit:a},parse:async e=>{const r=t.contractWrapper.parseLogs("PackOpened",e?.logs);if(0===r.length)throw new Error("PackOpened event not found");const a=r[0].args.rewardUnitsDistributed,s=[],o=[],c=[];for(const e of a)switch(e.tokenType){case 0:{const r=await(0,i.f)(t.contractWrapper.getProvider(),e.assetContract);s.push({contractAddress:e.assetContract,quantityPerReward:n.formatUnits(e.totalAmount,r.decimals).toString()});break}case 1:o.push({contractAddress:e.assetContract,tokenId:e.tokenId.toString()});break;case 2:c.push({contractAddress:e.assetContract,tokenId:e.tokenId.toString(),quantityPerReward:e.totalAmount.toString()})}return{erc20Rewards:s,erc721Rewards:o,erc1155Rewards:c}}})}})());async toPackContentArgs(t){const e=[],r=[],{erc20Rewards:n,erc721Rewards:s,erc1155Rewards:i}=t,l=this.contractWrapper.getProvider(),p=await this.contractWrapper.getSignerAddress();for(const t of n){const a=(await(0,c.n)(l,t.quantityPerReward,t.contractAddress)).mul(t.totalRewards);if(!await(0,o.h)(this.contractWrapper,t.contractAddress,a))throw new Error(`ERC20 token with contract address "${t.contractAddress}" does not have enough allowance to transfer.\n\nYou can set allowance to the multiwrap contract to transfer these tokens by running:\n\nawait sdk.getToken("${t.contractAddress}").setAllowance("${this.getAddress()}", ${a});\n\n`);r.push(t.totalRewards),e.push({assetContract:t.contractAddress,tokenType:0,totalAmount:a,tokenId:0})}for(const t of s){if(!await(0,d.i)(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,p))throw new Error(`ERC721 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.\n\nYou can give approval the multiwrap contract to transfer this token by running:\n\nawait sdk.getNFTCollection("${t.contractAddress}").setApprovalForToken("${this.getAddress()}", ${t.tokenId});\n\n`);r.push("1"),e.push({assetContract:t.contractAddress,tokenType:1,totalAmount:1,tokenId:t.tokenId})}for(const t of i){if(!await(0,d.i)(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,p))throw new Error(`ERC1155 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.\n\nYou can give approval the multiwrap contract to transfer this token by running:\n\nawait sdk.getEdition("${t.contractAddress}").setApprovalForAll("${this.getAddress()}", true);\n\n`);r.push(t.totalRewards),e.push({assetContract:t.contractAddress,tokenType:2,totalAmount:a.O$.from(t.quantityPerReward).mul(a.O$.from(t.totalRewards)),tokenId:t.tokenId})}return{contents:e,numOfRewardUnits:r}}async prepare(t,e,r){return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}detectVrf(){if((0,h.d)(this.contractWrapper,"PackVRF"))return new D(this.contractWrapper.getSignerOrProvider(),this.contractWrapper.address,this.storage,this.contractWrapper.options,this.chainId)}}},41518:(t,e,r)=>{"use strict";r.d(e,{B:()=>c,C:()=>h,N:()=>p,a:()=>l,s:()=>d});var a=r(7860),n=r(1604),s=r(68828);const i=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(i),i]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),l=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cA,n.z.unknown()])))(),p=(()=>n.z.union([l,n.z.string()]))(),h=(()=>l.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function d(t,e,n,i){if(!(0,s.i)(n)){const s=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=t.getSigner(),c=t.getProvider(),l=new a.cu(o||c,n,s,t.options,t.storage),p=await t.getSignerAddress(),h=t.address;return(await l.read("allowance",[p,h])).lt(e)&&await l.sendTransaction("approve",[h,e]),i}i.value=e}},58179:(t,e,r)=>{"use strict";r.d(e,{A:()=>R,B:()=>K,C:()=>G,D:()=>j,E:()=>T,F:()=>I,H:()=>Y,I:()=>Q,M:()=>ct,S:()=>X,a:()=>B,f:()=>M,k:()=>tt,o:()=>nt,p:()=>st,q:()=>it,r:()=>ot,s:()=>lt,t:()=>pt,u:()=>ht,v:()=>J,w:()=>O,x:()=>D,y:()=>x,z:()=>L});var a=r(21046),n=r(61744),s=r(31886),i=r(9279),o=r(38197),c=r(2593),l=r(16441),p=r(29251),h=r(7860),d=r(68828),u=r(19824),m=r(48764),f=r(56351),g=r.n(f),y=r(99269);class w{print(){w.print(this)}bufferIndexOf(t,e){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(t,e,m.Buffer.compare);return this.linearSearch(t,e,((t,e)=>t.equals(e)))}static binarySearch(t,e,r){let a=0,n=t.length-1;for(;a<=n;){const s=Math.floor((a+n)/2),i=r(t[s],e);if(0===i){for(let a=s-1;a>=0;a--)if(0!==r(t[a],e))return a+1;return 0}i<0?a=s+1:n=s-1}return-1}binarySearch(t,e,r){return w.binarySearch(t,e,r)}static linearSearch(t,e,r){for(let a=0;a<t.length;a++)if(r(t[a],e))return a;return-1}linearSearch(t,e,r){return w.linearSearch(t,e,r)}static bufferify(t){if(!m.Buffer.isBuffer(t)){if("object"==typeof t&&t.words)return m.Buffer.from(t.toString(W),"hex");if(w.isHexString(t))return m.Buffer.from(t.replace(/^0x/,""),"hex");if("string"==typeof t)return m.Buffer.from(t);if("bigint"==typeof t)return m.Buffer.from(t.toString(16),"hex");if(t instanceof Uint8Array)return m.Buffer.from(t.buffer);if("number"==typeof t){let e=t.toString();return e.length%2&&(e=`0${e}`),m.Buffer.from(e,"hex")}if(ArrayBuffer.isView(t))return m.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}return t}bigNumberify(t){return w.bigNumberify(t)}static bigNumberify(t){if("bigint"==typeof t)return t;if("string"==typeof t)return t.startsWith("0x")&&w.isHexString(t)?BigInt("0x"+t.replace("0x","").toString()):BigInt(t);if(m.Buffer.isBuffer(t))return BigInt("0x"+t.toString("hex"));if(t instanceof Uint8Array)return function(t){const e=Array.from(t).map((t=>t.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${e}`)}(t);if("number"==typeof t)return BigInt(t);throw new Error("cannot bigNumberify")}static isHexString(t){return"string"==typeof t&&/^(0x)?[0-9A-Fa-f]*$/.test(t)}static print(t){console.log(t.toString())}bufferToHex(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(t,e)}static bufferToHex(t){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(t||m.Buffer.alloc(0)).toString("hex")}`}bufferify(t){return w.bufferify(t)}bufferifyFn(t){return e=>{const r=t(e);if(m.Buffer.isBuffer(r))return r;if(this.isHexString(r))return m.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return m.Buffer.from(r);if("bigint"==typeof r)return m.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(r))return m.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e.buffer}(e.toString("hex")),n=function(t){const e=new Uint8Array(t);return Array.from(e).map((t=>t.toString(16).padStart(2,"0"))).join("")}(t(a));return m.Buffer.from(n,"hex")}}isHexString(t){return w.isHexString(t)}log2(t){return 1===t?0:1+this.log2(t/2|0)}zip(t,e){return t.map(((t,r)=>[t,e[r]]))}static hexZeroPad(t,e){return"0x"+t.replace("0x","").padStart(e,"0")}}var C=w;function W(t){const e=t.words,r=new ArrayBuffer(4*e.length),a=new Uint8Array(r);for(let t=0;t<e.length;t++)a[4*t]=e[t]>>24&255,a[4*t+1]=e[t]>>16&255,a[4*t+2]=e[t]>>8&255,a[4*t+3]=255&e[t];return r}class b extends C{duplicateOdd=!1;concatenator=m.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!m.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(t,e)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(e),this.processLeaves(t)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(t){if(this.hashLeaves&&(t=t.map(this.hashFn)),this.leaves=t.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(m.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(t){for(this.layers=[t];t.length>1;){const e=this.layers.length;this.layers.push([]);const r=this.complete&&1===e&&!Number.isInteger(Math.log2(t.length))?2*t.length-2**Math.ceil(Math.log2(t.length)):t.length;for(let a=0;a<t.length;a+=2){if(a>=r){this.layers[e].push(...t.slice(r));break}if(a+1===t.length&&t.length%2==1){const r=t[t.length-1];let n=r;if(this.isBitcoinTree){n=this.hashFn(this.concatenator([g()(r),g()(r)])),n=g()(this.hashFn(n)),this.layers[e].push(n);continue}if(!this.duplicateOdd){this.layers[e].push(t[a]);continue}}const n=t[a],s=a+1===t.length?n:t[a+1];let i=null;i=this.isBitcoinTree?[g()(n),g()(s)]:[n,s],this.sortPairs&&i.sort(m.Buffer.compare);let o=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(o=g()(this.hashFn(o))),this.layers[e].push(o)}t=this.layers[e]}}addLeaf(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=this.hashFn(t)),this.processLeaves(this.leaves.concat(t))}addLeaves(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=t.map(this.hashFn)),this.processLeaves(this.leaves.concat(t))}getLeaves(t){return Array.isArray(t)?(this.hashLeaves&&(t=t.map(this.hashFn),this.sortLeaves&&(t=t.sort(m.Buffer.compare))),this.leaves.filter((e=>-1!==this.bufferIndexOf(t,e,this.sortLeaves)))):this.leaves}getLeaf(t){return t<0||t>this.leaves.length-1?m.Buffer.from([]):this.leaves[t]}getLeafIndex(t){t=this.bufferify(t);const e=this.getLeaves();for(let r=0;r<e.length;r++){if(e[r].equals(t))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((t=>this.bufferToHex(t)))}static marshalLeaves(t){return JSON.stringify(t.map((t=>b.bufferToHex(t))),null,2)}static unmarshalLeaves(t){let e=null;if("string"==typeof t)e=JSON.parse(t);else{if(!(t instanceof Object))throw new Error("Expected type of string or object");e=t}if(!e)return[];if(!Array.isArray(e))throw new Error("Expected JSON string to be array");return e.map(b.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((t,e)=>(Array.isArray(e)?t.push(e.map((t=>this.bufferToHex(t)))):t.push(e),t)),[])}getLayersFlat(){const t=this.layers.reduce(((t,e)=>(Array.isArray(e)?t.unshift(...e):t.unshift(e),t)),[]);return t.unshift(m.Buffer.from([0])),t}getHexLayersFlat(){return this.getLayersFlat().map((t=>this.bufferToHex(t)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?m.Buffer.from([]):this.layers[this.layers.length-1][0]||m.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(t,e){if(void 0===t)throw new Error("leaf is required");t=this.bufferify(t);const r=[];if(!Number.isInteger(e)){e=-1;for(let r=0;r<this.leaves.length;r++)0===m.Buffer.compare(t,this.leaves[r])&&(e=r)}if(e<=-1)return[];for(let t=0;t<this.layers.length;t++){const a=this.layers[t],n=e%2,s=n?e-1:this.isBitcoinTree&&e===a.length-1&&t<this.layers.length-1?e:e+1;s<a.length&&r.push({position:n?"left":"right",data:a[s]}),e=e/2|0}return r}getHexProof(t,e){return this.getProof(t,e).map((t=>this.bufferToHex(t.data)))}getProofs(){const t=[];return this.getProofsDFS(this.layers.length-1,0,[],t),t}getProofsDFS(t,e,r,a){const n=e%2;if(-1===t)return void(n||a.push([...r].reverse()));if(e>=this.layers[t].length)return;const s=this.layers[t],i=n?e-1:e+1;let o=!1;i<s.length&&(o=!0,r.push({position:n?"left":"right",data:s[i]}));const c=2*e,l=2*e+1;this.getProofsDFS(t-1,c,r,a),this.getProofsDFS(t-1,l,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((t=>this.bufferToHex(t.data)))}getPositionalHexProof(t,e){return this.getProof(t,e).map((t=>["left"===t.position?0:1,this.bufferToHex(t.data)]))}getProofIndices(t,e){const r=2**e;let a=new Set;for(const e of t){let t=r+e;for(;t>1;)a.add(1^t),t=t/2|0}const n=t.map((t=>r+t)),s=Array.from(a).sort(((t,e)=>t-e)).reverse();a=n.concat(s);const i=new Set,o=[];for(let t of a)if(!i.has(t))for(o.push(t);t>1&&(i.add(t),i.has(1^t));)t=t/2|0;return o.filter((e=>!t.includes(e-r)))}getProofIndicesForUnevenTree(t,e){const r=Math.ceil(Math.log2(e)),a=[];for(let t=0;t<r;t++){e%2!=0&&a.push({index:t,leavesCount:e}),e=Math.ceil(e/2)}const n=[];let s=t;for(let t=0;t<r;t++){let e=s.map((t=>t%2==0?t+1:t-1)).filter((t=>!s.includes(t)));const r=a.find((e=>{let{index:r}=e;return r===t}));r&&s.includes(r.leavesCount-1)&&(e=e.slice(0,-1)),n.push(e),s=[...new Set(s.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))]}return n}getMultiProof(t,e){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),e||(e=t,t=this.getLayersFlat());if(this.isUnevenTree()&&e.every(Number.isInteger))return this.getMultiProofForUnevenTree(e);if(!e.every(Number.isInteger)){let t=e;this.sortPairs&&(t=t.sort(m.Buffer.compare));let r=t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1));if(!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=[],n=[];let s=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],o=this.getPairNode(e,i);a.push(e[i]),o&&n.push(o),s.push(i/2|0)}r=s.filter(((t,e,r)=>r.indexOf(t)===e)),s=[]}return n.filter((t=>!a.includes(t)))}return this.getProofIndices(e,Math.log2(t.length/2|0)).map((e=>t[e]))}getMultiProofForUnevenTree(t,e){e||(e=t,t=this.getLayers());let r=[],a=e;for(const e of t){const t=[];for(const r of a){if(r%2==0){const n=r+1;if(!a.includes(n)&&e[n]){t.push(e[n]);continue}}const n=r-1;a.includes(n)||!e[n]||t.push(e[n])}r=r.concat(t);const n=new Set;for(const t of a)t%2!=0?t%2!=0?n.add((t-1)/2):n.add((t+1)/2):n.add(t/2);a=Array.from(n)}return r}getHexMultiProof(t,e){return this.getMultiProof(t,e).map((t=>this.bufferToHex(t)))}getProofFlags(t,e){if(!Array.isArray(t)||t.length<=0)throw new Error("Invalid Inputs!");let r;if(r=t.every(Number.isInteger)?[...t].sort(((t,e)=>t===e?0:t>e?1:-1)):t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1)),!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=e.map((t=>this.bufferify(t))),n=[],s=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];r=r.reduce(((t,r)=>{if(!n.includes(e[r])){const t=this.getPairNode(e,r),i=a.includes(e[r])||a.includes(t);t&&s.push(!i),n.push(e[r]),n.push(t)}return t.push(r/2|0),t}),[])}return s}verify(t,e,r){let a=this.bufferify(e);if(r=this.bufferify(r),!Array.isArray(t)||!e||!r)return!1;for(let e=0;e<t.length;e++){const r=t[e];let n=null,s=null;if("string"==typeof r)n=this.bufferify(r),s=!0;else if(Array.isArray(r))s=0===r[0],n=this.bufferify(r[1]);else if(m.Buffer.isBuffer(r))n=r,s=!0;else{if(!(r instanceof Object))throw new Error("Expected node to be of type string or object");n=this.bufferify(r.data),s="left"===r.position}const i=[];this.isBitcoinTree?(i.push(g()(a)),i[s?"unshift":"push"](g()(n)),a=this.hashFn(this.concatenator(i)),a=g()(this.hashFn(a))):this.sortPairs?-1===m.Buffer.compare(a,n)?(i.push(a,n),a=this.hashFn(this.concatenator(i))):(i.push(n,a),a=this.hashFn(this.concatenator(i))):(i.push(a),i[s?"unshift":"push"](n),a=this.hashFn(this.concatenator(i)))}return 0===m.Buffer.compare(a,r)}verifyMultiProof(t,e,r,a,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(t,e,r,a,n);const s=Math.ceil(Math.log2(a));t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const i={};for(const[t,a]of this.zip(e,r))i[2**s+t]=a;for(const[t,r]of this.zip(this.getProofIndices(e,s),n))i[t]=r;let o=Object.keys(i).map((t=>Number(t))).sort(((t,e)=>t-e));o=o.slice(0,o.length-1);let c=0;for(;c<o.length;){const t=o[c];if(t>=2&&{}.hasOwnProperty.call(i,1^t)){let e=[i[t-t%2],i[t-t%2+1]];this.sortPairs&&(e=e.sort(m.Buffer.compare));const r=e[1]?this.hashFn(this.concatenator(e)):e[0];i[t/2|0]=r,o.push(t/2|0)}c+=1}return!e.length||{}.hasOwnProperty.call(i,1)&&i[1].equals(t)}verifyMultiProofWithFlags(t,e,r,a){t=this.bufferify(t),e=e.map(this.bufferify),r=r.map(this.bufferify);const n=e.length,s=a.length,i=[];let o=0,c=0,l=0;for(let t=0;t<s;t++){const s=[a[t]?o<n?e[o++]:i[c++]:r[l++],o<n?e[o++]:i[c++]].sort(m.Buffer.compare);i[t]=this.hashFn(this.concatenator(s))}return 0===m.Buffer.compare(i[s-1],t)}verifyMultiProofForUnevenTree(t,e,r,a,n){t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const s=this.calculateRootForUnevenTree(e,r,a,n);return t.equals(s)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const t=this.getLayers().map((t=>t.map((t=>this.bufferToHex(t,!1))))),e=[];for(let r=0;r<t.length;r++){const a=[];for(let n=0;n<t[r].length;n++){const s={[t[r][n]]:null};if(e.length){s[t[r][n]]={};const a=e.shift(),i=Object.keys(a)[0];if(s[t[r][n]][i]=a[i],e.length){const a=e.shift(),i=Object.keys(a)[0];s[t[r][n]][i]=a[i]}}a.push(s)}e.push(...a)}return e[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(t,e){const r=e%2==0?e+1:e-1;return r<t.length?t[r]:null}toTreeString(){const t=this.getLayersAsObject();return(0,y.asTree)(t,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(t){const e=t?.length||this.getDepth();return!this.isPowOf2(e)}isPowOf2(t){return t&&!(t&t-1)}calculateRootForUnevenTree(t,e,r,a){const n=this.zip(t,e).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})),s=n.map((t=>{let[e]=t;return e})),i=this.getProofIndicesForUnevenTree(s,r);let o=0;const c=[];for(let t=0;t<i.length;t++){const e=i[t],r=o;o+=e.length,c[t]=this.zip(e,a.slice(r,o))}const l=[n];for(let t=0;t<c.length;t++){const e=c[t].concat(l[t]).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})).map((t=>{let[,e]=t;return e})),r=l[t].map((t=>{let[e]=t;return e})),a=[...new Set(r.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))],n=[];for(let t=0;t<a.length;t++){const r=a[t],s=e[2*t],i=e[2*t+1],o=i?this.hashFn(this.concatenator([s,i])):s;n.push([r,o])}l.push(n)}return l[l.length-1][0][1]}}var P=r(89208),v=r(1604),k=r(41518),S=r(57632),A=r(48764).Buffer;function T(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function I(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function x(t,e){return"unlimited"===t?a.Bz:n.parseUnits(t,e)}async function E(t){const e=25e3,r=Array.from({length:Math.ceil(t.length/e)},((r,a)=>t.slice(a*e,a*e+e))),a=[],n=await Promise.all(r.map((t=>h.bO.parseAsync(t))));for(const t of n)a.push(...t);return a}let R=function(t){return t[t.V1=1]="V1",t[t.V2=2]="V2",t}({});class N{constructor(t,e,r,a,n){this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(t,e){try{const r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return N.fromShardedMerkleTreeInfo(r,e)}catch(t){return}}static async fromShardedMerkleTreeInfo(t,e){return new N(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case R.V1:return s.keccak256(["address","uint256"],[t.address,x(t.maxClaimable,e)]);case R.V2:return s.keccak256(["address","uint256","uint256","address"],[t.address,x(t.maxClaimable,e),x(t.price||"unlimited",r),t.currencyAddress||i.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){a=(await(0,d.f)(e,r)).decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,n){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const i=await E(t),c={};for(const t of i){const e=t.address.slice(2,2+s).toLowerCase();void 0===c[e]&&(c[e]=[]),c[e].push(t)}const l={},p=await Promise.all(Object.entries(c).map((async t=>{let[a,s]=t;return[a,new b(await Promise.all(s.map((async t=>{const a=await N.fetchAndCacheDecimals(l,r,t.currencyAddress);return N.hashEntry(t,e,a,n)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),h=Object.fromEntries(p),d=new b(Object.values(h),o.keccak256,{sort:!0}),u=[];for(const[t,e]of Object.entries(c)){const r={proofs:d.getProof(h[t]).map((t=>"0x"+t.data.toString("hex"))),entries:e};u.push({data:JSON.stringify(r),name:`${t}.json`})}const m=await a.uploadBatch(u),f=m[0].slice(0,m[0].lastIndexOf("/")),g=await a.upload(i),y={merkleRoot:d.getHexRoot(),baseUri:f,originalEntriesUri:g,shardNybbles:s,tokenDecimals:e,isShardedMerkleTree:!0};return{shardedMerkleInfo:y,uri:await a.upload(y)}}async getProof(t,e,r){const a=t.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[a];const s={};if(void 0===n)try{const t=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;n=this.shards[a]=await this.storage.downloadJSON(`${t}${a}.json`);const i=await Promise.all(n.entries.map((async t=>{const a=await N.fetchAndCacheDecimals(s,e,t.currencyAddress);return N.hashEntry(t,this.tokenDecimals,a,r)})));this.trees[a]=new b(i,o.keccak256,{sort:!0})}catch(t){return null}const i=n.entries.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!i)return null;const c=await N.fetchAndCacheDecimals(s,e,i.currencyAddress),l=N.hashEntry(i,this.tokenDecimals,c,r),p=this.trees[a].getProof(l).map((t=>"0x"+t.data.toString("hex")));return h.bP.parseAsync({...i,proof:p.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function M(t,e,r,a,n,s){if(!r)return null;const i=r[e];if(i){const r=await n.downloadJSON(i);if(r.isShardedMerkleTree&&r.merkleRoot===e){const e=await N.fromShardedMerkleTreeInfo(r,n);return await e.getProof(t,a,s)}const o=await h.bQ.parseAsync(r);if(e===o.merkleRoot)return o.claims.find((e=>e.address.toLowerCase()===t.toLowerCase()))||null}return null}function O(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function D(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function B(t,e,a,s,i){const o=t.getSigner(),l=t.getProvider(),p=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,d=new h.cu(o||l,e,p,t.options,t.storage),u=await t.getSignerAddress(),m=t.address,f=await d.read("allowance",[u,m]),g=c.O$.from(a).mul(c.O$.from(s)).div(n.parseUnits("1",i));f.lt(g)&&await d.sendTransaction("approve",[m,f.add(g)])}async function L(t,e,r,s,o,p,h,m,f){let g=x(r.maxClaimablePerWallet,o),y=[l.hexZeroPad([0],32)],w=r.price,C=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(i.d)){const e=await M(t,r.merkleRootHash.toString(),await s(),p.getProvider(),h,f);if(e)y=e.proof,g="unlimited"===e.maxClaimable?a.Bz:n.parseUnits(e.maxClaimable,o),w=void 0===e.price||"unlimited"===e.price?a.Bz:await(0,u.n)(p.getProvider(),e.price,e.currencyAddress||i.d),C=e.currencyAddress||i.d;else if(f===R.V1)throw new Error("No claim found for this address")}}catch(t){if("No claim found for this address"===t?.message)throw t;console.warn("failed to check claim condition merkle root hash, continuing anyways",t)}const W=await p.getCallOverrides()||{},b=w.toString()!==a.Bz.toString()?w:r.price,P=C!==i.d?C:r.currencyAddress;return b.gt(0)&&((0,d.i)(P)?W.value=c.O$.from(b).mul(e).div(n.parseUnits("1",o)):m&&await B(p,P,b,e,o)),{overrides:W,proofs:y,maxClaimable:g,price:b,currencyAddress:P,priceInProof:w,currencyAddressInProof:C}}const F=(()=>v.z.object({name:v.z.string(),symbol:v.z.string(),decimals:v.z.number()}))(),z=(()=>F.extend({value:h.b9,displayValue:v.z.string()}))(),U=(()=>v.z.object({name:v.z.string().optional()}).catchall(v.z.unknown()))(),$=(()=>v.z.object({startTime:P.S,currencyAddress:v.z.string().default(h.aZ),price:h.cz.default(0),maxClaimableSupply:h.cD,maxClaimablePerWallet:h.cD,waitInSeconds:h.ba.default(0),merkleRootHash:h.cE.default(l.hexZeroPad([0],32)),snapshot:v.z.optional(h.bO).nullable(),metadata:U.optional()}))(),q=(()=>v.z.array($))(),H=(()=>$.extend({availableSupply:h.cD,currentMintSupply:h.cD,currencyMetadata:z.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h.b9,waitInSeconds:h.b9,startTime:h.b9.transform((t=>new Date(1e3*t.toNumber()))),snapshot:h.bO.optional().nullable()}))();async function V(t,e,r,a,n){const s=[],i=await Promise.all(t.map((async t=>{if(t.snapshot&&t.snapshot.length>0){const i=await async function(t,e,r,a,n){const s=await E(t),i=s.map((t=>t.address));if(new Set(i).size<i.length)throw new h.s;const o=await N.buildAndUpload(s,e,r,a,n);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(t.snapshot,e,r,a,n);s.push(i),t.merkleRootHash=i.merkleRoot}else t.merkleRootHash=l.hexZeroPad([0],32);return t})));return{inputsWithSnapshots:i,snapshotInfos:s}}async function j(t,e,r,a,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await V(t,e,r,a,n),l=await q.parseAsync(s),p=(await Promise.all(l.map((t=>async function(t,e,r,a){const n=t.currencyAddress===i.d?h.aZ:t.currencyAddress,s=x(t.maxClaimableSupply,e),o=x(t.maxClaimablePerWallet,e);let c;return t.metadata&&(c="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,u.n)(r,t.price,n),currency:n,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:c}}(t,e,r,a))))).sort(((t,e)=>function(t,e){const r=c.O$.from(t),a=c.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1}(t.startTimestamp,e.startTimestamp)));return{snapshotInfos:o,sortedConditions:p}}async function _(t,e,r){if(!e)return null;const a=e[t];if(a){const e=await r.downloadJSON(a);if(e.isShardedMerkleTree&&e.merkleRoot===t){const t=await N.fromUri(a,r);return t?.getAllEntries()||null}{const r=await h.bQ.parseAsync(e);if(t===r.merkleRoot)return r.claims.map((t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress})))}}return null}function Z(t,e){return t.toString()===a.Bz.toString()?"unlimited":n.formatUnits(t,e)}async function J(t,e,r,a,n,s){const i=await(0,d.a)(r,t.currency,t.pricePerToken),o=Z(t.maxClaimableSupply,e),l=Z(t.maxClaimablePerWallet,e),p=Z(c.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),h=Z(t.supplyClaimed,e);let u;return t.metadata&&(u=await n.downloadJSON(t.metadata)),H.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:l,currentMintSupply:h,availableSupply:p,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:c.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:i,merkleRootHash:t.merkleRoot,snapshot:s?await _(t.merkleRoot,a,n):void 0,metadata:u})}async function Y(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);const a=r[t].currencyMetadata.decimals,s=r[t].price,i=n.formatUnits(s,a),o=await $.parseAsync({...r[t],price:i,...e}),c=await H.parseAsync({...o,price:s});return r.map(((e,r)=>{let s;s=r===t?c:e;const i=n.formatUnits(s.price,a);return{...s,price:i}}))}let G=function(t){return t.NotEnoughSupply="There is not enough supply to claim.",t.AddressNotAllowed="This address is not on the allowlist.",t.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",t.ClaimPhaseNotStarted="Claim phase has not started yet.",t.AlreadyClaimed="You have already claimed the token.",t.WrongPriceOrCurrency="Incorrect price or currency.",t.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",t.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",t.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",t.NoClaimConditionSet="There is no claim condition set.",t.NoWallet="No wallet connected.",t.Unknown="No claim conditions found.",t}({});function Q(t){if(void 0===t){const t=A.alloc(16);return(0,S.Z)({},t),l.hexlify(p.Y0(t.toString("hex")))}return l.hexlify(t)}const K=(()=>v.z.object({to:h.bd.refine((t=>t.toLowerCase()!==i.d),{message:"Cannot create payload to mint to zero address"}),price:h.cz.default(0),currencyAddress:h.bc.default(h.aZ),mintStartTime:P.S,mintEndTime:P.E,uid:v.z.string().optional().transform((t=>Q(t))),primarySaleRecipient:h.bd.default(i.d)}))(),X=(()=>K.extend({quantity:h.cz}))(),tt=(()=>X.extend({mintStartTime:h.b9,mintEndTime:h.b9}))(),et=(()=>K.extend({metadata:k.N,royaltyRecipient:v.z.string().default(i.d),royaltyBps:h.cF.default(0)}))(),rt=(()=>et.extend({metadata:k.N.default(""),uri:v.z.string(),royaltyBps:h.b9,mintStartTime:h.b9,mintEndTime:h.b9}))(),at=(()=>et.extend({metadata:k.N.default(""),quantity:h.ba}))(),nt=(()=>at.extend({tokenId:h.ba}))(),st=(()=>rt.extend({tokenId:h.b9,quantity:h.b9}))(),it=(()=>et.extend({metadata:k.N.default(""),quantity:h.b9.default(1)}))(),ot=(()=>rt.extend({quantity:h.b9.default(1)}))(),ct=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ht=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},56351:(t,e,r)=>{var a=r(48764).Buffer;t.exports=function(t){for(var e=new a(t.length),r=0,n=t.length-1;r<=n;++r,--n)e[r]=t[n],e[n]=t[r];return e}},99269:function(t){t.exports=function(){function t(t,e){var r=e?"└":"├";return r+=t?"─ ":"──┐"}function e(t,e){var r=[];for(var a in t)t.hasOwnProperty(a)&&(e&&"function"==typeof t[a]||r.push(a));return r}function r(a,n,s,i,o,c,l){var p,h,d="",u=0,m=i.slice(0);if(m.push([n,s])&&i.length>0&&(i.forEach((function(t,e){e>0&&(d+=(t[1]?" ":"│")+"  "),h||t[0]!==n||(h=!0)})),d+=t(a,s)+a,o&&("object"!=typeof n||n instanceof Date)&&(d+=": "+n),h&&(d+=" (circular ref.)"),l(d)),!h&&"object"==typeof n){var f=e(n,c);f.forEach((function(t){p=++u===f.length,r(t,n[t],p,m,o,c,l)}))}}var a={asLines:function(t,e,a,n){r(".",t,!1,[],e,"function"!=typeof a&&a,n||a)},asTree:function(t,e,a){var n="";return r(".",t,!1,[],e,a,(function(t){n+=t+"\n"})),n}};return a}()}}]);
//# sourceMappingURL=5132.js.map