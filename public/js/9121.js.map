{"version":3,"file":"js/9121.js","mappings":"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CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,QACN2L,KAAM,WACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,yBACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,YAEF+zB,GAAiB,CAAC,CACtB1/B,KAAM,KACN2L,KAAM,WACL,CACD3L,KAAM,mBACN2L,KAAM,WACL,CACD3L,KAAM,aACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,UACL,CACD3L,KAAM,QACN2L,KAAM,WACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,yBACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,YAEFg0B,GAAkB,CAAC,CACvB3/B,KAAM,KACN2L,KAAM,WACL,CACD3L,KAAM,mBACN2L,KAAM,WACL,CACD3L,KAAM,aACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,UACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,UACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,gBACN2L,KAAM,WACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,yBACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,YAEFi0B,GAA6B,CAAC,CAClC5/B,KAAM,KACN2L,KAAM,WACL,CACD3L,KAAM,mBACN2L,KAAM,WACL,CACD3L,KAAM,aACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,UACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,gBACN2L,KAAM,WACL,CACD3L,KAAM,WACN2L,KAAM,WACL,CACD3L,KAAM,yBACN2L,KAAM,WACL,CACD3L,KAAM,uBACN2L,KAAM,WACL,CACD3L,KAAM,MACN2L,KAAM,W,wCCl8BRk0B,EAAOC,QAAU,SAAkBC,GAGjC,IAFA,IAAIrT,EAAS,IAAInsB,EAAOw/B,EAAI17B,QAEnBD,EAAI,EAAG2H,EAAIg0B,EAAI17B,OAAS,EAAGD,GAAK2H,IAAK3H,IAAK2H,EACjD2gB,EAAOtoB,GAAK27B,EAAIh0B,GAChB2gB,EAAO3gB,GAAKg0B,EAAI37B,GAGlB,OAAOsoB,CACT,C,oBCDImT,EAAOC,QAOH,WAEN,SAASE,EAAWh1B,EAAKi1B,GACvB,IAAIC,EAAOD,EAAO,IAAM,IAMxB,OAJEC,GADEl1B,EACK,KAEA,KAGX,CAEA,SAASm1B,EAAWr0B,EAAKs0B,GACvB,IAAIhwB,EAAO,GACX,IAAK,IAAIiwB,KAAUv0B,EAEZA,EAAIkqB,eAAeqK,KAIpBD,GAAyC,mBAAft0B,EAAIu0B,IAGlCjwB,EAAKpE,KAAKq0B,IAEZ,OAAOjwB,CACT,CAEA,SAASkwB,EAAWt1B,EAAKuqB,EAAM0K,EAAMM,EAAYC,EAAYJ,EAAeK,GAC1E,IAA0BC,EAASC,EAA/BC,EAAO,GAAIt1B,EAAQ,EAAsBu1B,EAAiBN,EAAWl/B,MAAM,GA0B/E,GAxBIw/B,EAAe70B,KAAK,CAAEupB,EAAM0K,KAAWM,EAAWl8B,OAAS,IAG7Dk8B,EAAWn1B,SAAQ,SAAS01B,EAAWtR,GACjCA,EAAM,IACRoR,IAASE,EAAU,GAAK,IAAM,KAAO,MAEhCH,GAAYG,EAAU,KAAOvL,IAClCoL,GAAW,EAEf,IAIAC,GAAQZ,EAAWh1B,EAAKi1B,GAAQj1B,EAGhCw1B,IAA+B,iBAATjL,GAAqBA,aAAgBtwB,QAAU27B,GAAQ,KAAOrL,GACpFoL,IAAaC,GAAQ,oBAErBH,EAASG,KAIJD,GAA4B,iBAATpL,EAAmB,CAC3C,IAAInlB,EAAO+vB,EAAW5K,EAAM6K,GAC5BhwB,EAAKhF,SAAQ,SAASi1B,GAEpBK,IAAYp1B,IAAU8E,EAAK/L,OAG3Bi8B,EAAWD,EAAQ9K,EAAK8K,GAASK,EAASG,EAAgBL,EAAYJ,EAAeK,EACvF,GACF,CACF,CAIA,IAAIM,EAAU,CAMdA,QAAkB,SAASj1B,EAAK00B,EAAYJ,EAAeY,GAGzDV,EAAW,IAAKx0B,GAAK,EAAO,GAAI00B,EADgB,mBAAlBJ,GAA+BA,EACCY,GAAgBZ,EAChF,EAMAW,OAAiB,SAASj1B,EAAK00B,EAAYJ,GACzC,IAAI3S,EAAO,GAIX,OAHA6S,EAAW,IAAKx0B,GAAK,EAAO,GAAI00B,EAAYJ,GAAe,SAASQ,GAClEnT,GAAQmT,EAAO,IACjB,IACOnT,CACT,GAIA,OAAOsT,CAET,CAxGqBE,E","sources":["webpack:///./node_modules/@thirdweb-dev/sdk/dist/QueryParams-feab8e08.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/assertEnabled-ea837eec.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-appuri-4e9cb063.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-owner-1378b25d.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-roles-94655dc4.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-6a7767e6.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/erc-721-6f1fbec1.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/erc-721-standard-d20eb498.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/hasERC20Allowance-85fbd5f9.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/marketplace-f4856738.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/multiwrap-ebaa2da5.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7df9a12a.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/signature-ab20f9e3.browser.esm.js","webpack:///./node_modules/buffer-reverse/index.js","webpack:///./node_modules/treeify/treeify.js"],"sourcesContent":["import { C as CommonNFTOutput, a as CommonNFTInput } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport 'zod';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress - the contract address\n * @param provider - the provider to use\n * @param tokenId - the token id\n * @param storage - the storage to use\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata - the metadata to upload\n * @param storage - the storage to use\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas - the metadata to upload\n * @param storage - the storage to use\n * @param startNumber - the number to start the file names at\n * @param contractAddress - the contract address\n * @param signerAddress - the signer address\n * @param options - options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Pagination Parameters\n * @public\n */\n\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\n","import { BigNumber } from 'ethers';\nimport { z } from 'zod';\nimport { x as ExtensionNotImplementedError } from './index-827e427d.browser.esm.js';\n\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace - The namespace to check\n * @param feature - The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\nexport { EndDateSchema as E, RawDateSchema as R, StartDateSchema as S, assertEnabled as a };\n","import { am as isExtensionEnabled, bn as AbiSchema, d1 as FEATURE_METADATA, K as fetchContractMetadataFromAddress, x as ExtensionNotImplementedError, b1 as EventType, d2 as FEATURE_APPURI } from './index-827e427d.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { utils } from 'ethers';\nimport { replaceGatewayUrlWithScheme } from '@thirdweb-dev/storage';\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param featureName - The feature name to check\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  return isExtensionEnabled(AbiSchema.parse(contractWrapper.abi), featureName);\n}\n\n/**\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param functionName - The function name to check\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\n/**\n * @internal\n */\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  featureName = FEATURE_METADATA.name;\n  constructor(contractWrapper, schema, storage) {\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parseAsync(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parseAsync(metadata);\n  }\n  /**\n   * Get the metadata of this contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * console.log(metadata);\n   * ```\n   * @public\n   * @returns the metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.read(\"contractURI\", []);\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.read(\"name\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let contractSymbol;\n        try {\n          if (hasFunction(\"symbol\", this.contractWrapper)) {\n            contractSymbol = await this.contractWrapper.read(\"symbol\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let publishedMetadata;\n        try {\n          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n        } catch (err) {}\n        data = {\n          name: contractName || publishedMetadata?.name,\n          symbol: contractSymbol,\n          description: publishedMetadata?.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n\n  /**\n   * Set the metadata of this contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setContractURI\",\n        args: [uri],\n        parse: receipt => {\n          return {\n            receipt,\n            data: this.get\n          };\n        }\n      });\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  });\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   description: \"My new contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  update = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return await this.set.prepare({\n      ...(await this.get()),\n      ...metadata\n    });\n  });\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = await this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns a function to un-subscribe from the event\n   */\n  addEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          if (param.type === \"tuple[]\") {\n            // tuple[]\n            const objArray = [];\n            for (let i = 0; i < arr.length; i++) {\n              const tuple = arr[i];\n              const obj = {};\n              for (let j = 0; j < components.length; j++) {\n                const name = components[j].name;\n                obj[name] = tuple[j];\n              }\n              objArray.push(obj);\n            }\n            results[param.name] = objArray;\n          } else {\n            // simple tuple\n            const obj = {};\n            for (let i = 0; i < components.length; i++) {\n              const name = components[i].name;\n              obj[name] = arr[i];\n            }\n            results[param.name] = obj;\n          }\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);\n    return utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns the current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.app.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.app.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  featureName = FEATURE_APPURI.name;\n  constructor(contractWrapper, metadata, storage) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n    this.storage = storage;\n  }\n\n  /**\n   * Get App URI\n   * @returns the appURI (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = await contract.app.get();\n   * console.log(appURI) // \"ipfs://some_ipfs_hash\";\n   * ```\n   * @twfeature AppURI\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.read(\"appURI\", []);\n    }\n    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || \"\", this.storage.getGatewayUrls());\n  }\n\n  /**\n   * Set App URI\n   * @param appURI - the uri to set (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = \"ipfs://some_ipfs_hash\";\n   * await contract.app.set(appURI);\n   * ```\n   * @twfeature AppURI\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async appURI => {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setAppURI\",\n        args: [appURI]\n      });\n    }\n    return await this.metadata.update.prepare({\n      app_uri: appURI\n    });\n  });\n}\n\nexport { ContractMetadata as C, GasCostEstimator as G, ContractEvents as a, ContractAppURI as b, detectContractFeature as d, hasFunction as h };\n","import { h as hasFunction } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { d4 as FEATURE_ROYALTY, bH as CommonRoyaltySchema, aZ as NATIVE_TOKEN_ADDRESS, d5 as FEATURE_OWNER, aP as resolveAddress } from './index-827e427d.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport { a as CommonNFTInput } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, g as getBaseUriFromBatch } from './QueryParams-feab8e08.browser.esm.js';\nimport { a as approveErc20Allowance } from './signature-ab20f9e3.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const DeprecatedAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json')).default;\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns the owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\nexport { ContractRoyalty as C, DelayedReveal as D, ContractOwner as a, calculateClaimCost as c };\n","import invariant from 'tiny-invariant';\nimport { d3 as FEATURE_PERMISSIONS, H as getRoleHash, aP as resolveAddress, o as MissingRoleError } from './index-827e427d.browser.esm.js';\nimport { h as hasFunction } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractRoles {\n  featureName = FEATURE_PERMISSIONS.name;\n\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Get all members of all roles\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature PermissionsEnumerable\n   */\n  async getAll() {\n    invariant(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    const entries = Object.entries(this.roles);\n    (await Promise.all(entries.map(_ref => {\n      let [, role] = _ref;\n      return this.get(role);\n    }))).forEach((item, index) => roles[entries[index][1]] = item);\n    return roles;\n  }\n\n  /**\n   * Get all members of a specific role\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.read(\"getRoleMemberCount\", [roleHash])).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.read(\"getRoleMember\", [roleHash, i])));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Overwrite the list of members for specific roles\n   *\n   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  setAll = /* @__PURE__ */buildTransactionFunction(async rolesWithAddresses => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const [addresses, currentAddresses] = await Promise.all([Promise.all(rolesWithAddresses[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || []), Promise.all(currentRoles[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || [])]);\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(contractEncoder.encode(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        const revokeFunctionNames = await Promise.all(toRemove.map(address => this.getRevokeRoleFunctionName(address)));\n        revokeFunctionNames.forEach((revokeFunctionName, index) => encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), toRemove[index]])));\n      }\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const [members, resolvedAddress] = await Promise.all([this.get(role), resolveAddress(address)]);\n      if (!members.map(a => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {\n        throw new MissingRoleError(resolvedAddress, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Grant a role to a specific address\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  grant = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"grantRole\",\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /**\n   * Revoke a role from a specific address\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: revokeFunctionName,\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const [resolvedAddress, signerAddress] = await Promise.all([resolveAddress(address), this.contractWrapper.getSignerAddress()]);\n    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\nexport { ContractRoles as C };\n","import { utils, BigNumber, constants } from 'ethers';\nimport deepEqual from 'fast-deep-equal';\nimport { aP as resolveAddress, cz as AmountSchema, B as includesErrorMessage, d7 as isNode, cu as ContractWrapper } from './index-827e427d.browser.esm.js';\nimport { v as transformResultToClaimCondition, w as legacyContractModelToAbstract, x as newContractModelToAbstract, C as ClaimEligibility, y as convertQuantityToBigNumber, f as fetchSnapshotEntryForAddress, z as prepareClaim, A as SnapshotFormatVersion, D as processClaimConditionInputs, E as abstractContractModelToLegacy, F as abstractContractModelToNew, H as updateExistingClaimConditions } from './signature-ab20f9e3.browser.esm.js';\nimport { i as isNativeToken, C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { d as detectContractFeature, h as hasFunction } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(options) {\n    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);\n    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser context, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress - the wallet address to check\n   * @returns the total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);\n    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - The address to claim to\n   * @param quantity - The quantity to claim\n   * @param options - Options to override the claim transaction\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\nexport { DropClaimConditions as D };\n","import { utils, BigNumber, constants } from 'ethers';\nimport { u as uploadOrExtractURIs, g as getBaseUriFromBatch, b as uploadOrExtractURI, D as DEFAULT_QUERY_ALL_COUNT, F as FALLBACK_METADATA, f as fetchTokenMetadata } from './QueryParams-feab8e08.browser.esm.js';\nimport { cM as FEATURE_NFT_BATCH_MINTABLE, aP as resolveAddress, cN as FEATURE_NFT_CLAIM_CONDITIONS_V2, bk as CustomContractSchema, cO as FEATURE_NFT_CLAIM_CUSTOM, cP as FEATURE_NFT_LAZY_MINTABLE, cQ as FEATURE_NFT_REVEALABLE, cR as FEATURE_NFT_MINTABLE, cS as FEATURE_NFT_ENUMERABLE, cT as FEATURE_NFT_QUERYABLE, cU as FEATURE_NFT_SUPPLY, bd as AddressOrEnsSchema, cF as BasisPointsSchema, b9 as BigNumberSchema, cV as FEATURE_NFT_TIERED_DROP, cW as FEATURE_NFT_BURNABLE, cz as AmountSchema, cX as FEATURE_NFT_CLAIM_ZORA, cY as FEATURE_NFT_LOYALTY_CARD, cZ as FEATURE_NFT_UPDATABLE_METADATA, c_ as FEATURE_NFT_SHARED_METADATA, c$ as FEATURE_NFT_SIGNATURE_MINTABLE_V2, d0 as FEATURE_NFT, x as ExtensionNotImplementedError, n as NotFoundError } from './index-827e427d.browser.esm.js';\nimport { a as assertEnabled } from './assertEnabled-ea837eec.browser.esm.js';\nimport { C as ContractMetadata, d as detectContractFeature, h as hasFunction } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { D as DropClaimConditions } from './drop-claim-conditions-6a7767e6.browser.esm.js';\nimport { c as calculateClaimCost, D as DelayedReveal } from './contract-owner-1378b25d.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { isFileOrBuffer } from '@thirdweb-dev/storage';\nimport { s as setErc20Allowance, a as CommonNFTInput, B as BasicNFTInput } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport invariant from 'tiny-invariant';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport { z } from 'zod';\nimport { B as BaseSignaturePayloadInput, q as Signature721WithQuantityInput, r as Signature721WithQuantityOutput, s as MintRequest721, u as MintRequest721withQuantity } from './signature-ab20f9e3.browser.esm.js';\n\n/**\n * Mint Many ERC721 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\n\nclass Erc721BatchMintable {\n  featureName = FEATURE_NFT_BATCH_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```typescript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.mint.batch.to(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadatas) => {\n    const [uris, resolvedAddress] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), resolveAddress(to)]);\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = uris.map(uri => contractEncoder.encode(\"mintTo\", [resolvedAddress, uri]));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n        if (events.length === 0 || events.length < metadatas.length) {\n          throw new Error(\"TokenMinted event not found, minting failed\");\n        }\n        return events.map(e => {\n          const id = e.args.tokenIdMinted;\n          return {\n            id,\n            receipt,\n            data: () => this.erc721.get(id)\n          };\n        });\n      }\n    });\n  });\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(quantity);\n * await contract.erc721.claimConditions.getActive();\n * ```\n */\n\nclass Erc721ClaimableWithConditions {\n  featureName = FEATURE_NFT_CLAIM_CONDITIONS_V2.name;\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim unique NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * const claimedTokenId = tx[0].id; // the id of the first NFT claimed\n   * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - (optional) Options to configure the claim\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\n\nclass Erc721Claimable {\n  featureName = FEATURE_NFT_CLAIM_CUSTOM.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: [destinationAddress, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\n\n/**\n * Lazily mint and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.drop.claim(quantity);\n * ```\n */\n\nclass Erc721LazyMintable {\n  featureName = FEATURE_NFT_LAZY_MINTABLE.name;\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.nft.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc721Revealable();\n  }\n\n  /**\n   * Create a batch of unique NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args.startTokenId;\n        const endingIndex = event[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  detectErc721Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint ERC721 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc721Mintable {\n  featureName = FEATURE_NFT_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc721BatchMintable();\n  }\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.nft.mint.to(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadata) => {\n    const [uri, toAddress] = await Promise.all([uploadOrExtractURI(metadata, this.storage), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [toAddress, uri],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"Transfer\", receipt?.logs);\n        if (event.length === 0) {\n          throw new Error(\"TransferEvent event not found\");\n        }\n        const id = event[0].args.tokenId;\n        return {\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        };\n      }\n    });\n  });\n\n  /**\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, metadata) {\n    return this.to.prepare(await resolveAddress(to), metadata);\n  }\n  detectErc721BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721BatchMintable\")) {\n      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721Enumerable {\n  featureName = FEATURE_NFT_ENUMERABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress, queryParams) {\n    let tokenIds = await this.tokenIds(walletAddress);\n    if (queryParams) {\n      const start = queryParams?.start || 0;\n      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;\n      tokenIds = tokenIds.slice(start, start + count);\n    }\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    const balance = await this.contractWrapper.read(\"balanceOf\", [address]);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    return await Promise.all(indices.map(i => this.contractWrapper.read(\"tokenOfOwnerByIndex\", [address, i])));\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721AQueryable {\n  featureName = FEATURE_NFT_QUERYABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress, queryParams) {\n    let tokenIds = await this.tokenIds(walletAddress);\n    if (queryParams) {\n      const start = queryParams?.start || 0;\n      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;\n      tokenIds = tokenIds.slice(start, start + count);\n    }\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    return await this.contractWrapper.read(\"tokensOfOwner\", [address]);\n  }\n}\n\n/**\n * List ERC721 NFTs\n * @remarks Easily list all the NFTs in a ERC721 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.nft.query.all();\n * ```\n * @public\n */\n\nclass Erc721Supply {\n  featureName = FEATURE_NFT_SUPPLY.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.owned = this.detectErc721Owned();\n  }\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.nft.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    const start = BigNumber.from(queryParams?.start || 0).add(startTokenId).toNumber();\n    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();\n    const maxSupply = await this.erc721.nextTokenIdToMint();\n    const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc721.get((start + i).toString())));\n  }\n\n  /**\n   * Return all the owners of each token id in this contract\n   * @returns\n   */\n  async allOwners() {\n    let totalCount;\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    try {\n      totalCount = await this.erc721.totalClaimedSupply();\n    } catch (e) {\n      totalCount = await this.totalCount();\n    }\n    totalCount = totalCount.add(startTokenId);\n\n    // TODO use multicall3 if available\n    // TODO can't call toNumber() here, this can be a very large number\n    const arr = [...new Array(totalCount.toNumber()).keys()];\n    const owners = await Promise.all(arr.map(i => this.erc721.ownerOf(i).catch(() => constants.AddressZero)));\n    return arr.map(i => ({\n      tokenId: i,\n      owner: owners[i]\n    })).filter(o => o.owner !== constants.AddressZero);\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.erc721.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the number of NFTs of this contract currently owned by end users\n   * @returns the total number of NFTs of this contract in circulation (minted & not burned)\n   * @public\n   */\n  async totalCirculatingSupply() {\n    return await this.contractWrapper.read(\"totalSupply\", []);\n  }\n  detectErc721Owned() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Enumerable\")) {\n      return new Erc721Enumerable(this.erc721, this.contractWrapper);\n    } else if (detectContractFeature(this.contractWrapper, \"ERC721AQueryable\")) {\n      return new Erc721AQueryable(this.erc721, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @internal\n */\nconst TieredDropPayloadSchema = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  tierPriority: z.array(z.string()),\n  royaltyRecipient: AddressOrEnsSchema.default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\nclass Erc721TieredDrop {\n  featureName = FEATURE_NFT_TIERED_DROP.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n  async getMetadataInTier(tier) {\n    const tiers = await this.contractWrapper.read(\"getMetadataForAllTiers\", []);\n    const batches = tiers.find(t => t.tier === tier);\n    if (!batches) {\n      throw new Error(\"Tier not found in contract.\");\n    }\n    const nfts = await Promise.all(batches.ranges.map((range, i) => {\n      const nftsInRange = [];\n      const baseUri = batches.baseURIs[i];\n      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {\n        const uri = baseUri.endsWith(\"/\") ? `${baseUri}${j}` : `${baseUri}/${j}`;\n        const metadata = this.storage.downloadJSON(uri);\n        nftsInRange.push(metadata);\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  async getTokensInTier(tier) {\n    const endIndex = await this.contractWrapper.read(\"getTokensInTierLen\", []);\n    if (endIndex.eq(0)) {\n      return [];\n    }\n    const ranges = await this.contractWrapper.read(\"getTokensInTier\", [tier, 0, endIndex]);\n    const nfts = await Promise.all(ranges.map(range => {\n      const nftsInRange = [];\n      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {\n        nftsInRange.push(this.erc721.get(i));\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  createBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (metadatas, tier, options) => {\n    // TODO: Change this to on extension\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, tier, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  createDelayedRevealBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, tier, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const chainId = await this.contractWrapper.getChainID();\n    const hashedPassword = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, baseUriId, this.contractWrapper.address]);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n    const data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, tier, data],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const key = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchId, this.contractWrapper.address]);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n  async generate(payloadToSign) {\n    const [payload] = await this.generateBatch([payloadToSign]);\n    return payload;\n  }\n  async generateBatch(payloadsToSign) {\n    const parsedPayloads = await Promise.all(payloadsToSign.map(payload => TieredDropPayloadSchema.parseAsync(payload)));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedPayloads.map(async payload => {\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: \"SignatureAction\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        GenericRequest: GenericRequest\n      }, await this.mapPayloadToContractStruct(payload));\n      return {\n        payload,\n        signature: signature.toString()\n      };\n    }));\n  }\n  async verify(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signedPayload.signature]);\n    return verification[0];\n  }\n  async claimWithSignature(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"claimWithSignature\", [message, signedPayload.signature], overrides);\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n  async mapPayloadToContractStruct(payload) {\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);\n    const data = utils.defaultAbiCoder.encode([\"string[]\", \"address\", \"address\", \"uint256\", \"address\", \"uint256\", \"uint256\", \"address\"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);\n    return {\n      uid: payload.uid,\n      validityStartTimestamp: payload.mintStartTime,\n      validityEndTimestamp: payload.mintEndTime,\n      data\n    };\n  }\n}\n\nclass Erc721Burnable {\n  featureName = FEATURE_NFT_BURNABLE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to burn\n   * const tokenId = 0;\n   *\n   * await contract.nft.burn.token(tokenId);\n   * ```\n   */\n  token = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [tokenId]\n    });\n  });\n}\n\nfunction toWei(amount) {\n  return utils.parseEther(AmountSchema.parse(amount));\n}\n\n/**\n * Claim ERC721 NFTs from a Zora Drop\n * @remarks Purchase NFTs on a Zora Drop\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\nclass Erc721ClaimableZora {\n  featureName = FEATURE_NFT_CLAIM_ZORA.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Claim NFT\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to, needs to be the connected wallet address\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Not applicable\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO validation on destinationAddr / options\n    const signerAddress = await this.contractWrapper.getSigner()?.getAddress();\n    if (destinationAddress !== signerAddress) {\n      throw new Error(\"Zora Drop: Destination address must match connected wallet address\");\n    }\n    if (options?.pricePerToken) {\n      throw new Error(\"Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated\");\n    }\n    const saleDetails = await this.getSaleDetails();\n    const price = saleDetails.publicSalePrice;\n    const zoraFee = toWei(\"0.000777\");\n    const totalPrice = BigNumber.from(price).add(zoraFee).mul(quantity);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"purchase\",\n      args: [quantity],\n      overrides: {\n        value: totalPrice\n      }\n    });\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"Sale\", receipt?.logs);\n      const startingIndex = event[0].args.firstPurchasedTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n  async getSaleDetails() {\n    return this.contractWrapper.read(\"saleDetails\", []);\n  }\n}\n\nclass Erc721LoyaltyCard {\n  featureName = FEATURE_NFT_LOYALTY_CARD.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.cancel(tokenId);\n   * ```\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancel\",\n      args: [tokenId]\n    });\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.revoke(tokenId);\n   * ```\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"revoke\",\n      args: [tokenId]\n    });\n  });\n}\n\nclass Erc721UpdatableMetadata {\n  featureName = FEATURE_NFT_UPDATABLE_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\" }\n   *\n   * await contract.nft.metadata.update(tokenId, metadata);\n   * ```\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    const uri = await uploadOrExtractURI(metadata, this.storage);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setTokenURI\",\n      args: [tokenId, uri]\n    });\n  });\n}\n\n/**\n * Set shared metadata for ERC721 NFTs (Open Edition)\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.sharedMetadata.set(metadata);\n * ```\n */\nclass Erc721SharedMetadata {\n  featureName = FEATURE_NFT_SHARED_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get Shared Metadata\n   *\n   * @remarks Get the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.get();\n   * ```\n   *\n   * @returns - The shared metadata for the Open Edition NFTs.\n   */\n  async get() {\n    const metadata = await this.contractWrapper.read(\"sharedMetadata\", []);\n    if (metadata.every(value => value === \"\")) {\n      return undefined;\n    }\n    return {\n      name: metadata.name,\n      description: metadata.description,\n      image: metadata.imageURI,\n      animation_url: metadata.animationURI\n    };\n  }\n\n  /**\n   * Set Shared Metadata\n   *\n   * @remarks Set the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const metadata = {\n   *  name: \"My NFT\",\n   *  description: \"This is my NFT\",\n   *  image: ...\n   *  animation_url: ...\n   * };\n   *\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   *\n   * @param metadata - The metadata you want to set for the shared metadata.\n   *\n   * @returns - Receipt for the transaction\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const parsedMetadata = BasicNFTInput.parse(metadata);\n    // cleanup description\n    parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);\n\n    // take the input and upload image and animation if it is not a URI already\n    const batch = [];\n    if (isFileOrBuffer(parsedMetadata.image)) {\n      batch.push(this.storage.upload(parsedMetadata.image));\n    } else if (typeof parsedMetadata.image === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.image));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    if (isFileOrBuffer(parsedMetadata.animation_url)) {\n      batch.push(this.storage.upload(parsedMetadata.animation_url));\n    } else if (typeof parsedMetadata.animation_url === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.animation_url));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    const [imageUri, animationUri] = await Promise.all(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setSharedMetadata\",\n      args: [{\n        name: `${parsedMetadata.name || \"\"}`,\n        description: parsedMetadata.description || \"\",\n        imageURI: imageUri || \"\",\n        animationURI: animationUri || \"\"\n      }]\n    });\n  });\n  sanitizeJSONString(val) {\n    if (!val) {\n      return val;\n    }\n    const sanitized = JSON.stringify(val);\n    return sanitized.slice(1, sanitized.length - 1);\n  }\n}\n\n/**\n * Enables generating dynamic ERC721 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc721WithQuantitySignatureMintable {\n  featureName = FEATURE_NFT_SIGNATURE_MINTABLE_V2.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}\n   * @twfeature ERC721SignatureMint\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const overrides = await this.contractWrapper.getCallOverrides();\n    const parse = receipt => {\n      const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n      if (t.length === 0) {\n        throw new Error(\"No MintWithSignature event found\");\n      }\n      const id = t[0].args.tokenIdMinted;\n      return {\n        id,\n        receipt\n      };\n    };\n    if (await this.isLegacyNFTContract()) {\n      const message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      const price = message.price;\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    } else {\n      const message = await this.mapPayloadToContractStruct(mintRequest);\n      const price = message.pricePerToken.mul(message.quantity);\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    }\n  });\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC721SignatureMint\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const contractPayloads = (await Promise.all(signedPayloads.map(s => isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index) => {\n      const s = signedPayloads[index];\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    });\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      if (isLegacyNFTContract) {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      } else {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      }\n    });\n    if (hasFunction(\"multicall\", this.contractWrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => {\n          const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n          if (events.length === 0) {\n            throw new Error(\"No MintWithSignature event found\");\n          }\n          return events.map(log => ({\n            id: log.args.tokenIdMinted,\n            receipt\n          }));\n        }\n      });\n    } else {\n      throw new Error(\"Multicall not available on this contract!\");\n    }\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC721SignatureMint\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc721.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    let message;\n    let verification;\n    if (isLegacyNFTContract) {\n      message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    } else {\n      message = await this.mapPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    }\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a dynamic NFT\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC721SignatureMint\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.\n   *\n   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC721SignatureMint\n   */\n  async generateBatch(payloadsToSign) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature721WithQuantityInput.parseAsync(m)));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = await Signature721WithQuantityOutput.parseAsync({\n        ...m,\n        uri\n      });\n      let signature;\n      if (isLegacyNFTContract) {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"TokenERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721\n        }, await this.mapLegacyPayloadToContractStruct(finalPayload));\n      } else {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"SignatureMintERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: await this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721withQuantity\n        },\n        // TYPEHASH\n        await this.mapPayloadToContractStruct(finalPayload));\n      }\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid\n    };\n  }\n  async mapLegacyPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      price: normalizedPricePerToken,\n      uri: mintRequest.uri,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n  async isLegacyNFTContract() {\n    return detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\");\n  }\n}\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass Erc721 {\n  featureName = FEATURE_NFT.name;\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc721Enumerable();\n    this.mintable = this.detectErc721Mintable();\n    this.burnable = this.detectErc721Burnable();\n    this.lazyMintable = this.detectErc721LazyMintable();\n    this.tieredDropable = this.detectErc721TieredDrop();\n    this.signatureMintable = this.detectErc721SignatureMintable();\n    this.claimWithConditions = this.detectErc721ClaimableWithConditions();\n    this.claimCustom = this.detectErc721Claimable();\n    this.claimZora = this.detectErc721ClaimableZora();\n    this.erc721SharedMetadata = this.detectErc721SharedMetadata();\n    this.loyaltyCard = this.detectErc721LoyaltyCard();\n    this.updatableMetadata = this.detectErc721UpdatableMetadata();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC721 Extension //////\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc721.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC721\n   */\n  async get(tokenId) {\n    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => constants.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner,\n      metadata,\n      type: \"ERC721\",\n      supply: \"1\"\n    };\n  }\n\n  /**\n   * Get the current owner of an NFT\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   * @twfeature ERC721\n   */\n  async ownerOf(tokenId) {\n    return await this.contractWrapper.read(\"ownerOf\", [tokenId]);\n  }\n\n  /**\n   * Get NFT balance of a specific wallet\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc721.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   * @twfeature ERC721\n   */\n  async balanceOf(address) {\n    return await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address)]);\n  }\n\n  /**\n   * Get NFT balance for the currently connected wallet\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    const [_address, _operator] = await Promise.all([resolveAddress(address), resolveAddress(operator)]);\n    return await this.contractWrapper.read(\"isApprovedForAll\", [_address, _operator]);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transfer(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, tokenId) => {\n    const [from, _to] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [from, _to, tokenId]\n    });\n  });\n\n  /**\n   * Transfer an NFT from a specific wallet\n   *\n   * @remarks Transfer an NFT from the given wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const fromWalletAddress = \"{{wallet_address}}\";\n   * const toWalletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transferFrom(fromWalletAddress, toWalletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction(async (from, to, tokenId) => {\n    const [fromAddress, toAddress] = await Promise.all([resolveAddress(from), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [fromAddress, toAddress, tokenId]\n    });\n  });\n\n  /**\n   * Set approval for all NFTs\n   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * await contract.erc721.setApprovalForAll(operator, true);\n   * ```\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   * @twfeature ERC721\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setApprovalForAll\",\n      args: [await resolveAddress(operator), approved]\n    });\n  });\n\n  /**\n   * Set approval for a single NFT\n   * @remarks Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.setApprovalForToken(operator, tokenId);\n   * ```\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  setApprovalForToken = /* @__PURE__ */buildTransactionFunction(async (operator, tokenId) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: [await resolveAddress(operator), tokenId]\n    });\n  });\n\n  ////// ERC721 Supply Extension //////\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc721.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);\n  }\n\n  /**\n   * Get all NFT owners\n   * @example\n   * ```javascript\n   * const owners = await contract.erc721.getAllOwners();\n   * console.log(owners);\n   * ```\n   * @returns an array of token ids and owners\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAllOwners() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();\n  }\n\n  /**\n   * Get the total number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   * @example\n   * ```javascript\n   * const count = await contract.erc721.totalCount();\n   * console.log(count);\n   * ```\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return this.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the total count NFTs minted in this contract\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async totalCirculatingSupply() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();\n  }\n\n  ////// ERC721 Enumerable Extension //////\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc721.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getOwned(walletAddress, queryParams) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.all(walletAddress, queryParams);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      let ownedTokens = (allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase());\n      if (queryParams) {\n        const start = queryParams?.start || 0;\n        const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;\n        ownedTokens = ownedTokens.slice(start, start + count);\n      }\n      return await Promise.all(ownedTokens.map(async i => this.get(i.tokenId)));\n    }\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.tokenIds(walletAddress);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      return (allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => BigNumber.from(i.tokenId));\n    }\n  }\n\n  ////// ERC721 Mintable Extension //////\n\n  /**\n   * Mint an NFT\n   *\n   * @remarks Mint an NFT to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mint(metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);\n  });\n\n  /**\n   * Mint an NFT to a specific wallet\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mintTo(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadata) => {\n    return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);\n  });\n\n  /**\n   * Construct a mint transaction without executing it.\n   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param metadata - The metadata of the NFT you want to mint\n   *\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   * @twfeature ERC721Mintable\n   */\n  async getMintTransaction(receiver, metadata) {\n    return this.mintTo.prepare(receiver, metadata);\n  }\n\n  ////// ERC721 Batch Mintable Extension //////\n\n  /**\n   * Mint many NFTs\n   *\n   * @remarks Mint many unique NFTs at once to the connected wallet\n   *\n   * @example\n   * ```typescript\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatch(metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async metadatas => {\n    return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);\n  });\n\n  /**\n   * Mint many NFTs to a specific wallet\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```typescript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadatas) => {\n    return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);\n  });\n\n  ////// ERC721 Burnable Extension //////\n\n  /**\n   * Burn a single NFT\n   * @param tokenId - the token Id to burn\n   *\n   * @example\n   * ```javascript\n   * const result = await contract.erc721.burn(tokenId);\n   * ```\n   * @twfeature ERC721Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);\n  });\n\n  ////// ERC721 Loyalty Card Extension //////\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.cancel(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).cancel.prepare(tokenId);\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.revoke(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).revoke.prepare(tokenId);\n  });\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Lazy mint NFTs\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC721LazyMintable\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options);\n  });\n\n  ////// ERC721 Metadata Extension //////\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\" }\n   *\n   * await contract.erc721.update(tokenId, metadata);\n   * ```\n   * @twfeature ERC721UpdatableMetadata\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    return assertEnabled(this.updatableMetadata, FEATURE_NFT_UPDATABLE_METADATA).update.prepare(tokenId, metadata);\n  });\n\n  ////// ERC721 Claimable Extension //////\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claim(quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (quantity, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);\n  });\n\n  /**\n   * Claim NFTs to a specific wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - optional claim options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    const claimZora = this.claimZora;\n    if (claimWithConditions) {\n      return claimWithConditions.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claimZora) {\n      return claimZora.to.prepare(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  });\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - optional claim options\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Get the claimed supply\n   *\n   * @remarks Get the number of claimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const claimedNFTCount = await contract.totalClaimedSupply();\n   * console.log(`NFTs claimed: ${claimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalClaimedSupply() {\n    const contract = this.contractWrapper;\n    if (hasFunction(\"totalMinted\", contract)) {\n      return this.contractWrapper.read(\"totalMinted\", []);\n    }\n    if (hasFunction(\"nextTokenIdToClaim\", contract)) {\n      return this.contractWrapper.read(\"nextTokenIdToClaim\", []);\n    }\n    throw new Error(\"No function found on contract to get total claimed supply\");\n  }\n\n  /**\n   * Get the unclaimed supply\n   *\n   * @remarks Get the number of unclaimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();\n   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalUnclaimedSupply() {\n    const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);\n    return nextTokenIdToMint.sub(totalClaimedSupply);\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC721 Tiered Drop Extension //////\n\n  /**\n   * Tiered Drop\n   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.\n   * @twfeature ERC721TieredDrop\n   */\n  get tieredDrop() {\n    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);\n  }\n\n  ////// ERC721 SignatureMint Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = await contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);\n  }\n\n  ////// ERC721 DelayedReveal Extension //////\n\n  /**\n   * Mint delayed reveal NFTs\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc721.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC721Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);\n  }\n\n  ////// ERC721 Shared Metadata Extension (Open Edition) //////\n\n  /**\n   * Set shared metadata for all NFTs\n   * @remarks Set shared metadata for all NFTs in the collection. (Open Edition)\n   * @example\n   * ```javascript\n   * // defiine the metadata\n   * const metadata = {\n   *  name: \"Shared Metadata\",\n   *  description: \"Every NFT in this collection will share this metadata.\"\n   * };\n   *\n   *\n   * const tx = contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   * @twfeature ERC721SharedMetadata\n   */\n  get sharedMetadata() {\n    return assertEnabled(this.erc721SharedMetadata, FEATURE_NFT_SHARED_METADATA);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.read(\"tokenURI\", [tokenId]);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      let nextTokenIdToMint = await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n      // handle open editions and contracts with startTokenId\n      if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n        nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read(\"startTokenId\", []));\n      }\n      return nextTokenIdToMint;\n    } else if (hasFunction(\"totalSupply\", this.contractWrapper)) {\n      return await this.contractWrapper.read(\"totalSupply\", []);\n    } else {\n      throw new Error(\"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\");\n    }\n  }\n  detectErc721Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Supply\") || hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return new Erc721Supply(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Mintable\")) {\n      return new Erc721Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Burnable\")) {\n      return new Erc721Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LazyMintable\")) {\n      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721TieredDrop() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721TieredDrop\")) {\n      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\") || detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV2\")) {\n      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV2\")) {\n      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimCustom\")) {\n      return new Erc721Claimable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableZora() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimZora\")) {\n      return new Erc721ClaimableZora(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721SharedMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SharedMetadata\")) {\n      return new Erc721SharedMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721LoyaltyCard() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LoyaltyCard\")) {\n      return new Erc721LoyaltyCard(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721UpdatableMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721UpdatableMetadata\")) {\n      return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\nexport { Erc721BatchMintable as E, Erc721ClaimableWithConditions as a, Erc721Claimable as b, Erc721LazyMintable as c, Erc721Mintable as d, Erc721Supply as e, Erc721Enumerable as f, Erc721TieredDrop as g, Erc721 as h, Erc721WithQuantitySignatureMintable as i, Erc721Burnable as j, toWei as t };\n","import { aP as resolveAddress } from './index-827e427d.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { h as Erc721 } from './erc-721-6f1fbec1.browser.esm.js';\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass StandardErc721 {\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.erc721 = new Erc721(this.contractWrapper, this.storage, chainId);\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async getAll(queryParams) {\n    return this.erc721.getAll(queryParams);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async getOwned(walletAddress, queryParams) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return this.erc721.getOwned(walletAddress, queryParams);\n  }\n\n  /**\n   * Get Owned Token Ids\n   * @remarks Get all the token ids of NFTs owned by a specific wallet (no metadata)\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return this.erc721.getOwnedTokenIds(walletAddress);\n  }\n\n  /**\n   * Get total minted supply count\n   */\n  async totalSupply() {\n    return this.erc721.totalCirculatingSupply();\n  }\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   */\n  async get(tokenId) {\n    return this.erc721.get(tokenId);\n  }\n\n  /**\n   * Get the current owner of a given NFT within this Contract\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   */\n  async ownerOf(tokenId) {\n    return this.erc721.ownerOf(tokenId);\n  }\n\n  /**\n   * Get NFT Balance\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   */\n  async balanceOf(address) {\n    return this.erc721.balanceOf(address);\n  }\n\n  /**\n   * Get NFT Balance for the currently connected wallet\n   */\n  async balance() {\n    return this.erc721.balance();\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return this.erc721.isApproved(address, operator);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.transfer(walletAddress, tokenId);\n   * ```\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, tokenId) => {\n    return this.erc721.transfer.prepare(to, tokenId);\n  });\n\n  /**\n   * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   *\n   * @internal\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return this.erc721.setApprovalForAll.prepare(operator, approved);\n  });\n\n  /**\n   * Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  setApprovalForToken = /* @__PURE__ */buildTransactionFunction(async (operator, tokenId) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: [await resolveAddress(operator), tokenId]\n    });\n  });\n}\n\nexport { StandardErc721 as S };\n","import { cu as ContractWrapper } from './index-827e427d.browser.esm.js';\n\nasync function hasERC20Allowance(contractToApprove, currencyAddress, value) {\n  const provider = contractToApprove.getProvider();\n  const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n  const erc20 = new ContractWrapper(provider, currencyAddress, ERC20Abi, {}, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  return allowance.gte(value);\n}\n\nexport { hasERC20Allowance as h };\n","import { Contract, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { I as InterfaceId_IERC721, a as InterfaceId_IERC1155, D as DEFAULT_QUERY_ALL_COUNT } from './QueryParams-feab8e08.browser.esm.js';\nimport { cu as ContractWrapper, dy as MAX_BPS } from './index-827e427d.browser.esm.js';\nimport { a as fetchCurrencyValue } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns - True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(assetContract, ERC721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(assetContract, ERC1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper - The contract wrapper to use\n * @param marketplaceAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param from - The address of the account that owns the token.\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const [isERC721, isERC1155] = await Promise.all([erc165.read(\"supportsInterface\", [InterfaceId_IERC721]), erc165.read(\"supportsInterface\", [InterfaceId_IERC1155])]);\n  // check for token approval\n  if (isERC721) {\n    const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer - The offer to map\n * @returns - An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\nexport { isWinningBid as a, getAllInBatches as g, handleTokenApproval as h, isTokenApprovedForTransfer as i, mapOffer as m, validateNewListingParam as v };\n","import { utils } from 'ethers';\nimport { C as ContractEncoder, f as fetchCurrencyMetadata } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { h as hasERC20Allowance } from './hasERC20Allowance-85fbd5f9.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport { dB as MULTIWRAP_CONTRACT_ROLES, cu as ContractWrapper, bn as AbiSchema, dC as MultiwrapContractSchema, aP as resolveAddress } from './index-827e427d.browser.esm.js';\nimport { i as isTokenApprovedForTransfer } from './marketplace-f4856738.browser.esm.js';\nimport { b as uploadOrExtractURI } from './QueryParams-feab8e08.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { C as ContractMetadata, b as ContractAppURI, G as GasCostEstimator, a as ContractEvents } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { C as ContractRoyalty, a as ContractOwner } from './contract-owner-1378b25d.browser.esm.js';\nimport { C as ContractRoles } from './contract-roles-94655dc4.browser.esm.js';\nimport { S as StandardErc721 } from './erc-721-standard-d20eb498.browser.esm.js';\nimport 'zod';\nimport '@thirdweb-dev/chains';\nimport '@thirdweb-dev/storage';\nimport '@thirdweb-dev/crypto';\nimport 'tiny-invariant';\nimport 'bn.js';\nimport 'bs58';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport './setErc20Allowance-7df9a12a.browser.esm.js';\nimport './signature-ab20f9e3.browser.esm.js';\nimport '@thirdweb-dev/merkletree';\nimport './assertEnabled-ea837eec.browser.esm.js';\nimport 'uuid';\nimport './erc-721-6f1fbec1.browser.esm.js';\nimport './drop-claim-conditions-6a7767e6.browser.esm.js';\nimport 'fast-deep-equal';\n\n/**\n * Multiwrap lets you wrap any number of ERC20, ERC721 and ERC1155 tokens you own into a single wrapped token bundle.\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(\"{{chainName}}\");\n * const contract = await sdk.getContract(\"{{contract_address}}\", \"multiwrap\");\n * ```\n *\n * @beta\n */\nclass Multiwrap extends StandardErc721 {\n  static contractRoles = MULTIWRAP_CONTRACT_ROLES;\n\n  /**\n   * Configure royalties\n   * @remarks Set your own royalties for the entire contract or per token\n   * @example\n   * ```javascript\n   * // royalties on the whole contract\n   * contract.royalties.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1%\n   *   fee_recipient: \"0x...\"\n   * });\n   * // override royalty for a particular token\n   * contract.royalties.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 500, // 5%\n   *   fee_recipient: \"0x...\"\n   * });\n   * ```\n   */\n\n  constructor(network, address, storage) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let abi = arguments.length > 4 ? arguments[4] : undefined;\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);\n    super(contractWrapper, storage, chainId);\n    this.abi = AbiSchema.parse(abi || []);\n    this.metadata = new ContractMetadata(this.contractWrapper, MultiwrapContractSchema, this.storage);\n    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);\n    this.roles = new ContractRoles(this.contractWrapper, Multiwrap.contractRoles);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.events = new ContractEvents(this.contractWrapper);\n    this.royalties = new ContractRoyalty(this.contractWrapper, this.metadata);\n    this.owner = new ContractOwner(this.contractWrapper);\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the contents of a wrapped token bundle\n   * @example\n   * ```javascript\n   * const contents = await contract.getWrappedContents(wrappedTokenId);\n   * console.log(contents.erc20Tokens);\n   * console.log(contents.erc721Tokens);\n   * console.log(contents.erc1155Tokens);\n   * ```\n   * @param wrappedTokenId - the id of the wrapped token bundle\n   */\n  async getWrappedContents(wrappedTokenId) {\n    const wrappedTokens = await this.contractWrapper.read(\"getWrappedContents\", [wrappedTokenId]);\n    const erc20Tokens = [];\n    const erc721Tokens = [];\n    const erc1155Tokens = [];\n    for (const token of wrappedTokens) {\n      switch (token.tokenType) {\n        case 0:\n          {\n            const tokenMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), token.assetContract);\n            erc20Tokens.push({\n              contractAddress: token.assetContract,\n              quantity: utils.formatUnits(token.totalAmount, tokenMetadata.decimals)\n            });\n            break;\n          }\n        case 1:\n          {\n            erc721Tokens.push({\n              contractAddress: token.assetContract,\n              tokenId: token.tokenId\n            });\n            break;\n          }\n        case 2:\n          {\n            erc1155Tokens.push({\n              contractAddress: token.assetContract,\n              tokenId: token.tokenId,\n              quantity: token.totalAmount.toString()\n            });\n            break;\n          }\n      }\n    }\n    return {\n      erc20Tokens,\n      erc721Tokens,\n      erc1155Tokens\n    };\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Wrap any number of ERC20/ERC721/ERC1155 tokens into a single wrapped token\n   * @example\n   * ```javascript\n   * const tx = await contract.wrap({\n   *   erc20Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     quantity: \"0.8\"\n   *   }],\n   *   erc721Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     tokenId: \"0\"\n   *   }],\n   *   erc1155Tokens: [{\n   *     contractAddress: \"0x...\",\n   *     tokenId: \"1\",\n   *     quantity: \"2\"\n   *   }]\n   * }, {\n   *     name: \"Wrapped bundle\",\n   *     description: \"This is a wrapped bundle of tokens and NFTs\",\n   *     image: \"ipfs://...\",\n   * });\n   * const receipt = tx.receipt(); // the transaction receipt\n   * const wrappedTokenId = tx.id; // the id of the wrapped token bundle\n   * ```\n   * @param contents - the contents to wrap\n   * @param wrappedTokenMetadata - metadata to represent the wrapped token bundle\n   * @param recipientAddress - Optional. The address to send the wrapped token bundle to\n   */\n  wrap = /* @__PURE__ */buildTransactionFunction(async (contents, wrappedTokenMetadata, recipientAddress) => {\n    const [uri, tokens, recipient] = await Promise.all([uploadOrExtractURI(wrappedTokenMetadata, this.storage), this.toTokenStructList(contents), resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress())]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"wrap\",\n      args: [tokens, uri, recipient],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensWrapped\", receipt?.logs);\n        if (event.length === 0) {\n          throw new Error(\"TokensWrapped event not found\");\n        }\n        const tokenId = event[0].args.tokenIdOfWrappedToken;\n        return {\n          id: tokenId,\n          receipt,\n          data: () => this.get(tokenId)\n        };\n      }\n    });\n  });\n\n  /**\n   * Unwrap a wrapped token bundle, and retrieve its contents\n   * @example\n   * ```javascript\n   * await contract.unwrap(wrappedTokenId);\n   * ```\n   * @param wrappedTokenId - the id of the wrapped token bundle\n   * @param recipientAddress - Optional. The address to send the unwrapped tokens to\n   */\n  unwrap = /* @__PURE__ */buildTransactionFunction(async (wrappedTokenId, recipientAddress) => {\n    const recipient = await resolveAddress(recipientAddress ? recipientAddress : await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"unwrap\",\n      args: [wrappedTokenId, recipient]\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  async toTokenStructList(contents) {\n    const tokens = [];\n    const provider = this.contractWrapper.getProvider();\n    const owner = await this.contractWrapper.getSignerAddress();\n    if (contents.erc20Tokens) {\n      for (const erc20 of contents.erc20Tokens) {\n        const normalizedQuantity = await normalizePriceValue(provider, erc20.quantity, erc20.contractAddress);\n        const hasAllowance = await hasERC20Allowance(this.contractWrapper, erc20.contractAddress, normalizedQuantity);\n        if (!hasAllowance) {\n          throw new Error(`ERC20 token with contract address \"${erc20.contractAddress}\" does not have enough allowance to transfer.\\n\\nYou can set allowance to the multiwrap contract to transfer these tokens by running:\\n\\nawait sdk.getToken(\"${erc20.contractAddress}\").setAllowance(\"${this.getAddress()}\", ${erc20.quantity});\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc20.contractAddress,\n          totalAmount: normalizedQuantity,\n          tokenId: 0,\n          tokenType: 0\n        });\n      }\n    }\n    if (contents.erc721Tokens) {\n      for (const erc721 of contents.erc721Tokens) {\n        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc721.contractAddress, erc721.tokenId, owner);\n        if (!isApproved) {\n          throw new Error(`ERC721 token \"${erc721.tokenId}\" with contract address \"${erc721.contractAddress}\" is not approved for transfer.\\n\\nYou can give approval the multiwrap contract to transfer this token by running:\\n\\nawait sdk.getNFTCollection(\"${erc721.contractAddress}\").setApprovalForToken(\"${this.getAddress()}\", ${erc721.tokenId});\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc721.contractAddress,\n          totalAmount: 0,\n          tokenId: erc721.tokenId,\n          tokenType: 1\n        });\n      }\n    }\n    if (contents.erc1155Tokens) {\n      for (const erc1155 of contents.erc1155Tokens) {\n        const isApproved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), erc1155.contractAddress, erc1155.tokenId, owner);\n        if (!isApproved) {\n          throw new Error(`ERC1155 token \"${erc1155.tokenId}\" with contract address \"${erc1155.contractAddress}\" is not approved for transfer.\\n\\nYou can give approval the multiwrap contract to transfer this token by running:\\n\\nawait sdk.getEdition(\"${erc1155.contractAddress}\").setApprovalForAll(\"${this.getAddress()}\", true);\\n\\n`);\n        }\n        tokens.push({\n          assetContract: erc1155.contractAddress,\n          totalAmount: erc1155.quantity,\n          tokenId: erc1155.tokenId,\n          tokenType: 2\n        });\n      }\n    }\n    return tokens;\n  }\n\n  /**\n   * @internal\n   */\n  async prepare(method, args, overrides) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method,\n      args,\n      overrides\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName, args, overrides) {\n    return this.contractWrapper.call(functionName, args, overrides);\n  }\n}\n\nexport { Multiwrap };\n","import { cA as BigNumberTransformSchema, cB as FileOrBufferOrStringSchema, cC as HexColor, cu as ContractWrapper } from './index-827e427d.browser.esm.js';\nimport { z } from 'zod';\nimport { i as isNativeToken } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\nconst PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional().nullable())();\n\n/**\n * @internal\n */\nconst BasicNFTInput = /* @__PURE__ */(() => z.object({\n  name: z.union([z.string(), z.number()]).optional().nullable(),\n  description: z.string().nullable().optional().nullable(),\n  image: FileOrBufferOrStringSchema.nullable().optional(),\n  animation_url: FileOrBufferOrStringSchema.optional().nullable()\n}))();\n\n/**\n * @internal\n */\nconst CommonNFTInput = /* @__PURE__ */(() => BasicNFTInput.extend({\n  external_url: FileOrBufferOrStringSchema.nullable().optional(),\n  background_color: HexColor.optional().nullable(),\n  properties: OptionalPropertiesInput,\n  attributes: OptionalPropertiesInput\n}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst NFTInputOrUriSchema = /* @__PURE__ */(() => z.union([CommonNFTInput, z.string()]))();\n\n/**\n * @internal\n */\nconst CommonNFTOutput = /* @__PURE__ */(() => CommonNFTInput.extend({\n  id: z.string(),\n  uri: z.string(),\n  image: z.string().nullable().optional(),\n  external_url: z.string().nullable().optional(),\n  animation_url: z.string().nullable().optional()\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\nexport { BasicNFTInput as B, CommonNFTOutput as C, NFTInputOrUriSchema as N, CommonNFTInput as a, setErc20Allowance as s };\n","import { Buffer } from 'buffer';\nimport reverse from 'buffer-reverse';\nimport { asTree } from 'treeify';\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nclass Base {\n  /**\n   * print\n   * @desc Prints out a visual representation of the merkle tree.\n   * @example\n   *```js\n   *tree.print()\n   *```\n   */\n  print() {\n    Base.print(this);\n  }\n\n  /**\n   * bufferIndexOf\n   * @desc Returns the first index of which given buffer is found in array.\n   * @param {Buffer[]} haystack - Array of buffers.\n   * @param {Buffer} needle - Buffer to find.\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.bufferIndexOf(haystack, needle)\n   *```\n   */\n  bufferIndexOf(array, element) {\n    let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (isSorted) {\n      return this.binarySearch(array, element, Buffer.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n    return this.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) {\n            continue;\n          }\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * binarySearch\n   * @desc Returns the first index of which given item is found in array using binary search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} compareFunction\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.binarySearch(array, element, Buffer.compare)\n   *```\n   */\n  binarySearch(array, element, compareFunction) {\n    return Base.binarySearch(array, element, compareFunction);\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * linearSearch\n   * @desc Returns the first index of which given item is found in array using linear search.\n   * @param {Buffer[]} array - Array of items.\n   * @param {Buffer} element - Item to find.\n   * @param {Function} eqChecker\n   * @return {Number} - Index number\n   *\n   * @example\n   * ```js\n   *const index = tree.linearSearch(array, element, (a, b) => a === b)\n   *```\n   */\n  linearSearch(array, element, eqChecker) {\n    return Base.linearSearch(array, element, eqChecker);\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer|ArrayBuffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = MerkleTree.bufferify('0x1234')\n   *```\n   */\n  static bufferify(value) {\n    if (!Buffer.isBuffer(value)) {\n      // crypto-js support\n      if (typeof value === \"object\" && value.words) {\n        return Buffer.from(value.toString(convertWordsToBuffer), \"hex\");\n      } else if (Base.isHexString(value)) {\n        return Buffer.from(value.replace(/^0x/, \"\"), \"hex\");\n      } else if (typeof value === \"string\") {\n        return Buffer.from(value);\n      } else if (typeof value === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      } else if (value instanceof Uint8Array) {\n        return Buffer.from(value.buffer);\n      } else if (typeof value === \"number\") {\n        let s = value.toString();\n        if (s.length % 2) {\n          s = `0${s}`;\n        }\n        return Buffer.from(s, \"hex\");\n      } else if (ArrayBuffer.isView(value)) {\n        return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n      }\n    }\n    return value;\n  }\n  bigNumberify(value) {\n    return Base.bigNumberify(value);\n  }\n  static bigNumberify(value) {\n    if (typeof value === \"bigint\") {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      if (value.startsWith(\"0x\") && Base.isHexString(value)) {\n        return BigInt(\"0x\" + value.replace(\"0x\", \"\").toString());\n      }\n      return BigInt(value);\n    }\n    if (Buffer.isBuffer(value)) {\n      return BigInt(\"0x\" + value.toString(\"hex\"));\n    }\n    if (value instanceof Uint8Array) {\n      return uint8ArrayToBigInt(value);\n    }\n    if (typeof value === \"number\") {\n      return BigInt(value);\n    }\n    throw new Error(\"cannot bigNumberify\");\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  static isHexString(v) {\n    return typeof v === \"string\" && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n\n  /**\n   * print\n   * @desc Prints out a visual representation of the given merkle tree.\n   * @param {Object} tree - Merkle tree instance.\n   * @return {String}\n   * @example\n   *```js\n   *MerkleTree.print(tree)\n   *```\n   */\n  static print(tree) {\n    console.log(tree.toString());\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = tree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Base.bufferToHex(value, withPrefix);\n  }\n\n  /**\n   * bufferToHex\n   * @desc Returns a hex string with 0x prefix for given buffer.\n   * @param {Buffer} value\n   * @return {String}\n   * @example\n   *```js\n   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n   *```\n   */\n  static bufferToHex(value) {\n    let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return `${withPrefix ? \"0x\" : \"\"}${(value || Buffer.alloc(0)).toString(\"hex\")}`;\n  }\n\n  /**\n   * bufferify\n   * @desc Returns a buffer type for the given value.\n   * @param {String|Number|Object|Buffer} value\n   * @return {Buffer}\n   *\n   * @example\n   * ```js\n   *const buf = tree.bufferify('0x1234')\n   *```\n   */\n  bufferify(value) {\n    return Base.bufferify(value);\n  }\n\n  /**\n   * bufferifyFn\n   * @desc Returns a function that will bufferify the return value.\n   * @param {Function}\n   * @return {Function}\n   *\n   * @example\n   * ```js\n   *const fn = tree.bufferifyFn((value) => sha256(value))\n   *```\n   */\n  bufferifyFn(f) {\n    return value => {\n      const v = f(value);\n      if (Buffer.isBuffer(v)) {\n        return v;\n      }\n      if (this.isHexString(v)) {\n        return Buffer.from(v.replace(\"0x\", \"\"), \"hex\");\n      }\n      if (typeof v === \"string\") {\n        return Buffer.from(v);\n      }\n      if (typeof v === \"bigint\") {\n        return Buffer.from(value.toString(16), \"hex\");\n      }\n      if (ArrayBuffer.isView(v)) {\n        return Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n      }\n\n      // crypto-js support\n      const arrayBuffer = hexStringToArrayBuffer(value.toString(\"hex\"));\n      // Assuming f now works with ArrayBuffers\n      const processedBuffer = f(arrayBuffer);\n      const hexResult = arrayBufferToHexString(processedBuffer);\n      return Buffer.from(hexResult, \"hex\");\n    };\n  }\n\n  /**\n   * isHexString\n   * @desc Returns true if value is a hex string.\n   * @param {String} value\n   * @return {Boolean}\n   *\n   * @example\n   * ```js\n   *console.log(MerkleTree.isHexString('0x1234'))\n   *```\n   */\n  isHexString(value) {\n    return Base.isHexString(value);\n  }\n\n  /**\n   * log2\n   * @desc Returns the log2 of number.\n   * @param {Number} value\n   * @return {Number}\n   */\n  log2(n) {\n    return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n  }\n\n  /**\n   * zip\n   * @desc Returns true if value is a hex string.\n   * @param {String[]|Number[]|Buffer[]} a - first array\n   * @param {String[]|Number[]|Buffer[]} b -  second array\n   * @return {String[][]|Number[][]|Buffer[][]}\n   *\n   * @example\n   * ```js\n   *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n   *```\n   */\n  zip(a, b) {\n    return a.map((e, i) => [e, b[i]]);\n  }\n  static hexZeroPad(hexStr, length) {\n    return \"0x\" + hexStr.replace(\"0x\", \"\").padStart(length, \"0\");\n  }\n}\nvar Base$1 = Base;\n\n// UTILS\n\n// replaces CryptoJS.enc.Hex\nfunction convertWordsToBuffer(value) {\n  const wordArray = value.words;\n  const arrayBuffer = new ArrayBuffer(wordArray.length * 4); // 4 bytes per word\n  const uint8View = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < wordArray.length; i++) {\n    uint8View[i * 4] = wordArray[i] >> 24 & 0xff;\n    uint8View[i * 4 + 1] = wordArray[i] >> 16 & 0xff;\n    uint8View[i * 4 + 2] = wordArray[i] >> 8 & 0xff;\n    uint8View[i * 4 + 3] = wordArray[i] & 0xff;\n  }\n  return arrayBuffer;\n}\nfunction hexStringToArrayBuffer(hexString) {\n  const buffer = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < hexString.length; i += 2) {\n    buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n  return buffer.buffer;\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n  const uint8View = new Uint8Array(arrayBuffer);\n  return Array.from(uint8View).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction uint8ArrayToBigInt(u8a) {\n  const hex = Array.from(u8a).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  return BigInt(`0x${hex}`);\n}\n\n// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\n\n// TODO: Clean up and DRY up code\n// Disclaimer: The multiproof code is unaudited and may possibly contain serious issues. It's in a hacky state as is and needs to be rewritten.\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base$1 {\n  duplicateOdd = false;\n  concatenator = Buffer.concat;\n  hashLeaves = false;\n  isBitcoinTree = false;\n  leaves = [];\n  layers = [];\n  sortLeaves = false;\n  sortPairs = false;\n  sort = false;\n  fillDefaultHash = null;\n  complete = false;\n\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves, hashFn) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (options.complete) {\n      if (options.isBitcoinTree) {\n        throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n      }\n      if (options.duplicateOdd) {\n        throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n      }\n    }\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.complete = !!options.complete;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === \"function\") {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === \"string\") {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    this.sort = !!options.sort;\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n    this.duplicateOdd = !!options.duplicateOdd;\n    if (options.concatenator) {\n      this.concatenator = options.concatenator;\n    }\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    return {\n      complete: this.complete,\n      isBitcoinTree: this.isBitcoinTree,\n      hashLeaves: this.hashLeaves,\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs,\n      sort: this.sort,\n      fillDefaultHash: this.fillDefaultHash?.toString() ?? null,\n      duplicateOdd: this.duplicateOdd\n    };\n  }\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.leaves = leaves.map(this.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Buffer.compare);\n    }\n    if (this.fillDefaultHash) {\n      for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n      }\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            const data = nodes[nodes.length - 1];\n            let hash = data;\n\n            // is bitcoin tree\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              hash = this.hashFn(this.concatenator([reverse(data), reverse(data)]));\n              hash = reverse(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) ; else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let combined = null;\n        if (this.isBitcoinTree) {\n          combined = [reverse(left), reverse(right)];\n        } else {\n          combined = [left, right];\n        }\n        if (this.sortPairs) {\n          combined.sort(Buffer.compare);\n        }\n        let hash = this.hashFn(this.concatenator(combined));\n\n        // double hash if bitcoin tree\n        if (this.isBitcoinTree) {\n          hash = reverse(this.hashFn(hash));\n        }\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n        if (this.sortLeaves) {\n          values = values.sort(Buffer.compare);\n        }\n      }\n      return this.leaves.filter(\n      // @ts-expect-error - issue from original code\n      leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n    }\n    return this.leaves;\n  }\n\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return Buffer.from([]);\n    }\n    return this.leaves[index];\n  }\n\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n  getLeafCount() {\n    return this.leaves.length;\n  }\n\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n    if (typeof jsonStr === \"string\") {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error(\"Expected type of string or object\");\n    }\n    if (!parsed) {\n      return [];\n    }\n    if (!Array.isArray(parsed)) {\n      throw new Error(\"Expected JSON string to be array\");\n    }\n    return parsed.map(MerkleTree.bufferify);\n  }\n\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[][]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n  getLayers() {\n    return this.layers;\n  }\n\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[][]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n  }\n\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n      return acc;\n    }, []);\n    layers.unshift(Buffer.from([0]));\n    return layers;\n  }\n\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n  getRoot() {\n    if (this.layers.length === 0) {\n      return Buffer.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || Buffer.from([]);\n  }\n\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n  getProof(leaf, index) {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    leaf = this.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ?\n      // @ts-expect-error - issue from original code\n      index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ?\n      // Proof Generation for Bitcoin Trees\n      index :\n      // Proof Generation for Non-Bitcoin Trees\n      // @ts-expect-error - issue from original code\n      index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex]\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = index / 2 | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getProofs\n   * @desc Returns the proofs for all leaves.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n   * @example\n   * ```js\n   *const proofs = tree.getProofs()\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proofs = tree.getProofs()\n   *```\n   */\n  getProofs() {\n    // @ts-expect-error - issue from original code\n    const proof = [];\n    // @ts-expect-error - issue from original code\n    const proofs = [];\n\n    // @ts-expect-error - issue from original code\n    this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n\n    // @ts-expect-error - issue from original code\n    return proofs;\n  }\n\n  /**\n   * getProofsDFS\n   * @desc Get all proofs through single traverse\n   * @param {Number} currentLayer - Current layer index in traverse.\n   * @param {Number} index - Current tarvese node index in traverse.\n   * @param {Object[]} proof - Proof chain for single leaf.\n   * @param {Object[]} proofs - Proofs for all leaves\n   * @example\n   * ```js\n   *const layers = tree.getLayers()\n   *const index = 0;\n   *let proof = [];\n   *let proofs = [];\n   *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n   *```\n   */\n  // @ts-expect-error - issue from original code\n  getProofsDFS(currentLayer, index, proof, proofs) {\n    const isRightNode = index % 2;\n    if (currentLayer === -1) {\n      if (!isRightNode) {\n        proofs.push([...proof].reverse());\n      }\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    if (index >= this.layers[currentLayer].length) {\n      // @ts-expect-error - issue from original code\n      return;\n    }\n    const layer = this.layers[currentLayer];\n    const pairIndex = isRightNode ? index - 1 : index + 1;\n    let pushed = false;\n    if (pairIndex < layer.length) {\n      pushed = true;\n      proof.push({\n        position: isRightNode ? \"left\" : \"right\",\n        data: layer[pairIndex]\n      });\n    }\n    const leftchildIndex = index * 2;\n    const rightchildIndex = index * 2 + 1;\n    this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n    this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n    if (pushed) {\n      proof.splice(proof.length - 1, 1);\n    }\n  }\n\n  /**\n   * getHexProofs\n   * @desc Returns the proofs for all leaves as hex strings.\n   * @return {String[]} - Proofs array as hex strings.\n   * @example\n   * ```js\n   *const proofs = tree.getHexProofs()\n   *```\n   */\n  getHexProofs() {\n    return this.getProofs().map(item => this.bufferToHex(item.data));\n  }\n\n  /**\n   * getPositionalHexProof\n   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n   * @example\n   * ```js\n   *const proof = tree.getPositionalHexProof(leaves[2])\n   *```\n   */\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === \"left\" ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n  getProofIndices(treeIndices, depth) {\n    const leafCount = 2 ** depth;\n    let maximalIndices = new Set();\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((x, y) => x - y).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) {\n            break;\n          }\n          index = index / 2 | 0;\n        }\n      }\n    }\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n    }\n    return proofIndices;\n  }\n\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n  getMultiProof(tree, indices) {\n    if (!this.complete) {\n      console.warn(\"Warning: For correct multiProofs it's strongly recommended to set complete: true\");\n    }\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // @ts-expect-error - issue from original code\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n    // @ts-expect-error - issue from original code\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n      if (this.sortPairs) {\n        // @ts-expect-error - issue from original code\n        els = els.sort(Buffer.compare);\n      }\n\n      // @ts-expect-error - issue from original code\n      let ids = els.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error(\"Element does not exist in Merkle tree\");\n      }\n\n      // @ts-expect-error - issue from original code\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n          const pairElement = this.getPairNode(layer, idx);\n          hashes.push(layer[idx]);\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n          nextIds.push(idx / 2 | 0);\n        }\n        ids = nextIds.filter((value, j, self) => self.indexOf(value) === j);\n        nextIds = [];\n      }\n\n      // @ts-expect-error - issue from original code\n      return proof.filter(value => !hashes.includes(value));\n    }\n\n    // @ts-expect-error - issue from original code\n    return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(\n    // @ts-expect-error - issue from original code\n    index => tree[index]);\n  }\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n    let proofHashes = [];\n    // @ts-expect-error - issue from original code\n    let currentLayerIndices = indices;\n    // @ts-expect-error - issue from original code\n    for (const treeLayer of tree) {\n      const siblings = [];\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n        const idx = index - 1;\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n        uniqueIndices.add((index - 1) / 2);\n      }\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n    return proofHashes;\n  }\n\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error(\"Invalid Inputs!\");\n    }\n    let ids;\n    if (leaves.every(Number.isInteger)) {\n      ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error(\"Element does not exist in Merkle tree\");\n    }\n    const _proofs = proofs.map(item => this.bufferify(item));\n\n    // @ts-expect-error - issue from original code\n    const tested = [];\n    // @ts-expect-error - issue from original code\n    const flags = [];\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids_, idx) => {\n        // @ts-expect-error - issue from original code\n        const skipped = tested.includes(layer[idx]);\n        if (!skipped) {\n          const pairElement = this.getPairNode(layer, idx);\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n          // eslint-disable-next-line no-unused-expressions\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n        // @ts-expect-error - issue from original code\n        ids_.push(idx / 2 | 0);\n        return ids_;\n      }, []);\n    }\n\n    // @ts-expect-error - issue from original code\n    return flags;\n  }\n\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null;\n\n      // case for when proof is hex values only\n      if (typeof node === \"string\") {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === \"left\";\n      } else {\n        throw new Error(\"Expected node to be of type string or object\");\n      }\n      const buffers = [];\n      if (this.isBitcoinTree) {\n        buffers.push(reverse(hash));\n        buffers[isLeftNode ? \"unshift\" : \"push\"](reverse(data));\n        hash = this.hashFn(this.concatenator(buffers));\n        hash = reverse(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(this.concatenator(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(this.concatenator(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? \"unshift\" : \"push\"](data);\n          hash = this.hashFn(this.concatenator(buffers));\n        }\n      }\n    }\n    return Buffer.compare(hash, root) === 0;\n  }\n\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n    for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n      // @ts-expect-error - issue from original code\n      tree[2 ** depth + index] = leaf;\n    }\n    for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n      // @ts-expect-error - issue from original code\n      tree[index] = proofitem;\n    }\n    let indexqueue = Object.keys(tree).map(value => Number(value)).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        // @ts-expect-error - issue from original code\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n        if (this.sortPairs) {\n          pair = pair.sort(Buffer.compare);\n        }\n        const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n        // @ts-expect-error - issue from original code\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n      i += 1;\n    }\n    return !proofIndices.length ||\n    // @ts-expect-error - issue from original code\n    {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(Buffer.compare);\n      hashes[i] = this.hashFn(this.concatenator(buffers));\n    }\n    return Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n        if (objs.length) {\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          // @ts-expect-error - issue from original code\n          const akey = Object.keys(a)[0];\n          // @ts-expect-error - issue from original code\n          obj[layers[i][j]][akey] = a[akey];\n          if (objs.length) {\n            const b = objs.shift();\n            // @ts-expect-error - issue from original code\n            const bkey = Object.keys(b)[0];\n            // @ts-expect-error - issue from original code\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n        arr.push(obj);\n      }\n      objs.push(...arr);\n    }\n    return objs[0];\n  }\n\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n  getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      // @ts-expect-error - issue from original code\n      return null;\n    }\n  }\n\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n  toTreeString() {\n    const obj = this.getLayersAsObject();\n    return asTree(obj, true, false);\n  }\n\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n  toString() {\n    return this.toTreeString();\n  }\n  isUnevenTree(treeLayers) {\n    const depth = treeLayers?.length || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n    const tree = [leafTuples];\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex])\n      // @ts-expect-error - issue from original code\n      .sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      })\n      // @ts-expect-error - issue from original code\n      .map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex_] = _ref8;\n        return layerIndex_;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n      tree.push(parentLayer);\n    }\n    return tree[tree.length - 1][0][1];\n  }\n}\n\nexport { MerkleTree };\n","import { constants, utils, BigNumber } from 'ethers';\nimport { bO as SnapshotInputSchema, bP as SnapshotEntryWithProofSchema, bQ as SnapshotSchema, cu as ContractWrapper, b9 as BigNumberSchema, aZ as NATIVE_TOKEN_ADDRESS, cz as AmountSchema, cD as QuantitySchema, ba as BigNumberishSchema, cE as BytesLikeSchema, s as DuplicateLeafsError, bd as AddressOrEnsSchema, bc as AddressSchema, cF as BasisPointsSchema } from './index-827e427d.browser.esm.js';\nimport { f as fetchCurrencyMetadata, i as isNativeToken, a as fetchCurrencyValue } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport { MerkleTree } from '@thirdweb-dev/merkletree';\nimport { S as StartDateSchema, E as EndDateSchema } from './assertEnabled-ea837eec.browser.esm.js';\nimport { z } from 'zod';\nimport { N as NFTInputOrUriSchema } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { v4 } from 'uuid';\n\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\n\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\n\n/**\n * @internal\n * @param quantity - The quantity to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return constants.MaxUint256;\n  } else {\n    return utils.parseUnits(quantity, tokenDecimals);\n  }\n}\n\nasync function parseSnapshotInputs(inputs) {\n  const chunkSize = 25000;\n  const chunks = Array.from({\n    length: Math.ceil(inputs.length / chunkSize)\n  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));\n  const results = [];\n  const parsedChunks = await Promise.all(chunks.map(chunk => SnapshotInputSchema.parseAsync(chunk)));\n  for (const chunk of parsedChunks) {\n    results.push(...chunk);\n  }\n  return results;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion = /*#__PURE__*/function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n  return SnapshotFormatVersion;\n}({}); // address, maxClaimable, price, currencyAddress\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = await parseSnapshotInputs(snapshotInput);\n\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new MerkleTree(Object.values(roots), utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        const uri = this.baseUri.endsWith(\"/\") ? this.baseUri : `${this.baseUri}/`;\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${uri}${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new MerkleTree(hashedEntries, utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parseAsync({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\n\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = await SnapshotSchema.parseAsync(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\n\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\n\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns - `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? constants.MaxUint256 : utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = BigNumber.from(pricePerToken).mul(quantity).div(utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * @internal\n */\nconst CurrencySchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  symbol: z.string(),\n  decimals: z.number()\n}))();\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = /* @__PURE__ */(() => CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: z.string()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = /* @__PURE__ */(() => z.object({\n  name: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = /* @__PURE__ */(() => z.object({\n  startTime: StartDateSchema,\n  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: AmountSchema.default(0),\n  maxClaimableSupply: QuantitySchema,\n  maxClaimablePerWallet: QuantitySchema,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([0], 32)),\n  snapshot: z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = /* @__PURE__ */(() => z.array(ClaimConditionInputSchema))();\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.partial())();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.extend({\n  availableSupply: QuantitySchema,\n  currentMintSupply: QuantitySchema,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n}))();\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider - the provider to use\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion - the snapshot format version\n * @returns the generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = await parseSnapshotInputs(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\n\nfunction compare(a, b) {\n  const left = BigNumber.from(a);\n  const right = BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c - The condition input\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs - The claim conditions to process\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param storage - The storage to use\n * @param snapshotFormatVersion - The snapshot format version to use\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot - The merkle root to fetch the snapshot for\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = await SnapshotSchema.parseAsync(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param bn - The big number to convert\n * @param tokenDecimals - The token decimals to use\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm - The contract model to transform\n * @param tokenDecimals - The token decimals to use\n * @param provider - The provider to use\n * @param merkleMetadata - The merkle metadata to use\n * @param storage - The storage to use\n * @param shouldDownloadSnapshot - Whether to download the snapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parseAsync({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param index - The index of the condition to update\n * @param claimConditionInput - The input claim condition to update\n * @param existingConditions - The existing claim conditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\nlet ClaimEligibility = /*#__PURE__*/function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"ClaimPhaseNotStarted\"] = \"Claim phase has not started yet.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"WrongPriceOrCurrency\"] = \"Incorrect price or currency.\";\n  ClaimEligibility[\"OverMaxClaimablePerWallet\"] = \"Cannot claim more than maximum allowed quantity.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n  return ClaimEligibility;\n}({});\n\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    v4({}, buffer);\n    return utils.hexlify(utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = /* @__PURE__ */(() => z.object({\n  to: AddressOrEnsSchema.refine(address => address.toLowerCase() !== constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: AmountSchema.default(0),\n  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  quantity: AmountSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = /* @__PURE__ */(() => Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  metadata: NFTInputOrUriSchema,\n  royaltyRecipient: z.string().default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0)\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  uri: z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = /* @__PURE__ */(() => Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\nexport { SnapshotFormatVersion as A, BaseSignaturePayloadInput as B, ClaimEligibility as C, processClaimConditionInputs as D, abstractContractModelToLegacy as E, abstractContractModelToNew as F, GenericRequest as G, updateExistingClaimConditions as H, resolveOrGenerateId as I, MintRequest20 as M, PartialClaimConditionInputSchema as P, Signature20PayloadInput as S, approveErc20Allowance as a, createSnapshot as b, convertToReadableQuantity as c, ClaimConditionMetadataSchema as d, ClaimConditionInputSchema as e, fetchSnapshotEntryForAddress as f, ClaimConditionInputArray as g, ClaimConditionOutputSchema as h, CurrencySchema as i, CurrencyValueSchema as j, Signature20PayloadOutput as k, Signature721PayloadInput as l, Signature721PayloadOutput as m, Signature1155PayloadInput as n, Signature1155PayloadInputWithTokenId as o, Signature1155PayloadOutput as p, Signature721WithQuantityInput as q, Signature721WithQuantityOutput as r, MintRequest721 as s, MintRequest1155 as t, MintRequest721withQuantity as u, transformResultToClaimCondition as v, legacyContractModelToAbstract as w, newContractModelToAbstract as x, convertQuantityToBigNumber as y, prepareClaim as z };\n","module.exports = function reverse (src) {\n  var buffer = new Buffer(src.length)\n\n  for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n","//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '└' : '├');\n    if (key) {\n      str += '─ ';\n    } else {\n      str += '──┐';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '│') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"],"names":["InterfaceId_IERC721","InterfaceId_IERC1155","FALLBACK_METADATA","name","async","fetchTokenMetadata","tokenId","tokenUri","storage","startsWith","Buffer","base64","split","jsonMetadata","JSON","parse","from","toString","C","id","uri","parsedUri","replace","toHexString","slice","downloadJSON","err","unparsedTokenIdUri","e","console","warn","stringify","fetchTokenMetadataForContract","contractAddress","provider","ERC165MetadataAbi","default","erc165","isERC721","isERC1155","Promise","all","supportsInterface","ERC721MetadataAbi","erc721","tokenURI","Error","ERC1155MetadataAbi","erc1155","uploadOrExtractURI","metadata","upload","uploadOrExtractURIs","metadatas","startNumber","options","undefined","find","m","isUriList","isMetadataList","uploadBatch","map","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","uris","baseUri","substring","lastIndexOf","i","length","DEFAULT_QUERY_ALL_COUNT","RawDateSchema","z","union","date","transform","Math","floor","getTime","number","StartDateSchema","Date","EndDateSchema","now","assertEnabled","namespace","feature","detectContractFeature","contractWrapper","featureName","abi","hasFunction","functionName","readContract","functions","ContractMetadata","constructor","schema","this","parseOutputMetadata","output","parseAsync","parseInputMetadata","input","get","data","supportsContractMetadata","read","includes","contractName","contractSymbol","publishedMetadata","address","getProvider","symbol","description","info","title","set","_parseAndUploadMetadata","wrapper","T","fromContractWrapper","method","args","receipt","update","prepare","parsedMetadata","ContractEvents","addTransactionListener","listener","addListener","Transaction","removeTransactionListener","off","addEventListener","eventName","event","interface","getEvent","filter","topics","getEventTopic","wrappedListener","log","parsedLog","parseLog","toContractEvent","eventFragment","on","listenToAllEvents","error","removeEventListener","removeAllListeners","getAllEvents","filters","arguments","fromBlock","toBlock","order","orderedEvents","queryFilter","sort","a","b","blockNumber","parseEvents","getEvents","eventInterface","inputs","events","transaction","Object","fromEntries","entries","key","value","rawLog","results","forEach","param","index","Array","isArray","components","arr","type","objArray","tuple","obj","j","push","GasCostEstimator","gasCostOf","fn","price","gasUnits","getGasPrice","estimateGas","mul","gasLimitOf","currentGasPriceInGwei","ContractAppURI","app_uri","getGatewayUrls","appURI","ContractRoyalty","getDefaultRoyaltyInfo","royaltyRecipient","royaltyBps","fee_recipient","seller_fee_basis_points","getTokenRoyaltyInfo","setDefaultRoyaltyInfo","oldMetadata","mergedMetadata","royaltyData","contractURI","h","contractEncoder","encoded","encode","setTokenRoyaltyInfo","parsedRoyaltyData","DelayedReveal","nextTokenIdToMintFn","createDelayedRevealBatch","placeholder","password","placeholderUris","placeholderUri","g","startFileNumber","toNumber","baseUriId","hashedPassword","hashDelayRevealPassword","encryptedBaseUri","isLegacyContract","chainId","getChainID","provenanceHash","endsWith","parseLogs","logs","startingIndex","startTokenId","endingIndex","endTokenId","lte","add","reveal","batchId","decryptedUri","callStatic","getBatchesToReveal","count","isZero","countRangeArray","keys","uriIndices","uriIndicesWithZeroStart","tokenMetadatas","getNftMetadata","legacyContract","encryptedBaseUris","getLegacyEncryptedData","decode","meta","batchUri","placeholderMetadata","_","batchTokenIndex","DeprecatedAbi","legacy","result","calculateClaimCost","pricePerToken","quantity","currencyAddress","checkERC20Allowance","overrides","currency","totalCost","n","gt","ContractOwner","resolvedAddress","ContractRoles","roles","getAll","_ref","role","item","roleHash","setAll","rolesWithAddresses","every","currentRoles","sortedRoles","addresses","currentAddresses","addressOrEns","toAdd","toRemove","getRevokeRoleFunctionName","revokeFunctionName","verify","members","toLowerCase","grant","revoke","signerAddress","getSignerAddress","DropClaimConditions","getActive","cc","tokenDecimals","getTokenDecimals","merkle","withAllowList","conditionId","isLegacySinglePhaseDrop","contractModel","isLegacyMultiPhaseDrop","isNewSinglePhaseDrop","isNewMultiphaseDrop","currentStartId","countBn","startId","conditions","decimals","fetchedConditions","c","canClaim","addressToCheck","getClaimIneligibilityReasons","reasons","activeConditionIndex","claimCondition","NoWallet","quantityWithDecimals","NoClaimConditionSet","Unknown","availableSupply","lt","NotEnoughSupply","hasAllowList","merkleRootHash","allowListEntry","getClaimerProofs","AddressNotAllowed","claimVerification","prepareClaim","validMerkleProof","proofs","maxClaimable","proof","maxQuantityInAllowlist","quantityLimitPerWallet","currencyAddressInProof","priceInProof","reason","OverMaxClaimablePerWallet","WrongPriceOrCurrency","ClaimPhaseNotStarted","claimedSupply","maxClaimablePerWallet","getSupplyClaimedByWallet","eq","lastClaimedTimestamp","timestampForNextClaim","div","AlreadyClaimed","WaitBeforeNextClaimTransaction","totalPrice","getBalance","NotEnoughTokens","ERC20Abi","erc20","claimerAddress","claimConditionId","merkleRoot","f","getSnapshotFormatVersion","walletAddress","activeClaimConditionId","_this","claimConditionInputs","resetClaimEligibilityForAll","claimConditionsProcessed","startTime","maxClaimableSupply","waitInSeconds","snapshot","s","Number","reduce","acc","current","snapshotInfos","sortedConditions","merkleInfo","snapshotUri","cw","baseContractEncoder","contractEncoderLegacy","claimConditionInput","existingConditions","newConditionInputs","d","resolve","addressToClaim","activeClaimConditions","getClaimArguments","destinationAddress","getClaimTransaction","V1","V2","Erc721BatchMintable","to","u","tokenIdMinted","Erc721ClaimableWithConditions","D","tx","setParse","Erc721Claimable","Erc721LazyMintable","revealer","detectErc721Revealable","lazyMint","nextTokenIdToMint","batch","getTokenMetadata","Erc721Mintable","detectErc721BatchMintable","toAddress","getMintTransaction","Erc721Enumerable","queryParams","tokenIds","start","balance","indices","Erc721AQueryable","Erc721Supply","owned","detectErc721Owned","maxSupply","maxId","min","allOwners","totalCount","totalClaimedSupply","owners","ownerOf","catch","owner","o","totalCirculatingSupply","TieredDropPayloadSchema","B","extend","tierPriority","array","string","GenericRequest","Erc721TieredDrop","getMetadataInTier","tier","batches","t","ranges","range","nftsInRange","baseURIs","startIdInclusive","endIdNonInclusive","flat","getTokensInTier","endIndex","createBatchWithTier","createDelayedRevealBatchWithTier","generate","payloadToSign","payload","generateBatch","payloadsToSign","parsedPayloads","signer","getSigner","signature","signTypedData","version","verifyingContract","mapPayloadToContractStruct","signedPayload","message","claimWithSignature","normalizedTotalPrice","getCallOverrides","sendTransaction","quantityClaimed","primarySaleRecipient","uid","validityStartTimestamp","mintStartTime","validityEndTimestamp","mintEndTime","Erc721Burnable","token","Erc721ClaimableZora","getAddress","getSaleDetails","publicSalePrice","zoraFee","amount","firstPurchasedTokenId","Erc721LoyaltyCard","cancel","Erc721UpdatableMetadata","Erc721SharedMetadata","image","imageURI","animation_url","animationURI","sanitizeJSONString","imageUri","animationUri","val","sanitized","Erc721WithQuantitySignatureMintable","mint","mintRequest","isLegacyNFTContract","mapLegacyPayloadToContractStruct","mintBatch","contractPayloads","signedPayloads","p","verification","parsedRequests","r","finalPayload","MintRequest","normalizedPricePerToken","Erc721","_chainId","query","detectErc721Enumerable","mintable","detectErc721Mintable","burnable","detectErc721Burnable","lazyMintable","detectErc721LazyMintable","tieredDropable","detectErc721TieredDrop","signatureMintable","detectErc721SignatureMintable","claimWithConditions","detectErc721ClaimableWithConditions","claimCustom","detectErc721Claimable","claimZora","detectErc721ClaimableZora","erc721SharedMetadata","detectErc721SharedMetadata","loyaltyCard","detectErc721LoyaltyCard","updatableMetadata","detectErc721UpdatableMetadata","onNetworkUpdated","network","updateSignerOrProvider","F","supply","balanceOf","isApproved","operator","_address","_operator","transfer","_to","transferFrom","fromAddress","setApprovalForAll","approved","setApprovalForToken","getAllOwners","getOwned","ownedTokens","getOwnedTokenIds","mintTo","receiver","mintBatchTo","burn","claim","claimTo","contract","totalUnclaimedSupply","sub","claimConditions","tieredDrop","sharedMetadata","StandardErc721","totalSupply","hasERC20Allowance","contractToApprove","spender","gte","isTokenApprovedForTransfer","transferrerContractAddress","assetContract","ERC165Abi","I","ERC721Abi","asset","isApprovedForAll","approvedAddress","getApproved","ERC1155Abi","handleTokenApproval","marketplaceAddress","getSignerOrProvider","validateNewListingParam","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","startTimestamp","reservePricePerToken","mapOffer","listingId","offer","quantityDesired","currencyContractAddress","buyerAddress","offeror","quantityWanted","currencyValue","isWinningBid","winningPrice","newBidPrice","bidBuffer","getAllInBatches","end","Multiwrap","S","static","super","app","contractRoles","encoder","estimator","G","royalties","getWrappedContents","wrappedTokenId","wrappedTokens","erc20Tokens","erc721Tokens","erc1155Tokens","tokenType","tokenMetadata","totalAmount","wrap","contents","wrappedTokenMetadata","recipientAddress","tokens","recipient","toTokenStructList","tokenIdOfWrappedToken","unwrap","normalizedQuantity","call","PropertiesInput","object","catchall","unknown","OptionalPropertiesInput","optional","nullable","BasicNFTInput","CommonNFTInput","external_url","background_color","properties","attributes","NFTInputOrUriSchema","CommonNFTOutput","setErc20Allowance","Base","print","bufferIndexOf","element","binarySearch","compare","linearSearch","buffer1","buffer2","equals","compareFunction","mid","ordering","eqChecker","bufferify","isBuffer","words","convertWordsToBuffer","isHexString","Uint8Array","buffer","ArrayBuffer","isView","byteOffset","byteLength","bigNumberify","BigInt","u8a","hex","byte","padStart","join","uint8ArrayToBigInt","v","test","tree","bufferToHex","withPrefix","alloc","bufferifyFn","arrayBuffer","hexString","parseInt","hexStringToArrayBuffer","hexResult","uint8View","arrayBufferToHexString","log2","zip","hexZeroPad","hexStr","Base$1","wordArray","MerkleTree","duplicateOdd","concatenator","concat","hashLeaves","isBitcoinTree","leaves","layers","sortLeaves","sortPairs","fillDefaultHash","complete","hashFn","idx","processLeaves","getOptions","pow","ceil","createHashes","nodes","layerIndex","layerLimit","isInteger","hash","left","right","combined","addLeaf","leaf","addLeaves","getLeaves","values","getLeaf","getLeafIndex","target","getLeafCount","getHexLeaves","marshalLeaves","unmarshalLeaves","jsonStr","parsed","getLayers","getHexLayers","layer","getLayersFlat","unshift","getHexLayersFlat","getLayerCount","getRoot","getHexRoot","getProof","isRightNode","pairIndex","position","getHexProof","getProofs","getProofsDFS","currentLayer","reverse","pushed","leftchildIndex","rightchildIndex","splice","getHexProofs","getPositionalHexProof","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","x","y","redundantIndices","has","getProofIndicesForUnevenTree","sortedLeafIndices","leavesCount","unevenLayers","proofIndices","layerNodes","proofNodeIndices","unevenLayer","getMultiProof","isUnevenTree","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","pairElement","getPairNode","self","indexOf","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getHexMultiProof","getProofFlags","_proofs","tested","flags","ids_","proofUsed","targetNode","root","node","isLeftNode","buffers","verifyMultiProof","proofLeaves","verifyMultiProofForUnevenTree","proofitem","indexqueue","hasOwnProperty","pair","verifyMultiProofWithFlags","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","computedRoot","calculateRootForUnevenTree","getDepth","getLayersAsObject","objs","shift","akey","bkey","resetTree","pairIdx","toTreeString","asTree","treeLayers","isPowOf2","leafIndices","leafHashes","totalLeavesCount","leafTuples","_ref2","_ref3","indexA","indexB","leafTupleIndices","_ref4","nextSliceStart","proofTuplesByLayers","sliceStart","_ref5","_ref6","_ref7","_ref8","layerIndex_","parentIndices","parentLayer","parentNodeTreeIndex","bufA","bufB","abstractContractModelToLegacy","model","supplyClaimed","quantityLimitPerTransaction","waitTimeInSecondsBetweenClaims","abstractContractModelToNew","convertQuantityToBigNumber","parseSnapshotInputs","chunkSize","chunks","parsedChunks","chunk","SnapshotFormatVersion","ShardedMerkleTree","originalEntriesUri","shardNybbles","shards","trees","fromUri","shardedMerkleTreeInfo","isShardedMerkleTree","fromShardedMerkleTreeInfo","hashEntry","entry","currencyDecimals","snapshotFormatVersion","fetchAndCacheDecimals","cache","buildAndUpload","snapshotInput","snapshotEntry","shard","currencyDecimalMap","subTrees","roots","shardsToUpload","shardId","shardedMerkleInfo","hashedEntries","getAllEntries","fetchSnapshotEntryForAddress","merkleMetadata","raw","merkleTree","snapshotData","claims","legacyContractModelToAbstract","newContractModelToAbstract","approveErc20Allowance","allowance","activeClaimCondition","merkleMetadataFetcher","CurrencySchema","CurrencyValueSchema","displayValue","ClaimConditionMetadataSchema","ClaimConditionInputSchema","ClaimConditionInputArray","ClaimConditionOutputSchema","currentMintSupply","currencyMetadata","processSnapshotData","inputsWithSnapshots","conditionInput","snapshotInfo","size","createSnapshot","processClaimConditionInputs","parsedInputs","metadataOrUri","convertToContractModel","fetchSnapshot","smt","convertToReadableQuantity","bn","transformResultToClaimCondition","pm","shouldDownloadSnapshot","cv","resolvedMetadata","updateExistingClaimConditions","priceDecimals","priceInWei","priceInTokens","newConditionParsed","mergedConditionOutput","existingOutput","newConditionAtIndex","formattedPrice","ClaimEligibility","resolveOrGenerateId","requestUId","v4","BaseSignaturePayloadInput","refine","E","arg","Signature20PayloadInput","Signature20PayloadOutput","Signature721PayloadInput","N","Signature721PayloadOutput","Signature1155PayloadInput","Signature1155PayloadInputWithTokenId","Signature1155PayloadOutput","Signature721WithQuantityInput","Signature721WithQuantityOutput","MintRequest20","MintRequest721","MintRequest1155","MintRequest721withQuantity","module","exports","src","makePrefix","last","str","filterKeys","hideFunctions","branch","growBranch","lastStates","showValues","callback","lastKey","circular","line","lastStatesCopy","lastState","Treeify","lineCallback","factory"],"sourceRoot":""}