"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9967],{89050:(t,r,e)=>{e.d(r,{D:()=>g,F:()=>d,I:()=>c,a:()=>p,b:()=>h,c:()=>u,f:()=>l,g:()=>f,u:()=>m});var a=e(41518),n=e(16441),o=e(2593),i=e(64146),s=e(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),d={name:"Failed to load NFT metadata"};async function l(t,r,e){if(r.startsWith("data:application/json;base64")&&void 0!==s){const e=r.split(",")[1],n=JSON.parse(s.from(e,"base64").toString("utf-8"));return a.C.parse({...n,id:o.O$.from(t).toString(),uri:r})}const i=r.replace("{id}",n.hexZeroPad(o.O$.from(t).toHexString(),32).slice(2));let c;try{c=await e.downloadJSON(i)}catch(a){const n=r.replace("{id}",o.O$.from(t).toString());try{c=await e.downloadJSON(n)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:r})} -- falling back to default metadata`),c=d}}return a.C.parse({...c,id:o.O$.from(t).toString(),uri:r})}async function u(t,r,n,s){let u;const h=(await e.e(5025).then(e.t.bind(e,25025,19))).default,m=new i.CH(t,h,r),[f,g]=await Promise.all([m.supportsInterface(c),m.supportsInterface(p)]);if(f){const a=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,o=new i.CH(t,a,r);u=await o.tokenURI(n)}else{if(!g)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,o=new i.CH(t,a,r);u=await o.uri(n)}}return u?l(n,u,s):a.C.parse({...d,id:o.O$.from(n).toString(),uri:""})}async function h(t,r){return"string"==typeof t?t:await r.upload(a.a.parse(t))}async function m(t,r,e,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await r.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function f(t){const r=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const a=t[e].substring(0,t[e].lastIndexOf("/"));if(r!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${r}' but got '${a}'`)}return r.replace(/\/$/,"")+"/"}const g=100},89208:(t,r,e)=>{e.d(r,{E:()=>c,R:()=>i,S:()=>s,a:()=>p});var a=e(2593),n=e(1604),o=e(7860);const i=(()=>n.z.union([n.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),n.z.number().transform((t=>a.O$.from(t)))]))(),s=(()=>i.default(new Date(0)))(),c=(()=>i.default(new Date(Date.now()+31536e7)))();function p(t,r){if(!t)throw new o.x(r);return t}},15070:(t,r,e)=>{e.d(r,{c:()=>o});var a=e(7860),n=e(68828);function o(t){return(0,n.i)(t)?a.aZ:t}},89536:(t,r,e)=>{e.d(r,{C:()=>p,G:()=>l,a:()=>d,b:()=>u,d:()=>s,h:()=>c});var a=e(7860),n=e(19578),o=e(61744),i=e(40721);function s(t,r){return(0,a.am)(a.bn.parse(t.abi),r)}function c(t,r){return t in r.readContract.functions}class p{featureName=a.d1.name;constructor(t,r,e){this.contractWrapper=t,this.schema=r,this.storage=e}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const r=await this.contractWrapper.read("contractURI",[]);r&&r.includes("://")&&(t=await this.storage.downloadJSON(r))}if(!t)try{let r,e,n;try{c("name",this.contractWrapper)&&(r=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(e=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:r||n?.name,symbol:e,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const r=await this._parseAndUploadMetadata(t),e=this.contractWrapper;if(this.supportsContractMetadata(e))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[r],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const r=await this.parseInputMetadata(t);return this.storage.upload(r)}supportsContractMetadata(t){return s(t,"ContractMetadata")}}class d{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,r){const e=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(e)]},n=t=>{const e=this.contractWrapper.readContract.interface.parseLog(t);r(this.toContractEvent(e.eventFragment,e.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const r={address:this.contractWrapper.address},e=r=>{try{const e=this.contractWrapper.readContract.interface.parseLog(r);t(this.toContractEvent(e.eventFragment,e.args,r))}catch(t){console.error("Could not parse event:",r,t)}};return this.contractWrapper.getProvider().on(r,e),()=>{this.contractWrapper.getProvider().off(r,e)}}removeEventListener(t,r){const e=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(e.name,r)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((r,e)=>"desc"===t.order?e.blockNumber-r.blockNumber:r.blockNumber-e.blockNumber));return this.parseEvents(r)}async getEvents(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=this.contractWrapper.readContract.interface.getEvent(t),a=r.filters?e.inputs.map((t=>r.filters[t.name])):[],n=this.contractWrapper.readContract.filters[e.name](...a),o=(await this.contractWrapper.readContract.queryFilter(n,r.fromBlock,r.toBlock)).sort(((t,e)=>"desc"===r.order?e.blockNumber-t.blockNumber:t.blockNumber-e.blockNumber));return this.parseEvents(o)}parseEvents(t){return t.map((t=>{const r=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const e=Object.entries(t.args),a=e.slice(e.length/2,e.length),n={};for(const[t,r]of a)n[t]=r;return{eventName:t.event||"",data:n,transaction:r}}return{eventName:t.event||"",data:{},transaction:r}}))}toContractEvent(t,r,e){const a=Object.fromEntries(Object.entries(e).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,e)=>{if(Array.isArray(r[e])){const a=t.components;if(a){const o=r[e];if("tuple[]"===t.type){const r=[];for(let t=0;t<o.length;t++){const e=o[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=e[t]}r.push(n)}n[t.name]=r}else{const r={};for(let t=0;t<a.length;t++){r[a[t].name]=o[t]}n[t.name]=r}}}else n[t.name]=r[e]})),{eventName:t.name,data:n,transaction:a}}}class l{constructor(t){this.contractWrapper=t}async gasCostOf(t,r){const[e,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,r)]);return o.formatEther(a.mul(e))}async gasLimitOf(t,r){return this.contractWrapper.estimateGas(t,r)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return o.formatUnits(t,"gwei")}}class u{featureName=a.d2.name;constructor(t,r,e){this.contractWrapper=t,this.metadata=r,this.storage=e}async get(){return s(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,i.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>s(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,r,e)=>{e.d(r,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},5995:(t,r,e)=>{e.d(r,{C:()=>o});var a=e(19578),n=e(7860);class o{featureName=n.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,r]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:r})}set=(0,a.c)((async t=>{const r=await n.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[r.platform_fee_recipient,r.platform_fee_basis_points]})}))}},74935:(t,r,e)=>{e.d(r,{C:()=>c});var a=e(38776),n=e(7860),o=e(89536),i=e(19578),s=e(68828);class c{featureName=n.d3.name;constructor(t,r){this.contractWrapper=t,this.roles=r}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},r=Object.entries(this.roles);return(await Promise.all(r.map((t=>{let[,r]=t;return this.get(r)})))).forEach(((e,a)=>t[r[a][1]]=e)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=this.contractWrapper;if((0,o.h)("getRoleMemberCount",r)&&(0,o.h)("getRoleMember",r)){const e=(0,n.H)(t),a=(await r.read("getRoleMemberCount",[e])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>r.read("getRoleMember",[e,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,i.c)((async t=>{const r=new s.C(this.contractWrapper),e=Object.keys(t);(0,a.Z)(e.length,"you must provide at least one role to set"),(0,a.Z)(e.every((t=>this.roles.includes(t))),"this contract does not support the given role");const o=await this.getAll(),c=[],p=e.sort((t=>"admin"===t?1:-1));for(let e=0;e<p.length;e++){const a=p[e],[i,s]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(o[a]?.map((t=>(0,n.aP)(t)))||[])]),d=i.filter((t=>!s.includes(t))),l=s.filter((t=>!i.includes(t)));if(d.length&&d.forEach((t=>{c.push(r.encode("grantRole",[(0,n.H)(a),t]))})),l.length){(await Promise.all(l.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,e)=>c.push(r.encode(t,[(0,n.H)(a),l[e]]))))}}return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,r){await Promise.all(t.map((async t=>{const[e,a]=await Promise.all([this.get(t),(0,n.aP)(r)]);if(!e.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,i.c)((async(t,r)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=await(0,n.aP)(r);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),e]})}));revoke=(0,i.c)((async(t,r)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=await(0,n.aP)(r),o=await this.getRevokeRoleFunctionName(e);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:o,args:[(0,n.H)(t),e]})}));async getRevokeRoleFunctionName(t){const[r,e]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return e.toLowerCase()===r.toLowerCase()?"renounceRole":"revokeRole"}}},48109:(t,r,e)=>{e.d(r,{a:()=>h,g:()=>m,h:()=>d,i:()=>p,m:()=>u,v:()=>l});var a=e(64146),n=e(2593),o=e(38776),i=e(89050),s=e(7860),c=e(68828);async function p(t,r,n,o,s){try{const c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,p=new a.CH(n,c,t),[d,l]=await Promise.all([p.supportsInterface(i.I),p.supportsInterface(i.a)]);if(d){const i=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,c=new a.CH(n,i,t);if(await c.isApprovedForAll(s,r))return!0;let p;try{p=await c.getApproved(o)}catch(t){}return p?.toLowerCase()===r.toLowerCase()}if(l){const o=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,i=new a.CH(n,o,t);return await i.isApprovedForAll(s,r)}return console.error("Contract does not implement ERC 1155 or ERC 721."),!1}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function d(t,r,a,n,o){const c=(await e.e(5025).then(e.t.bind(e,25025,19))).default,p=new s.cu(t.getSignerOrProvider(),a,c,t.options,t.storage),[d,l]=await Promise.all([p.read("supportsInterface",[i.I]),p.read("supportsInterface",[i.a])]);if(d){const i=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,c=new s.cu(t.getSignerOrProvider(),a,i,t.options,t.storage);if(!await c.read("isApprovedForAll",[o,r])){(await c.read("getApproved",[n])).toLowerCase()===r.toLowerCase()||await c.sendTransaction("setApprovalForAll",[r,!0])}}else{if(!l)throw Error("Contract must implement ERC 1155 or ERC 721.");{const n=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,i=new s.cu(t.getSignerOrProvider(),a,n,t.options,t.storage);await i.read("isApprovedForAll",[o,r])||await i.sendTransaction("setApprovalForAll",[r,!0])}}}function l(t){if((0,o.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,o.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,o.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,o.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,o.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,o.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type)(0,o.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function u(t,r,e){return{quantity:e.quantityDesired,pricePerToken:e.pricePerToken,currencyContractAddress:e.currency,buyerAddress:e.offeror,quantityDesired:e.quantityWanted,currencyValue:await(0,c.a)(t,e.currency,e.quantityWanted.mul(e.pricePerToken)),listingId:r}}function h(t,r,e){if(e=n.O$.from(e),t=n.O$.from(t),r=n.O$.from(r),t.eq(n.O$.from(0)))return!1;return r.sub(t).mul(s.dy).div(t).gte(e)}async function m(t,r,e){const a=[];for(;r-t>i.D;)a.push(e(t,t+i.D-1)),t+=i.D;return a.push(e(t,r-1)),await Promise.all(a)}},9967:(t,r,e)=>{e.r(r),e.d(r,{MarketplaceV3:()=>u});var a=e(89208),n=e(89536),o=e(7860),i=e(68828),s=e(52153),c=e(5995),p=e(74935),d=e(70735),l=e(19578);e(13550),e(77191),e(54146);class u{static contractRoles=o.dA;get directListings(){return(0,a.a)(this.detectDirectListings(),o.dk)}get englishAuctions(){return(0,a.a)(this.detectEnglishAuctions(),o.dl)}get offers(){return(0,a.a)(this.detectOffers(),o.dm)}get chainId(){return this._chainId}constructor(t,r,e){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},d=arguments.length>4?arguments[4]:void 0,l=arguments.length>5?arguments[5]:void 0,h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new o.cu(t,r,d,a,e);this._chainId=l,this.abi=o.bn.parse(d||[]),this.contractWrapper=h,this.storage=e,this.metadata=new n.C(this.contractWrapper,o.c1,this.storage),this.app=new n.b(this.contractWrapper,this.metadata,this.storage),this.roles=new p.C(this.contractWrapper,u.contractRoles),this.encoder=new i.C(this.contractWrapper),this.estimator=new n.G(this.contractWrapper),this.events=new n.a(this.contractWrapper),this.platformFees=new c.C(this.contractWrapper),this.interceptor=new s.C(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async prepare(t,r,e){return l.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:r,overrides:e})}async call(t,r,e){return this.contractWrapper.call(t,r,e)}detectDirectListings(){if((0,n.d)(this.contractWrapper,"DirectListings"))return new d.M(this.contractWrapper,this.storage)}detectEnglishAuctions(){if((0,n.d)(this.contractWrapper,"EnglishAuctions"))return new d.a(this.contractWrapper,this.storage)}detectOffers(){if((0,n.d)(this.contractWrapper,"Offers"))return new d.b(this.contractWrapper,this.storage)}}},70735:(t,r,e)=>{e.d(r,{M:()=>A,a:()=>k,b:()=>T});var a=e(2593),n=e(64146),o=e(9279),i=e(61744),s=e(38776),c=e(15070),p=e(68828),d=e(19824),l=e(41518),u=e(7860),h=e(48109),m=e(89050),f=e(19578),g=e(89208),w=e(1604),y=e(89536),W=e(52153);const C=(()=>w.z.object({assetContractAddress:u.bd,tokenId:u.ba,quantity:u.ba.default(1),currencyContractAddress:u.bd.default(u.aZ),pricePerToken:u.cz,startTimestamp:g.R.default(new Date),endTimestamp:g.E,isReservedListing:w.z.boolean().default(!1)}))();let v=function(t){return t[t.UNSET=0]="UNSET",t[t.Created=1]="Created",t[t.Completed=2]="Completed",t[t.Cancelled=3]="Cancelled",t[t.Active=4]="Active",t[t.Expired=5]="Expired",t}({});class A{featureName=u.dk.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new y.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new y.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No listings exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllListings",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapListing(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No listings exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllValidListings",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapListing(t))))}async getListing(t){const r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(a.O$.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await(0,u.aP)(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(a.O$.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await(0,u.aP)(r)])}async currencyPriceForListing(t,r){const e=await this.validateListing(a.O$.from(t)),n=await(0,u.aP)(r);if(n===e.currencyContractAddress)return e.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,n))throw new Error(`Currency ${n} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,n])}createListing=(0,f.c)((async t=>{const r=await C.parseAsync(t);await(0,h.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await(0,d.n)(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),n=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return r.startTimestamp.lt(n)&&(r.startTimestamp=a.O$.from(n)),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,c.c)(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("NewListing",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,f.c)((async t=>{const r=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode()));return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewListing",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))})}));updateListing=(0,f.c)((async(t,r)=>{const e=await C.parseAsync(r);await(0,h.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const a=await(0,d.n)(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress);return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:(0,c.c)(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("UpdatedListing",t?.logs)[0].args.listingId,receipt:t})})}));cancelListing=(0,f.c)((async t=>f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]})));buyFromListing=(0,f.c)((async(t,r,e)=>{e&&(e=await(0,u.aP)(e));const n=await this.validateListing(a.O$.from(t)),{valid:o,error:i}=await this.isStillValidListing(n,r);if(!o)throw new Error(`Listing ${t} is no longer valid. ${i}`);const s=e||await this.contractWrapper.getSignerAddress(),c=a.O$.from(r),p=a.O$.from(n.pricePerToken).mul(c),d=await this.contractWrapper.getCallOverrides()||{};return await(0,l.s)(this.contractWrapper,p,n.currencyContractAddress,d),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,s,c,n.currencyContractAddress,p],overrides:d})}));approveBuyerForReservedListing=(0,f.c)((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))throw new Error(`Buyer ${r} already approved for listing ${t}.`);return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]})}));revokeBuyerApprovalForReservedListing=(0,f.c)((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});throw new Error(`Buyer ${r} not approved for listing ${t}.`)}));approveCurrencyForListing=(0,f.c)((async(t,r,e)=>{const n=await this.validateListing(a.O$.from(t)),o=await(0,u.aP)(r);o===n.currencyContractAddress&&(0,s.Z)(e===n.pricePerToken,"Approving listing currency with a different price.");const i=await this.contractWrapper.read("currencyPriceForListing",[t,o]);return(0,s.Z)(e===i,"Currency already approved with this price."),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,o,e]})}));revokeCurrencyApprovalForListing=(0,f.c)((async(t,r)=>{const e=await this.validateListing(a.O$.from(t)),n=await(0,u.aP)(r);if(n===e.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const o=await this.contractWrapper.read("currencyPriceForListing",[t,n]);return(0,s.Z)(!o.isZero(),"Currency not approved."),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,a.O$.from(0)]})}));async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){let r=v.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.O$.from(t.startTimestamp).gt(e)?v.Created:a.O$.from(t.endTimestamp).lt(e)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:a.O$.from(t.startTimestamp).toNumber(),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.O$.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){if(!await(0,h.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),o=(await e.e(5025).then(e.t.bind(e,25025,19))).default,i=new n.CH(t.assetContractAddress,o,a),s=await i.supportsInterface(m.I),c=await i.supportsInterface(m.a);if(s){const r=(await Promise.resolve().then(e.t.bind(e,70332,19))).default,o=new n.CH(t.assetContractAddress,r,a);let i;try{i=await o.ownerOf(t.tokenId)}catch(t){}const s=i?.toLowerCase()===t.creatorAddress.toLowerCase();return{valid:s,error:s?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(c){const o=(await Promise.resolve().then(e.t.bind(e,8455,19))).default,i=new n.CH(t.assetContractAddress,o,a),s=(await i.balanceOf(t.creatorAddress,t.tokenId)).gte(r||t.quantity);return{valid:s,error:s?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await(0,u.aP)(r.seller);e=e.filter((r=>r.listingCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await(0,u.aP)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}const b=(()=>w.z.object({assetContractAddress:u.bd,tokenId:u.ba,quantity:u.ba.default(1),currencyContractAddress:u.bd.default(u.aZ),minimumBidAmount:u.cz,buyoutBidAmount:u.cz,timeBufferInSeconds:u.ba.default(900),bidBufferBps:u.ba.default(500),startTimestamp:g.R.default(new Date),endTimestamp:g.E}))();class k{featureName=u.dl.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new y.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new y.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No auctions exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllAuctions",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapAuction(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No auctions exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllValidAuctions",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapAuction(t))))}async getAuction(t){const r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(a.O$.from(t));const r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==o.d)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){const r=await this.validateAuction(a.O$.from(t)),e=await this.contractWrapper.read("getWinningBid",[t]),n=a.O$.from(Math.floor(Date.now()/1e3)),i=a.O$.from(r.endTimeInSeconds);if(n.gt(i)&&e._bidder!==o.d)return e._bidder;const s=new y.a(this.contractWrapper),c=(await s.getEvents("AuctionClosed")).find((r=>r.data.auctionId.eq(a.O$.from(t))));if(!c)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return c.data.winningBidder}createAuction=(0,f.c)((async t=>{const r=b.parse(t);await(0,h.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await(0,d.n)(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),n=await(0,d.n)(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),o=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return r.startTimestamp.lt(o)&&(r.startTimestamp=a.O$.from(o)),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,c.c)(r.currencyContractAddress),minimumBidAmount:n,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewAuction",t.logs)[0].args.auctionId,receipt:t})})}));createAuctionsBatch=(0,f.c)((async t=>{const r=(await Promise.all(t.map((t=>this.createAuction.prepare(t))))).map((t=>t.encode()));return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewAuction",t?.logs).map((r=>({id:r.args.auctionId,receipt:t})))})}));buyoutAuction=(0,f.c)((async t=>{const r=await this.validateAuction(a.O$.from(t)),e=await(0,p.f)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,i.formatUnits(r.buyoutBidAmount,e.decimals))}));makeBid=(0,f.c)((async(t,r)=>{const e=await this.validateAuction(a.O$.from(t)),n=await(0,d.n)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(n.eq(a.O$.from(0)))throw new Error("Cannot make a bid with 0 value");if(a.O$.from(e.buyoutBidAmount).gt(0)&&n.gt(e.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const r=await this.isWinningBid(t,n);(0,s.Z)(r,"Bid price is too low based on the current winning bid and the bid buffer")}else{const t=n,r=a.O$.from(e.minimumBidAmount);(0,s.Z)(t.gte(r),"Bid price is too low based on minimum bid amount")}const o=await this.contractWrapper.getCallOverrides()||{};return await(0,l.s)(this.contractWrapper,n,e.currencyContractAddress,o),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",args:[t,n],overrides:o})}));cancelAuction=(0,f.c)((async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]})}));closeAuctionForBidder=(0,f.c)((async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateAuction(a.O$.from(t));try{return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[a.O$.from(t)]})}catch(r){throw r.message.includes("Marketplace: auction still active.")?new u.w(t.toString(),e.endTimeInSeconds.toString()):r}}));closeAuctionForSeller=(0,f.c)((async t=>{const r=await this.validateAuction(a.O$.from(t));try{return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[a.O$.from(t)]})}catch(e){throw e.message.includes("Marketplace: auction still active.")?new u.w(t.toString(),r.endTimeInSeconds.toString()):e}}));executeSale=(0,f.c)((async t=>{const r=await this.validateAuction(a.O$.from(t));try{const r=await this.getWinningBid(t);(0,s.Z)(r,"No winning bid found");const e=this.encoder.encode("collectAuctionPayout",[t]),a=this.encoder.encode("collectAuctionTokens",[t]);return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[e,a]]})}catch(e){throw e.message.includes("Marketplace: auction still active.")?new u.w(t.toString(),r.endTimeInSeconds.toString()):e}}));async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,e,n]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(a.O$.from(t))]),o=e?a.O$.from(e.bidAmount):a.O$.from(n.minimumBidAmount),i=o.add(o.mul(r).div(1e4));return(0,p.a)(this.contractWrapper.getProvider(),n.currencyContractAddress,i)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error(`Error getting the auction with id ${t}`),r}}async mapAuction(t){let r=v.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.O$.from(t.startTimestamp).gt(e)?v.Created:a.O$.from(t.endTimestamp).lt(e)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:a.O$.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:a.O$.from(t.bidBufferBps).toNumber(),startTimeInSeconds:a.O$.from(t.startTimestamp).toNumber(),endTimeInSeconds:a.O$.from(t.endTimestamp).toNumber(),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){const n=await(0,u.aP)(r),o=await(0,u.aP)(e);return{auctionId:t,bidderAddress:n,currencyContractAddress:o,bidAmount:a,bidAmountCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),o,a)}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await(0,u.aP)(r.seller);e=e.filter((r=>r.auctionCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await(0,u.aP)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}const P=(()=>w.z.object({assetContractAddress:u.bd,tokenId:u.ba,quantity:u.ba.default(1),currencyContractAddress:u.bd.default(u.aZ),totalPrice:u.cz,endTimestamp:g.E}))();class T{featureName=u.dm.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new y.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new y.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No offers exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllOffers",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapOffer(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.O$.from(t?.start||0).toNumber(),n=r.toNumber();if(0===n)throw new Error("No offers exist on the contract.");let o=[];o=(await(0,h.g)(e,n,((t,r)=>this.contractWrapper.read("getAllValidOffers",[t,r])))).flat();const i=await this.applyFilter(o,t);return await Promise.all(i.map((t=>this.mapOffer(t))))}async getOffer(t){const r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}makeOffer=(0,f.c)((async t=>{const r=await P.parseAsync(t),e=await this.contractWrapper.getChainID(),a=(0,p.i)(r.currencyContractAddress)?u.a_[e].wrapped.address:r.currencyContractAddress,n=await(0,d.n)(this.contractWrapper.getProvider(),r.totalPrice,a),o=await this.contractWrapper.getCallOverrides();return await(0,l.s)(this.contractWrapper,n,a,o),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:n,expirationTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewOffer",t?.logs)[0].args.offerId,receipt:t})})}));cancelOffer=(0,f.c)((async t=>f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})));acceptOffer=(0,f.c)((async t=>{const r=await this.validateOffer(a.O$.from(t)),{valid:e,error:n}=await this.isStillValidOffer(r);if(!e)throw new Error(`Offer ${t} is no longer valid. ${n}`);const o=await this.contractWrapper.getCallOverrides()||{};return await(0,h.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:o})}));async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error(`Error getting the offer with id ${t}`),r}}async mapOffer(t){let r=v.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.O$.from(t.expirationTimestamp).lt(e)?v.Expired:v.Active;break;case 2:r=v.Completed;break;case 3:r=v.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.O$.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){if(a.O$.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};const r=await this.contractWrapper.getChainID(),n=(0,p.i)(t.currencyContractAddress)?u.a_[r].wrapped.address:t.currencyContractAddress,o=this.contractWrapper.getProvider(),i=(await Promise.resolve().then(e.t.bind(e,49242,19))).default,s=new u.cu(o,n,i,{},this.storage);if((await s.read("balanceOf",[t.offerorAddress])).lt(t.totalPrice))return{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${n}`};return(await s.read("allowance",[t.offerorAddress,this.getAddress()])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${n}`}:{valid:!0,error:""}}async applyFilter(t,r){let e=[...t];if(r){if(r.offeror){const t=await(0,u.aP)(r.offeror);e=e.filter((r=>r.offeror.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await(0,u.aP)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}},41518:(t,r,e)=>{e.d(r,{B:()=>c,C:()=>l,N:()=>d,a:()=>p,s:()=>u});var a=e(7860),n=e(1604),o=e(68828);const i=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),s=(()=>n.z.union([n.z.array(i),i]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),p=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:s,attributes:s}).catchall(n.z.union([a.cA,n.z.unknown()])))(),d=(()=>n.z.union([p,n.z.string()]))(),l=(()=>p.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function u(t,r,n,i){if(!(0,o.i)(n)){const o=(await Promise.resolve().then(e.t.bind(e,49242,19))).default,s=t.getSigner(),c=t.getProvider(),p=new a.cu(s||c,n,o,t.options,t.storage),d=await t.getSignerAddress(),l=t.address;return(await p.read("allowance",[d,l])).lt(r)&&await p.sendTransaction("approve",[l,r]),i}i.value=r}}}]);
//# sourceMappingURL=9967.js.map