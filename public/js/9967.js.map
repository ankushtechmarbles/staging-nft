{"version":3,"file":"js/9967.js","mappings":"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","sources":["webpack:///./node_modules/@thirdweb-dev/sdk/dist/QueryParams-feab8e08.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/assertEnabled-ea837eec.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/cleanCurrencyAddress-6092c6bb.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-appuri-4e9cb063.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-interceptor-6f8989ff.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-platform-fee-dba35fa6.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/contract-roles-94655dc4.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/marketplace-f4856738.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/marketplacev3-1343d717.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/marketplacev3-offers-49f33f6e.browser.esm.js","webpack:///./node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7df9a12a.browser.esm.js"],"sourcesContent":["import { C as CommonNFTOutput, a as CommonNFTInput } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport 'zod';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress - the contract address\n * @param provider - the provider to use\n * @param tokenId - the token id\n * @param storage - the storage to use\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata - the metadata to upload\n * @param storage - the storage to use\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas - the metadata to upload\n * @param storage - the storage to use\n * @param startNumber - the number to start the file names at\n * @param contractAddress - the contract address\n * @param signerAddress - the signer address\n * @param options - options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Pagination Parameters\n * @public\n */\n\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\n","import { BigNumber } from 'ethers';\nimport { z } from 'zod';\nimport { x as ExtensionNotImplementedError } from './index-827e427d.browser.esm.js';\n\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace - The namespace to check\n * @param feature - The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\nexport { EndDateSchema as E, RawDateSchema as R, StartDateSchema as S, assertEnabled as a };\n","import { aZ as NATIVE_TOKEN_ADDRESS } from './index-827e427d.browser.esm.js';\nimport { i as isNativeToken } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\nfunction cleanCurrencyAddress(currencyAddress) {\n  if (isNativeToken(currencyAddress)) {\n    return NATIVE_TOKEN_ADDRESS;\n  }\n  return currencyAddress;\n}\n\nexport { cleanCurrencyAddress as c };\n","import { am as isExtensionEnabled, bn as AbiSchema, d1 as FEATURE_METADATA, K as fetchContractMetadataFromAddress, x as ExtensionNotImplementedError, b1 as EventType, d2 as FEATURE_APPURI } from './index-827e427d.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { utils } from 'ethers';\nimport { replaceGatewayUrlWithScheme } from '@thirdweb-dev/storage';\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param featureName - The feature name to check\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  return isExtensionEnabled(AbiSchema.parse(contractWrapper.abi), featureName);\n}\n\n/**\n * @internal\n * @param contractWrapper - The contract wrapper to check\n * @param functionName - The function name to check\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\n/**\n * @internal\n */\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  featureName = FEATURE_METADATA.name;\n  constructor(contractWrapper, schema, storage) {\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parseAsync(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parseAsync(metadata);\n  }\n  /**\n   * Get the metadata of this contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * console.log(metadata);\n   * ```\n   * @public\n   * @returns the metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.read(\"contractURI\", []);\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.read(\"name\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let contractSymbol;\n        try {\n          if (hasFunction(\"symbol\", this.contractWrapper)) {\n            contractSymbol = await this.contractWrapper.read(\"symbol\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let publishedMetadata;\n        try {\n          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n        } catch (err) {}\n        data = {\n          name: contractName || publishedMetadata?.name,\n          symbol: contractSymbol,\n          description: publishedMetadata?.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n\n  /**\n   * Set the metadata of this contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setContractURI\",\n        args: [uri],\n        parse: receipt => {\n          return {\n            receipt,\n            data: this.get\n          };\n        }\n      });\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  });\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   description: \"My new contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  update = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return await this.set.prepare({\n      ...(await this.get()),\n      ...metadata\n    });\n  });\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = await this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns a function to un-subscribe from the event\n   */\n  addEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          if (param.type === \"tuple[]\") {\n            // tuple[]\n            const objArray = [];\n            for (let i = 0; i < arr.length; i++) {\n              const tuple = arr[i];\n              const obj = {};\n              for (let j = 0; j < components.length; j++) {\n                const name = components[j].name;\n                obj[name] = tuple[j];\n              }\n              objArray.push(obj);\n            }\n            results[param.name] = objArray;\n          } else {\n            // simple tuple\n            const obj = {};\n            for (let i = 0; i < components.length; i++) {\n              const name = components[i].name;\n              obj[name] = arr[i];\n            }\n            results[param.name] = obj;\n          }\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);\n    return utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns the current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.app.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.app.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  featureName = FEATURE_APPURI.name;\n  constructor(contractWrapper, metadata, storage) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n    this.storage = storage;\n  }\n\n  /**\n   * Get App URI\n   * @returns the appURI (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = await contract.app.get();\n   * console.log(appURI) // \"ipfs://some_ipfs_hash\";\n   * ```\n   * @twfeature AppURI\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.read(\"appURI\", []);\n    }\n    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || \"\", this.storage.getGatewayUrls());\n  }\n\n  /**\n   * Set App URI\n   * @param appURI - the uri to set (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = \"ipfs://some_ipfs_hash\";\n   * await contract.app.set(appURI);\n   * ```\n   * @twfeature AppURI\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async appURI => {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setAppURI\",\n        args: [appURI]\n      });\n    }\n    return await this.metadata.update.prepare({\n      app_uri: appURI\n    });\n  });\n}\n\nexport { ContractMetadata as C, GasCostEstimator as G, ContractEvents as a, ContractAppURI as b, detectContractFeature as d, hasFunction as h };\n","/**\n * Allows overriding transaction behavior for this contract\n * @public\n */\nclass ContractInterceptor {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * The next transaction executed will add/replace any overrides passed via the passed in hook.\n   * @remarks Overridden values will be applied to the next transaction executed.\n   * @example\n   * ```javascript\n   * contract.interceptor.overrideNextTransaction(() => ({\n   *   gasLimit: 3000000,\n   * }));\n   * ```\n   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)\n   * @public\n   */\n  overrideNextTransaction(hook) {\n    this.contractWrapper.withTransactionOverride(hook);\n  }\n}\n\nexport { ContractInterceptor as C };\n","import { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { dn as FEATURE_PLATFORM_FEE, bJ as CommonPlatformFeeSchema } from './index-827e427d.browser.esm.js';\n\n/**\n * Handle platform fees and recipients\n * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const feeInfo = await contract.platformFees.get();\n * await contract.platformFees.set({\n *   platform_fee_basis_points: 100, // 1% fee\n *   platform_fee_recipient: \"0x...\" // the fee recipient\n * })\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractPlatformFee {\n  featureName = FEATURE_PLATFORM_FEE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * const feeInfo = await contract.platformFees.get();\n   * console.log(feeInfo.platform_fee_recipient);\n   * console.log(feeInfo.platform_fee_basis_points);\n   * ```\n   * @twfeature PlatformFee\n   */\n  async get() {\n    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read(\"getPlatformFeeInfo\", []);\n    return CommonPlatformFeeSchema.parseAsync({\n      platform_fee_recipient: platformFeeRecipient,\n      platform_fee_basis_points: platformFeeBps\n    });\n  }\n\n  /**\n   * Set the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * await contract.platformFees.set({\n   *   platform_fee_basis_points: 100, // 1% fee\n   *   platform_fee_recipient: \"0x...\" // the fee recipient\n   * })\n   * ```\n   *\n   * @param platformFeeInfo - the platform fee information\n   * @twfeature PlatformFee\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async platformFeeInfo => {\n    const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPlatformFeeInfo\",\n      args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]\n    });\n  });\n}\n\nexport { ContractPlatformFee as C };\n","import invariant from 'tiny-invariant';\nimport { d3 as FEATURE_PERMISSIONS, H as getRoleHash, aP as resolveAddress, o as MissingRoleError } from './index-827e427d.browser.esm.js';\nimport { h as hasFunction } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractRoles {\n  featureName = FEATURE_PERMISSIONS.name;\n\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Get all members of all roles\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature PermissionsEnumerable\n   */\n  async getAll() {\n    invariant(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    const entries = Object.entries(this.roles);\n    (await Promise.all(entries.map(_ref => {\n      let [, role] = _ref;\n      return this.get(role);\n    }))).forEach((item, index) => roles[entries[index][1]] = item);\n    return roles;\n  }\n\n  /**\n   * Get all members of a specific role\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.read(\"getRoleMemberCount\", [roleHash])).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.read(\"getRoleMember\", [roleHash, i])));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Overwrite the list of members for specific roles\n   *\n   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  setAll = /* @__PURE__ */buildTransactionFunction(async rolesWithAddresses => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const [addresses, currentAddresses] = await Promise.all([Promise.all(rolesWithAddresses[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || []), Promise.all(currentRoles[role]?.map(addressOrEns => resolveAddress(addressOrEns)) || [])]);\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(contractEncoder.encode(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        const revokeFunctionNames = await Promise.all(toRemove.map(address => this.getRevokeRoleFunctionName(address)));\n        revokeFunctionNames.forEach((revokeFunctionName, index) => encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), toRemove[index]])));\n      }\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const [members, resolvedAddress] = await Promise.all([this.get(role), resolveAddress(address)]);\n      if (!members.map(a => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {\n        throw new MissingRoleError(resolvedAddress, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Grant a role to a specific address\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  grant = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"grantRole\",\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /**\n   * Revoke a role from a specific address\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: revokeFunctionName,\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const [resolvedAddress, signerAddress] = await Promise.all([resolveAddress(address), this.contractWrapper.getSignerAddress()]);\n    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\nexport { ContractRoles as C };\n","import { Contract, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { I as InterfaceId_IERC721, a as InterfaceId_IERC1155, D as DEFAULT_QUERY_ALL_COUNT } from './QueryParams-feab8e08.browser.esm.js';\nimport { cu as ContractWrapper, dy as MAX_BPS } from './index-827e427d.browser.esm.js';\nimport { a as fetchCurrencyValue } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns - True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(assetContract, ERC721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(assetContract, ERC1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper - The contract wrapper to use\n * @param marketplaceAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param from - The address of the account that owns the token.\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const [isERC721, isERC1155] = await Promise.all([erc165.read(\"supportsInterface\", [InterfaceId_IERC721]), erc165.read(\"supportsInterface\", [InterfaceId_IERC1155])]);\n  // check for token approval\n  if (isERC721) {\n    const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer - The offer to map\n * @returns - An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\nexport { isWinningBid as a, getAllInBatches as g, handleTokenApproval as h, isTokenApprovedForTransfer as i, mapOffer as m, validateNewListingParam as v };\n","import { a as assertEnabled } from './assertEnabled-ea837eec.browser.esm.js';\nimport { C as ContractMetadata, b as ContractAppURI, G as GasCostEstimator, a as ContractEvents, d as detectContractFeature } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { dA as MARKETPLACE_CONTRACT_ROLES, dk as FEATURE_DIRECT_LISTINGS, dl as FEATURE_ENGLISH_AUCTIONS, dm as FEATURE_OFFERS, cu as ContractWrapper, bn as AbiSchema, c1 as MarketplaceContractSchema } from './index-827e427d.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { C as ContractInterceptor } from './contract-interceptor-6f8989ff.browser.esm.js';\nimport { C as ContractPlatformFee } from './contract-platform-fee-dba35fa6.browser.esm.js';\nimport { C as ContractRoles } from './contract-roles-94655dc4.browser.esm.js';\nimport { M as MarketplaceV3DirectListings, a as MarketplaceV3EnglishAuctions, b as MarketplaceV3Offers } from './marketplacev3-offers-49f33f6e.browser.esm.js';\nimport { T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport 'ethers';\nimport 'zod';\nimport '@thirdweb-dev/storage';\nimport '@thirdweb-dev/chains';\nimport '@thirdweb-dev/crypto';\nimport 'tiny-invariant';\nimport 'bn.js';\nimport 'bs58';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json';\nimport '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport './cleanCurrencyAddress-6092c6bb.browser.esm.js';\nimport './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport './setErc20Allowance-7df9a12a.browser.esm.js';\nimport './marketplace-f4856738.browser.esm.js';\nimport './QueryParams-feab8e08.browser.esm.js';\n\n/**\n * Create your own whitelabel marketplace that enables users to buy and sell any digital assets.\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(\"{{chainName}}\");\n * const contract = await sdk.getContract(\"{{contract_address}}\", \"marketplace\");\n * ```\n *\n * @public\n */\nclass MarketplaceV3 {\n  static contractRoles = MARKETPLACE_CONTRACT_ROLES;\n\n  /**\n   * @internal\n   */\n\n  /**\n   * Direct listings\n   * @remarks Create and manage direct listings in your marketplace.\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   *\n   * // And on the buyers side:\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired);\n   * ```\n   */\n  get directListings() {\n    return assertEnabled(this.detectDirectListings(), FEATURE_DIRECT_LISTINGS);\n  }\n  /**\n   * Auctions\n   * @remarks Create and manage auctions in your marketplace.\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"1000\",\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"100\", // 100 bps stands for 1%\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   *\n   * // And on the buyers side:\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   */\n  get englishAuctions() {\n    return assertEnabled(this.detectEnglishAuctions(), FEATURE_ENGLISH_AUCTIONS);\n  }\n\n  /**\n   * Offers\n   * @remarks Make and manage offers.\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   *\n   * // And on the seller's side:\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   */\n  get offers() {\n    return assertEnabled(this.detectOffers(), FEATURE_OFFERS);\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(network, address, storage) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let abi = arguments.length > 4 ? arguments[4] : undefined;\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);\n    this._chainId = chainId;\n    this.abi = AbiSchema.parse(abi || []);\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.metadata = new ContractMetadata(this.contractWrapper, MarketplaceContractSchema, this.storage);\n    this.app = new ContractAppURI(this.contractWrapper, this.metadata, this.storage);\n    this.roles = new ContractRoles(this.contractWrapper, MarketplaceV3.contractRoles);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.events = new ContractEvents(this.contractWrapper);\n    this.platformFees = new ContractPlatformFee(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n  }\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /**\n   * @internal\n   */\n  async prepare(method, args, overrides) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method,\n      args,\n      overrides\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName, args, overrides) {\n    return this.contractWrapper.call(functionName, args, overrides);\n  }\n\n  /** ********************\n   * FEATURE DETECTION\n   * ********************/\n\n  detectDirectListings() {\n    if (detectContractFeature(this.contractWrapper, \"DirectListings\")) {\n      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectEnglishAuctions() {\n    if (detectContractFeature(this.contractWrapper, \"EnglishAuctions\")) {\n      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectOffers() {\n    if (detectContractFeature(this.contractWrapper, \"Offers\")) {\n      return new MarketplaceV3Offers(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\nexport { MarketplaceV3 };\n","import { BigNumber, Contract, constants, utils } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { c as cleanCurrencyAddress } from './cleanCurrencyAddress-6092c6bb.browser.esm.js';\nimport { C as ContractEncoder, a as fetchCurrencyValue, f as fetchCurrencyMetadata, i as isNativeToken } from './fetchCurrencyValue-39f97190.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-3b8bca4f.browser.esm.js';\nimport { s as setErc20Allowance } from './setErc20Allowance-7df9a12a.browser.esm.js';\nimport { bd as AddressOrEnsSchema, ba as BigNumberishSchema, aZ as NATIVE_TOKEN_ADDRESS, cz as AmountSchema, dk as FEATURE_DIRECT_LISTINGS, aP as resolveAddress, dl as FEATURE_ENGLISH_AUCTIONS, w as AuctionHasNotEndedError, dm as FEATURE_OFFERS, a_ as NATIVE_TOKENS, cu as ContractWrapper } from './index-827e427d.browser.esm.js';\nimport { g as getAllInBatches, i as isTokenApprovedForTransfer, h as handleTokenApproval } from './marketplace-f4856738.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, I as InterfaceId_IERC721, a as InterfaceId_IERC1155 } from './QueryParams-feab8e08.browser.esm.js';\nimport { c as buildTransactionFunction, T as Transaction } from './transactions-ec5ea12e.browser.esm.js';\nimport { R as RawDateSchema, E as EndDateSchema } from './assertEnabled-ea837eec.browser.esm.js';\nimport { z } from 'zod';\nimport { a as ContractEvents, G as GasCostEstimator } from './contract-appuri-4e9cb063.browser.esm.js';\nimport { C as ContractInterceptor } from './contract-interceptor-6f8989ff.browser.esm.js';\n\n/**\n * @internal\n */\nconst DirectListingInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being listed.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to list.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The price to pay per unit of NFTs listed.\n   */\n  pricePerToken: AmountSchema,\n  /**\n   * The start time of the listing.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the listing.\n   */\n  endTimestamp: EndDateSchema,\n  /**\n   * Whether the listing is reserved to be bought from a specific set of buyers.\n   */\n  isReservedListing: z.boolean().default(false)\n}))();\n\n/**\n * @public\n */\n\nlet Status = /*#__PURE__*/function (Status) {\n  Status[Status[\"UNSET\"] = 0] = \"UNSET\";\n  Status[Status[\"Created\"] = 1] = \"Created\";\n  Status[Status[\"Completed\"] = 2] = \"Completed\";\n  Status[Status[\"Cancelled\"] = 3] = \"Cancelled\";\n  Status[Status[\"Active\"] = 4] = \"Active\";\n  Status[Status[\"Expired\"] = 5] = \"Expired\";\n  return Status;\n}({});\n\n/**\n * Handles direct listings\n * @public\n */\nclass MarketplaceV3DirectListings {\n  featureName = FEATURE_DIRECT_LISTINGS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of direct listings\n   *\n   * @returns Returns the total number of direct listings created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalListings = await contract.directListings.getTotalCount();\n   * ```\n   * @twfeature DirectListings\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalListings\", []);\n  }\n\n  /**\n   * Get all direct listings\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAll(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get all valid direct listings\n   *\n   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAllValid(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get a single direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @returns the Direct listing object\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.read(\"getListing\", [listingId]);\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Check if a buyer is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param buyer - buyer address\n   * @twfeature DirectListings\n   */\n  async isBuyerApprovedForListing(listingId, buyer) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    if (!listing.isReservedListing) {\n      throw new Error(`Listing ${listingId} is not a reserved listing.`);\n    }\n    return await this.contractWrapper.read(\"isBuyerApprovedForListing\", [listingId, await resolveAddress(buyer)]);\n  }\n\n  /**\n   * Check if a currency is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currency - currency address\n   * @twfeature DirectListings\n   */\n  async isCurrencyApprovedForListing(listingId, currency) {\n    await this.validateListing(BigNumber.from(listingId));\n    return await this.contractWrapper.read(\"isCurrencyApprovedForListing\", [listingId, await resolveAddress(currency)]);\n  }\n\n  /**\n   * Check price per token for an approved currency\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currencyContractAddress - currency contract address\n   * @twfeature DirectListings\n   */\n  async currencyPriceForListing(listingId, currencyContractAddress) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      return listing.pricePerToken;\n    }\n    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);\n    if (!isApprovedCurrency) {\n      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);\n    }\n    return await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create new direct listing\n   *\n   * @remarks Create a new listing on the marketplace where people can buy an asset directly.\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  createListing = /* @__PURE__ */buildTransactionFunction(async listing => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedListing.startTimestamp.lt(blockTime)) {\n      parsedListing.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createListing\",\n      args: [{\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new listings\n   *\n   * @remarks Create a batch of new listings on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const listings = [...];\n   * const tx = await contract.directListings.createListingsBatch(listings);\n   * ```\n   */\n  createListingsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = (await Promise.all(listings.map(listing => this.createListing.prepare(listing)))).map(tx => tx.encode());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.listingId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Update a direct listing\n   *\n   * @param listing - the new listing information\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to update\n   *\n   * const listingId = 0; // ID of the listing you want to update\n   *\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\", // should be same as original listing\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\", // should be same as original listing\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.updateListing(listingId, listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  updateListing = /* @__PURE__ */buildTransactionFunction(async (listingId, listing) => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"updateListing\",\n      args: [listingId, {\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"UpdatedListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel Direct Listing\n   *\n   * @remarks Cancel a direct listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to cancel\n   * const listingId = 0;\n   *\n   * await contract.directListings.cancelListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  cancelListing = /* @__PURE__ */buildTransactionFunction(async listingId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelListing\",\n      args: [listingId]\n    });\n  });\n\n  /**\n   * Buy direct listing for a specific wallet\n   *\n   * @remarks Buy from a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param quantityDesired - the quantity to buy\n   * @param receiver - optional receiver of the bought listing if different from the connected wallet\n   * @twfeature DirectListings\n   */\n  buyFromListing = /* @__PURE__ */buildTransactionFunction(async (listingId, quantityDesired, receiver) => {\n    if (receiver) {\n      receiver = await resolveAddress(receiver);\n    }\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidListing(listing, quantityDesired);\n    if (!valid) {\n      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);\n    }\n    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();\n    const quantity = BigNumber.from(quantityDesired);\n    const value = BigNumber.from(listing.pricePerToken).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"buyFromListing\",\n      args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],\n      overrides\n    });\n  });\n\n  /**\n   * Approve buyer for a reserved direct listing\n   *\n   * @remarks Approve a buyer to buy from a reserved listing.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveBuyerForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   * @twfeature DirectListings\n   */\n  approveBuyerForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (!isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, true]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Revoke approval of a buyer for a reserved direct listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   */\n  revokeBuyerApprovalForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, false]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Approve a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency being approved\n   * @param pricePerTokenInCurrency - Price per token in the currency\n   * @twfeature DirectListings\n   */\n  approveCurrencyForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      invariant(pricePerTokenInCurrency === listing.pricePerToken, \"Approving listing currency with a different price.\");\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(pricePerTokenInCurrency === currencyPrice, \"Currency already approved with this price.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]\n    });\n  });\n\n  /**\n   * Revoke approval of a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to revoke currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency\n   * @twfeature DirectListings\n   */\n  revokeCurrencyApprovalForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      throw new Error(`Can't revoke approval for main listing currency.`);\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(!currencyPrice.isZero(), \"Currency not approved.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapListing(listing) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (listing.status) {\n      case 1:\n        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      assetContractAddress: listing.assetContract,\n      currencyContractAddress: listing.currency,\n      pricePerToken: listing.pricePerToken.toString(),\n      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId.toString(),\n      quantity: listing.quantity.toString(),\n      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),\n      creatorAddress: listing.listingCreator,\n      isReservedListing: listing.reserved,\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if a direct listing is still valid.\n   *\n   * Ways a direct listing can become invalid:\n   * 1. The asset holder transferred the asset to another wallet\n   * 2. The asset holder burned the asset\n   * 3. The asset holder removed the approval on the marketplace\n   *\n   * @internal\n   * @param listing - The listing to check.\n   * @returns - True if the listing is valid, false otherwise.\n   */\n  async isStillValidListing(listing, quantity) {\n    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);\n    if (!approved) {\n      return {\n        valid: false,\n        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`\n      };\n    }\n    const provider = this.contractWrapper.getProvider();\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(listing.assetContractAddress, ERC721Abi, provider);\n\n      // Handle reverts in case of non-existent tokens\n      let owner;\n      try {\n        owner = await asset.ownerOf(listing.tokenId);\n      } catch (e) {}\n      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();\n      return {\n        valid,\n        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`\n      };\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(listing.assetContractAddress, ERC1155Abi, provider);\n      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);\n      const valid = balance.gte(quantity || listing.quantity);\n      return {\n        valid,\n        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`\n      };\n    } else {\n      return {\n        valid: false,\n        error: \"Contract does not implement ERC 1155 or ERC 721.\"\n      };\n    }\n  }\n  async applyFilter(listings, filter) {\n    let rawListings = [...listings];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawListings = rawListings.filter(seller => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawListings = rawListings.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawListings = rawListings.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;\n  }\n}\n\n/**\n * @internal\n */\nconst EnglishAuctionInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being auctioned.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to auction.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The minimum price that a bid must be in order to be accepted.\n   */\n  minimumBidAmount: AmountSchema,\n  /**\n   * The buyout price of the auction.\n   */\n  buyoutBidAmount: AmountSchema,\n  /**\n   * This is a buffer e.g. x seconds.\n   *\n   * If a new winning bid is made less than x seconds before expirationTimestamp, the\n   * expirationTimestamp is increased by x seconds.\n   */\n  timeBufferInSeconds: BigNumberishSchema.default(900),\n  // 15 minutes by default\n\n  /**\n   * This is a buffer in basis points e.g. x%.\n   *\n   * To be considered as a new winning bid, a bid must be at least x% greater than\n   * the current winning bid.\n   */\n  bidBufferBps: BigNumberishSchema.default(500),\n  // 5% by default\n\n  /**\n   * The start time of the auction.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the auction.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles auctions\n * @public\n */\nclass MarketplaceV3EnglishAuctions {\n  featureName = FEATURE_ENGLISH_AUCTIONS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of english auctions\n   *\n   * @returns Returns the total number of auctions created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalAuctions = await contract.englishAuctions.getTotalCount();\n   * ```\n   * @twfeature EnglishAuctions\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalAuctions\", []);\n  }\n\n  /**\n   * Get all english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAll(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get all valid english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAllValid(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get a single english auction\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const auction = await contract.englishAuctions.getAuction(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction Id\n   * @returns the Auction object\n   * @twfeature EnglishAuctions\n   */\n  async getAuction(auctionId) {\n    const auction = await this.contractWrapper.read(\"getAuction\", [auctionId]);\n    return await this.mapAuction(auction);\n  }\n\n  /**\n   * Get winning bid of an english auction\n   *\n   * @remarks Get the current highest bid of an active auction.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction\n   * const auctionId = 0;\n   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @twfeature EnglishAuctions\n   */\n  async getWinningBid(auctionId) {\n    await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    if (bid._bidder === constants.AddressZero) {\n      return undefined;\n    }\n    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());\n  }\n\n  /**\n   * Check if a bid is or will be a winning bid\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const bidAmount = 100;\n   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);\n   * ```\n   *\n   * @param auctionId - Auction Id\n   * @param bidAmount - Amount to bid\n   * @returns true if the bid is or will be a winning bid\n   * @twfeature EnglishAuctions\n   */\n  async isWinningBid(auctionId, bidAmount) {\n    return await this.contractWrapper.read(\"isNewWinningBid\", [auctionId, bidAmount]);\n  }\n\n  /**\n   * Get the winner for a specific english auction\n   *\n   * @remarks Get the winner of the auction after an auction ends.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of a closed english auction\n   * const auctionId = 0;\n   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @returns the address of the auction winner\n   * @twfeature EnglishAuctions\n   */\n  async getWinner(auctionId) {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    const endTime = BigNumber.from(auction.endTimeInSeconds);\n\n    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner\n    if (now.gt(endTime) && bid._bidder !== constants.AddressZero) {\n      return bid._bidder;\n    }\n    // otherwise fall back to query filter things\n\n    // TODO this should be via indexer or direct contract call\n    const contractEvent = new ContractEvents(this.contractWrapper);\n    const closedAuctions = await contractEvent.getEvents(\"AuctionClosed\");\n    const closed = closedAuctions.find(a => a.data.auctionId.eq(BigNumber.from(auctionId)));\n    if (!closed) {\n      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);\n    }\n    return closed.data.winningBidder;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create an english auction\n   *\n   * @remarks Create a new auction where people can bid on an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"900\", // 15 minutes by default\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"500\", // 5% by default\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   * ```\n   * @param auction - the auction data\n   * @returns the transaction hash and the auction id\n   * @twfeature EnglishAuctions\n   */\n  createAuction = /* @__PURE__ */buildTransactionFunction(async auction => {\n    const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);\n    const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedAuction.startTimestamp.lt(blockTime)) {\n      parsedAuction.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAuction\",\n      args: [{\n        assetContract: parsedAuction.assetContractAddress,\n        tokenId: parsedAuction.tokenId,\n        quantity: parsedAuction.quantity,\n        currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),\n        minimumBidAmount: normalizedMinBidAmount,\n        buyoutBidAmount: normalizedBuyoutAmount,\n        timeBufferInSeconds: parsedAuction.timeBufferInSeconds,\n        bidBufferBps: parsedAuction.bidBufferBps,\n        startTimestamp: parsedAuction.startTimestamp,\n        endTimestamp: parsedAuction.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewAuction\", receipt.logs)[0];\n        return {\n          id: event.args.auctionId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new auctions\n   *\n   * @remarks Create a batch of new auctions on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const auctions = [...];\n   * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);\n   * ```\n   */\n  createAuctionsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = (await Promise.all(listings.map(listing => this.createAuction.prepare(listing)))).map(tx => tx.encode());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewAuction\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.auctionId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Buyout an english auction\n   *\n   * @remarks Buy a specific auction from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID you want to buy\n   * const auctionId = 0;\n   *\n   * await contract.englishAuctions.buyoutAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  buyoutAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);\n    return this.makeBid.prepare(auctionId, utils.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));\n  });\n\n  /**\n   * Bid on an english auction\n   *\n   * @remarks Make a bid on an auction\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   * @param auctionId - the auction id\n   * @param bidAmount - the amount you are willing to bid\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  makeBid = /* @__PURE__ */buildTransactionFunction(async (auctionId, bidAmount) => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);\n    if (normalizedBidAmount.eq(BigNumber.from(0))) {\n      throw new Error(\"Cannot make a bid with 0 value\");\n    }\n    if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {\n      throw new Error(\"Bid amount must be less than or equal to buyoutBidAmount\");\n    }\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);\n      invariant(isWinnner, \"Bid price is too low based on the current winning bid and the bid buffer\");\n    } else {\n      const tokenPrice = normalizedBidAmount;\n      const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);\n      invariant(tokenPrice.gte(minimumBidAmount), \"Bid price is too low based on minimum bid amount\");\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"bidInAuction\",\n      args: [auctionId, normalizedBidAmount],\n      overrides\n    });\n  });\n\n  /**\n   * Cancel an english auction\n   *\n   * @remarks Cancel an auction on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to cancel\n   * const auctionId = \"0\";\n   *\n   * await contract.englishAuctions.cancelAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  cancelAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      throw new Error(`Bids already made.`);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelAuction\",\n      args: [auctionId]\n    });\n  });\n\n  /**\n   * Close the english auction for the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for the buyer.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.closeAuctionForBidder(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForBidder = /* @__PURE__ */buildTransactionFunction(async (auctionId, closeFor) => {\n    if (!closeFor) {\n      closeFor = await this.contractWrapper.getSignerAddress();\n    }\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionTokens\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for the seller\n   *\n   * @remarks Closes the Auction and executes the sale for the seller.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auctionId = \"0\";\n   * await contract.englishAuctions.closeAuctionForSeller(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForSeller = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionPayout\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for both the seller and the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for both parties.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.executeSale(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  executeSale = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const winningBid = await this.getWinningBid(auctionId);\n      invariant(winningBid, \"No winning bid found\");\n      const closeForSeller = this.encoder.encode(\"collectAuctionPayout\", [auctionId]);\n      const closeForBuyer = this.encoder.encode(\"collectAuctionTokens\", [auctionId]);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [[closeForSeller, closeForBuyer]]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Get the buffer for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the buffer for\n   * const auctionId = \"0\";\n   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);\n   * ```\n   *\n   * @param auctionId - id of the auction\n   * @returns the buffer in basis points\n   * @twfeature EnglishAuctions\n   */\n  async getBidBufferBps(auctionId) {\n    return (await this.getAuction(auctionId)).bidBufferBps;\n  }\n\n  /**\n   * Get the minimum next bid for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the minimum next bid for\n   * const auctionId = \"0\";\n   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);\n   * ```\n   *\n   * @returns the minimum bid a user can place to outbid the previous highest bid\n   * @param auctionId - id of the auction\n   * @twfeature EnglishAuctions\n   */\n  async getMinimumNextBid(auctionId) {\n    // we can fetch all of these at the same time using promise.all\n    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);\n    const currentBidOrReservePrice = winningBid ?\n    // if there is a winning bid use the value of it\n    BigNumber.from(winningBid.bidAmount) :\n    // if there is no winning bid use the reserve price\n    BigNumber.from(auction.minimumBidAmount);\n    const minimumNextBid = currentBidOrReservePrice.add(\n    // the addition of the current bid and the buffer\n    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))\n    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));\n\n    // it's more useful to return a currency value here\n    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if auction could not be found\n   *\n   * @param auctionId - Auction to check for\n   */\n  async validateAuction(auctionId) {\n    try {\n      return await this.getAuction(auctionId);\n    } catch (err) {\n      console.error(`Error getting the auction with id ${auctionId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction to the auction interface.\n   *\n   * @internal\n   * @param auction - The auction to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapAuction(auction) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (auction.status) {\n      case 1:\n        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: auction.auctionId.toString(),\n      creatorAddress: auction.auctionCreator,\n      assetContractAddress: auction.assetContract,\n      tokenId: auction.tokenId.toString(),\n      quantity: auction.quantity.toString(),\n      currencyContractAddress: auction.currency,\n      minimumBidAmount: auction.minimumBidAmount.toString(),\n      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),\n      buyoutBidAmount: auction.buyoutBidAmount.toString(),\n      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),\n      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),\n      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),\n      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),\n      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),\n      status: status\n    };\n  }\n\n  /**\n   * Maps an auction-bid to the strict interface\n   *\n   * @internal\n   * @param bid - The bid to map, as returned from the contract.\n   * @returns - A `Bid` object\n   */\n  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {\n    const resolvedBidderAddress = await resolveAddress(bidderAddress);\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    return {\n      auctionId,\n      bidderAddress: resolvedBidderAddress,\n      currencyContractAddress: resolvedCurrencyAddress,\n      bidAmount,\n      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)\n    };\n  }\n  async applyFilter(auctions, filter) {\n    let rawAuctions = [...auctions];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawAuctions = rawAuctions.filter(seller => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;\n  }\n}\n\n/**\n * @internal\n */\nconst OfferInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being sought.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to buy.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency offered for the NFTs.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The total offer amount for the NFTs.\n   */\n  totalPrice: AmountSchema,\n  /**\n   * The end time of the offer.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles marketplace offers\n * @public\n */\nclass MarketplaceV3Offers {\n  featureName = FEATURE_OFFERS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of offers\n   *\n   * @returns Returns the total number of offers created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalOffers = await contract.offers.getTotalCount();\n   * ```\n   * @twfeature Offers\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalOffers\", []);\n  }\n\n  /**\n   * Get all offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAll(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get all valid offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAllValid(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get a single offer\n   *\n   * @example\n   * ```javascript\n   * const offerId = 0;\n   * const offer = await contract.offers.getOffer(offerId);\n   * ```\n   *\n   * @param offerId - the listing id\n   * @returns the Direct listing object\n   * @twfeature Offers\n   */\n  async getOffer(offerId) {\n    const offer = await this.contractWrapper.read(\"getOffer\", [offerId]);\n    return await this.mapOffer(offer);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Make an offer\n   *\n   * @remarks Make an offer on the marketplace for an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   * ```\n   * @param offer - the offer data\n   * @returns the transaction receipt and the id of the newly created offer\n   * @twfeature Offers\n   */\n  makeOffer = /* @__PURE__ */buildTransactionFunction(async offer => {\n    const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"makeOffer\",\n      args: [{\n        assetContract: parsedOffer.assetContractAddress,\n        tokenId: parsedOffer.tokenId,\n        quantity: parsedOffer.quantity,\n        currency: currency,\n        totalPrice: normalizedTotalPrice,\n        expirationTimestamp: parsedOffer.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewOffer\", receipt?.logs);\n        return {\n          id: event[0].args.offerId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel an offer\n   *\n   * @remarks Cancel an offer on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to cancel\n   * const offerId = \"0\";\n   *\n   * await contract.offers.cancelOffer(offerId);\n   * ```\n   * @param offerId - the offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  cancelOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelOffer\",\n      args: [offerId]\n    });\n  });\n\n  /**\n   * Accept an offer\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   *\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   *\n   * @param offerId - The offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  acceptOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    const offer = await this.validateOffer(BigNumber.from(offerId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidOffer(offer);\n    if (!valid) {\n      throw new Error(`Offer ${offerId} is no longer valid. ${error}`);\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"acceptOffer\",\n      args: [offerId],\n      overrides\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if offer could not be found\n   *\n   * @param offerId - offer to check for\n   */\n  async validateOffer(offerId) {\n    try {\n      return await this.getOffer(offerId);\n    } catch (err) {\n      console.error(`Error getting the offer with id ${offerId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the offer to the offer interface.\n   *\n   * @internal\n   * @param offer - The offer to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapOffer(offer) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (offer.status) {\n      case 1:\n        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: offer.offerId.toString(),\n      offerorAddress: offer.offeror,\n      assetContractAddress: offer.assetContract,\n      currencyContractAddress: offer.currency,\n      tokenId: offer.tokenId.toString(),\n      quantity: offer.quantity.toString(),\n      totalPrice: offer.totalPrice.toString(),\n      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),\n      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if an offer is still valid.\n   *\n   * Ways an offer can become invalid:\n   * 1. The offer has expired\n   * 2. The offeror doesn't have enough balance of currency tokens\n   * 3. The offeror removed the approval of currency tokens on the marketplace\n   *\n   * @internal\n   * @param offer - The offer to check.\n   * @returns - True if the offer is valid, false otherwise.\n   */\n  async isStillValidOffer(offer) {\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    if (now.gt(offer.endTimeInSeconds)) {\n      return {\n        valid: false,\n        error: `Offer with ID ${offer.id} has expired`\n      };\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;\n    const provider = this.contractWrapper.getProvider();\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const erc20 = new ContractWrapper(provider, currency, ERC20Abi, {}, this.storage);\n    const offerorBalance = await erc20.read(\"balanceOf\", [offer.offerorAddress]);\n    if (offerorBalance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`\n      };\n    }\n    const offerorAllowance = await erc20.read(\"allowance\", [offer.offerorAddress, this.getAddress()]);\n    if (offerorAllowance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`\n      };\n    }\n    return {\n      valid: true,\n      error: \"\"\n    };\n  }\n  async applyFilter(offers, filter) {\n    let rawOffers = [...offers];\n    if (filter) {\n      if (filter.offeror) {\n        const resolvedOfferor = await resolveAddress(filter.offeror);\n        rawOffers = rawOffers.filter(offeror => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;\n  }\n}\n\nexport { MarketplaceV3DirectListings as M, Status as S, MarketplaceV3EnglishAuctions as a, MarketplaceV3Offers as b };\n","import { cA as BigNumberTransformSchema, cB as FileOrBufferOrStringSchema, cC as HexColor, cu as ContractWrapper } from './index-827e427d.browser.esm.js';\nimport { z } from 'zod';\nimport { i as isNativeToken } from './fetchCurrencyValue-39f97190.browser.esm.js';\n\nconst PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional().nullable())();\n\n/**\n * @internal\n */\nconst BasicNFTInput = /* @__PURE__ */(() => z.object({\n  name: z.union([z.string(), z.number()]).optional().nullable(),\n  description: z.string().nullable().optional().nullable(),\n  image: FileOrBufferOrStringSchema.nullable().optional(),\n  animation_url: FileOrBufferOrStringSchema.optional().nullable()\n}))();\n\n/**\n * @internal\n */\nconst CommonNFTInput = /* @__PURE__ */(() => BasicNFTInput.extend({\n  external_url: FileOrBufferOrStringSchema.nullable().optional(),\n  background_color: HexColor.optional().nullable(),\n  properties: OptionalPropertiesInput,\n  attributes: OptionalPropertiesInput\n}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\nconst NFTInputOrUriSchema = /* @__PURE__ */(() => z.union([CommonNFTInput, z.string()]))();\n\n/**\n * @internal\n */\nconst CommonNFTOutput = /* @__PURE__ */(() => CommonNFTInput.extend({\n  id: z.string(),\n  uri: z.string(),\n  image: z.string().nullable().optional(),\n  external_url: z.string().nullable().optional(),\n  animation_url: z.string().nullable().optional()\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\nexport { BasicNFTInput as B, CommonNFTOutput as C, NFTInputOrUriSchema as N, CommonNFTInput as a, setErc20Allowance as s };\n"],"names":["InterfaceId_IERC721","InterfaceId_IERC1155","FALLBACK_METADATA","name","async","fetchTokenMetadata","tokenId","tokenUri","storage","startsWith","Buffer","base64","split","jsonMetadata","JSON","parse","from","toString","C","id","uri","parsedUri","replace","toHexString","slice","downloadJSON","err","unparsedTokenIdUri","e","console","warn","stringify","fetchTokenMetadataForContract","contractAddress","provider","ERC165MetadataAbi","default","erc165","isERC721","isERC1155","Promise","all","supportsInterface","ERC721MetadataAbi","erc721","tokenURI","Error","ERC1155MetadataAbi","erc1155","uploadOrExtractURI","metadata","upload","uploadOrExtractURIs","metadatas","startNumber","options","undefined","find","m","isUriList","isMetadataList","uploadBatch","map","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","uris","baseUri","substring","lastIndexOf","i","length","DEFAULT_QUERY_ALL_COUNT","RawDateSchema","z","union","date","transform","Math","floor","getTime","number","StartDateSchema","Date","EndDateSchema","now","assertEnabled","namespace","feature","cleanCurrencyAddress","currencyAddress","detectContractFeature","contractWrapper","featureName","abi","hasFunction","functionName","readContract","functions","ContractMetadata","constructor","schema","this","parseOutputMetadata","output","parseAsync","parseInputMetadata","input","get","data","supportsContractMetadata","read","includes","contractName","contractSymbol","publishedMetadata","address","getProvider","symbol","description","info","title","set","_parseAndUploadMetadata","wrapper","T","fromContractWrapper","method","args","receipt","update","prepare","parsedMetadata","ContractEvents","addTransactionListener","listener","addListener","Transaction","removeTransactionListener","off","addEventListener","eventName","event","interface","getEvent","filter","topics","getEventTopic","wrappedListener","log","parsedLog","parseLog","toContractEvent","eventFragment","on","listenToAllEvents","error","removeEventListener","removeAllListeners","getAllEvents","filters","arguments","fromBlock","toBlock","order","orderedEvents","queryFilter","sort","a","b","blockNumber","parseEvents","getEvents","eventInterface","inputs","events","transaction","Object","fromEntries","entries","key","value","rawLog","results","forEach","param","index","Array","isArray","components","arr","type","objArray","tuple","obj","j","push","GasCostEstimator","gasCostOf","fn","price","gasUnits","getGasPrice","estimateGas","mul","gasLimitOf","currentGasPriceInGwei","ContractAppURI","app_uri","getGatewayUrls","appURI","ContractInterceptor","overrideNextTransaction","hook","withTransactionOverride","ContractPlatformFee","platformFeeRecipient","platformFeeBps","platform_fee_recipient","platform_fee_basis_points","parsed","platformFeeInfo","ContractRoles","roles","getAll","_ref","role","item","h","roleHash","count","toNumber","keys","setAll","contractEncoder","rolesWithAddresses","every","currentRoles","encoded","sortedRoles","addresses","currentAddresses","addressOrEns","toAdd","toRemove","encode","getRevokeRoleFunctionName","revokeFunctionName","verify","members","resolvedAddress","toLowerCase","grant","revoke","signerAddress","getSignerAddress","isTokenApprovedForTransfer","transferrerContractAddress","assetContract","owner","ERC165Abi","I","ERC721Abi","asset","isApprovedForAll","approvedAddress","getApproved","ERC1155Abi","handleTokenApproval","marketplaceAddress","getSignerOrProvider","sendTransaction","validateNewListingParam","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","startTimestamp","quantity","reservePricePerToken","mapOffer","listingId","offer","quantityDesired","pricePerToken","currencyContractAddress","currency","buyerAddress","offeror","quantityWanted","currencyValue","isWinningBid","winningPrice","newBidPrice","bidBuffer","eq","sub","div","gte","getAllInBatches","start","end","batches","D","MarketplaceV3","static","directListings","detectDirectListings","englishAuctions","detectEnglishAuctions","offers","detectOffers","chainId","_chainId","network","app","contractRoles","encoder","estimator","G","platformFees","interceptor","onNetworkUpdated","updateSignerOrProvider","getAddress","overrides","call","d","M","DirectListingInputParamsSchema","object","R","endTimestamp","E","isReservedListing","boolean","Status","MarketplaceV3DirectListings","getTotalCount","totalListings","rawListings","g","startId","endId","flat","filteredListings","applyFilter","listing","mapListing","getAllValid","getListing","isBuyerApprovedForListing","buyer","validateListing","isCurrencyApprovedForListing","currencyPriceForListing","resolvedCurrencyAddress","createListing","parsedListing","normalizedPricePerToken","n","blockTime","getBlock","timestamp","lt","c","reserved","parseLogs","logs","createListingsBatch","listings","tx","updateListing","cancelListing","buyFromListing","receiver","valid","isStillValidListing","buyFor","getCallOverrides","s","approveBuyerForReservedListing","revokeBuyerApprovalForReservedListing","approveCurrencyForListing","pricePerTokenInCurrency","currencyPrice","revokeCurrencyApprovalForListing","isZero","status","UNSET","gt","Created","Expired","Active","Completed","Cancelled","currencyValuePerToken","startTimeInSeconds","endTimeInSeconds","creatorAddress","listingCreator","ownerOf","balanceOf","seller","resolvedSeller","tokenContract","resolvedToken","EnglishAuctionInputParamsSchema","minimumBidAmount","buyoutBidAmount","timeBufferInSeconds","bidBufferBps","MarketplaceV3EnglishAuctions","totalAuctions","rawAuctions","filteredAuctions","auction","mapAuction","getAuction","auctionId","getWinningBid","validateAuction","bid","_bidder","mapBid","_currency","_bidAmount","bidAmount","getWinner","endTime","contractEvent","closed","winningBidder","createAuction","parsedAuction","normalizedBuyoutAmount","normalizedMinBidAmount","createAuctionsBatch","buyoutAuction","currencyMetadata","f","makeBid","decimals","normalizedBidAmount","isWinnner","tokenPrice","cancelAuction","closeAuctionForBidder","closeFor","message","closeAuctionForSeller","executeSale","winningBid","closeForSeller","closeForBuyer","getBidBufferBps","getMinimumNextBid","currentBidBufferBps","currentBidOrReservePrice","minimumNextBid","add","auctionCreator","minimumBidCurrencyValue","buyoutCurrencyValue","bidderAddress","resolvedBidderAddress","bidAmountCurrencyValue","auctions","OfferInputParamsSchema","totalPrice","MarketplaceV3Offers","totalOffers","rawOffers","filteredOffers","getOffer","offerId","makeOffer","parsedOffer","getChainID","wrapped","normalizedTotalPrice","expirationTimestamp","cancelOffer","acceptOffer","validateOffer","isStillValidOffer","offerorAddress","ERC20Abi","erc20","resolvedOfferor","PropertiesInput","catchall","unknown","OptionalPropertiesInput","array","optional","nullable","BasicNFTInput","string","image","animation_url","CommonNFTInput","extend","external_url","background_color","properties","attributes","NFTInputOrUriSchema","CommonNFTOutput","setErc20Allowance","contractToApprove","signer","getSigner","spender"],"sourceRoot":""}