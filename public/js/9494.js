(self.webpackChunk=self.webpackChunk||[]).push([[9494],{89050:(t,e,r)=>{"use strict";r.d(e,{D:()=>f,F:()=>l,I:()=>c,a:()=>p,b:()=>u,c:()=>h,f:()=>d,g:()=>g,u:()=>m});var a=r(41518),n=r(16441),i=r(2593),s=r(64146),o=r(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),l={name:"Failed to load NFT metadata"};async function d(t,e,r){if(e.startsWith("data:application/json;base64")&&void 0!==o){const r=e.split(",")[1],n=JSON.parse(o.from(r,"base64").toString("utf-8"));return a.C.parse({...n,id:i.O$.from(t).toString(),uri:e})}const s=e.replace("{id}",n.hexZeroPad(i.O$.from(t).toHexString(),32).slice(2));let c;try{c=await r.downloadJSON(s)}catch(a){const n=e.replace("{id}",i.O$.from(t).toString());try{c=await r.downloadJSON(n)}catch(r){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),c=l}}return a.C.parse({...c,id:i.O$.from(t).toString(),uri:e})}async function h(t,e,n,o){let h;const u=(await r.e(5025).then(r.t.bind(r,25025,19))).default,m=new s.CH(t,u,e),[g,f]=await Promise.all([m.supportsInterface(c),m.supportsInterface(p)]);if(g){const a=(await Promise.resolve().then(r.t.bind(r,34161,19))).default,i=new s.CH(t,a,e);h=await i.tokenURI(n)}else{if(!f)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(r.t.bind(r,50266,19))).default,i=new s.CH(t,a,e);h=await i.uri(n)}}return h?d(n,h,o):a.C.parse({...l,id:i.O$.from(n).toString(),uri:""})}async function u(t,e){return"string"==typeof t?t:await e.upload(a.a.parse(t))}async function m(t,e,r,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await e.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:r||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function g(t){const e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){const a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}const f=100},89208:(t,e,r)=>{"use strict";r.d(e,{E:()=>c,R:()=>s,S:()=>o,a:()=>p});var a=r(2593),n=r(1604),i=r(7860);const s=(()=>n.z.union([n.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),n.z.number().transform((t=>a.O$.from(t)))]))(),o=(()=>s.default(new Date(0)))(),c=(()=>s.default(new Date(Date.now()+31536e7)))();function p(t,e){if(!t)throw new i.x(e);return t}},15070:(t,e,r)=>{"use strict";r.d(e,{c:()=>i});var a=r(7860),n=r(68828);function i(t){return(0,n.i)(t)?a.aZ:t}},89536:(t,e,r)=>{"use strict";r.d(e,{C:()=>p,G:()=>d,a:()=>l,b:()=>h,d:()=>o,h:()=>c});var a=r(7860),n=r(19578),i=r(61744),s=r(40721);function o(t,e){return(0,a.am)(a.bn.parse(t.abi),e)}function c(t,e){return t in e.readContract.functions}class p{featureName=a.d1.name;constructor(t,e,r){this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const e=await this.contractWrapper.read("contractURI",[]);e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let e,r,n;try{c("name",this.contractWrapper)&&(e=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(r=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:e||n?.name,symbol:r,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class l{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},n=t=>{const r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const e={address:this.contractWrapper.address},r=e=>{try{const r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(t){console.error("Could not parse event:",e,t)}};return this.contractWrapper.getProvider().on(e,r),()=>{this.contractWrapper.getProvider().off(e,r)}}removeEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber));return this.parseEvents(e)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=this.contractWrapper.readContract.interface.getEvent(t),a=e.filters?r.inputs.map((t=>e.filters[t.name])):[],n=this.contractWrapper.readContract.filters[r.name](...a),i=(await this.contractWrapper.readContract.queryFilter(n,e.fromBlock,e.toBlock)).sort(((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber));return this.parseEvents(i)}parseEvents(t){return t.map((t=>{const e=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const r=Object.entries(t.args),a=r.slice(r.length/2,r.length),n={};for(const[t,e]of a)n[t]=e;return{eventName:t.event||"",data:n,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}}))}toContractEvent(t,e,r){const a=Object.fromEntries(Object.entries(r).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,r)=>{if(Array.isArray(e[r])){const a=t.components;if(a){const i=e[r];if("tuple[]"===t.type){const e=[];for(let t=0;t<i.length;t++){const r=i[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=r[t]}e.push(n)}n[t.name]=e}else{const e={};for(let t=0;t<a.length;t++){e[a[t].name]=i[t]}n[t.name]=e}}}else n[t.name]=e[r]})),{eventName:t.name,data:n,transaction:a}}}class d{constructor(t){this.contractWrapper=t}async gasCostOf(t,e){const[r,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,e)]);return i.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return i.formatUnits(t,"gwei")}}class h{featureName=a.d2.name;constructor(t,e,r){this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,s.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>o(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,e,r)=>{"use strict";r.d(e,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},83833:(t,e,r)=>{"use strict";r.d(e,{C:()=>y,D:()=>w,a:()=>C,c:()=>W});var a=r(89536),n=r(19578),i=r(7860),s=r(68828),o=r(29251),c=r(31886),p=r(84243),l=r(16441),d=r(2593),h=r(64146),u=r(41518),m=r(89050),g=r(58179),f=r(19824);class y{featureName=i.d4.name;constructor(t,e){this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){const[t,e]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return i.bH.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){const[e,r]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return i.bH.parseAsync({fee_recipient:e,seller_fee_basis_points:r})}setDefaultRoyaltyInfo=(0,n.c)((async t=>{const e=await this.metadata.get(),r=await this.metadata.parseInputMetadata({...e,...t}),i=await this.metadata._parseAndUploadMetadata(r);if((0,a.h)("setContractURI",this.contractWrapper)){const t=new s.C(this.contractWrapper),e=[t.encode("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),t.encode("setContractURI",[i])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.c)((async(t,e)=>{const r=i.bH.parse(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class w{constructor(t,e,r,a){this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}createDelayedRevealBatch=(0,n.c)((async(t,e,r,a)=>{if(!r)throw new Error("Password is required");const i=await this.storage.uploadBatch([u.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),s=(0,m.g)(i),l=await this.nextTokenIdToMintFn(),d=await this.storage.uploadBatch(e.map((t=>u.a.parse(t))),{onProgress:a?.onProgress,rewriteFileNames:{fileStartNumber:l.toNumber()}}),h=(0,m.g)(d),g=await this.contractWrapper.read("getBaseURICount",[]),f=await this.hashDelayRevealPassword(g,r),y=await this.contractWrapper.read("encryptDecrypt",[o.Y0(h),f]);let w;if(await this.isLegacyContract())w=y;else{const t=await this.contractWrapper.getChainID(),e=c.keccak256(["bytes","bytes","uint256"],[o.Y0(h),f,t]);w=p.$.encode(["bytes","bytes32"],[y,e])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[d.length,s.endsWith("/")?s:`${s}/`,w],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t});return n}})}));reveal=(0,n.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.hashDelayRevealPassword(t,e);try{const e=await this.contractWrapper.callStatic().reveal(t,r);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map((t=>{if((0,a.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,a.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=r.slice(0,r.length-1),i=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),s=await this.isLegacyContract(),o=(await Promise.all(Array.from([...r]).map((t=>s?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(l.hexDataLength(t)>0){if(s)return t;return p.$.decode(["bytes","bytes32"],t)[0]}return t}));return i.map(((t,e)=>({batchId:d.O$.from(e),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,e)=>l.hexDataLength(o[e])>0))}async hashDelayRevealPassword(t,e){const r=await this.contractWrapper.getChainID(),a=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return(0,m.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,a.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const e=(await r.e(8839).then(r.t.bind(r,98839,19))).default,a=new h.CH(this.contractWrapper.address,e,this.contractWrapper.getProvider()),n=await a.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function W(t,e,r,a,n){let s={};const o=a||i.aZ,c=(await(0,f.n)(t.getProvider(),e,o)).mul(r);return c.gt(0)&&(o===i.aZ?s={value:c}:o!==i.aZ&&n&&await(0,g.a)(t,o,c,r,0)),s}class C{featureName=i.d5.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.c)((async t=>{const e=await(0,i.aP)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})}))}},5995:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),n=r(7860);class i{featureName=n.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,e]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:e})}set=(0,a.c)((async t=>{const e=await n.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[e.platform_fee_recipient,e.platform_fee_basis_points]})}))}},74935:(t,e,r)=>{"use strict";r.d(e,{C:()=>c});var a=r(38776),n=r(7860),i=r(89536),s=r(19578),o=r(68828);class c{featureName=n.d3.name;constructor(t,e){this.contractWrapper=t,this.roles=e}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},e=Object.entries(this.roles);return(await Promise.all(e.map((t=>{let[,e]=t;return this.get(e)})))).forEach(((r,a)=>t[e[a][1]]=r)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=this.contractWrapper;if((0,i.h)("getRoleMemberCount",e)&&(0,i.h)("getRoleMember",e)){const r=(0,n.H)(t),a=(await e.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>e.read("getRoleMember",[r,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,s.c)((async t=>{const e=new o.C(this.contractWrapper),r=Object.keys(t);(0,a.Z)(r.length,"you must provide at least one role to set"),(0,a.Z)(r.every((t=>this.roles.includes(t))),"this contract does not support the given role");const i=await this.getAll(),c=[],p=r.sort((t=>"admin"===t?1:-1));for(let r=0;r<p.length;r++){const a=p[r],[s,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(i[a]?.map((t=>(0,n.aP)(t)))||[])]),l=s.filter((t=>!o.includes(t))),d=o.filter((t=>!s.includes(t)));if(l.length&&l.forEach((t=>{c.push(e.encode("grantRole",[(0,n.H)(a),t]))})),d.length){(await Promise.all(d.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,r)=>c.push(e.encode(t,[(0,n.H)(a),d[r]]))))}}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,e){await Promise.all(t.map((async t=>{const[r,a]=await Promise.all([this.get(t),(0,n.aP)(e)]);if(!r.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,s.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),r]})}));revoke=(0,s.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e),i=await this.getRevokeRoleFunctionName(r);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:i,args:[(0,n.H)(t),r]})}));async getRevokeRoleFunctionName(t){const[e,r]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}},82714:(t,e,r)=>{"use strict";r.d(e,{C:()=>i});var a=r(19578),n=r(7860);class i{featureName=n.d6.name;constructor(t){this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.read("primarySaleRecipient",[])}setRecipient=(0,a.c)((async t=>a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPrimarySaleRecipient",args:[t]})))}},62245:(t,e,r)=>{"use strict";r.d(e,{D:()=>f});var a=r(61744),n=r(16441),i=r(2593),s=r(21046),o=r(9279),c=r(29251),p=r(64063),l=r.n(p),d=r(7860),h=r(58179),u=r(68828),m=r(89536),g=r(19578);class f{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){const[e,r,a]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await(0,h.v)(e,a,this.contractWrapper.getProvider(),r.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,h.w)(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,h.w)(r)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,h.x)(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,h.x)(r)}throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,r]=await this.contractWrapper.read("claimCondition",[]),a=e.toNumber(),n=r.toNumber(),i=[];for(let t=a;t<a+n;t++)i.push(this.get(t));const[s,o,...c]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...i]);return Promise.all(c.map((e=>(0,h.v)(e,o,this.contractWrapper.getProvider(),s.merkle,this.storage,t?.withAllowList||!1))))}return[await this.getActive(t)]}async canClaim(t,e){return e&&(e=await(0,d.aP)(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){const o=[];let c,p;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!e)return[h.C.NoWallet];const[l,m]=await Promise.all([(0,d.aP)(e),this.getTokenDecimals()]),g=a.parseUnits(d.cz.parse(t),m);try{p=await this.getActive()}catch(t){return(0,d.B)(t,"!CONDITION")||(0,d.B)(t,"no active mint condition")?(o.push(h.C.NoClaimConditionSet),o):(console.warn("failed to get active claim condition",t),o.push(h.C.Unknown),o)}if("unlimited"!==p.availableSupply){if(a.parseUnits(p.availableSupply,m).lt(g))return o.push(h.C.NotEnoughSupply),o}const f=n.stripZeros(p.merkleRootHash).length>0;let y=null;if(f){if(y=await this.getClaimerProofs(l),!y&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(h.C.AddressNotAllowed),o;if(y)try{const e=await this.prepareClaim(t,!1,m,l);let r;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[r]=await this.contractWrapper.read("verifyClaimMerkleProof",[c,l,t,e.proofs,e.maxClaimable]),!r)return o.push(h.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([r]=await this.contractWrapper.read("verifyClaimMerkleProof",[l,t,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable}]),!r)return o.push(h.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[l,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[c,l,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(h.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(h.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(h.C.NotEnoughSupply);break;case"cant claim yet":o.push(h.C.ClaimPhaseNotStarted);break;default:o.push(h.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=i.O$.from(0),e=(0,h.y)(p.maxClaimablePerWallet,m);try{t=await this.getSupplyClaimedByWallet(l)}catch(t){}if(y&&(e=(0,h.y)(y.maxClaimable,m)),e.gt(0)&&e.lt(t.add(g)))return o.push(h.C.OverMaxClaimablePerWallet),o;if((!f||f&&!y)&&(e.lte(t)||e.eq(0)))return o.push(h.C.AddressNotAllowed),o}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,e]=[i.O$.from(0),i.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,e]=await this.contractWrapper.read("getClaimTimestamp",[c,l])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,e]=await this.contractWrapper.read("getClaimTimestamp",[l]));const r=i.O$.from(Date.now()).div(1e3);if(t.gt(0)&&r.lt(e))return e.eq(s.Bz)?o.push(h.C.AlreadyClaimed):o.push(h.C.WaitBeforeNextClaimTransaction),o}if(p.price.gt(0)&&(0,d.d7)()){const e=p.price.mul(i.O$.from(t)),a=this.contractWrapper.getProvider();if((0,u.i)(p.currencyAddress)){(await a.getBalance(l)).lt(e)&&o.push(h.C.NotEnoughTokens)}else{const t=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new d.cu(a,p.currencyAddress,t,{},this.storage);(await n.read("balanceOf",[l])).lt(e)&&o.push(h.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e){const r=(await this.get(e)).merkleRoot;if(n.stripZeros(r).length>0){const[e,a]=await Promise.all([this.metadata.get(),(0,d.aP)(t)]);return await(0,h.f)(a,r.toString(),e.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const e=await(0,d.aP)(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,g.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=e;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(r=!0,0===e.length)a=[{startTime:new Date(0),currencyAddress:o.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(e.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&a.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:i,sortedConditions:s}=await(0,h.D)(a,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),c={};i.forEach((t=>{c[t.merkleRoot]=t.snapshotUri}));const p=await t.metadata.get(),d=[];if(!l()(p.merkle,c)){const e=await t.metadata.parseInputMetadata({...p,merkle:c}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,m.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new u.C(t.contractWrapper);d.push(e.encode("setContractURI",[r]))}}const f=t.contractWrapper,y=new u.C(f);if(t.isLegacySinglePhaseDrop(f)){const t=new u.C(f);d.push(t.encode("setClaimConditions",[(0,h.E)(s[0]),r]))}else if(t.isLegacyMultiPhaseDrop(f))d.push(y.encode("setClaimConditions",[s.map(h.E),r]));else if(t.isNewSinglePhaseDrop(f))d.push(y.encode("setClaimConditions",[(0,h.F)(s[0]),r]));else{if(!t.isNewMultiphaseDrop(f))throw new Error("Contract does not support claim conditions");d.push(y.encode("setClaimConditions",[s.map(h.F),r]))}if((0,m.h)("multicall",t.contractWrapper))return g.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[d]});throw new Error("Contract does not support multicall")}})());update=(0,g.c)((async(t,e)=>{const r=await this.getAll(),a=await(0,h.H)(t,e,r);return await this.set.prepare(a)}));async getTokenDecimals(){return(0,m.d)(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3?arguments[3]:void 0;const[n,i]=await Promise.all([a||this.contractWrapper.getSignerAddress(),this.getActive()]);return(0,h.z)(n,t,i,(async()=>(await this.metadata.get()).merkle),r,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r){const a=await(0,d.aP)(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,r.proofs,r.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable},c.Y0("")]:[a,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,pricePerToken:r.priceInProof,currency:r.currencyAddressInProof},c.Y0("")]}async getClaimTransaction(t,e,r){if(r?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const a=await this.prepareClaim(e,void 0===r?.checkERC20Allowance||r.checkERC20Allowance,await this.getTokenDecimals());return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,a),overrides:a.overrides})}isNewSinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV2")||(0,m.d)(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV2")||(0,m.d)(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV1")||(0,m.d)(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV1")||(0,m.d)(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?h.A.V1:h.A.V2}}},40795:(t,e,r)=>{"use strict";r.d(e,{D:()=>v,e:()=>L,f:()=>M});var a=r(2593),n=r(16441),i=r(21046),s=r(9279),o=r(29251),c=r(7860),p=r(89208),l=r(89536),d=r(89050),h=r(19578),u=r(1604),m=r(83833),g=r(64063),f=r.n(g),y=r(58179),w=r(68828),W=r(38776),C=r(19824),b=r(41518);class v{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t,e){const r=await this.get(t),a=await this.metadata.get();return await(0,y.v)(r,0,this.contractWrapper.getProvider(),a.merkle,this.storage,e?.withAllowList||!1)}async get(t,e){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,y.w)(e)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,y.w)(a)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return(0,y.x)(e)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=void 0!==e?e:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,r]);return(0,y.x)(a)}throw new Error("Contract does not support claim conditions")}async getAll(t,e){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]),a=r.currentStartId.toNumber(),n=r.count.toNumber(),i=[];for(let e=a;e<a+n;e++)i.push(await this.get(t,e));const s=await this.metadata.get();return Promise.all(i.map((t=>(0,y.v)(t,0,this.contractWrapper.getProvider(),s.merkle,this.storage,e?.withAllowList||!1))))}return[await this.getActive(t,e)]}async canClaim(t,e,r){return r&&(r=await(0,c.aP)(r)),0===(await this.getClaimIneligibilityReasons(t,e,r)).length}async getClaimIneligibilityReasons(t,e,s){const o=[];let p,l;if(void 0===s)try{s=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!s)return[y.C.NoWallet];const d=await(0,c.aP)(s);try{l=await this.getActive(t)}catch(t){return(0,c.B)(t,"!CONDITION")||(0,c.B)(t,"no active mint condition")?(o.push(y.C.NoClaimConditionSet),o):(o.push(y.C.Unknown),o)}if("unlimited"!==l.availableSupply&&a.O$.from(l.availableSupply).lt(e))return o.push(y.C.NotEnoughSupply),o;const h=n.stripZeros(l.merkleRootHash).length>0;let u=null;if(h){if(u=await this.getClaimerProofs(t,d),!u&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(y.C.AddressNotAllowed),o;if(u)try{const r=await this.prepareClaim(t,e,!1,d);let a;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(p=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[a]=await this.contractWrapper.read("verifyClaimMerkleProof",[p,d,t,e,r.proofs,r.maxClaimable]),!a)return o.push(y.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([a]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,d,e,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable}]),!a)return o.push(y.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,d,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(p=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[p,d,t,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,currency:r.currencyAddressInProof,pricePerToken:r.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(y.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(y.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(y.C.NotEnoughSupply);break;case"cant claim yet":o.push(y.C.ClaimPhaseNotStarted);break;default:o.push(y.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let r=a.O$.from(0),n=(0,y.y)(l.maxClaimablePerWallet,0);try{r=await this.getSupplyClaimedByWallet(t,d)}catch(t){}if(u&&(n=(0,y.y)(u.maxClaimable,0)),n.gt(0)&&n.lt(r.add(e)))return o.push(y.C.OverMaxClaimablePerWallet),o;if((!h||h&&!u)&&(n.lte(r)||n.eq(0)))return o.push(y.C.AddressNotAllowed),o}let[m,g]=[a.O$.from(0),a.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(p=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[m,g]=await this.contractWrapper.read("getClaimTimestamp",[t,p,d])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([m,g]=await this.contractWrapper.read("getClaimTimestamp",[t,d]));const f=a.O$.from(Date.now()).div(1e3);if(m.gt(0)&&f.lt(g))return g.eq(i.Bz)?o.push(y.C.AlreadyClaimed):o.push(y.C.WaitBeforeNextClaimTransaction),o;if(l.price.gt(0)&&(0,c.d7)()){const t=l.price.mul(e),a=this.contractWrapper.getProvider();if((0,w.i)(l.currencyAddress)){(await a.getBalance(d)).lt(t)&&o.push(y.C.NotEnoughTokens)}else{const e=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new c.cu(a,l.currencyAddress,e,{},this.storage);(await n.read("balanceOf",[d])).lt(t)&&o.push(y.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e,r){const a=(await this.get(t,r)).merkleRoot;if(n.stripZeros(a).length>0){const t=await this.metadata.get(),r=await(0,c.aP)(e);return await(0,y.f)(r,a.toString(),t.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t,e){const r=await(0,c.aP)(e);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,h.c)((()=>{var t=this;return async function(e,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t.setBatch.prepare([{tokenId:e,claimConditions:r}],a)}})());setBatch=(0,h.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const a={},i=await Promise.all(e.map((async e=>{let{tokenId:i,claimConditions:o}=e,c=o;if(t.isLegacySinglePhaseDrop(t.contractWrapper))if(r=!0,0===o.length)c=[{startTime:new Date(0),currencyAddress:s.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(o.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&c.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:p,sortedConditions:l}=await(0,y.D)(c,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return p.forEach((t=>{a[t.merkleRoot]=t.snapshotUri})),{tokenId:i,sortedConditions:l}}))),o=await t.metadata.get(),c=[];for(const t of Object.keys(o.merkle||{}))a[t]=o.merkle[t];if(!f()(o.merkle,a)){const e=await t.metadata.parseInputMetadata({...o,merkle:a}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,l.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new w.C(t.contractWrapper);c.push(e.encode("setContractURI",[r]))}}if(i.forEach((e=>{let{tokenId:a,sortedConditions:n}=e;const i=new w.C(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const e=new w.C(t.contractWrapper);c.push(e.encode("setClaimConditions",[a,(0,y.E)(n[0]),r]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(i.encode("setClaimConditions",[a,n.map(y.E),r]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(i.encode("setClaimConditions",[a,(0,y.F)(n[0]),r]));else{if(!t.isNewMultiphaseDrop(t.contractWrapper))throw new Error("Contract does not support claim conditions");c.push(i.encode("setClaimConditions",[a,n.map(y.F),r]))}})),(0,l.h)("multicall",t.contractWrapper))return h.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})());update=(0,h.c)((async(t,e,r)=>{const a=await this.getAll(t),n=await(0,y.H)(e,r,a);return await this.set.prepare(t,n)}));async prepareClaim(t,e,r,a){const n=await(0,c.aP)(a||await this.contractWrapper.getSignerAddress());return(0,y.z)(n,e,await this.getActive(t),(async()=>(await this.metadata.get()).merkle),0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r,a){const n=await(0,c.aP)(e);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},o.Y0("")]:[n,t,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},o.Y0("")]}async getClaimTransaction(t,e,r,a){if(a?.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const n=await this.prepareClaim(e,r,a?.checkERC20Allowance||!0);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(e,t,r,n),overrides:n.overrides})}isNewSinglePhaseDrop(t){return(0,l.d)(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,l.d)(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,l.d)(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,l.d)(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?y.A.V1:y.A.V2}}class P{featureName=c.d8.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r}to=(0,h.c)((async(t,e)=>{const r=e.map((t=>t.metadata)),a=e.map((t=>t.supply)),n=await(0,d.u)(r,this.storage),s=await(0,c.aP)(t),o=new w.C(this.contractWrapper),p=await Promise.all(n.map((async(t,e)=>o.encode("mintTo",[s,i.Bz,t,a[e]]))));return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[p],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===e.length||e.length<r.length)throw new Error("TokenMinted event not found, minting failed");return e.map((e=>{const r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}))}})}))}class T{featureName=c.d9.name;constructor(t){this.contractWrapper=t}tokens=(0,h.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,e)}));from=(0,h.c)((async(t,e,r)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await(0,c.aP)(t),e,r]})));batch=(0,h.c)((async(t,e)=>{const r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,e)}));batchFrom=(0,h.c)((async(t,e,r)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await(0,c.aP)(t),e,r]})))}class A{featureName=c.da.name;constructor(t,e){this.erc1155=t,this.contractWrapper=e}async all(t){const e=a.O$.from(t?.start||0).toNumber(),r=a.O$.from(t?.count||d.D).toNumber(),n=Math.min((await this.totalCount()).toNumber(),e+r);return await Promise.all([...Array(n-e).keys()].map((t=>this.erc1155.get((e+t).toString()))))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,e){const[r,a]=await Promise.all([(0,c.aP)(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let n=(await this.contractWrapper.read("balanceOfBatch",[Array(a.toNumber()).fill(r),Array.from(Array(a.toNumber()).keys())])).map(((t,e)=>({tokenId:e,balance:t}))).filter((t=>t.balance.gt(0)));if(e){const t=e?.start||0,r=e?.count||d.D;n=n.slice(t,t+r)}return(await Promise.all(n.map((t=>this.erc1155.get(t.tokenId.toString()))))).map(((t,e)=>({...t,owner:r,quantityOwned:n[e].balance.toString()})))}}class S{featureName=c.db.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc1155Revealable()}lazyMint=(0,h.c)((async(t,e)=>{const r=await this.erc1155.nextTokenIdToMint(),a=await(0,d.u)(t,this.storage,r.toNumber(),e),n=a[0].substring(0,a[0].lastIndexOf("/"));for(let t=0;t<a.length;t++){const e=a[t].substring(0,a[t].lastIndexOf("/"));if(n!==e)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${e}'`)}const i=t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc1155.getTokenMetadata(e)});return n},s=await(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,s)?h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`],parse:i}):h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`,o.Y0("")],parse:i})}));detectErc1155Revealable(){if((0,l.d)(this.contractWrapper,"ERC1155Revealable"))return new m.D(this.contractWrapper,this.storage,c.dc.name,(()=>this.erc1155.nextTokenIdToMint()))}isLegacyEditionDropContract(t,e){return e&&"DropERC1155"===e.type&&e.version<3||!1}}class k{featureName=c.de.name;constructor(t,e,r){this.erc1155=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc1155BatchMintable()}to=(0,h.c)((async(t,e)=>{const r=await this.getMintTransaction(t,e);return r.setParse((t=>{const e=this.contractWrapper.parseLogs("TransferSingle",t?.logs);if(0===e.length)throw new Error("TransferSingleEvent event not found");const r=e[0].args.id;return{id:r,receipt:t,data:()=>this.erc1155.get(r.toString())}})),r}));async getMintTransaction(t,e){const r=await(0,d.b)(e.metadata,this.storage);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),i.Bz,r,e.supply]})}additionalSupplyTo=(0,h.c)((async(t,e,r)=>{const n=await this.erc1155.getTokenMetadata(e);return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await(0,c.aP)(t),e,n.uri,r],parse:t=>({id:a.O$.from(e),receipt:t,data:()=>this.erc1155.get(e)})})}));detectErc1155BatchMintable(){if((0,l.d)(this.contractWrapper,"ERC1155BatchMintable"))return new P(this.erc1155,this.contractWrapper,this.storage)}}const E=(()=>u.z.object({address:c.bd,quantity:c.cz.default(1)}))(),I=(()=>u.z.union([u.z.array(u.z.string()).transform((async t=>await Promise.all(t.map((t=>E.parseAsync({address:t})))))),u.z.array(E)]))();class x{featureName=c.df.name;constructor(t){this.contractWrapper=t}async getClaimTransaction(t,e,r,a){let n={};return a&&a.pricePerToken&&(n=await(0,m.c)(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await(0,c.aP)(t),e,r],overrides:n})}to=(0,h.c)((async(t,e,r,a)=>await this.getClaimTransaction(t,e,r,a)))}class N{featureName=c.dg.name;constructor(t,e){this.contractWrapper=t,this.storage=e;const r=new l.C(this.contractWrapper,c.bk,this.storage);this.conditions=new v(t,r,this.storage)}to=(0,h.c)((async(t,e,r,a)=>await this.conditions.getClaimTransaction(t,e,r,a)))}class M{featureName=c.dh.name;constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.roles=r}mint=(0,h.c)((async t=>{const e=t.payload,r=t.signature,[a,n]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,b.s)(this.contractWrapper,a.pricePerToken.mul(a.quantity),e.currencyAddress,n),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,r],overrides:n,parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return{id:e[0].args.tokenIdMinted,receipt:t}}})}));mintBatch=(0,h.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const n=e[r],i=t.signature,s=t.payload.price;if(a.O$.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:i}})),n=new w.C(this.contractWrapper),i=r.map((t=>n.encode("mintWithSignature",[t.message,t.signature])));if((0,l.h)("multicall",this.contractWrapper))return h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return e.map((e=>({id:e.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not supported on this contract!")}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){const e={...t,tokenId:i.Bz};return this.generateFromTokenId(e)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const e=t.map((t=>({...t,tokenId:i.Bz})));return this.generateBatchFromTokenIds(e)}async generateBatchFromTokenIds(t){const e=this.contractWrapper.getSigner();(0,W.Z)(e,"No signer available"),await(this.roles?.verify(["minter"],await e.getAddress()));const r=await Promise.all(t.map((t=>y.o.parseAsync(t)))),a=r.map((t=>t.metadata)),[n,i,s]=await Promise.all([(0,d.u)(a,this.storage),this.contractWrapper.getChainID(),(0,c.dd)(this.contractWrapper.address,this.contractWrapper.getProvider())]),o=await Promise.all(r.map(((t,e)=>y.p.parseAsync({...t,uri:n[e]})))),p=await Promise.all(o.map((t=>this.mapPayloadToContractStruct(t)))),l="TokenERC1155"===s?.type;return(await Promise.all(p.map((t=>this.contractWrapper.signTypedData(e,{name:l?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.address},{MintRequest:y.t},t))))).map(((t,e)=>({payload:o[e],signature:t.toString()})))}async mapPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class L{featureName=c.di.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,r]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch((()=>a.O$.from(0))),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...d.F})))]);return{owner:s.d,metadata:r,type:"ERC1155",supply:e.toString()}}async totalSupply(t){if((0,l.d)(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new c.x(c.dj)}async balanceOf(t,e){return await this.contractWrapper.read("balanceOf",[await(0,c.aP)(t),e])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,e){return await this.contractWrapper.read("isApprovedForAll",[await(0,c.aP)(t),await(0,c.aP)(e)])}transfer=(0,h.c)((()=>{var t=this;return async function(e,r,a){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const i=await t.contractWrapper.getSignerAddress();return h.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[i,await(0,c.aP)(e),r,a,n]})}})());transferFrom=(0,h.c)((()=>{var t=this;return async function(e,r,a,n){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[0];return h.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await(0,c.aP)(e),await(0,c.aP)(r),a,n,i]})}})());setApprovalForAll=(0,h.c)((async(t,e)=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,e]})));airdrop=(0,h.c)((()=>{var t=this;return async function(e,r,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const s=n?await(0,c.aP)(n):await t.contractWrapper.getSignerAddress(),o=await t.balanceOf(s,e),p=await I.parseAsync(r),l=p.reduce(((t,e)=>a.O$.from(t).add(a.O$.from(e?.quantity||1))),a.O$.from(0));if(o.lt(a.O$.from(l)))throw new Error(`The caller owns ${o.toString()} NFTs, but wants to airdrop ${l.toString()} NFTs.`);const d=new w.C(t.contractWrapper),u=p.map((t=>{let{address:r,quantity:a}=t;return d.encode("safeTransferFrom",[s,r,e,a,i])}));return h.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[u]})}})());async nextTokenIdToMint(){if((0,l.h)("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return(0,p.a)(this.query,c.da).all(t)}async totalCount(){return(0,p.a)(this.query,c.da).totalCount()}async totalCirculatingSupply(t){return(0,p.a)(this.query,c.da).totalCirculatingSupply(t)}async getOwned(t,e){return t&&(t=await(0,c.aP)(t)),(0,p.a)(this.query,c.da).owned(t,e)}mint=(0,h.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,h.c)((async(t,e)=>(0,p.a)(this.mintable,c.de).to.prepare(t,e)));async getMintTransaction(t,e){return(0,p.a)(this.mintable,c.de).getMintTransaction(t,e)}mintAdditionalSupply=(0,h.c)((async(t,e)=>(0,p.a)(this.mintable,c.de).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));mintAdditionalSupplyTo=(0,h.c)((async(t,e,r)=>(0,p.a)(this.mintable,c.de).additionalSupplyTo.prepare(t,e,r)));mintBatch=(0,h.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=(0,h.c)((async(t,e)=>(0,p.a)(this.mintable?.batch,c.d8).to.prepare(t,e)));burn=(0,h.c)((async(t,e)=>(0,p.a)(this.burnable,c.d9).tokens.prepare(t,e)));burnFrom=(0,h.c)((async(t,e,r)=>(0,p.a)(this.burnable,c.d9).from.prepare(t,e,r)));burnBatch=(0,h.c)((async(t,e)=>(0,p.a)(this.burnable,c.d9).batch.prepare(t,e)));burnBatchFrom=(0,h.c)((async(t,e,r)=>(0,p.a)(this.burnable,c.d9).batchFrom.prepare(t,e,r)));lazyMint=(0,h.c)((async(t,e)=>(0,p.a)(this.lazyMintable,c.db).lazyMint.prepare(t,e)));async getClaimTransaction(t,e,r,a){const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,e,r,a);if(i)return i.getClaimTransaction(t,e,r,a);throw new c.x(c.df)}claim=(0,h.c)((async(t,e,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e,r)));claimTo=(0,h.c)((async(t,e,r,a)=>{const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.to.prepare(t,e,r,a);if(i)return i.to.prepare(t,e,r,a);throw new c.x(c.df)}));get claimConditions(){return(0,p.a)(this.claimWithConditions,c.dg).conditions}get signature(){return(0,p.a)(this.signatureMintable,c.dh)}get revealer(){return(0,p.a)(this.lazyMintable?.revealer,c.dc)}async getTokenMetadata(t){const e=await this.contractWrapper.read("uri",[t]);if(!e)throw new c.n;return(0,d.f)(t,e,this.storage)}detectErc1155Enumerable(){if((0,l.d)(this.contractWrapper,"ERC1155Enumerable"))return new A(this,this.contractWrapper)}detectErc1155Mintable(){if((0,l.d)(this.contractWrapper,"ERC1155Mintable"))return new k(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if((0,l.d)(this.contractWrapper,"ERC1155Burnable"))return new T(this.contractWrapper)}detectErc1155LazyMintable(){if((0,l.d)(this.contractWrapper,"ERC1155LazyMintableV1")||(0,l.d)(this.contractWrapper,"ERC1155LazyMintableV2"))return new S(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if((0,l.d)(this.contractWrapper,"ERC1155SignatureMintable"))return new M(this.contractWrapper,this.storage)}detectErc1155Claimable(){if((0,l.d)(this.contractWrapper,"ERC1155ClaimCustom"))return new x(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if((0,l.d)(this.contractWrapper,"ERC1155ClaimConditionsV1")||(0,l.d)(this.contractWrapper,"ERC1155ClaimConditionsV2")||(0,l.d)(this.contractWrapper,"ERC1155ClaimPhasesV1")||(0,l.d)(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new N(this.contractWrapper,this.storage)}}},11846:(t,e,r)=>{"use strict";r.d(e,{e:()=>C,f:()=>b});var a=r(2593),n=r(61744),i=r(68828),s=r(7860),o=r(89208),c=r(89536),p=r(19578),l=r(62245),d=r(38776),h=r(19824),u=r(41518),m=r(58179);class g{featureName=s.cG.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}to=(0,p.c)((async t=>{const e=new i.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([(0,s.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[r,a]=t;return e.encode("mintTo",[r,a])}));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}))}class f{featureName=s.cH.name;constructor(t,e){this.erc20=t,this.contractWrapper=e}tokens=(0,p.c)((async t=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})));from=(0,p.c)((async(t,e)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,s.aP)(t),this.erc20.normalizeAmount(e)])})))}class y{featureName=s.cI.name;constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r;const a=new c.C(this.contractWrapper,s.bk,this.storage);this.conditions=new l.D(this.contractWrapper,a,this.storage)}to=(0,p.c)((async(t,e,r)=>{const a=await this.erc20.normalizeAmount(e);return await this.conditions.getClaimTransaction(t,a,r)}))}class w{constructor(t,e,r){this.erc20=t,this.contractWrapper=e,this.storage=r,this.claim=new y(this.erc20,this.contractWrapper,this.storage)}}class W{featureName=s.cJ.name;constructor(t,e){this.erc20=t,this.contractWrapper=e,this.batch=this.detectErc20BatchMintable()}to=(0,p.c)((async(t,e)=>await this.getMintTransaction(t,e)));async getMintTransaction(t,e){return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,s.aP)(t),this.erc20.normalizeAmount(e)])})}detectErc20BatchMintable(){if((0,c.d)(this.contractWrapper,"ERC20BatchMintable"))return new g(this.erc20,this.contractWrapper)}}class C{featureName=s.cK.name;constructor(t,e){this.contractWrapper=t,this.roles=e}mint=(0,p.c)((async t=>{const e=t.payload,r=t.signature,[n,i]=await Promise.all([this.mapPayloadToContractStruct(e),this.contractWrapper.getCallOverrides()]);return await(0,u.s)(this.contractWrapper,a.O$.from(n.price),e.currencyAddress,i),p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,r],overrides:i})}));mintBatch=(0,p.c)((async t=>{const e=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const n=e[r],i=t.signature,s=t.payload.price;if(a.O$.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:i}})),n=new i.C(this.contractWrapper),s=r.map((t=>n.encode("mintWithSignature",[t.message,t.signature])));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s]})}));async verify(t){const e=t.payload,r=t.signature,a=await this.mapPayloadToContractStruct(e);return(await this.contractWrapper.read("verify",[a,r]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await(this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[e,r,a]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>m.S.parseAsync(t))))]),n=this.contractWrapper.getSigner();(0,d.Z)(n,"No signer available");const i=await Promise.all(a.map((t=>m.k.parseAsync(t)))),s=await Promise.all(i.map((t=>this.mapPayloadToContractStruct(t)))),o=await Promise.all(s.map((t=>this.contractWrapper.signTypedData(n,{name:r,version:"1",chainId:e,verifyingContract:this.contractWrapper.address},{MintRequest:m.M},t))));return a.map(((t,e)=>({payload:i[e],signature:o[e].toString()})))}async mapPayloadToContractStruct(t){const[e,r]=await Promise.all([(0,h.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),a=n.parseUnits(t.quantity,r);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:a,price:e,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class b{featureName=s.cL.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await(0,i.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await(0,s.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[e,r]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,s.aP)(t)]);return await this.allowanceOf(e,r)}async allowanceOf(t,e){const r=await Promise.all([(0,s.aP)(t),(0,s.aP)(e)]);return await this.getValue(await this.contractWrapper.read("allowance",r))}transfer=(0,p.c)((async(t,e)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,s.aP)(t),this.normalizeAmount(e)])})));transferFrom=(0,p.c)((async(t,e,r)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,s.aP)(t),(0,s.aP)(e),this.normalizeAmount(r)])})));setAllowance=(0,p.c)((async(t,e)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,s.aP)(t),this.normalizeAmount(e)])})));transferBatch=(0,p.c)((async t=>{const e=new i.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),(0,s.aP)(t.toAddress)]))))).map((t=>{let[r,a]=t;return e.encode("transfer",[a,r])}));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));mint=(0,p.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,p.c)((async(t,e)=>(0,o.a)(this.mintable,s.cJ).to.prepare(t,e)));async getMintTransaction(t,e){return(0,o.a)(this.mintable,s.cJ).getMintTransaction(t,e)}mintBatchTo=(0,p.c)((async t=>(0,o.a)(this.mintable?.batch,s.cG).to.prepare(t)));burn=(0,p.c)((async t=>(0,o.a)(this.burnable,s.cH).tokens.prepare(t)));burnFrom=(0,p.c)((async(t,e)=>(0,o.a)(this.burnable,s.cH).from.prepare(t,e)));claim=(0,p.c)((async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));claimTo=(0,p.c)((async(t,e,r)=>(0,o.a)(this.droppable?.claim,s.cI).to.prepare(t,e,r)));get claimConditions(){return(0,o.a)(this.droppable?.claim,s.cI).conditions}get signature(){return(0,o.a)(this.signatureMintable,s.cK)}async normalizeAmount(t){return async function(t,e){const r=await t.read("decimals",[]);return n.parseUnits(s.cz.parse(e),r)}(this.contractWrapper,t)}async getValue(t){return await(0,i.a)(this.contractWrapper.getProvider(),this.getAddress(),a.O$.from(t))}detectErc20Mintable(){if((0,c.d)(this.contractWrapper,"ERC20"))return new W(this,this.contractWrapper)}detectErc20Burnable(){if((0,c.d)(this.contractWrapper,"ERC20Burnable"))return new f(this,this.contractWrapper)}detectErc20Droppable(){if((0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,c.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new w(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,c.d)(this.contractWrapper,"ERC20SignatureMintable"))return new C(this.contractWrapper)}}},15039:(t,e,r)=>{"use strict";r.d(e,{h:()=>q,i:()=>$});var a=r(29251),n=r(2593),i=r(9279),s=r(31886),o=r(84243),c=r(61744),p=r(89050),l=r(7860),d=r(89208),h=r(89536),u=r(19578),m=r(62245),g=r(83833),f=r(68828),y=r(40721),w=r(41518),W=r(38776),C=r(19824),b=r(1604),v=r(58179);class P{featureName=l.cM.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r}to=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([(0,p.u)(e,this.storage),(0,l.aP)(t)]),n=new f.C(this.contractWrapper),i=r.map((t=>n.encode("mintTo",[a,t])));return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{const r=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===r.length||r.length<e.length)throw new Error("TokenMinted event not found, minting failed");return r.map((e=>{const r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}))}})}))}class T{featureName=l.cN.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r;const a=new h.C(this.contractWrapper,l.bk,this.storage);this.conditions=new m.D(this.contractWrapper,a,this.storage)}to=(0,u.c)((async(t,e,r)=>{const a=await this.conditions.getClaimTransaction(t,e,r);return a.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),a}))}class A{featureName=l.cO.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async getClaimTransaction(t,e,r){let a={};return r&&r.pricePerToken&&(a=await(0,g.c)(this.contractWrapper,r.pricePerToken,e,r.currencyAddress,r.checkERC20Allowance)),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,e],overrides:a})}to=(0,u.c)((async(t,e,r)=>{const a=await this.getClaimTransaction(t,e,r);return a.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),a}))}class S{featureName=l.cP.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc721Revealable()}lazyMint=(0,u.c)((async(t,e)=>{const r=await this.erc721.nextTokenIdToMint(),n=await(0,p.u)(t,this.storage,r.toNumber(),e),i=(0,p.g)(n);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[n.length,i.endsWith("/")?i:`${i}/`,a.Y0("")],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));detectErc721Revealable(){if((0,h.d)(this.contractWrapper,"ERC721Revealable"))return new g.D(this.contractWrapper,this.storage,l.cQ.name,(()=>this.erc721.nextTokenIdToMint()))}}class k{featureName=l.cR.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc721BatchMintable()}to=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([(0,p.b)(e,this.storage),(0,l.aP)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[a,r],parse:t=>{const e=this.contractWrapper.parseLogs("Transfer",t?.logs);if(0===e.length)throw new Error("TransferEvent event not found");const r=e[0].args.tokenId;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}})}));async getMintTransaction(t,e){return this.to.prepare(await(0,l.aP)(t),e)}detectErc721BatchMintable(){if((0,h.d)(this.contractWrapper,"ERC721BatchMintable"))return new P(this.erc721,this.contractWrapper,this.storage)}}class E{featureName=l.cS.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async all(t,e){let r=await this.tokenIds(t);if(e){const t=e?.start||0,a=e?.count||p.D;r=r.slice(t,t+a)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const e=await(0,l.aP)(t||await this.contractWrapper.getSignerAddress()),r=await this.contractWrapper.read("balanceOf",[e]),a=Array.from(Array(r.toNumber()).keys());return await Promise.all(a.map((t=>this.contractWrapper.read("tokenOfOwnerByIndex",[e,t]))))}}class I{featureName=l.cT.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async all(t,e){let r=await this.tokenIds(t);if(e){const t=e?.start||0,a=e?.count||p.D;r=r.slice(t,t+a)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const e=await(0,l.aP)(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[e])}}class x{featureName=l.cU.name;constructor(t,e){this.erc721=t,this.contractWrapper=e,this.owned=this.detectErc721Owned()}async all(t){let e=n.O$.from(0);(0,h.h)("startTokenId",this.contractWrapper)&&(e=await this.contractWrapper.read("startTokenId",[]));const r=n.O$.from(t?.start||0).add(e).toNumber(),a=n.O$.from(t?.count||p.D).toNumber(),i=await this.erc721.nextTokenIdToMint(),s=Math.min(i.add(e).toNumber(),r+a);return await Promise.all([...Array(s-r).keys()].map((t=>this.erc721.get((r+t).toString()))))}async allOwners(){let t,e=n.O$.from(0);(0,h.h)("startTokenId",this.contractWrapper)&&(e=await this.contractWrapper.read("startTokenId",[]));try{t=await this.erc721.totalClaimedSupply()}catch(e){t=await this.totalCount()}t=t.add(e);const r=[...new Array(t.toNumber()).keys()],a=await Promise.all(r.map((t=>this.erc721.ownerOf(t).catch((()=>i.d)))));return r.map((t=>({tokenId:t,owner:a[t]}))).filter((t=>t.owner!==i.d))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){return(0,h.d)(this.contractWrapper,"ERC721Enumerable")?new E(this.erc721,this.contractWrapper):(0,h.d)(this.contractWrapper,"ERC721AQueryable")?new I(this.erc721,this.contractWrapper):void 0}}const N=(()=>v.B.extend({tierPriority:b.z.array(b.z.string()),royaltyRecipient:l.bd.default(i.d),royaltyBps:l.cF.default(0),quantity:l.b9.default(1)}))(),M=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class L{featureName=l.cV.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r}async getMetadataInTier(t){const e=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find((e=>e.tier===t));if(!e)throw new Error("Tier not found in contract.");return await Promise.all(e.ranges.map(((t,r)=>{const a=[],n=e.baseURIs[r];for(let e=t.startIdInclusive.toNumber();e<t.endIdNonInclusive.toNumber();e++){const t=n.endsWith("/")?`${n}${e}`:`${n}/${e}`,r=this.storage.downloadJSON(t);a.push(r)}return a})).flat())}async getTokensInTier(t){const e=await this.contractWrapper.read("getTokensInTierLen",[]);if(e.eq(0))return[];const r=await this.contractWrapper.read("getTokensInTier",[t,0,e]);return await Promise.all(r.map((t=>{const e=[];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++)e.push(this.erc721.get(r));return e})).flat())}createBatchWithTier=(0,u.c)((async(t,e,r)=>{const n=await this.erc721.nextTokenIdToMint(),i=await(0,p.u)(t,this.storage,n.toNumber(),r),s=(0,p.g)(i);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[i.length,s.endsWith("/")?s:`${s}/`,e,a.Y0("")],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));createDelayedRevealBatchWithTier=(0,u.c)((async(t,e,r,n,i)=>{if(!r)throw new Error("Password is required");const c=await this.storage.uploadBatch([w.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),l=(0,p.g)(c),d=await this.erc721.nextTokenIdToMint(),h=await this.storage.uploadBatch(e.map((t=>w.a.parse(t))),{onProgress:i?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),m=(0,p.g)(h),g=await this.contractWrapper.read("getBaseURICount",[]),f=await this.contractWrapper.getChainID(),y=s.keccak256(["string","uint256","uint256","address"],[r,f,g,this.contractWrapper.address]),W=await this.contractWrapper.read("encryptDecrypt",[a.Y0(m),y]),C=s.keccak256(["bytes","bytes","uint256"],[a.Y0(m),y,f]),b=o.$.encode(["bytes","bytes32"],[W,C]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[h.length,l.endsWith("/")?l:`${l}/`,n,b],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));reveal=(0,u.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.contractWrapper.getChainID(),a=s.keccak256(["string","uint256","uint256","address"],[e,r,t,this.contractWrapper.address]);try{const e=await this.contractWrapper.callStatic().reveal(t,a);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,a]})}));async generate(t){const[e]=await this.generateBatch([t]);return e}async generateBatch(t){const e=await Promise.all(t.map((t=>N.parseAsync(t)))),r=await this.contractWrapper.getChainID(),a=this.contractWrapper.getSigner();return(0,W.Z)(a,"No signer available"),await Promise.all(e.map((async t=>({payload:t,signature:(await this.contractWrapper.signTypedData(a,{name:"SignatureAction",version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{GenericRequest:M},await this.mapPayloadToContractStruct(t))).toString()}))))}async verify(t){const e=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[e,t.signature]))[0]}async claimWithSignature(t){const e=await this.mapPayloadToContractStruct(t.payload),r=await(0,C.n)(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),a=await this.contractWrapper.getCallOverrides();await(0,w.s)(this.contractWrapper,r,t.payload.currencyAddress,a);const n=await this.contractWrapper.sendTransaction("claimWithSignature",[e,t.signature],a),i=this.contractWrapper.parseLogs("TokensClaimed",n?.logs),s=i[0].args.startTokenId,o=s.add(i[0].args.quantityClaimed),c=[];for(let t=s;t.lt(o);t=t.add(1))c.push({id:t,receipt:n,data:()=>this.erc721.get(t)});return c}async mapPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=o.$.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,e,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:r}}}class O{featureName=l.cW.name;constructor(t){this.contractWrapper=t}token=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]})))}class R{featureName=l.cX.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}to=(0,u.c)((async(t,e,r)=>{if(t!==await(this.contractWrapper.getSigner()?.getAddress()))throw new Error("Zora Drop: Destination address must match connected wallet address");if(r?.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const a=(await this.getSaleDetails()).publicSalePrice,i=(s="0.000777",c.parseEther(l.cz.parse(s)));var s;const o=n.O$.from(a).add(i).mul(e),p=u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[e],overrides:{value:o}});return p.setParse((t=>{const r=this.contractWrapper.parseLogs("Sale",t?.logs)[0].args.firstPurchasedTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),p}));async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class B{featureName=l.cY.name;constructor(t){this.contractWrapper=t}cancel=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]})));revoke=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]})))}class D{featureName=l.cZ.name;constructor(t,e){this.contractWrapper=t,this.storage=e}update=(0,u.c)((async(t,e)=>{const r=await(0,p.b)(e,this.storage);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,r]})}))}class F{featureName=l.c_.name;constructor(t,e){this.contractWrapper=t,this.storage=e}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every((t=>""===t)))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}set=(0,u.c)((async t=>{const e=w.B.parse(t);e.description=this.sanitizeJSONString(e.description);const r=[];(0,y.XT)(e.image)?r.push(this.storage.upload(e.image)):"string"==typeof e.image?r.push(Promise.resolve(e.image)):r.push(Promise.resolve(void 0)),(0,y.XT)(e.animation_url)?r.push(this.storage.upload(e.animation_url)):"string"==typeof e.animation_url?r.push(Promise.resolve(e.animation_url)):r.push(Promise.resolve(void 0));const[a,n]=await Promise.all(r);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${e.name||""}`,description:e.description||"",imageURI:a||"",animationURI:n||""}]})}));sanitizeJSONString(t){if(!t)return t;const e=JSON.stringify(t);return e.slice(1,e.length-1)}}class ${featureName=l.c$.name;constructor(t,e){this.contractWrapper=t,this.storage=e}mint=(0,u.c)((async t=>{const e=t.payload,r=t.signature,a=await this.contractWrapper.getCallOverrides(),n=t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return{id:e[0].args.tokenIdMinted,receipt:t}};if(await this.isLegacyNFTContract()){const t=await this.mapLegacyPayloadToContractStruct(e),i=t.price;return await(0,w.s)(this.contractWrapper,i,e.currencyAddress,a),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:a,parse:n})}{const t=await this.mapPayloadToContractStruct(e),i=t.pricePerToken.mul(t.quantity);return await(0,w.s)(this.contractWrapper,i,e.currencyAddress,a),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:a,parse:n})}}));mintBatch=(0,u.c)((async t=>{const e=await this.isLegacyNFTContract(),r=(await Promise.all(t.map((t=>e?this.mapLegacyPayloadToContractStruct(t.payload):this.mapPayloadToContractStruct(t.payload))))).map(((e,r)=>{const a=t[r],i=a.signature,s=a.payload.price;if(n.O$.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:i}})),a=new f.C(this.contractWrapper),i=r.map((t=>a.encode("mintWithSignature",[t.message,t.signature])));if((0,h.h)("multicall",this.contractWrapper))return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return e.map((e=>({id:e.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not available on this contract!")}));async verify(t){const e=await this.isLegacyNFTContract(),r=t.payload,a=t.signature;let n,i;return e?(n=await this.mapLegacyPayloadToContractStruct(r),i=await this.contractWrapper.read("verify",[n,a])):(n=await this.mapPayloadToContractStruct(r),i=await this.contractWrapper.read("verify",[n,a])),i[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const e=await this.isLegacyNFTContract(),r=await Promise.all(t.map((t=>v.q.parseAsync(t)))),a=r.map((t=>t.metadata)),n=await(0,p.u)(a,this.storage),i=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,W.Z)(s,"No signer available"),await Promise.all(r.map((async(t,r)=>{const a=n[r],o=await v.r.parseAsync({...t,uri:a});let c;return c=e?await this.contractWrapper.signTypedData(s,{name:"TokenERC721",version:"1",chainId:i,verifyingContract:this.contractWrapper.address},{MintRequest:v.s},await this.mapLegacyPayloadToContractStruct(o)):await this.contractWrapper.signTypedData(s,{name:"SignatureMintERC721",version:"1",chainId:i,verifyingContract:await this.contractWrapper.address},{MintRequest:v.u},await this.mapPayloadToContractStruct(o)),{payload:o,signature:c.toString()}})))}async mapPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:e,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return(0,h.d)(this.contractWrapper,"ERC721SignatureMintV1")}}class q{featureName=l.d0.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,r]=await Promise.all([this.ownerOf(t).catch((()=>i.d)),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...p.F})))]);return{owner:e,metadata:r,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await(0,l.aP)(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,e){const[r,a]=await Promise.all([(0,l.aP)(t),(0,l.aP)(e)]);return await this.contractWrapper.read("isApprovedForAll",[r,a])}transfer=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,l.aP)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[r,a,e]})}));transferFrom=(0,u.c)((async(t,e,r)=>{const[a,n]=await Promise.all([(0,l.aP)(t),(0,l.aP)(e)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[a,n,r]})}));setApprovalForAll=(0,u.c)((async(t,e)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await(0,l.aP)(t),e]})));setApprovalForToken=(0,u.c)((async(t,e)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await(0,l.aP)(t),e]})));async getAll(t){return(0,d.a)(this.query,l.cU).all(t)}async getAllOwners(){return(0,d.a)(this.query,l.cU).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return(0,d.a)(this.query,l.cU).totalCirculatingSupply()}async getOwned(t,e){if(t&&(t=await(0,l.aP)(t)),this.query?.owned)return this.query.owned.all(t,e);{const[r,a]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);let n=(a||[]).filter((t=>r?.toLowerCase()===t.owner?.toLowerCase()));if(e){const t=e?.start||0,r=e?.count||p.D;n=n.slice(t,t+r)}return await Promise.all(n.map((async t=>this.get(t.tokenId))))}}async getOwnedTokenIds(t){if(t&&(t=await(0,l.aP)(t)),this.query?.owned)return this.query.owned.tokenIds(t);{const[e,r]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(r||[]).filter((t=>e?.toLowerCase()===t.owner?.toLowerCase())).map((t=>n.O$.from(t.tokenId)))}}mint=(0,u.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,u.c)((async(t,e)=>(0,d.a)(this.mintable,l.cR).to.prepare(t,e)));async getMintTransaction(t,e){return this.mintTo.prepare(t,e)}mintBatch=(0,u.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=(0,u.c)((async(t,e)=>(0,d.a)(this.mintable?.batch,l.cM).to.prepare(t,e)));burn=(0,u.c)((async t=>(0,d.a)(this.burnable,l.cW).token.prepare(t)));cancel=(0,u.c)((async t=>(0,d.a)(this.loyaltyCard,l.cY).cancel.prepare(t)));revoke=(0,u.c)((async t=>(0,d.a)(this.loyaltyCard,l.cY).revoke.prepare(t)));lazyMint=(0,u.c)((async(t,e)=>(0,d.a)(this.lazyMintable,l.cP).lazyMint.prepare(t,e)));update=(0,u.c)((async(t,e)=>(0,d.a)(this.updatableMetadata,l.cZ).update.prepare(t,e)));claim=(0,u.c)((async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));claimTo=(0,u.c)((async(t,e,r)=>{const a=this.claimWithConditions,n=this.claimCustom,i=this.claimZora;if(a)return a.to.prepare(t,e,r);if(n)return n.to.prepare(t,e,r);if(i)return i.to.prepare(t,e,r);throw new l.x(l.cO)}));async getClaimTransaction(t,e,r){const a=this.claimWithConditions,n=this.claimCustom;if(a)return a.conditions.getClaimTransaction(t,e,r);if(n)return n.getClaimTransaction(t,e,r);throw new l.x(l.cO)}async totalClaimedSupply(){const t=this.contractWrapper;if((0,h.h)("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if((0,h.h)("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,e]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(e)}get claimConditions(){return(0,d.a)(this.claimWithConditions,l.cN).conditions}get tieredDrop(){return(0,d.a)(this.tieredDropable,l.cV)}get signature(){return(0,d.a)(this.signatureMintable,l.c$)}get revealer(){return(0,d.a)(this.lazyMintable?.revealer,l.cQ)}get sharedMetadata(){return(0,d.a)(this.erc721SharedMetadata,l.c_)}async getTokenMetadata(t){const e=await this.contractWrapper.read("tokenURI",[t]);if(!e)throw new l.n;return(0,p.f)(t,e,this.storage)}async nextTokenIdToMint(){if((0,h.h)("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return(0,h.h)("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}if((0,h.h)("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if((0,h.d)(this.contractWrapper,"ERC721Supply")||(0,h.h)("nextTokenIdToMint",this.contractWrapper))return new x(this,this.contractWrapper)}detectErc721Mintable(){if((0,h.d)(this.contractWrapper,"ERC721Mintable"))return new k(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if((0,h.d)(this.contractWrapper,"ERC721Burnable"))return new O(this.contractWrapper)}detectErc721LazyMintable(){if((0,h.d)(this.contractWrapper,"ERC721LazyMintable"))return new S(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if((0,h.d)(this.contractWrapper,"ERC721TieredDrop"))return new L(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if((0,h.d)(this.contractWrapper,"ERC721SignatureMintV1")||(0,h.d)(this.contractWrapper,"ERC721SignatureMintV2"))return new $(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if((0,h.d)(this.contractWrapper,"ERC721ClaimConditionsV1")||(0,h.d)(this.contractWrapper,"ERC721ClaimConditionsV2")||(0,h.d)(this.contractWrapper,"ERC721ClaimPhasesV1")||(0,h.d)(this.contractWrapper,"ERC721ClaimPhasesV2"))return new T(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if((0,h.d)(this.contractWrapper,"ERC721ClaimCustom"))return new A(this,this.contractWrapper)}detectErc721ClaimableZora(){if((0,h.d)(this.contractWrapper,"ERC721ClaimZora"))return new R(this,this.contractWrapper)}detectErc721SharedMetadata(){if((0,h.d)(this.contractWrapper,"ERC721SharedMetadata"))return new F(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if((0,h.d)(this.contractWrapper,"ERC721LoyaltyCard"))return new B(this.contractWrapper)}detectErc721UpdatableMetadata(){if((0,h.d)(this.contractWrapper,"ERC721UpdatableMetadata"))return new D(this.contractWrapper,this.storage)}}},48109:(t,e,r)=>{"use strict";r.d(e,{a:()=>u,g:()=>m,h:()=>l,i:()=>p,m:()=>h,v:()=>d});var a=r(64146),n=r(2593),i=r(38776),s=r(89050),o=r(7860),c=r(68828);async function p(t,e,n,i,o){try{const c=(await r.e(5025).then(r.t.bind(r,25025,19))).default,p=new a.CH(n,c,t),[l,d]=await Promise.all([p.supportsInterface(s.I),p.supportsInterface(s.a)]);if(l){const s=(await Promise.resolve().then(r.t.bind(r,70332,19))).default,c=new a.CH(n,s,t);if(await c.isApprovedForAll(o,e))return!0;let p;try{p=await c.getApproved(i)}catch(t){}return p?.toLowerCase()===e.toLowerCase()}if(d){const i=(await Promise.resolve().then(r.t.bind(r,8455,19))).default,s=new a.CH(n,i,t);return await s.isApprovedForAll(o,e)}return console.error("Contract does not implement ERC 1155 or ERC 721."),!1}catch(t){return console.error("Failed to check if token is approved",t),!1}}async function l(t,e,a,n,i){const c=(await r.e(5025).then(r.t.bind(r,25025,19))).default,p=new o.cu(t.getSignerOrProvider(),a,c,t.options,t.storage),[l,d]=await Promise.all([p.read("supportsInterface",[s.I]),p.read("supportsInterface",[s.a])]);if(l){const s=(await Promise.resolve().then(r.t.bind(r,70332,19))).default,c=new o.cu(t.getSignerOrProvider(),a,s,t.options,t.storage);if(!await c.read("isApprovedForAll",[i,e])){(await c.read("getApproved",[n])).toLowerCase()===e.toLowerCase()||await c.sendTransaction("setApprovalForAll",[e,!0])}}else{if(!d)throw Error("Contract must implement ERC 1155 or ERC 721.");{const n=(await Promise.resolve().then(r.t.bind(r,8455,19))).default,s=new o.cu(t.getSignerOrProvider(),a,n,t.options,t.storage);await s.read("isApprovedForAll",[i,e])||await s.sendTransaction("setApprovalForAll",[e,!0])}}}function d(t){if((0,i.Z)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,i.Z)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,i.Z)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,i.Z)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,i.Z)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,i.Z)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type)(0,i.Z)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function h(t,e,r){return{quantity:r.quantityDesired,pricePerToken:r.pricePerToken,currencyContractAddress:r.currency,buyerAddress:r.offeror,quantityDesired:r.quantityWanted,currencyValue:await(0,c.a)(t,r.currency,r.quantityWanted.mul(r.pricePerToken)),listingId:e}}function u(t,e,r){if(r=n.O$.from(r),t=n.O$.from(t),e=n.O$.from(e),t.eq(n.O$.from(0)))return!1;return e.sub(t).mul(o.dy).div(t).gte(r)}async function m(t,e,r){const a=[];for(;e-t>s.D;)a.push(r(t,t+s.D-1)),t+=s.D;return a.push(r(t,e-1)),await Promise.all(a)}},70735:(t,e,r)=>{"use strict";r.d(e,{M:()=>v,a:()=>T,b:()=>S});var a=r(2593),n=r(64146),i=r(9279),s=r(61744),o=r(38776),c=r(15070),p=r(68828),l=r(19824),d=r(41518),h=r(7860),u=r(48109),m=r(89050),g=r(19578),f=r(89208),y=r(1604),w=r(89536),W=r(52153);const C=(()=>y.z.object({assetContractAddress:h.bd,tokenId:h.ba,quantity:h.ba.default(1),currencyContractAddress:h.bd.default(h.aZ),pricePerToken:h.cz,startTimestamp:f.R.default(new Date),endTimestamp:f.E,isReservedListing:y.z.boolean().default(!1)}))();let b=function(t){return t[t.UNSET=0]="UNSET",t[t.Created=1]="Created",t[t.Completed=2]="Completed",t[t.Cancelled=3]="Cancelled",t[t.Active=4]="Active",t[t.Expired=5]="Expired",t}({});class v{featureName=h.dk.name;constructor(t,e){this.contractWrapper=t,this.storage=e,this.events=new w.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new w.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No listings exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllListings",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapListing(t))))}async getAllValid(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No listings exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllValidListings",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapListing(t))))}async getListing(t){const e=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(e)}async isBuyerApprovedForListing(t,e){if(!(await this.validateListing(a.O$.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await(0,h.aP)(e)])}async isCurrencyApprovedForListing(t,e){return await this.validateListing(a.O$.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await(0,h.aP)(e)])}async currencyPriceForListing(t,e){const r=await this.validateListing(a.O$.from(t)),n=await(0,h.aP)(e);if(n===r.currencyContractAddress)return r.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,n))throw new Error(`Currency ${n} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,n])}createListing=(0,g.c)((async t=>{const e=await C.parseAsync(t);await(0,u.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const r=await(0,l.n)(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress),n=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return e.startTimestamp.lt(n)&&(e.startTimestamp=a.O$.from(n)),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:(0,c.c)(e.currencyContractAddress),pricePerToken:r,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("NewListing",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,g.c)((async t=>{const e=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode()));return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>this.contractWrapper.parseLogs("NewListing",t?.logs).map((e=>({id:e.args.listingId,receipt:t})))})}));updateListing=(0,g.c)((async(t,e)=>{const r=await C.parseAsync(e);await(0,u.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const a=await(0,l.n)(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress);return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,c.c)(r.currencyContractAddress),pricePerToken:a,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("UpdatedListing",t?.logs)[0].args.listingId,receipt:t})})}));cancelListing=(0,g.c)((async t=>g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]})));buyFromListing=(0,g.c)((async(t,e,r)=>{r&&(r=await(0,h.aP)(r));const n=await this.validateListing(a.O$.from(t)),{valid:i,error:s}=await this.isStillValidListing(n,e);if(!i)throw new Error(`Listing ${t} is no longer valid. ${s}`);const o=r||await this.contractWrapper.getSignerAddress(),c=a.O$.from(e),p=a.O$.from(n.pricePerToken).mul(c),l=await this.contractWrapper.getCallOverrides()||{};return await(0,d.s)(this.contractWrapper,p,n.currencyContractAddress,l),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,o,c,n.currencyContractAddress,p],overrides:l})}));approveBuyerForReservedListing=(0,g.c)((async(t,e)=>{if(await this.isBuyerApprovedForListing(t,e))throw new Error(`Buyer ${e} already approved for listing ${t}.`);return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,e,!0]})}));revokeBuyerApprovalForReservedListing=(0,g.c)((async(t,e)=>{if(await this.isBuyerApprovedForListing(t,e))return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,e,!1]});throw new Error(`Buyer ${e} not approved for listing ${t}.`)}));approveCurrencyForListing=(0,g.c)((async(t,e,r)=>{const n=await this.validateListing(a.O$.from(t)),i=await(0,h.aP)(e);i===n.currencyContractAddress&&(0,o.Z)(r===n.pricePerToken,"Approving listing currency with a different price.");const s=await this.contractWrapper.read("currencyPriceForListing",[t,i]);return(0,o.Z)(r===s,"Currency already approved with this price."),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,i,r]})}));revokeCurrencyApprovalForListing=(0,g.c)((async(t,e)=>{const r=await this.validateListing(a.O$.from(t)),n=await(0,h.aP)(e);if(n===r.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const i=await this.contractWrapper.read("currencyPriceForListing",[t,n]);return(0,o.Z)(!i.isZero(),"Currency not approved."),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,a.O$.from(0)]})}));async validateListing(t){try{return await this.getListing(t)}catch(e){throw console.error(`Error getting the listing with id ${t}`),e}}async mapListing(t){let e=b.UNSET;const r=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:e=a.O$.from(t.startTimestamp).gt(r)?b.Created:a.O$.from(t.endTimestamp).lt(r)?b.Expired:b.Active;break;case 2:e=b.Completed;break;case 3:e=b.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:a.O$.from(t.startTimestamp).toNumber(),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.O$.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:e}}async isStillValidListing(t,e){if(!await(0,u.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),i=(await r.e(5025).then(r.t.bind(r,25025,19))).default,s=new n.CH(t.assetContractAddress,i,a),o=await s.supportsInterface(m.I),c=await s.supportsInterface(m.a);if(o){const e=(await Promise.resolve().then(r.t.bind(r,70332,19))).default,i=new n.CH(t.assetContractAddress,e,a);let s;try{s=await i.ownerOf(t.tokenId)}catch(t){}const o=s?.toLowerCase()===t.creatorAddress.toLowerCase();return{valid:o,error:o?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(c){const i=(await Promise.resolve().then(r.t.bind(r,8455,19))).default,s=new n.CH(t.assetContractAddress,i,a),o=(await s.balanceOf(t.creatorAddress,t.tokenId)).gte(e||t.quantity);return{valid:o,error:o?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,e){let r=[...t];if(e){if(e.seller){const t=await(0,h.aP)(e.seller);r=r.filter((e=>e.listingCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(e.tokenContract){const t=await(0,h.aP)(e.tokenContract);r=r.filter((e=>e.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==e.tokenId&&(r=r.filter((t=>t.tokenId.toString()===e?.tokenId?.toString())))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}const P=(()=>y.z.object({assetContractAddress:h.bd,tokenId:h.ba,quantity:h.ba.default(1),currencyContractAddress:h.bd.default(h.aZ),minimumBidAmount:h.cz,buyoutBidAmount:h.cz,timeBufferInSeconds:h.ba.default(900),bidBufferBps:h.ba.default(500),startTimestamp:f.R.default(new Date),endTimestamp:f.E}))();class T{featureName=h.dl.name;constructor(t,e){this.contractWrapper=t,this.storage=e,this.events=new w.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new w.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No auctions exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllAuctions",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapAuction(t))))}async getAllValid(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No auctions exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllValidAuctions",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapAuction(t))))}async getAuction(t){const e=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(e)}async getWinningBid(t){await this.validateAuction(a.O$.from(t));const e=await this.contractWrapper.read("getWinningBid",[t]);if(e._bidder!==i.d)return await this.mapBid(t.toString(),e._bidder,e._currency,e._bidAmount.toString())}async isWinningBid(t,e){return await this.contractWrapper.read("isNewWinningBid",[t,e])}async getWinner(t){const e=await this.validateAuction(a.O$.from(t)),r=await this.contractWrapper.read("getWinningBid",[t]),n=a.O$.from(Math.floor(Date.now()/1e3)),s=a.O$.from(e.endTimeInSeconds);if(n.gt(s)&&r._bidder!==i.d)return r._bidder;const o=new w.a(this.contractWrapper),c=(await o.getEvents("AuctionClosed")).find((e=>e.data.auctionId.eq(a.O$.from(t))));if(!c)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return c.data.winningBidder}createAuction=(0,g.c)((async t=>{const e=P.parse(t);await(0,u.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const r=await(0,l.n)(this.contractWrapper.getProvider(),e.buyoutBidAmount,e.currencyContractAddress),n=await(0,l.n)(this.contractWrapper.getProvider(),e.minimumBidAmount,e.currencyContractAddress),i=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return e.startTimestamp.lt(i)&&(e.startTimestamp=a.O$.from(i)),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:(0,c.c)(e.currencyContractAddress),minimumBidAmount:n,buyoutBidAmount:r,timeBufferInSeconds:e.timeBufferInSeconds,bidBufferBps:e.bidBufferBps,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewAuction",t.logs)[0].args.auctionId,receipt:t})})}));createAuctionsBatch=(0,g.c)((async t=>{const e=(await Promise.all(t.map((t=>this.createAuction.prepare(t))))).map((t=>t.encode()));return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>this.contractWrapper.parseLogs("NewAuction",t?.logs).map((e=>({id:e.args.auctionId,receipt:t})))})}));buyoutAuction=(0,g.c)((async t=>{const e=await this.validateAuction(a.O$.from(t)),r=await(0,p.f)(this.contractWrapper.getProvider(),e.currencyContractAddress);return this.makeBid.prepare(t,s.formatUnits(e.buyoutBidAmount,r.decimals))}));makeBid=(0,g.c)((async(t,e)=>{const r=await this.validateAuction(a.O$.from(t)),n=await(0,l.n)(this.contractWrapper.getProvider(),e,r.currencyContractAddress);if(n.eq(a.O$.from(0)))throw new Error("Cannot make a bid with 0 value");if(a.O$.from(r.buyoutBidAmount).gt(0)&&n.gt(r.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const e=await this.isWinningBid(t,n);(0,o.Z)(e,"Bid price is too low based on the current winning bid and the bid buffer")}else{const t=n,e=a.O$.from(r.minimumBidAmount);(0,o.Z)(t.gte(e),"Bid price is too low based on minimum bid amount")}const i=await this.contractWrapper.getCallOverrides()||{};return await(0,d.s)(this.contractWrapper,n,r.currencyContractAddress,i),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",args:[t,n],overrides:i})}));cancelAuction=(0,g.c)((async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]})}));closeAuctionForBidder=(0,g.c)((async(t,e)=>{e||(e=await this.contractWrapper.getSignerAddress());const r=await this.validateAuction(a.O$.from(t));try{return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[a.O$.from(t)]})}catch(e){throw e.message.includes("Marketplace: auction still active.")?new h.w(t.toString(),r.endTimeInSeconds.toString()):e}}));closeAuctionForSeller=(0,g.c)((async t=>{const e=await this.validateAuction(a.O$.from(t));try{return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[a.O$.from(t)]})}catch(r){throw r.message.includes("Marketplace: auction still active.")?new h.w(t.toString(),e.endTimeInSeconds.toString()):r}}));executeSale=(0,g.c)((async t=>{const e=await this.validateAuction(a.O$.from(t));try{const e=await this.getWinningBid(t);(0,o.Z)(e,"No winning bid found");const r=this.encoder.encode("collectAuctionPayout",[t]),a=this.encoder.encode("collectAuctionTokens",[t]);return g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[r,a]]})}catch(r){throw r.message.includes("Marketplace: auction still active.")?new h.w(t.toString(),e.endTimeInSeconds.toString()):r}}));async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[e,r,n]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(a.O$.from(t))]),i=r?a.O$.from(r.bidAmount):a.O$.from(n.minimumBidAmount),s=i.add(i.mul(e).div(1e4));return(0,p.a)(this.contractWrapper.getProvider(),n.currencyContractAddress,s)}async validateAuction(t){try{return await this.getAuction(t)}catch(e){throw console.error(`Error getting the auction with id ${t}`),e}}async mapAuction(t){let e=b.UNSET;const r=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:e=a.O$.from(t.startTimestamp).gt(r)?b.Created:a.O$.from(t.endTimestamp).lt(r)?b.Expired:b.Active;break;case 2:e=b.Completed;break;case 3:e=b.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:a.O$.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:a.O$.from(t.bidBufferBps).toNumber(),startTimeInSeconds:a.O$.from(t.startTimestamp).toNumber(),endTimeInSeconds:a.O$.from(t.endTimestamp).toNumber(),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:e}}async mapBid(t,e,r,a){const n=await(0,h.aP)(e),i=await(0,h.aP)(r);return{auctionId:t,bidderAddress:n,currencyContractAddress:i,bidAmount:a,bidAmountCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),i,a)}}async applyFilter(t,e){let r=[...t];if(e){if(e.seller){const t=await(0,h.aP)(e.seller);r=r.filter((e=>e.auctionCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(e.tokenContract){const t=await(0,h.aP)(e.tokenContract);r=r.filter((e=>e.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==e.tokenId&&(r=r.filter((t=>t.tokenId.toString()===e?.tokenId?.toString())))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}const A=(()=>y.z.object({assetContractAddress:h.bd,tokenId:h.ba,quantity:h.ba.default(1),currencyContractAddress:h.bd.default(h.aZ),totalPrice:h.cz,endTimestamp:f.E}))();class S{featureName=h.dm.name;constructor(t,e){this.contractWrapper=t,this.storage=e,this.events=new w.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new W.C(this.contractWrapper),this.estimator=new w.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No offers exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllOffers",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapOffer(t))))}async getAllValid(t){const e=await this.getTotalCount(),r=a.O$.from(t?.start||0).toNumber(),n=e.toNumber();if(0===n)throw new Error("No offers exist on the contract.");let i=[];i=(await(0,u.g)(r,n,((t,e)=>this.contractWrapper.read("getAllValidOffers",[t,e])))).flat();const s=await this.applyFilter(i,t);return await Promise.all(s.map((t=>this.mapOffer(t))))}async getOffer(t){const e=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(e)}makeOffer=(0,g.c)((async t=>{const e=await A.parseAsync(t),r=await this.contractWrapper.getChainID(),a=(0,p.i)(e.currencyContractAddress)?h.a_[r].wrapped.address:e.currencyContractAddress,n=await(0,l.n)(this.contractWrapper.getProvider(),e.totalPrice,a),i=await this.contractWrapper.getCallOverrides();return await(0,d.s)(this.contractWrapper,n,a,i),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:a,totalPrice:n,expirationTimestamp:e.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewOffer",t?.logs)[0].args.offerId,receipt:t})})}));cancelOffer=(0,g.c)((async t=>g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})));acceptOffer=(0,g.c)((async t=>{const e=await this.validateOffer(a.O$.from(t)),{valid:r,error:n}=await this.isStillValidOffer(e);if(!r)throw new Error(`Offer ${t} is no longer valid. ${n}`);const i=await this.contractWrapper.getCallOverrides()||{};return await(0,u.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress()),g.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:i})}));async validateOffer(t){try{return await this.getOffer(t)}catch(e){throw console.error(`Error getting the offer with id ${t}`),e}}async mapOffer(t){let e=b.UNSET;const r=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:e=a.O$.from(t.expirationTimestamp).lt(r)?b.Expired:b.Active;break;case 2:e=b.Completed;break;case 3:e=b.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await(0,m.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.O$.from(t.expirationTimestamp).toNumber(),status:e}}async isStillValidOffer(t){if(a.O$.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};const e=await this.contractWrapper.getChainID(),n=(0,p.i)(t.currencyContractAddress)?h.a_[e].wrapped.address:t.currencyContractAddress,i=this.contractWrapper.getProvider(),s=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=new h.cu(i,n,s,{},this.storage);if((await o.read("balanceOf",[t.offerorAddress])).lt(t.totalPrice))return{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${n}`};return(await o.read("allowance",[t.offerorAddress,this.getAddress()])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${n}`}:{valid:!0,error:""}}async applyFilter(t,e){let r=[...t];if(e){if(e.offeror){const t=await(0,h.aP)(e.offeror);r=r.filter((e=>e.offeror.toString().toLowerCase()===t?.toString().toLowerCase()))}if(e.tokenContract){const t=await(0,h.aP)(e.tokenContract);r=r.filter((e=>e.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==e.tokenId&&(r=r.filter((t=>t.tokenId.toString()===e?.tokenId?.toString())))}return e?.count&&e.count<r.length?r.slice(0,e.count):r}}},41518:(t,e,r)=>{"use strict";r.d(e,{B:()=>c,C:()=>d,N:()=>l,a:()=>p,s:()=>h});var a=r(7860),n=r(1604),i=r(68828);const s=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(s),s]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),p=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cA,n.z.unknown()])))(),l=(()=>n.z.union([p,n.z.string()]))(),d=(()=>p.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function h(t,e,n,s){if(!(0,i.i)(n)){const i=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=t.getSigner(),c=t.getProvider(),p=new a.cu(o||c,n,i,t.options,t.storage),l=await t.getSignerAddress(),d=t.address;return(await p.read("allowance",[l,d])).lt(e)&&await p.sendTransaction("approve",[d,e]),s}s.value=e}},58179:(t,e,r)=>{"use strict";r.d(e,{A:()=>N,B:()=>Q,C:()=>G,D:()=>_,E:()=>k,F:()=>E,H:()=>Y,I:()=>K,M:()=>ct,S:()=>X,a:()=>B,f:()=>L,k:()=>tt,o:()=>nt,p:()=>it,q:()=>st,r:()=>ot,s:()=>pt,t:()=>lt,u:()=>dt,v:()=>J,w:()=>O,x:()=>R,y:()=>I,z:()=>D});var a=r(21046),n=r(61744),i=r(31886),s=r(9279),o=r(38197),c=r(2593),p=r(16441),l=r(29251),d=r(7860),h=r(68828),u=r(19824),m=r(48764),g=r(56351),f=r.n(g),y=r(99269);class w{print(){w.print(this)}bufferIndexOf(t,e){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(t,e,m.Buffer.compare);return this.linearSearch(t,e,((t,e)=>t.equals(e)))}static binarySearch(t,e,r){let a=0,n=t.length-1;for(;a<=n;){const i=Math.floor((a+n)/2),s=r(t[i],e);if(0===s){for(let a=i-1;a>=0;a--)if(0!==r(t[a],e))return a+1;return 0}s<0?a=i+1:n=i-1}return-1}binarySearch(t,e,r){return w.binarySearch(t,e,r)}static linearSearch(t,e,r){for(let a=0;a<t.length;a++)if(r(t[a],e))return a;return-1}linearSearch(t,e,r){return w.linearSearch(t,e,r)}static bufferify(t){if(!m.Buffer.isBuffer(t)){if("object"==typeof t&&t.words)return m.Buffer.from(t.toString(C),"hex");if(w.isHexString(t))return m.Buffer.from(t.replace(/^0x/,""),"hex");if("string"==typeof t)return m.Buffer.from(t);if("bigint"==typeof t)return m.Buffer.from(t.toString(16),"hex");if(t instanceof Uint8Array)return m.Buffer.from(t.buffer);if("number"==typeof t){let e=t.toString();return e.length%2&&(e=`0${e}`),m.Buffer.from(e,"hex")}if(ArrayBuffer.isView(t))return m.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}return t}bigNumberify(t){return w.bigNumberify(t)}static bigNumberify(t){if("bigint"==typeof t)return t;if("string"==typeof t)return t.startsWith("0x")&&w.isHexString(t)?BigInt("0x"+t.replace("0x","").toString()):BigInt(t);if(m.Buffer.isBuffer(t))return BigInt("0x"+t.toString("hex"));if(t instanceof Uint8Array)return function(t){const e=Array.from(t).map((t=>t.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${e}`)}(t);if("number"==typeof t)return BigInt(t);throw new Error("cannot bigNumberify")}static isHexString(t){return"string"==typeof t&&/^(0x)?[0-9A-Fa-f]*$/.test(t)}static print(t){console.log(t.toString())}bufferToHex(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(t,e)}static bufferToHex(t){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(t||m.Buffer.alloc(0)).toString("hex")}`}bufferify(t){return w.bufferify(t)}bufferifyFn(t){return e=>{const r=t(e);if(m.Buffer.isBuffer(r))return r;if(this.isHexString(r))return m.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return m.Buffer.from(r);if("bigint"==typeof r)return m.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(r))return m.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e.buffer}(e.toString("hex")),n=function(t){const e=new Uint8Array(t);return Array.from(e).map((t=>t.toString(16).padStart(2,"0"))).join("")}(t(a));return m.Buffer.from(n,"hex")}}isHexString(t){return w.isHexString(t)}log2(t){return 1===t?0:1+this.log2(t/2|0)}zip(t,e){return t.map(((t,r)=>[t,e[r]]))}static hexZeroPad(t,e){return"0x"+t.replace("0x","").padStart(e,"0")}}var W=w;function C(t){const e=t.words,r=new ArrayBuffer(4*e.length),a=new Uint8Array(r);for(let t=0;t<e.length;t++)a[4*t]=e[t]>>24&255,a[4*t+1]=e[t]>>16&255,a[4*t+2]=e[t]>>8&255,a[4*t+3]=255&e[t];return r}class b extends W{duplicateOdd=!1;concatenator=m.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!m.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(t,e)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(e),this.processLeaves(t)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(t){if(this.hashLeaves&&(t=t.map(this.hashFn)),this.leaves=t.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(m.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(t){for(this.layers=[t];t.length>1;){const e=this.layers.length;this.layers.push([]);const r=this.complete&&1===e&&!Number.isInteger(Math.log2(t.length))?2*t.length-2**Math.ceil(Math.log2(t.length)):t.length;for(let a=0;a<t.length;a+=2){if(a>=r){this.layers[e].push(...t.slice(r));break}if(a+1===t.length&&t.length%2==1){const r=t[t.length-1];let n=r;if(this.isBitcoinTree){n=this.hashFn(this.concatenator([f()(r),f()(r)])),n=f()(this.hashFn(n)),this.layers[e].push(n);continue}if(!this.duplicateOdd){this.layers[e].push(t[a]);continue}}const n=t[a],i=a+1===t.length?n:t[a+1];let s=null;s=this.isBitcoinTree?[f()(n),f()(i)]:[n,i],this.sortPairs&&s.sort(m.Buffer.compare);let o=this.hashFn(this.concatenator(s));this.isBitcoinTree&&(o=f()(this.hashFn(o))),this.layers[e].push(o)}t=this.layers[e]}}addLeaf(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=this.hashFn(t)),this.processLeaves(this.leaves.concat(t))}addLeaves(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=t.map(this.hashFn)),this.processLeaves(this.leaves.concat(t))}getLeaves(t){return Array.isArray(t)?(this.hashLeaves&&(t=t.map(this.hashFn),this.sortLeaves&&(t=t.sort(m.Buffer.compare))),this.leaves.filter((e=>-1!==this.bufferIndexOf(t,e,this.sortLeaves)))):this.leaves}getLeaf(t){return t<0||t>this.leaves.length-1?m.Buffer.from([]):this.leaves[t]}getLeafIndex(t){t=this.bufferify(t);const e=this.getLeaves();for(let r=0;r<e.length;r++){if(e[r].equals(t))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((t=>this.bufferToHex(t)))}static marshalLeaves(t){return JSON.stringify(t.map((t=>b.bufferToHex(t))),null,2)}static unmarshalLeaves(t){let e=null;if("string"==typeof t)e=JSON.parse(t);else{if(!(t instanceof Object))throw new Error("Expected type of string or object");e=t}if(!e)return[];if(!Array.isArray(e))throw new Error("Expected JSON string to be array");return e.map(b.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((t,e)=>(Array.isArray(e)?t.push(e.map((t=>this.bufferToHex(t)))):t.push(e),t)),[])}getLayersFlat(){const t=this.layers.reduce(((t,e)=>(Array.isArray(e)?t.unshift(...e):t.unshift(e),t)),[]);return t.unshift(m.Buffer.from([0])),t}getHexLayersFlat(){return this.getLayersFlat().map((t=>this.bufferToHex(t)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?m.Buffer.from([]):this.layers[this.layers.length-1][0]||m.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(t,e){if(void 0===t)throw new Error("leaf is required");t=this.bufferify(t);const r=[];if(!Number.isInteger(e)){e=-1;for(let r=0;r<this.leaves.length;r++)0===m.Buffer.compare(t,this.leaves[r])&&(e=r)}if(e<=-1)return[];for(let t=0;t<this.layers.length;t++){const a=this.layers[t],n=e%2,i=n?e-1:this.isBitcoinTree&&e===a.length-1&&t<this.layers.length-1?e:e+1;i<a.length&&r.push({position:n?"left":"right",data:a[i]}),e=e/2|0}return r}getHexProof(t,e){return this.getProof(t,e).map((t=>this.bufferToHex(t.data)))}getProofs(){const t=[];return this.getProofsDFS(this.layers.length-1,0,[],t),t}getProofsDFS(t,e,r,a){const n=e%2;if(-1===t)return void(n||a.push([...r].reverse()));if(e>=this.layers[t].length)return;const i=this.layers[t],s=n?e-1:e+1;let o=!1;s<i.length&&(o=!0,r.push({position:n?"left":"right",data:i[s]}));const c=2*e,p=2*e+1;this.getProofsDFS(t-1,c,r,a),this.getProofsDFS(t-1,p,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((t=>this.bufferToHex(t.data)))}getPositionalHexProof(t,e){return this.getProof(t,e).map((t=>["left"===t.position?0:1,this.bufferToHex(t.data)]))}getProofIndices(t,e){const r=2**e;let a=new Set;for(const e of t){let t=r+e;for(;t>1;)a.add(1^t),t=t/2|0}const n=t.map((t=>r+t)),i=Array.from(a).sort(((t,e)=>t-e)).reverse();a=n.concat(i);const s=new Set,o=[];for(let t of a)if(!s.has(t))for(o.push(t);t>1&&(s.add(t),s.has(1^t));)t=t/2|0;return o.filter((e=>!t.includes(e-r)))}getProofIndicesForUnevenTree(t,e){const r=Math.ceil(Math.log2(e)),a=[];for(let t=0;t<r;t++){e%2!=0&&a.push({index:t,leavesCount:e}),e=Math.ceil(e/2)}const n=[];let i=t;for(let t=0;t<r;t++){let e=i.map((t=>t%2==0?t+1:t-1)).filter((t=>!i.includes(t)));const r=a.find((e=>{let{index:r}=e;return r===t}));r&&i.includes(r.leavesCount-1)&&(e=e.slice(0,-1)),n.push(e),i=[...new Set(i.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))]}return n}getMultiProof(t,e){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),e||(e=t,t=this.getLayersFlat());if(this.isUnevenTree()&&e.every(Number.isInteger))return this.getMultiProofForUnevenTree(e);if(!e.every(Number.isInteger)){let t=e;this.sortPairs&&(t=t.sort(m.Buffer.compare));let r=t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1));if(!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=[],n=[];let i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const s=r[t],o=this.getPairNode(e,s);a.push(e[s]),o&&n.push(o),i.push(s/2|0)}r=i.filter(((t,e,r)=>r.indexOf(t)===e)),i=[]}return n.filter((t=>!a.includes(t)))}return this.getProofIndices(e,Math.log2(t.length/2|0)).map((e=>t[e]))}getMultiProofForUnevenTree(t,e){e||(e=t,t=this.getLayers());let r=[],a=e;for(const e of t){const t=[];for(const r of a){if(r%2==0){const n=r+1;if(!a.includes(n)&&e[n]){t.push(e[n]);continue}}const n=r-1;a.includes(n)||!e[n]||t.push(e[n])}r=r.concat(t);const n=new Set;for(const t of a)t%2!=0?t%2!=0?n.add((t-1)/2):n.add((t+1)/2):n.add(t/2);a=Array.from(n)}return r}getHexMultiProof(t,e){return this.getMultiProof(t,e).map((t=>this.bufferToHex(t)))}getProofFlags(t,e){if(!Array.isArray(t)||t.length<=0)throw new Error("Invalid Inputs!");let r;if(r=t.every(Number.isInteger)?[...t].sort(((t,e)=>t===e?0:t>e?1:-1)):t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1)),!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=e.map((t=>this.bufferify(t))),n=[],i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];r=r.reduce(((t,r)=>{if(!n.includes(e[r])){const t=this.getPairNode(e,r),s=a.includes(e[r])||a.includes(t);t&&i.push(!s),n.push(e[r]),n.push(t)}return t.push(r/2|0),t}),[])}return i}verify(t,e,r){let a=this.bufferify(e);if(r=this.bufferify(r),!Array.isArray(t)||!e||!r)return!1;for(let e=0;e<t.length;e++){const r=t[e];let n=null,i=null;if("string"==typeof r)n=this.bufferify(r),i=!0;else if(Array.isArray(r))i=0===r[0],n=this.bufferify(r[1]);else if(m.Buffer.isBuffer(r))n=r,i=!0;else{if(!(r instanceof Object))throw new Error("Expected node to be of type string or object");n=this.bufferify(r.data),i="left"===r.position}const s=[];this.isBitcoinTree?(s.push(f()(a)),s[i?"unshift":"push"](f()(n)),a=this.hashFn(this.concatenator(s)),a=f()(this.hashFn(a))):this.sortPairs?-1===m.Buffer.compare(a,n)?(s.push(a,n),a=this.hashFn(this.concatenator(s))):(s.push(n,a),a=this.hashFn(this.concatenator(s))):(s.push(a),s[i?"unshift":"push"](n),a=this.hashFn(this.concatenator(s)))}return 0===m.Buffer.compare(a,r)}verifyMultiProof(t,e,r,a,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(t,e,r,a,n);const i=Math.ceil(Math.log2(a));t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const s={};for(const[t,a]of this.zip(e,r))s[2**i+t]=a;for(const[t,r]of this.zip(this.getProofIndices(e,i),n))s[t]=r;let o=Object.keys(s).map((t=>Number(t))).sort(((t,e)=>t-e));o=o.slice(0,o.length-1);let c=0;for(;c<o.length;){const t=o[c];if(t>=2&&{}.hasOwnProperty.call(s,1^t)){let e=[s[t-t%2],s[t-t%2+1]];this.sortPairs&&(e=e.sort(m.Buffer.compare));const r=e[1]?this.hashFn(this.concatenator(e)):e[0];s[t/2|0]=r,o.push(t/2|0)}c+=1}return!e.length||{}.hasOwnProperty.call(s,1)&&s[1].equals(t)}verifyMultiProofWithFlags(t,e,r,a){t=this.bufferify(t),e=e.map(this.bufferify),r=r.map(this.bufferify);const n=e.length,i=a.length,s=[];let o=0,c=0,p=0;for(let t=0;t<i;t++){const i=[a[t]?o<n?e[o++]:s[c++]:r[p++],o<n?e[o++]:s[c++]].sort(m.Buffer.compare);s[t]=this.hashFn(this.concatenator(i))}return 0===m.Buffer.compare(s[i-1],t)}verifyMultiProofForUnevenTree(t,e,r,a,n){t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const i=this.calculateRootForUnevenTree(e,r,a,n);return t.equals(i)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const t=this.getLayers().map((t=>t.map((t=>this.bufferToHex(t,!1))))),e=[];for(let r=0;r<t.length;r++){const a=[];for(let n=0;n<t[r].length;n++){const i={[t[r][n]]:null};if(e.length){i[t[r][n]]={};const a=e.shift(),s=Object.keys(a)[0];if(i[t[r][n]][s]=a[s],e.length){const a=e.shift(),s=Object.keys(a)[0];i[t[r][n]][s]=a[s]}}a.push(i)}e.push(...a)}return e[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(t,e){const r=e%2==0?e+1:e-1;return r<t.length?t[r]:null}toTreeString(){const t=this.getLayersAsObject();return(0,y.asTree)(t,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(t){const e=t?.length||this.getDepth();return!this.isPowOf2(e)}isPowOf2(t){return t&&!(t&t-1)}calculateRootForUnevenTree(t,e,r,a){const n=this.zip(t,e).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})),i=n.map((t=>{let[e]=t;return e})),s=this.getProofIndicesForUnevenTree(i,r);let o=0;const c=[];for(let t=0;t<s.length;t++){const e=s[t],r=o;o+=e.length,c[t]=this.zip(e,a.slice(r,o))}const p=[n];for(let t=0;t<c.length;t++){const e=c[t].concat(p[t]).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})).map((t=>{let[,e]=t;return e})),r=p[t].map((t=>{let[e]=t;return e})),a=[...new Set(r.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))],n=[];for(let t=0;t<a.length;t++){const r=a[t],i=e[2*t],s=e[2*t+1],o=s?this.hashFn(this.concatenator([i,s])):i;n.push([r,o])}p.push(n)}return p[p.length-1][0][1]}}var v=r(89208),P=r(1604),T=r(41518),A=r(57632),S=r(48764).Buffer;function k(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function E(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function I(t,e){return"unlimited"===t?a.Bz:n.parseUnits(t,e)}async function x(t){const e=25e3,r=Array.from({length:Math.ceil(t.length/e)},((r,a)=>t.slice(a*e,a*e+e))),a=[],n=await Promise.all(r.map((t=>d.bO.parseAsync(t))));for(const t of n)a.push(...t);return a}let N=function(t){return t[t.V1=1]="V1",t[t.V2=2]="V2",t}({});class M{constructor(t,e,r,a,n){this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(t,e){try{const r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return M.fromShardedMerkleTreeInfo(r,e)}catch(t){return}}static async fromShardedMerkleTreeInfo(t,e){return new M(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case N.V1:return i.keccak256(["address","uint256"],[t.address,I(t.maxClaimable,e)]);case N.V2:return i.keccak256(["address","uint256","uint256","address"],[t.address,I(t.maxClaimable,e),I(t.price||"unlimited",r),t.currencyAddress||s.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){a=(await(0,h.f)(e,r)).decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,n){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const s=await x(t),c={};for(const t of s){const e=t.address.slice(2,2+i).toLowerCase();void 0===c[e]&&(c[e]=[]),c[e].push(t)}const p={},l=await Promise.all(Object.entries(c).map((async t=>{let[a,i]=t;return[a,new b(await Promise.all(i.map((async t=>{const a=await M.fetchAndCacheDecimals(p,r,t.currencyAddress);return M.hashEntry(t,e,a,n)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),d=Object.fromEntries(l),h=new b(Object.values(d),o.keccak256,{sort:!0}),u=[];for(const[t,e]of Object.entries(c)){const r={proofs:h.getProof(d[t]).map((t=>"0x"+t.data.toString("hex"))),entries:e};u.push({data:JSON.stringify(r),name:`${t}.json`})}const m=await a.uploadBatch(u),g=m[0].slice(0,m[0].lastIndexOf("/")),f=await a.upload(s),y={merkleRoot:h.getHexRoot(),baseUri:g,originalEntriesUri:f,shardNybbles:i,tokenDecimals:e,isShardedMerkleTree:!0};return{shardedMerkleInfo:y,uri:await a.upload(y)}}async getProof(t,e,r){const a=t.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[a];const i={};if(void 0===n)try{const t=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;n=this.shards[a]=await this.storage.downloadJSON(`${t}${a}.json`);const s=await Promise.all(n.entries.map((async t=>{const a=await M.fetchAndCacheDecimals(i,e,t.currencyAddress);return M.hashEntry(t,this.tokenDecimals,a,r)})));this.trees[a]=new b(s,o.keccak256,{sort:!0})}catch(t){return null}const s=n.entries.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!s)return null;const c=await M.fetchAndCacheDecimals(i,e,s.currencyAddress),p=M.hashEntry(s,this.tokenDecimals,c,r),l=this.trees[a].getProof(p).map((t=>"0x"+t.data.toString("hex")));return d.bP.parseAsync({...s,proof:l.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function L(t,e,r,a,n,i){if(!r)return null;const s=r[e];if(s){const r=await n.downloadJSON(s);if(r.isShardedMerkleTree&&r.merkleRoot===e){const e=await M.fromShardedMerkleTreeInfo(r,n);return await e.getProof(t,a,i)}const o=await d.bQ.parseAsync(r);if(e===o.merkleRoot)return o.claims.find((e=>e.address.toLowerCase()===t.toLowerCase()))||null}return null}function O(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function R(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function B(t,e,a,i,s){const o=t.getSigner(),p=t.getProvider(),l=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,h=new d.cu(o||p,e,l,t.options,t.storage),u=await t.getSignerAddress(),m=t.address,g=await h.read("allowance",[u,m]),f=c.O$.from(a).mul(c.O$.from(i)).div(n.parseUnits("1",s));g.lt(f)&&await h.sendTransaction("approve",[m,g.add(f)])}async function D(t,e,r,i,o,l,d,m,g){let f=I(r.maxClaimablePerWallet,o),y=[p.hexZeroPad([0],32)],w=r.price,W=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(s.d)){const e=await L(t,r.merkleRootHash.toString(),await i(),l.getProvider(),d,g);if(e)y=e.proof,f="unlimited"===e.maxClaimable?a.Bz:n.parseUnits(e.maxClaimable,o),w=void 0===e.price||"unlimited"===e.price?a.Bz:await(0,u.n)(l.getProvider(),e.price,e.currencyAddress||s.d),W=e.currencyAddress||s.d;else if(g===N.V1)throw new Error("No claim found for this address")}}catch(t){if("No claim found for this address"===t?.message)throw t;console.warn("failed to check claim condition merkle root hash, continuing anyways",t)}const C=await l.getCallOverrides()||{},b=w.toString()!==a.Bz.toString()?w:r.price,v=W!==s.d?W:r.currencyAddress;return b.gt(0)&&((0,h.i)(v)?C.value=c.O$.from(b).mul(e).div(n.parseUnits("1",o)):m&&await B(l,v,b,e,o)),{overrides:C,proofs:y,maxClaimable:f,price:b,currencyAddress:v,priceInProof:w,currencyAddressInProof:W}}const F=(()=>P.z.object({name:P.z.string(),symbol:P.z.string(),decimals:P.z.number()}))(),$=(()=>F.extend({value:d.b9,displayValue:P.z.string()}))(),q=(()=>P.z.object({name:P.z.string().optional()}).catchall(P.z.unknown()))(),z=(()=>P.z.object({startTime:v.S,currencyAddress:P.z.string().default(d.aZ),price:d.cz.default(0),maxClaimableSupply:d.cD,maxClaimablePerWallet:d.cD,waitInSeconds:d.ba.default(0),merkleRootHash:d.cE.default(p.hexZeroPad([0],32)),snapshot:P.z.optional(d.bO).nullable(),metadata:q.optional()}))(),U=(()=>P.z.array(z))(),V=(()=>z.extend({availableSupply:d.cD,currentMintSupply:d.cD,currencyMetadata:$.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:d.b9,waitInSeconds:d.b9,startTime:d.b9.transform((t=>new Date(1e3*t.toNumber()))),snapshot:d.bO.optional().nullable()}))();async function H(t,e,r,a,n){const i=[],s=await Promise.all(t.map((async t=>{if(t.snapshot&&t.snapshot.length>0){const s=await async function(t,e,r,a,n){const i=await x(t),s=i.map((t=>t.address));if(new Set(s).size<s.length)throw new d.s;const o=await M.buildAndUpload(i,e,r,a,n);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(t.snapshot,e,r,a,n);i.push(s),t.merkleRootHash=s.merkleRoot}else t.merkleRootHash=p.hexZeroPad([0],32);return t})));return{inputsWithSnapshots:s,snapshotInfos:i}}async function _(t,e,r,a,n){const{inputsWithSnapshots:i,snapshotInfos:o}=await H(t,e,r,a,n),p=await U.parseAsync(i),l=(await Promise.all(p.map((t=>async function(t,e,r,a){const n=t.currencyAddress===s.d?d.aZ:t.currencyAddress,i=I(t.maxClaimableSupply,e),o=I(t.maxClaimablePerWallet,e);let c;return t.metadata&&(c="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:i,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,u.n)(r,t.price,n),currency:n,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:c}}(t,e,r,a))))).sort(((t,e)=>function(t,e){const r=c.O$.from(t),a=c.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1}(t.startTimestamp,e.startTimestamp)));return{snapshotInfos:o,sortedConditions:l}}async function Z(t,e,r){if(!e)return null;const a=e[t];if(a){const e=await r.downloadJSON(a);if(e.isShardedMerkleTree&&e.merkleRoot===t){const t=await M.fromUri(a,r);return t?.getAllEntries()||null}{const r=await d.bQ.parseAsync(e);if(t===r.merkleRoot)return r.claims.map((t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress})))}}return null}function j(t,e){return t.toString()===a.Bz.toString()?"unlimited":n.formatUnits(t,e)}async function J(t,e,r,a,n,i){const s=await(0,h.a)(r,t.currency,t.pricePerToken),o=j(t.maxClaimableSupply,e),p=j(t.maxClaimablePerWallet,e),l=j(c.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),d=j(t.supplyClaimed,e);let u;return t.metadata&&(u=await n.downloadJSON(t.metadata)),V.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:p,currentMintSupply:d,availableSupply:l,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:c.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:s,merkleRootHash:t.merkleRoot,snapshot:i?await Z(t.merkleRoot,a,n):void 0,metadata:u})}async function Y(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);const a=r[t].currencyMetadata.decimals,i=r[t].price,s=n.formatUnits(i,a),o=await z.parseAsync({...r[t],price:s,...e}),c=await V.parseAsync({...o,price:i});return r.map(((e,r)=>{let i;i=r===t?c:e;const s=n.formatUnits(i.price,a);return{...i,price:s}}))}let G=function(t){return t.NotEnoughSupply="There is not enough supply to claim.",t.AddressNotAllowed="This address is not on the allowlist.",t.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",t.ClaimPhaseNotStarted="Claim phase has not started yet.",t.AlreadyClaimed="You have already claimed the token.",t.WrongPriceOrCurrency="Incorrect price or currency.",t.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",t.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",t.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",t.NoClaimConditionSet="There is no claim condition set.",t.NoWallet="No wallet connected.",t.Unknown="No claim conditions found.",t}({});function K(t){if(void 0===t){const t=S.alloc(16);return(0,A.Z)({},t),p.hexlify(l.Y0(t.toString("hex")))}return p.hexlify(t)}const Q=(()=>P.z.object({to:d.bd.refine((t=>t.toLowerCase()!==s.d),{message:"Cannot create payload to mint to zero address"}),price:d.cz.default(0),currencyAddress:d.bc.default(d.aZ),mintStartTime:v.S,mintEndTime:v.E,uid:P.z.string().optional().transform((t=>K(t))),primarySaleRecipient:d.bd.default(s.d)}))(),X=(()=>Q.extend({quantity:d.cz}))(),tt=(()=>X.extend({mintStartTime:d.b9,mintEndTime:d.b9}))(),et=(()=>Q.extend({metadata:T.N,royaltyRecipient:P.z.string().default(s.d),royaltyBps:d.cF.default(0)}))(),rt=(()=>et.extend({metadata:T.N.default(""),uri:P.z.string(),royaltyBps:d.b9,mintStartTime:d.b9,mintEndTime:d.b9}))(),at=(()=>et.extend({metadata:T.N.default(""),quantity:d.ba}))(),nt=(()=>at.extend({tokenId:d.ba}))(),it=(()=>rt.extend({tokenId:d.b9,quantity:d.b9}))(),st=(()=>et.extend({metadata:T.N.default(""),quantity:d.b9.default(1)}))(),ot=(()=>rt.extend({quantity:d.b9.default(1)}))(),ct=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],dt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},99494:(t,e,r)=>{"use strict";r.r(e),r.d(e,{SmartContract:()=>z});var a=r(89208),n=r(89536),i=r(7860),s=r(19578),o=r(2593),c=r(61744),p=r(19485),l=r(29251),d=r(38776),h=r(58179),u=r(1604);class m{constructor(t,e){this.contractWrapper=t,this.storage=e}async get(){return this._cachedMetadata||(this._cachedMetadata=await(0,i.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)),this._cachedMetadata}async extractSources(){const t=await this.get();return(0,i.as)(t,this.storage)}async extractFunctions(){let t;try{t=await this.get()}catch(t){}return(0,i.a6)(i.bn.parse(this.contractWrapper.abi),t?.metadata)}async extractEvents(){let t;try{t=await this.get()}catch(t){}return function(t,e){const r=i.bn.parse(t||[]).filter((t=>"event"===t.type)),a=[];for(const t of r){const r=(0,i.a4)(t.name,e,"events");a.push({inputs:t.inputs||[],outputs:t.outputs||[],name:t.name||"unknown",comment:r})}return a}(i.bn.parse(this.contractWrapper.abi),t?.metadata)}}let g=function(t){return t[t.None=0]="None",t[t.AddAdmin=1]="AddAdmin",t[t.RemoveAdmin=2]="RemoveAdmin",t}({});const f={startDate:o.O$.from(0),expirationDate:o.O$.from(0),approvedCallTargets:[],nativeTokenLimitPerTransaction:"0"},y=(()=>u.z.object({startDate:a.S,expirationDate:a.E,nativeTokenLimitPerTransaction:i.cz.default(0),approvedCallTargets:u.z.union([u.z.array(i.bd),u.z.literal("*")])}))(),w=(()=>u.z.array(u.z.object({signer:i.bd,makeAdmin:u.z.boolean(),permissions:y})))(),W=[{name:"signer",type:"address"},{name:"approvedTargets",type:"address[]"},{name:"nativeTokenLimitPerTransaction",type:"uint256"},{name:"permissionStartTimestamp",type:"uint128"},{name:"permissionEndTimestamp",type:"uint128"},{name:"reqValidityStartTimestamp",type:"uint128"},{name:"reqValidityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],C=[{name:"signer",type:"address"},{name:"isAdmin",type:"uint8"},{name:"approvedTargets",type:"address[]"},{name:"nativeTokenLimitPerTransaction",type:"uint256"},{name:"permissionStartTimestamp",type:"uint128"},{name:"permissionEndTimestamp",type:"uint128"},{name:"reqValidityStartTimestamp",type:"uint128"},{name:"reqValidityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];class b{featureName=i.dp.name;constructor(t){this.contractWrapper=t}getAddress(){return this.contractWrapper.address}hasDuplicateSigners(t){const e={},r=t.map((t=>t.signer));for(const t of r){if(e[t])return!0;e[t]=!0}return!1}parseSignerPermissionsStruct(t){return{startDate:new Date(1e3*parseInt(t.startTimestamp.toString())),expirationDate:new Date(1e3*parseInt(t.endTimestamp.toString())),nativeTokenLimitPerTransaction:o.O$.from(t.nativeTokenLimitPerTransaction),approvedCallTargets:t.approvedTargets}}async sendSignerPermissionRequest(t,e,r){if((0,n.d)(this.contractWrapper,"AccountPermissionsV1")){if(r===g.AddAdmin||r===g.RemoveAdmin)return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAdmin",args:[t,r===g.AddAdmin]});{const{payload:r,signature:a}=await this.generateLegacyPayload(t,e);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPermissionsForSigner",args:[r,a]})}}const{payload:a,signature:i}=await this.generatePayload(t,e,r);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPermissionsForSigner",args:[a,i]})}async generatePayload(t,e,r){const a={signer:t,isAdmin:r.valueOf(),approvedTargets:"*"===e.approvedCallTargets?[i.cx]:e.approvedCallTargets,nativeTokenLimitPerTransaction:c.parseEther(e.nativeTokenLimitPerTransaction),permissionStartTimestamp:e.startDate,permissionEndTimestamp:e.expirationDate,reqValidityStartTimestamp:0,reqValidityEndTimestamp:o.O$.from(Math.floor(new Date(Date.now()+31536e7).getTime()/1e3)),uid:(0,h.I)(void 0)},n=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();(0,d.Z)(s,"No signer available");return{payload:a,signature:await this.contractWrapper.signTypedData(s,{name:"Account",version:"1",chainId:n,verifyingContract:this.getAddress()},{SignerPermissionRequest:C},a)}}async generateLegacyPayload(t,e){if("*"===e.approvedCallTargets)throw new Error("Wildcard call targets are not supported on legacy account permissions contract, please deploy an updated contract factory.");const r={signer:t,approvedTargets:e.approvedCallTargets,nativeTokenLimitPerTransaction:c.parseEther(e.nativeTokenLimitPerTransaction),permissionStartTimestamp:e.startDate,permissionEndTimestamp:e.expirationDate,reqValidityStartTimestamp:0,reqValidityEndTimestamp:o.O$.from(Math.floor(new Date(Date.now()+31536e7).getTime()/1e3)),uid:(0,h.I)(void 0)},a=await this.contractWrapper.getChainID(),n=this.contractWrapper.getSigner();(0,d.Z)(n,"No signer available");return{payload:r,signature:await this.contractWrapper.signTypedData(n,{name:"Account",version:"1",chainId:a,verifyingContract:this.getAddress()},{SignerPermissionRequest:W},r)}}async isAdmin(t){const e=await(0,i.aP)(t);return await this.contractWrapper.read("isAdmin",[e])}async isSigner(t){const e=await(0,i.aP)(t);return await this.contractWrapper.read("isActiveSigner",[e])}async getAllAdmins(){return await this.contractWrapper.read("getAllAdmins",[])}async getAllSigners(){const t=await this.contractWrapper.read("getAllActiveSigners",[]);return await Promise.all(t.map((async t=>({signer:t.signer,permissions:this.parseSignerPermissionsStruct(t)}))))}async getAllAdminsAndSigners(){return[...(await this.getAllAdmins()).map((t=>({isAdmin:!0,signer:t,permissions:{startDate:new Date(0),expirationDate:new Date(0),nativeTokenLimitPerTransaction:o.O$.from(0),approvedCallTargets:[]}}))),...await this.getAllSigners()]}grantAdminPermissions=(0,s.c)((async t=>{const e=await(0,i.aP)(t);return await this.sendSignerPermissionRequest(e,f,g.AddAdmin)}));revokeAdminPermissions=(0,s.c)((async t=>{const e=await(0,i.aP)(t);return await this.sendSignerPermissionRequest(e,f,g.RemoveAdmin)}));grantPermissions=(0,s.c)((async(t,e)=>{const r=await(0,i.aP)(t),a=await y.parseAsync(e);if(await this.isAdmin(r))throw new Error("Signer is already an admin. Cannot grant permissions to an existing admin.");if(await this.isSigner(r))throw new Error("Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.");return await this.sendSignerPermissionRequest(r,a,g.None)}));updatePermissions=(0,s.c)((async(t,e)=>{const r=await(0,i.aP)(t),a=await y.parseAsync(e);if(await this.isAdmin(r))throw new Error("Signer is already an admin. Cannot update permissions of an existing admin.");if(!await this.isSigner(r))throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");return await this.sendSignerPermissionRequest(r,a,g.None)}));revokeAccess=(0,s.c)((async t=>{const e=await(0,i.aP)(t);if(await this.isAdmin(e))throw new Error("Signer is already an admin. Cannot revoke permissions of an admin.");if(!await this.isSigner(e))throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");return await this.sendSignerPermissionRequest(e,{startDate:o.O$.from(0),expirationDate:o.O$.from(0),approvedCallTargets:[],nativeTokenLimitPerTransaction:"0"},g.None)}));approveTargetForSigner=(0,s.c)((async(t,e)=>{const r=await(0,i.aP)(t),a=await(0,i.aP)(e);if(await this.isAdmin(r))throw new Error("Signer is already an admin. Cannot approve targets for an admin.");if(!await this.isSigner(r))throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");const n=await this.contractWrapper.read("getPermissionsForSigner",[r]);if(n.approvedTargets.includes(e))throw new Error("Target is already approved");const s=[...n.approvedTargets,a];return await this.sendSignerPermissionRequest(r,{startDate:o.O$.from(n.startTimestamp),expirationDate:o.O$.from(n.endTimestamp),approvedCallTargets:s,nativeTokenLimitPerTransaction:n.nativeTokenLimitPerTransaction.toString()},g.None)}));disapproveTargetForSigner=(0,s.c)((async(t,e)=>{const r=await(0,i.aP)(t),a=await(0,i.aP)(e);if(await this.isAdmin(r))throw new Error("Signer is already an admin. Cannot approve targets for an admin.");if(!await this.isSigner(r))throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");const n=await this.contractWrapper.read("getPermissionsForSigner",[r]);if(!n.approvedTargets.includes(a))throw new Error("Target is currently not approved");const s=n.approvedTargets.filter((t=>p.getAddress(t)!==p.getAddress(a)));return await this.sendSignerPermissionRequest(r,{startDate:o.O$.from(n.startTimestamp),expirationDate:o.O$.from(n.endTimestamp),approvedCallTargets:s,nativeTokenLimitPerTransaction:n.nativeTokenLimitPerTransaction.toString()},g.None)}));resetAllPermissions=(0,s.c)((async t=>{const e=await w.parseAsync(t);if(this.hasDuplicateSigners(e))throw new Error("Duplicate signers found in input.");const r=[],a=[],n=[],i=await this.getAllAdmins(),o=e.filter((t=>t.makeAdmin)).map((t=>t.signer));i.forEach((async t=>{if(!o.includes(t)){const e=(await this.sendSignerPermissionRequest(t,f,g.RemoveAdmin)).encode();r.push(e)}}));const c=await this.getAllSigners(),p=e.filter((t=>!t.makeAdmin)).map((t=>t.signer));await Promise.all(c.map((async t=>{if(!p.includes(t.signer)){const e=(await this.sendSignerPermissionRequest(t.signer,f,g.None)).encode();n.push(e)}})));for(const t of e)if(t.makeAdmin)(await this.sendSignerPermissionRequest(t.signer,f,g.AddAdmin)).encode();else{const e=(await this.sendSignerPermissionRequest(t.signer,t.permissions,g.None)).encode();a.push(e)}const l=[];return r.forEach((t=>{l.push(t)})),n.forEach((t=>{l.push(t)})),a.forEach((t=>{l.push(t)})),s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[l]})}))}class v{featureName=i.dq.name;constructor(t){this.contractWrapper=t,this.accountPermissions=this.detectAccountPermissions()}detectAccountPermissions(){if((0,n.d)(this.contractWrapper,"AccountPermissions")||(0,n.d)(this.contractWrapper,"AccountPermissionsV1"))return new b(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async isAdmin(t){return(0,a.a)(this.accountPermissions,i.dp).isAdmin(t)}async isSigner(t){return(0,a.a)(this.accountPermissions,i.dp).isSigner(t)}async getAllAdmins(){return(0,a.a)(this.accountPermissions,i.dp).getAllAdmins()}async getAllSigners(){return(0,a.a)(this.accountPermissions,i.dp).getAllSigners()}async getAllAdminsAndSigners(){return(0,a.a)(this.accountPermissions,i.dp).getAllAdminsAndSigners()}grantAdminPermissions=(0,s.c)((async t=>(0,a.a)(this.accountPermissions,i.dp).grantAdminPermissions.prepare(t)));revokeAdminPermissions=(0,s.c)((async t=>(0,a.a)(this.accountPermissions,i.dp).revokeAdminPermissions.prepare(t)));grantPermissions=(0,s.c)((async(t,e)=>(0,a.a)(this.accountPermissions,i.dp).grantPermissions.prepare(t,e)));updatePermissions=(0,s.c)((async(t,e)=>(0,a.a)(this.accountPermissions,i.dp).updatePermissions.prepare(t,e)));revokeAccess=(0,s.c)((async t=>(0,a.a)(this.accountPermissions,i.dp).revokeAccess.prepare(t)));approveTargetForSigner=(0,s.c)((async(t,e)=>(0,a.a)(this.accountPermissions,i.dp).approveTargetForSigner.prepare(t,e)));disapproveTargetForSigner=(0,s.c)((async(t,e)=>(0,a.a)(this.accountPermissions,i.dp).disapproveTargetForSigner.prepare(t,e)));resetAllPermissions=(0,s.c)((async t=>(0,a.a)(this.accountPermissions,i.dp).resetAllPermissions.prepare(t)))}class P{featureName=i.dr.name;constructor(t){this.contractWrapper=t,this.events=new n.a(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async predictAccountAddress(t,e){let r=l.Y0("");return e&&(r=e),this.contractWrapper.read("getAddress",[t,r])}async getAssociatedAccounts(t){return this.contractWrapper.read("getAccountsOfSigner",[t])}async getAllAccounts(){return await this.contractWrapper.read("getAllAccounts",[])}async isAccountDeployed(t,e){const r=await this.predictAccountAddress(t,e);return(0,i.az)(r,this.contractWrapper.getProvider())}createAccount=(0,s.c)((async(t,e)=>{if(await this.isAccountDeployed(t,e))throw new Error(`Account already deployed for admin: ${t}`);let r=l.Y0("");return e&&(r=e),s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAccount",args:[t,r],parse:t=>({address:this.contractWrapper.parseLogs("AccountCreated",t?.logs)[0].args.account,receipt:t})})}))}var T=r(68828),A=r(52153),S=r(83833),k=r(5995),E=r(74935),I=r(82714),x=r(40795),N=r(11846),M=r(15039),L=r(70735),O=r(58915),R=r(32046),B=r(8198);r(13550),r(77191),r(54146),r(64063);class D{featureName=i.dI.name;constructor(t){this.contractWrapper=t}getAddress(){return this.contractWrapper.address}drop=(0,s.c)((async(t,e,r)=>s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"airdropERC1155",args:[t,e,r],parse:t=>{const e=this.contractWrapper.parseLogs("AirdropFailed",t.logs).map((t=>({recipient:t.args.recipient,tokenId:t.args.tokenId.toNumber(),amount:t.args.amount.toString()})));return{successfulDropCount:r.length-e.length,failedDropCount:e.length,failedDrops:e}}})))}class F{featureName=i.dJ.name;constructor(t){this.contractWrapper=t}getAddress(){return this.contractWrapper.address}drop=(0,s.c)((async(t,e,r)=>s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"airdropERC20",args:[t,e,r],parse:t=>{const e=this.contractWrapper.parseLogs("AirdropFailed",t.logs).map((t=>({recipient:t.args.recipient,amount:t.args.amount.toString()})));return{successfulDropCount:r.length-e.length,failedDropCount:e.length,failedDrops:e}}})))}class ${featureName=i.dK.name;constructor(t){this.contractWrapper=t}getAddress(){return this.contractWrapper.address}drop=(0,s.c)((async(t,e,r)=>s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"airdropERC721",args:[t,e,r],parse:t=>{const e=this.contractWrapper.parseLogs("AirdropFailed",t.logs).map((t=>({recipient:t.args.recipient,tokenId:t.args.tokenId.toNumber()})));return{successfulDropCount:r.length-e.length,failedDropCount:e.length,failedDrops:e}}})))}class q{featureName=i.dL.name;constructor(t){this.contractWrapper=t}getAddress(){return this.contractWrapper.readContract.address}async getAll(){return await this.contractWrapper.readContract.getAllExtensions()}async get(t){return await this.contractWrapper.readContract.getExtension(t)}async getExtensionAddress(t){return(await this.get(t)).metadata.implementation}async getAllFunctions(t){return(await this.get(t)).functions}async getExtensionForFunction(t){let e=t.functionSelector;e||((0,d.Z)(t.functionSignature,"Atleast one of function selector and signature must be provided"),e=R.id(t.functionSignature).substring(0,10));return await this.contractWrapper.readContract.getMetadataForFunction(e)}async getExtensionAddressForFunction(t){return(await this.getExtensionForFunction(t)).implementation}add=(0,s.c)((async t=>s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"addExtension",args:[t.extension],parse:async e=>{if(this.contractWrapper.parseLogs("ExtensionAdded",e.logs).length<1)throw new Error("No ExtensionAdded event found");const r=t.extensionAbi?i.bn.parse(t.extensionAbi):(await(0,i.K)(t.extension.metadata.implementation,this.contractWrapper.getProvider(),this.contractWrapper.storage)).abi,a=this.filterAbiForAdd(r,t.extension),n=(0,i.an)([i.bn.parse(this.contractWrapper.abi),a]);return this.contractWrapper.updateAbi(n),e}})));addDeployed=(0,s.c)((async t=>{let e=t.extensionAbi;if(!e){e=(await(0,i.K)(t.extensionAddress,this.contractWrapper.getProvider(),this.contractWrapper.storage,this.contractWrapper.options)).abi}(0,d.Z)(e,"Require extension ABI");let r="";if(t.extensionMetadata)if("string"==typeof t.extensionMetadata)r=t.extensionMetadata;else{const e=await i.bF.parseAsync(t.extensionMetadata);r=await this.contractWrapper.storage.upload(e)}const a=(0,O.b)(i.bn.parse(e)),n={metadata:{name:t.extensionName,metadataURI:r,implementation:t.extensionAddress},functions:a};return this.add.prepare({extension:n,extensionAbi:e})}));addPublished=(0,s.c)((async t=>{const e=t.version||"latest",{deployedExtensionAddress:r,extensionMetadata:a}=await this.deployExtension(t.extensionName,t.publisherAddress||i.aL,e);return this.addDeployed.prepare({extensionName:t.extensionName,extensionAddress:r,extensionMetadata:t.extensionMetadataOverride||a})}));replace=(0,s.c)((async t=>s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"replaceExtension",args:[t.extension],parse:async e=>{if(this.contractWrapper.parseLogs("ExtensionReplaced",e.logs).length<1)throw new Error("No ExtensionReplaced event found");const r=t.extensionAbi?i.bn.parse(t.extensionAbi):(await(0,i.K)(t.extension.metadata.implementation,this.contractWrapper.getProvider(),this.contractWrapper.storage)).abi,a=this.filterAbiForRemove(i.bn.parse(this.contractWrapper.abi),r),n=this.filterAbiForAdd(r,t.extension),s=(0,i.an)([a,n]);return this.contractWrapper.updateAbi(s),e}})));replaceDeployed=(0,s.c)((async t=>{let e=t.extensionAbi;if(!e){e=(await(0,i.K)(t.extensionAddress,this.contractWrapper.getProvider(),this.contractWrapper.storage,this.contractWrapper.options)).abi}(0,d.Z)(e,"Require extension ABI");let r="";if(t.extensionMetadata)if("string"==typeof t.extensionMetadata)r=t.extensionMetadata;else{const e=await i.bF.parseAsync(t.extensionMetadata);r=await this.contractWrapper.storage.upload(e)}const a=(0,O.b)(i.bn.parse(e)),n={metadata:{name:t.extensionName,metadataURI:r,implementation:t.extensionAddress},functions:a};return this.replace.prepare({extension:n,extensionAbi:e})}));replacePublished=(0,s.c)((async t=>{const e=t.version||"latest",{deployedExtensionAddress:r,extensionMetadata:a}=await this.deployExtension(t.extensionName,t.publisherAddress||i.aL,e);return this.replaceDeployed.prepare({extensionName:t.extensionName,extensionAddress:r,extensionMetadata:t.extensionMetadataOverride||a})}));remove=(0,s.c)((async t=>{const e=await this.getExtensionAddress(t.extensionName);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"removeExtension",args:[t.extensionName],parse:async t=>{if(this.contractWrapper.parseLogs("ExtensionRemoved",t.logs).length<1)throw new Error("No ExtensionRemoved event found");const r=(await(0,i.K)(e,this.contractWrapper.getProvider(),this.contractWrapper.storage)).abi,a=this.filterAbiForRemove(i.bn.parse(this.contractWrapper.abi),r);return this.contractWrapper.updateAbi(a),t}})}));filterAbiForAdd(t,e){const r=new B.vU(t),a=e.functions.map((t=>t.functionSelector));return t.filter((t=>{const e=Object.values(new B.vU([t]).functions);if(0===e.length)return!1;const n=r.getSighash(e[0]);return a.includes(n)}))}filterAbiForRemove(t,e){const r=new B.vU(t),a=new B.vU(e),n=Object.values(a.functions).map((t=>a.getSighash(t)));return t.filter((t=>{const e=Object.values(new B.vU([t]).functions);if(0===e.length)return!1;const a=r.getSighash(e[0]);return!n.includes(a)}))}async deployExtension(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"latest";const a=await(0,i.aM)(e,t,r,this.contractWrapper.storage,this.contractWrapper.options.clientId,this.contractWrapper.options.secretKey),n=await(0,O.g)(a.metadataUri,this.contractWrapper.storage,this.contractWrapper.getProvider(),"",this.contractWrapper.options.clientId,this.contractWrapper.options.secretKey),s=n.find((t=>"implementation"===t.type))?.transaction.predictedAddress,o=n.filter((t=>t.transaction.data&&t.transaction.data.length>0)),c=o.filter((t=>"infra"!==t.type)).map((t=>t.transaction)),p=o.filter((t=>"infra"===t.type)).map((t=>t.transaction)),l=this.contractWrapper.getSigner();(0,d.Z)(l,"Signer is required"),await(0,O.a)(l,p,{});for(const t of c)try{await(0,O.d)(l,t)}catch(e){console.debug(`Error deploying contract at ${t.predictedAddress}`,e?.message)}return{deployedExtensionAddress:s,extensionMetadata:a.metadataUri}}}class z{get abi(){return i.bn.parse(this.contractWrapper.abi||[])}get royalties(){return(0,a.a)(this.detectRoyalties(),i.d4)}get roles(){return(0,a.a)(this.detectRoles(),i.d3)}get sales(){return(0,a.a)(this.detectPrimarySales(),i.d6)}get platformFees(){return(0,a.a)(this.detectPlatformFees(),i.dn)}get owner(){return(0,a.a)(this.detectOwnable(),i.d5)}get erc20(){return(0,a.a)(this.detectErc20(),i.cL)}get erc721(){return(0,a.a)(this.detectErc721(),i.d0)}get erc1155(){return(0,a.a)(this.detectErc1155(),i.di)}get app(){return(0,a.a)(this.detectApp(),i.d2)}get directListings(){return(0,a.a)(this.detectDirectListings(),i.dk)}get englishAuctions(){return(0,a.a)(this.detectEnglishAuctions(),i.dl)}get offers(){return(0,a.a)(this.detectOffers(),i.dm)}get airdrop20(){return(0,a.a)(this.detectAirdrop20(),i.dJ)}get airdrop721(){return(0,a.a)(this.detectAirdrop721(),i.dK)}get airdrop1155(){return(0,a.a)(this.detectAirdrop1155(),i.dI)}get accountFactory(){return(0,a.a)(this.detectAccountFactory(),i.dr)}get account(){return(0,a.a)(this.detectAccount(),i.dq)}get extensions(){return(0,a.a)(this.detectBaseRouter(),i.dL)}get chainId(){return this._chainId}constructor(t,e,r,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},o=arguments.length>5?arguments[5]:void 0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new i.cu(t,e,r,s,a);this._chainId=o,this.storage=a,this.contractWrapper=c,this.events=new n.a(this.contractWrapper),this.encoder=new T.C(this.contractWrapper),this.interceptor=new A.C(this.contractWrapper),this.estimator=new n.G(this.contractWrapper),this.publishedMetadata=new m(this.contractWrapper,this.storage),this.metadata=new n.C(this.contractWrapper,i.bk,this.storage)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}prepare(t,e,r){return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}detectRoyalties(){if((0,n.d)(this.contractWrapper,"Royalty")){const t=new n.C(this.contractWrapper,i.bk,this.storage);return new S.C(this.contractWrapper,t)}}detectRoles(){if((0,n.d)(this.contractWrapper,"Permissions"))return new E.C(this.contractWrapper,i.G)}detectPrimarySales(){if((0,n.d)(this.contractWrapper,"PrimarySale"))return new I.C(this.contractWrapper)}detectPlatformFees(){if((0,n.d)(this.contractWrapper,"PlatformFee"))return new k.C(this.contractWrapper)}detectErc20(){if((0,n.d)(this.contractWrapper,"ERC20"))return new N.f(this.contractWrapper,this.storage,this.chainId)}detectErc721(){if((0,n.d)(this.contractWrapper,"ERC721"))return new M.h(this.contractWrapper,this.storage,this.chainId)}detectErc1155(){if((0,n.d)(this.contractWrapper,"ERC1155"))return new x.e(this.contractWrapper,this.storage,this.chainId)}detectOwnable(){if((0,n.d)(this.contractWrapper,"Ownable"))return new S.a(this.contractWrapper)}detectApp(){const t=new n.C(this.contractWrapper,i.bk,this.storage);return(0,n.d)(this.contractWrapper,"AppURI")||(0,n.d)(this.contractWrapper,"ContractMetadata")?new n.b(this.contractWrapper,t,this.storage):void 0}detectDirectListings(){if((0,n.d)(this.contractWrapper,"DirectListings"))return new L.M(this.contractWrapper,this.storage)}detectEnglishAuctions(){if((0,n.d)(this.contractWrapper,"EnglishAuctions"))return new L.a(this.contractWrapper,this.storage)}detectOffers(){if((0,n.d)(this.contractWrapper,"Offers"))return new L.b(this.contractWrapper,this.storage)}detectBaseRouter(){if((0,n.d)(this.contractWrapper,i.dL.name))return new q(this.contractWrapper)}detectAirdrop20(){if((0,n.d)(this.contractWrapper,"AirdropERC20"))return new F(this.contractWrapper)}detectAirdrop721(){if((0,n.d)(this.contractWrapper,"AirdropERC721"))return new $(this.contractWrapper)}detectAirdrop1155(){if((0,n.d)(this.contractWrapper,"AirdropERC1155"))return new D(this.contractWrapper)}detectAccountFactory(){if((0,n.d)(this.contractWrapper,i.dr.name))return new P(this.contractWrapper)}detectAccount(){if((0,n.d)(this.contractWrapper,i.dq.name))return new v(this.contractWrapper)}}},56351:(t,e,r)=>{var a=r(48764).Buffer;t.exports=function(t){for(var e=new a(t.length),r=0,n=t.length-1;r<=n;++r,--n)e[r]=t[n],e[n]=t[r];return e}},99269:function(t){t.exports=function(){function t(t,e){var r=e?"":"";return r+=t?" ":""}function e(t,e){var r=[];for(var a in t)t.hasOwnProperty(a)&&(e&&"function"==typeof t[a]||r.push(a));return r}function r(a,n,i,s,o,c,p){var l,d,h="",u=0,m=s.slice(0);if(m.push([n,i])&&s.length>0&&(s.forEach((function(t,e){e>0&&(h+=(t[1]?" ":"")+"  "),d||t[0]!==n||(d=!0)})),h+=t(a,i)+a,o&&("object"!=typeof n||n instanceof Date)&&(h+=": "+n),d&&(h+=" (circular ref.)"),p(h)),!d&&"object"==typeof n){var g=e(n,c);g.forEach((function(t){l=++u===g.length,r(t,n[t],l,m,o,c,p)}))}}var a={asLines:function(t,e,a,n){r(".",t,!1,[],e,"function"!=typeof a&&a,n||a)},asTree:function(t,e,a){var n="";return r(".",t,!1,[],e,a,(function(t){n+=t+"\n"})),n}};return a}()}}]);
//# sourceMappingURL=9494.js.map