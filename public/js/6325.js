(self.webpackChunk=self.webpackChunk||[]).push([[6325],{89050:(t,e,r)=>{"use strict";r.d(e,{D:()=>y,F:()=>p,I:()=>c,a:()=>l,b:()=>u,c:()=>d,f:()=>h,g:()=>f,u:()=>m});var a=r(41518),n=r(16441),s=r(2593),i=r(64146),o=r(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),l=(()=>n.arrayify("0xd9b67a26"))(),p={name:"Failed to load NFT metadata"};async function h(t,e,r){if(e.startsWith("data:application/json;base64")&&void 0!==o){const r=e.split(",")[1],n=JSON.parse(o.from(r,"base64").toString("utf-8"));return a.C.parse({...n,id:s.O$.from(t).toString(),uri:e})}const i=e.replace("{id}",n.hexZeroPad(s.O$.from(t).toHexString(),32).slice(2));let c;try{c=await r.downloadJSON(i)}catch(a){const n=e.replace("{id}",s.O$.from(t).toString());try{c=await r.downloadJSON(n)}catch(r){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),c=p}}return a.C.parse({...c,id:s.O$.from(t).toString(),uri:e})}async function d(t,e,n,o){let d;const u=(await r.e(5025).then(r.t.bind(r,25025,19))).default,m=new i.CH(t,u,e),[f,y]=await Promise.all([m.supportsInterface(c),m.supportsInterface(l)]);if(f){const a=(await Promise.resolve().then(r.t.bind(r,34161,19))).default,s=new i.CH(t,a,e);d=await s.tokenURI(n)}else{if(!y)throw Error("Contract must implement ERC 1155 or ERC 721.");{const a=(await Promise.resolve().then(r.t.bind(r,50266,19))).default,s=new i.CH(t,a,e);d=await s.uri(n)}}return d?h(n,d,o):a.C.parse({...p,id:s.O$.from(n).toString(),uri:""})}async function u(t,e){return"string"==typeof t?t:await e.upload(a.a.parse(t))}async function m(t,e,r,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await e.uploadBatch(t.map((t=>a.a.parse(t))),{rewriteFileNames:{fileStartNumber:r||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function f(t){const e=t[0].substring(0,t[0].lastIndexOf("/"));for(let r=0;r<t.length;r++){const a=t[r].substring(0,t[r].lastIndexOf("/"));if(e!==a)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)}return e.replace(/\/$/,"")+"/"}const y=100},89208:(t,e,r)=>{"use strict";r.d(e,{E:()=>c,R:()=>i,S:()=>o,a:()=>l});var a=r(2593),n=r(1604),s=r(7860);const i=(()=>n.z.union([n.z.date().transform((t=>a.O$.from(Math.floor(t.getTime()/1e3)))),n.z.number().transform((t=>a.O$.from(t)))]))(),o=(()=>i.default(new Date(0)))(),c=(()=>i.default(new Date(Date.now()+31536e7)))();function l(t,e){if(!t)throw new s.x(e);return t}},89536:(t,e,r)=>{"use strict";r.d(e,{C:()=>l,G:()=>h,a:()=>p,b:()=>d,d:()=>o,h:()=>c});var a=r(7860),n=r(19578),s=r(61744),i=r(40721);function o(t,e){return(0,a.am)(a.bn.parse(t.abi),e)}function c(t,e){return t in e.readContract.functions}class l{featureName=a.d1.name;constructor(t,e,r){this.contractWrapper=t,this.schema=e,this.storage=r}parseOutputMetadata(t){return this.schema.output.parseAsync(t)}parseInputMetadata(t){return this.schema.input.parseAsync(t)}async get(){let t;if(this.supportsContractMetadata(this.contractWrapper)){const e=await this.contractWrapper.read("contractURI",[]);e&&e.includes("://")&&(t=await this.storage.downloadJSON(e))}if(!t)try{let e,r,n;try{c("name",this.contractWrapper)&&(e=await this.contractWrapper.read("name",[]))}catch(t){}try{c("symbol",this.contractWrapper)&&(r=await this.contractWrapper.read("symbol",[]))}catch(t){}try{n=await(0,a.K)(this.contractWrapper.address,this.contractWrapper.getProvider(),this.storage,this.contractWrapper.options)}catch(t){}t={name:e||n?.name,symbol:r,description:n?.info.title}}catch(t){throw new Error("Could not fetch contract metadata")}return this.parseOutputMetadata(t)}set=(0,n.c)((async t=>{const e=await this._parseAndUploadMetadata(t),r=this.contractWrapper;if(this.supportsContractMetadata(r))return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setContractURI",args:[e],parse:t=>({receipt:t,data:this.get})});throw new a.x(a.d1)}));update=(0,n.c)((async t=>await this.set.prepare({...await this.get(),...t})));async _parseAndUploadMetadata(t){const e=await this.parseInputMetadata(t);return this.storage.upload(e)}supportsContractMetadata(t){return o(t,"ContractMetadata")}}class p{constructor(t){this.contractWrapper=t}addTransactionListener(t){this.contractWrapper.addListener(a.b1.Transaction,t)}removeTransactionListener(t){this.contractWrapper.off(a.b1.Transaction,t)}addEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t),a={address:this.contractWrapper.address,topics:[this.contractWrapper.readContract.interface.getEventTopic(r)]},n=t=>{const r=this.contractWrapper.readContract.interface.parseLog(t);e(this.toContractEvent(r.eventFragment,r.args,t))};return this.contractWrapper.getProvider().on(a,n),()=>{this.contractWrapper.getProvider().off(a,n)}}listenToAllEvents(t){const e={address:this.contractWrapper.address},r=e=>{try{const r=this.contractWrapper.readContract.interface.parseLog(e);t(this.toContractEvent(r.eventFragment,r.args,e))}catch(t){console.error("Could not parse event:",e,t)}};return this.contractWrapper.getProvider().on(e,r),()=>{this.contractWrapper.getProvider().off(e,r)}}removeEventListener(t,e){const r=this.contractWrapper.readContract.interface.getEvent(t);this.contractWrapper.readContract.off(r.name,e)}removeAllListeners(){this.contractWrapper.readContract.removeAllListeners();const t={address:this.contractWrapper.address};this.contractWrapper.getProvider().removeAllListeners(t)}async getAllEvents(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{fromBlock:0,toBlock:"latest",order:"desc"};const e=(await this.contractWrapper.readContract.queryFilter({},t.fromBlock,t.toBlock)).sort(((e,r)=>"desc"===t.order?r.blockNumber-e.blockNumber:e.blockNumber-r.blockNumber));return this.parseEvents(e)}async getEvents(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{fromBlock:0,toBlock:"latest",order:"desc"};const r=this.contractWrapper.readContract.interface.getEvent(t),a=e.filters?r.inputs.map((t=>e.filters[t.name])):[],n=this.contractWrapper.readContract.filters[r.name](...a),s=(await this.contractWrapper.readContract.queryFilter(n,e.fromBlock,e.toBlock)).sort(((t,r)=>"desc"===e.order?r.blockNumber-t.blockNumber:t.blockNumber-r.blockNumber));return this.parseEvents(s)}parseEvents(t){return t.map((t=>{const e=Object.fromEntries(Object.entries(t).filter((t=>"function"!=typeof t[1]&&"args"!==t[0])));if(t.args){const r=Object.entries(t.args),a=r.slice(r.length/2,r.length),n={};for(const[t,e]of a)n[t]=e;return{eventName:t.event||"",data:n,transaction:e}}return{eventName:t.event||"",data:{},transaction:e}}))}toContractEvent(t,e,r){const a=Object.fromEntries(Object.entries(r).filter((t=>"function"!=typeof t[1]&&"args"!==t[0]))),n={};return t.inputs.forEach(((t,r)=>{if(Array.isArray(e[r])){const a=t.components;if(a){const s=e[r];if("tuple[]"===t.type){const e=[];for(let t=0;t<s.length;t++){const r=s[t],n={};for(let t=0;t<a.length;t++){n[a[t].name]=r[t]}e.push(n)}n[t.name]=e}else{const e={};for(let t=0;t<a.length;t++){e[a[t].name]=s[t]}n[t.name]=e}}}else n[t.name]=e[r]})),{eventName:t.name,data:n,transaction:a}}}class h{constructor(t){this.contractWrapper=t}async gasCostOf(t,e){const[r,a]=await Promise.all([this.contractWrapper.getProvider().getGasPrice(),this.contractWrapper.estimateGas(t,e)]);return s.formatEther(a.mul(r))}async gasLimitOf(t,e){return this.contractWrapper.estimateGas(t,e)}async currentGasPriceInGwei(){const t=await this.contractWrapper.getProvider().getGasPrice();return s.formatUnits(t,"gwei")}}class d{featureName=a.d2.name;constructor(t,e,r){this.contractWrapper=t,this.metadata=e,this.storage=r}async get(){return o(this.contractWrapper,"AppURI")?await this.contractWrapper.read("appURI",[]):(0,i.ov)((await this.metadata.get()).app_uri||"",this.storage.getGatewayUrls())}set=(0,n.c)((async t=>o(this.contractWrapper,"AppURI")?n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAppURI",args:[t]}):await this.metadata.update.prepare({app_uri:t})))}},52153:(t,e,r)=>{"use strict";r.d(e,{C:()=>a});class a{constructor(t){this.contractWrapper=t}overrideNextTransaction(t){this.contractWrapper.withTransactionOverride(t)}}},83833:(t,e,r)=>{"use strict";r.d(e,{C:()=>g,D:()=>w,a:()=>C,c:()=>W});var a=r(89536),n=r(19578),s=r(7860),i=r(68828),o=r(29251),c=r(31886),l=r(84243),p=r(16441),h=r(2593),d=r(64146),u=r(41518),m=r(89050),f=r(58179),y=r(19824);class g{featureName=s.d4.name;constructor(t,e){this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){const[t,e]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return s.bH.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){const[e,r]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return s.bH.parseAsync({fee_recipient:e,seller_fee_basis_points:r})}setDefaultRoyaltyInfo=(0,n.c)((async t=>{const e=await this.metadata.get(),r=await this.metadata.parseInputMetadata({...e,...t}),s=await this.metadata._parseAndUploadMetadata(r);if((0,a.h)("setContractURI",this.contractWrapper)){const t=new i.C(this.contractWrapper),e=[t.encode("setDefaultRoyaltyInfo",[r.fee_recipient,r.seller_fee_basis_points]),t.encode("setContractURI",[s])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.c)((async(t,e)=>{const r=s.bH.parse(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class w{constructor(t,e,r,a){this.featureName=r,this.nextTokenIdToMintFn=a,this.contractWrapper=t,this.storage=e}createDelayedRevealBatch=(0,n.c)((async(t,e,r,a)=>{if(!r)throw new Error("Password is required");const s=await this.storage.uploadBatch([u.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),i=(0,m.g)(s),p=await this.nextTokenIdToMintFn(),h=await this.storage.uploadBatch(e.map((t=>u.a.parse(t))),{onProgress:a?.onProgress,rewriteFileNames:{fileStartNumber:p.toNumber()}}),d=(0,m.g)(h),f=await this.contractWrapper.read("getBaseURICount",[]),y=await this.hashDelayRevealPassword(f,r),g=await this.contractWrapper.read("encryptDecrypt",[o.Y0(d),y]);let w;if(await this.isLegacyContract())w=g;else{const t=await this.contractWrapper.getChainID(),e=c.keccak256(["bytes","bytes","uint256"],[o.Y0(d),y,t]);w=l.$.encode(["bytes","bytes32"],[g,e])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[h.length,i.endsWith("/")?i:`${i}/`,w],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t});return n}})}));reveal=(0,n.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.hashDelayRevealPassword(t,e);try{const e=await this.contractWrapper.callStatic().reveal(t,r);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const e=Array.from(Array(t.toNumber()).keys()),r=await Promise.all(e.map((t=>{if((0,a.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,a.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=r.slice(0,r.length-1),s=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),i=await this.isLegacyContract(),o=(await Promise.all(Array.from([...r]).map((t=>i?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(p.hexDataLength(t)>0){if(i)return t;return l.$.decode(["bytes","bytes32"],t)[0]}return t}));return s.map(((t,e)=>({batchId:h.O$.from(e),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,e)=>p.hexDataLength(o[e])>0))}async hashDelayRevealPassword(t,e){const r=await this.contractWrapper.getChainID(),a=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[e,r,t,a])}async getNftMetadata(t){return(0,m.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,a.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const e=(await r.e(8839).then(r.t.bind(r,98839,19))).default,a=new d.CH(this.contractWrapper.address,e,this.contractWrapper.getProvider()),n=await a.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function W(t,e,r,a,n){let i={};const o=a||s.aZ,c=(await(0,y.n)(t.getProvider(),e,o)).mul(r);return c.gt(0)&&(o===s.aZ?i={value:c}:o!==s.aZ&&n&&await(0,f.a)(t,o,c,r,0)),i}class C{featureName=s.d5.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.c)((async t=>{const e=await(0,s.aP)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})}))}},5995:(t,e,r)=>{"use strict";r.d(e,{C:()=>s});var a=r(19578),n=r(7860);class s{featureName=n.dn.name;constructor(t){this.contractWrapper=t}async get(){const[t,e]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bJ.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:e})}set=(0,a.c)((async t=>{const e=await n.bJ.parseAsync(t);return a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[e.platform_fee_recipient,e.platform_fee_basis_points]})}))}},74935:(t,e,r)=>{"use strict";r.d(e,{C:()=>c});var a=r(38776),n=r(7860),s=r(89536),i=r(19578),o=r(68828);class c{featureName=n.d3.name;constructor(t,e){this.contractWrapper=t,this.roles=e}async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");const t={},e=Object.entries(this.roles);return(await Promise.all(e.map((t=>{let[,e]=t;return this.get(e)})))).forEach(((r,a)=>t[e[a][1]]=r)),t}async get(t){(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const e=this.contractWrapper;if((0,s.h)("getRoleMemberCount",e)&&(0,s.h)("getRoleMember",e)){const r=(0,n.H)(t),a=(await e.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((t=>e.read("getRoleMember",[r,t]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}setAll=(0,i.c)((async t=>{const e=new o.C(this.contractWrapper),r=Object.keys(t);(0,a.Z)(r.length,"you must provide at least one role to set"),(0,a.Z)(r.every((t=>this.roles.includes(t))),"this contract does not support the given role");const s=await this.getAll(),c=[],l=r.sort((t=>"admin"===t?1:-1));for(let r=0;r<l.length;r++){const a=l[r],[i,o]=await Promise.all([Promise.all(t[a]?.map((t=>(0,n.aP)(t)))||[]),Promise.all(s[a]?.map((t=>(0,n.aP)(t)))||[])]),p=i.filter((t=>!o.includes(t))),h=o.filter((t=>!i.includes(t)));if(p.length&&p.forEach((t=>{c.push(e.encode("grantRole",[(0,n.H)(a),t]))})),h.length){(await Promise.all(h.map((t=>this.getRevokeRoleFunctionName(t))))).forEach(((t,r)=>c.push(e.encode(t,[(0,n.H)(a),h[r]]))))}}return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[c]})}));async verify(t,e){await Promise.all(t.map((async t=>{const[r,a]=await Promise.all([this.get(t),(0,n.aP)(e)]);if(!r.map((t=>t.toLowerCase())).includes(a.toLowerCase()))throw new n.o(a,t)})))}grant=(0,i.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,n.H)(t),r]})}));revoke=(0,i.c)((async(t,e)=>{(0,a.Z)(this.roles.includes(t),`this contract does not support the "${t}" role`);const r=await(0,n.aP)(e),s=await this.getRevokeRoleFunctionName(r);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:s,args:[(0,n.H)(t),r]})}));async getRevokeRoleFunctionName(t){const[e,r]=await Promise.all([(0,n.aP)(t),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===e.toLowerCase()?"renounceRole":"revokeRole"}}},82714:(t,e,r)=>{"use strict";r.d(e,{C:()=>s});var a=r(19578),n=r(7860);class s{featureName=n.d6.name;constructor(t){this.contractWrapper=t}async getRecipient(){return await this.contractWrapper.read("primarySaleRecipient",[])}setRecipient=(0,a.c)((async t=>a.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPrimarySaleRecipient",args:[t]})))}},62245:(t,e,r)=>{"use strict";r.d(e,{D:()=>y});var a=r(61744),n=r(16441),s=r(2593),i=r(21046),o=r(9279),c=r(29251),l=r(64063),p=r.n(l),h=r(7860),d=r(58179),u=r(68828),m=r(89536),f=r(19578);class y{constructor(t,e,r){this.storage=r,this.contractWrapper=t,this.metadata=e}async getActive(t){const[e,r,a]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await(0,d.v)(e,a,this.contractWrapper.getProvider(),r.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,d.w)(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,d.w)(r)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return(0,d.x)(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return(0,d.x)(r)}throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,r]=await this.contractWrapper.read("claimCondition",[]),a=e.toNumber(),n=r.toNumber(),s=[];for(let t=a;t<a+n;t++)s.push(this.get(t));const[i,o,...c]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...s]);return Promise.all(c.map((e=>(0,d.v)(e,o,this.contractWrapper.getProvider(),i.merkle,this.storage,t?.withAllowList||!1))))}return[await this.getActive(t)]}async canClaim(t,e){return e&&(e=await(0,h.aP)(e)),0===(await this.getClaimIneligibilityReasons(t,e)).length}async getClaimIneligibilityReasons(t,e){const o=[];let c,l;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(t){console.warn("failed to get signer address",t)}if(!e)return[d.C.NoWallet];const[p,m]=await Promise.all([(0,h.aP)(e),this.getTokenDecimals()]),f=a.parseUnits(h.cz.parse(t),m);try{l=await this.getActive()}catch(t){return(0,h.B)(t,"!CONDITION")||(0,h.B)(t,"no active mint condition")?(o.push(d.C.NoClaimConditionSet),o):(console.warn("failed to get active claim condition",t),o.push(d.C.Unknown),o)}if("unlimited"!==l.availableSupply){if(a.parseUnits(l.availableSupply,m).lt(f))return o.push(d.C.NotEnoughSupply),o}const y=n.stripZeros(l.merkleRootHash).length>0;let g=null;if(y){if(g=await this.getClaimerProofs(p),!g&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return o.push(d.C.AddressNotAllowed),o;if(g)try{const e=await this.prepareClaim(t,!1,m,p);let r;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[r]=await this.contractWrapper.read("verifyClaimMerkleProof",[c,p,t,e.proofs,e.maxClaimable]),!r)return o.push(d.C.AddressNotAllowed),o}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([r]=await this.contractWrapper.read("verifyClaimMerkleProof",[p,t,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable}]),!r)return o.push(d.C.AddressNotAllowed),o}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[c,p,t,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,currency:e.currencyAddressInProof,pricePerToken:e.priceInProof}]))}catch(t){console.warn("Merkle proof verification failed:","reason"in t?t.reason:t);switch(t.reason){case"!Qty":o.push(d.C.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":o.push(d.C.WrongPriceOrCurrency);break;case"!MaxSupply":o.push(d.C.NotEnoughSupply);break;case"cant claim yet":o.push(d.C.ClaimPhaseNotStarted);break;default:o.push(d.C.AddressNotAllowed)}return o}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=s.O$.from(0),e=(0,d.y)(l.maxClaimablePerWallet,m);try{t=await this.getSupplyClaimedByWallet(p)}catch(t){}if(g&&(e=(0,d.y)(g.maxClaimable,m)),e.gt(0)&&e.lt(t.add(f)))return o.push(d.C.OverMaxClaimablePerWallet),o;if((!y||y&&!g)&&(e.lte(t)||e.eq(0)))return o.push(d.C.AddressNotAllowed),o}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,e]=[s.O$.from(0),s.O$.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(c=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,e]=await this.contractWrapper.read("getClaimTimestamp",[c,p])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,e]=await this.contractWrapper.read("getClaimTimestamp",[p]));const r=s.O$.from(Date.now()).div(1e3);if(t.gt(0)&&r.lt(e))return e.eq(i.Bz)?o.push(d.C.AlreadyClaimed):o.push(d.C.WaitBeforeNextClaimTransaction),o}if(l.price.gt(0)&&(0,h.d7)()){const e=l.price.mul(s.O$.from(t)),a=this.contractWrapper.getProvider();if((0,u.i)(l.currencyAddress)){(await a.getBalance(p)).lt(e)&&o.push(d.C.NotEnoughTokens)}else{const t=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,n=new h.cu(a,l.currencyAddress,t,{},this.storage);(await n.read("balanceOf",[p])).lt(e)&&o.push(d.C.NotEnoughTokens)}}return o}async getClaimerProofs(t,e){const r=(await this.get(e)).merkleRoot;if(n.stripZeros(r).length>0){const[e,a]=await Promise.all([this.metadata.get(),(0,h.aP)(t)]);return await(0,d.f)(a,r.toString(),e.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const e=await(0,h.aP)(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=(0,f.c)((()=>{var t=this;return async function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=e;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(r=!0,0===e.length)a=[{startTime:new Date(0),currencyAddress:o.d,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:n.hexZeroPad([0],32),snapshot:[]}];else if(e.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&a.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,e)=>t+e),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:s,sortedConditions:i}=await(0,d.D)(a,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),c={};s.forEach((t=>{c[t.merkleRoot]=t.snapshotUri}));const l=await t.metadata.get(),h=[];if(!p()(l.merkle,c)){const e=await t.metadata.parseInputMetadata({...l,merkle:c}),r=await t.metadata._parseAndUploadMetadata(e);if(!(0,m.h)("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const e=new u.C(t.contractWrapper);h.push(e.encode("setContractURI",[r]))}}const y=t.contractWrapper,g=new u.C(y);if(t.isLegacySinglePhaseDrop(y)){const t=new u.C(y);h.push(t.encode("setClaimConditions",[(0,d.E)(i[0]),r]))}else if(t.isLegacyMultiPhaseDrop(y))h.push(g.encode("setClaimConditions",[i.map(d.E),r]));else if(t.isNewSinglePhaseDrop(y))h.push(g.encode("setClaimConditions",[(0,d.F)(i[0]),r]));else{if(!t.isNewMultiphaseDrop(y))throw new Error("Contract does not support claim conditions");h.push(g.encode("setClaimConditions",[i.map(d.F),r]))}if((0,m.h)("multicall",t.contractWrapper))return f.T.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[h]});throw new Error("Contract does not support multicall")}})());update=(0,f.c)((async(t,e)=>{const r=await this.getAll(),a=await(0,d.H)(t,e,r);return await this.set.prepare(a)}));async getTokenDecimals(){return(0,m.d)(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3?arguments[3]:void 0;const[n,s]=await Promise.all([a||this.contractWrapper.getSignerAddress(),this.getActive()]);return(0,d.z)(n,t,s,(async()=>(await this.metadata.get()).merkle),r,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,e,r){const a=await(0,h.aP)(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,r.proofs,r.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[a,e,r.currencyAddress,r.price,{proof:r.proofs,maxQuantityInAllowlist:r.maxClaimable},c.Y0("")]:[a,e,r.currencyAddress,r.price,{proof:r.proofs,quantityLimitPerWallet:r.maxClaimable,pricePerToken:r.priceInProof,currency:r.currencyAddressInProof},c.Y0("")]}async getClaimTransaction(t,e,r){if(r?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const a=await this.prepareClaim(e,void 0===r?.checkERC20Allowance||r.checkERC20Allowance,await this.getTokenDecimals());return f.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,e,a),overrides:a.overrides})}isNewSinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV2")||(0,m.d)(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV2")||(0,m.d)(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return(0,m.d)(t,"ERC721ClaimConditionsV1")||(0,m.d)(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return(0,m.d)(t,"ERC721ClaimPhasesV1")||(0,m.d)(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?d.A.V1:d.A.V2}}},15039:(t,e,r)=>{"use strict";r.d(e,{h:()=>z,i:()=>U});var a=r(29251),n=r(2593),s=r(9279),i=r(31886),o=r(84243),c=r(61744),l=r(89050),p=r(7860),h=r(89208),d=r(89536),u=r(19578),m=r(62245),f=r(83833),y=r(68828),g=r(40721),w=r(41518),W=r(38776),C=r(19824),b=r(1604),v=r(58179);class T{featureName=p.cM.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r}to=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([(0,l.u)(e,this.storage),(0,p.aP)(t)]),n=new y.C(this.contractWrapper),s=r.map((t=>n.encode("mintTo",[a,t])));return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:t=>{const r=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===r.length||r.length<e.length)throw new Error("TokenMinted event not found, minting failed");return r.map((e=>{const r=e.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}))}})}))}class P{featureName=p.cN.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r;const a=new d.C(this.contractWrapper,p.bk,this.storage);this.conditions=new m.D(this.contractWrapper,a,this.storage)}to=(0,u.c)((async(t,e,r)=>{const a=await this.conditions.getClaimTransaction(t,e,r);return a.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),a}))}class S{featureName=p.cO.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async getClaimTransaction(t,e,r){let a={};return r&&r.pricePerToken&&(a=await(0,f.c)(this.contractWrapper,r.pricePerToken,e,r.currencyAddress,r.checkERC20Allowance)),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,e],overrides:a})}to=(0,u.c)((async(t,e,r)=>{const a=await this.getClaimTransaction(t,e,r);return a.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),a}))}class k{featureName=p.cP.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r,this.revealer=this.detectErc721Revealable()}lazyMint=(0,u.c)((async(t,e)=>{const r=await this.erc721.nextTokenIdToMint(),n=await(0,l.u)(t,this.storage,r.toNumber(),e),s=(0,l.g)(n);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[n.length,s.endsWith("/")?s:`${s}/`,a.Y0("")],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args.startTokenId,a=e[0].args.endTokenId,n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));detectErc721Revealable(){if((0,d.d)(this.contractWrapper,"ERC721Revealable"))return new f.D(this.contractWrapper,this.storage,p.cQ.name,(()=>this.erc721.nextTokenIdToMint()))}}class I{featureName=p.cR.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r,this.batch=this.detectErc721BatchMintable()}to=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([(0,l.b)(e,this.storage),(0,p.aP)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[a,r],parse:t=>{const e=this.contractWrapper.parseLogs("Transfer",t?.logs);if(0===e.length)throw new Error("TransferEvent event not found");const r=e[0].args.tokenId;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}})}));async getMintTransaction(t,e){return this.to.prepare(await(0,p.aP)(t),e)}detectErc721BatchMintable(){if((0,d.d)(this.contractWrapper,"ERC721BatchMintable"))return new T(this.erc721,this.contractWrapper,this.storage)}}class A{featureName=p.cS.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async all(t,e){let r=await this.tokenIds(t);if(e){const t=e?.start||0,a=e?.count||l.D;r=r.slice(t,t+a)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const e=await(0,p.aP)(t||await this.contractWrapper.getSignerAddress()),r=await this.contractWrapper.read("balanceOf",[e]),a=Array.from(Array(r.toNumber()).keys());return await Promise.all(a.map((t=>this.contractWrapper.read("tokenOfOwnerByIndex",[e,t]))))}}class x{featureName=p.cT.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}async all(t,e){let r=await this.tokenIds(t);if(e){const t=e?.start||0,a=e?.count||l.D;r=r.slice(t,t+a)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const e=await(0,p.aP)(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[e])}}class E{featureName=p.cU.name;constructor(t,e){this.erc721=t,this.contractWrapper=e,this.owned=this.detectErc721Owned()}async all(t){let e=n.O$.from(0);(0,d.h)("startTokenId",this.contractWrapper)&&(e=await this.contractWrapper.read("startTokenId",[]));const r=n.O$.from(t?.start||0).add(e).toNumber(),a=n.O$.from(t?.count||l.D).toNumber(),s=await this.erc721.nextTokenIdToMint(),i=Math.min(s.add(e).toNumber(),r+a);return await Promise.all([...Array(i-r).keys()].map((t=>this.erc721.get((r+t).toString()))))}async allOwners(){let t,e=n.O$.from(0);(0,d.h)("startTokenId",this.contractWrapper)&&(e=await this.contractWrapper.read("startTokenId",[]));try{t=await this.erc721.totalClaimedSupply()}catch(e){t=await this.totalCount()}t=t.add(e);const r=[...new Array(t.toNumber()).keys()],a=await Promise.all(r.map((t=>this.erc721.ownerOf(t).catch((()=>s.d)))));return r.map((t=>({tokenId:t,owner:a[t]}))).filter((t=>t.owner!==s.d))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){return(0,d.d)(this.contractWrapper,"ERC721Enumerable")?new A(this.erc721,this.contractWrapper):(0,d.d)(this.contractWrapper,"ERC721AQueryable")?new x(this.erc721,this.contractWrapper):void 0}}const M=(()=>v.B.extend({tierPriority:b.z.array(b.z.string()),royaltyRecipient:p.bd.default(s.d),royaltyBps:p.cF.default(0),quantity:p.b9.default(1)}))(),N=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class R{featureName=p.cV.name;constructor(t,e,r){this.erc721=t,this.contractWrapper=e,this.storage=r}async getMetadataInTier(t){const e=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find((e=>e.tier===t));if(!e)throw new Error("Tier not found in contract.");return await Promise.all(e.ranges.map(((t,r)=>{const a=[],n=e.baseURIs[r];for(let e=t.startIdInclusive.toNumber();e<t.endIdNonInclusive.toNumber();e++){const t=n.endsWith("/")?`${n}${e}`:`${n}/${e}`,r=this.storage.downloadJSON(t);a.push(r)}return a})).flat())}async getTokensInTier(t){const e=await this.contractWrapper.read("getTokensInTierLen",[]);if(e.eq(0))return[];const r=await this.contractWrapper.read("getTokensInTier",[t,0,e]);return await Promise.all(r.map((t=>{const e=[];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++)e.push(this.erc721.get(r));return e})).flat())}createBatchWithTier=(0,u.c)((async(t,e,r)=>{const n=await this.erc721.nextTokenIdToMint(),s=await(0,l.u)(t,this.storage,n.toNumber(),r),i=(0,l.g)(s);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[s.length,i.endsWith("/")?i:`${i}/`,e,a.Y0("")],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));createDelayedRevealBatchWithTier=(0,u.c)((async(t,e,r,n,s)=>{if(!r)throw new Error("Password is required");const c=await this.storage.uploadBatch([w.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),p=(0,l.g)(c),h=await this.erc721.nextTokenIdToMint(),d=await this.storage.uploadBatch(e.map((t=>w.a.parse(t))),{onProgress:s?.onProgress,rewriteFileNames:{fileStartNumber:h.toNumber()}}),m=(0,l.g)(d),f=await this.contractWrapper.read("getBaseURICount",[]),y=await this.contractWrapper.getChainID(),g=i.keccak256(["string","uint256","uint256","address"],[r,y,f,this.contractWrapper.address]),W=await this.contractWrapper.read("encryptDecrypt",[a.Y0(m),g]),C=i.keccak256(["bytes","bytes","uint256"],[a.Y0(m),g,y]),b=o.$.encode(["bytes","bytes32"],[W,C]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[d.length,p.endsWith("/")?p:`${p}/`,n,b],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=e[0].args[1],a=e[0].args[2],n=[];for(let e=r;e.lte(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.getTokenMetadata(e)});return n}})}));reveal=(0,u.c)((async(t,e)=>{if(!e)throw new Error("Password is required");const r=await this.contractWrapper.getChainID(),a=i.keccak256(["string","uint256","uint256","address"],[e,r,t,this.contractWrapper.address]);try{const e=await this.contractWrapper.callStatic().reveal(t,a);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,a]})}));async generate(t){const[e]=await this.generateBatch([t]);return e}async generateBatch(t){const e=await Promise.all(t.map((t=>M.parseAsync(t)))),r=await this.contractWrapper.getChainID(),a=this.contractWrapper.getSigner();return(0,W.Z)(a,"No signer available"),await Promise.all(e.map((async t=>({payload:t,signature:(await this.contractWrapper.signTypedData(a,{name:"SignatureAction",version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{GenericRequest:N},await this.mapPayloadToContractStruct(t))).toString()}))))}async verify(t){const e=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[e,t.signature]))[0]}async claimWithSignature(t){const e=await this.mapPayloadToContractStruct(t.payload),r=await(0,C.n)(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),a=await this.contractWrapper.getCallOverrides();await(0,w.s)(this.contractWrapper,r,t.payload.currencyAddress,a);const n=await this.contractWrapper.sendTransaction("claimWithSignature",[e,t.signature],a),s=this.contractWrapper.parseLogs("TokensClaimed",n?.logs),i=s[0].args.startTokenId,o=i.add(s[0].args.quantityClaimed),c=[];for(let t=i;t.lt(o);t=t.add(1))c.push({id:t,receipt:n,data:()=>this.erc721.get(t)});return c}async mapPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=o.$.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,e,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:r}}}class B{featureName=p.cW.name;constructor(t){this.contractWrapper=t}token=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]})))}class O{featureName=p.cX.name;constructor(t,e){this.erc721=t,this.contractWrapper=e}to=(0,u.c)((async(t,e,r)=>{if(t!==await(this.contractWrapper.getSigner()?.getAddress()))throw new Error("Zora Drop: Destination address must match connected wallet address");if(r?.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const a=(await this.getSaleDetails()).publicSalePrice,s=(i="0.000777",c.parseEther(p.cz.parse(i)));var i;const o=n.O$.from(a).add(s).mul(e),l=u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[e],overrides:{value:o}});return l.setParse((t=>{const r=this.contractWrapper.parseLogs("Sale",t?.logs)[0].args.firstPurchasedTokenId,a=r.add(e),n=[];for(let e=r;e.lt(a);e=e.add(1))n.push({id:e,receipt:t,data:()=>this.erc721.get(e)});return n})),l}));async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class L{featureName=p.cY.name;constructor(t){this.contractWrapper=t}cancel=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]})));revoke=(0,u.c)((async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]})))}class D{featureName=p.cZ.name;constructor(t,e){this.contractWrapper=t,this.storage=e}update=(0,u.c)((async(t,e)=>{const r=await(0,l.b)(e,this.storage);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,r]})}))}class F{featureName=p.c_.name;constructor(t,e){this.contractWrapper=t,this.storage=e}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every((t=>""===t)))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}set=(0,u.c)((async t=>{const e=w.B.parse(t);e.description=this.sanitizeJSONString(e.description);const r=[];(0,g.XT)(e.image)?r.push(this.storage.upload(e.image)):"string"==typeof e.image?r.push(Promise.resolve(e.image)):r.push(Promise.resolve(void 0)),(0,g.XT)(e.animation_url)?r.push(this.storage.upload(e.animation_url)):"string"==typeof e.animation_url?r.push(Promise.resolve(e.animation_url)):r.push(Promise.resolve(void 0));const[a,n]=await Promise.all(r);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${e.name||""}`,description:e.description||"",imageURI:a||"",animationURI:n||""}]})}));sanitizeJSONString(t){if(!t)return t;const e=JSON.stringify(t);return e.slice(1,e.length-1)}}class U{featureName=p.c$.name;constructor(t,e){this.contractWrapper=t,this.storage=e}mint=(0,u.c)((async t=>{const e=t.payload,r=t.signature,a=await this.contractWrapper.getCallOverrides(),n=t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return{id:e[0].args.tokenIdMinted,receipt:t}};if(await this.isLegacyNFTContract()){const t=await this.mapLegacyPayloadToContractStruct(e),s=t.price;return await(0,w.s)(this.contractWrapper,s,e.currencyAddress,a),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:a,parse:n})}{const t=await this.mapPayloadToContractStruct(e),s=t.pricePerToken.mul(t.quantity);return await(0,w.s)(this.contractWrapper,s,e.currencyAddress,a),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:a,parse:n})}}));mintBatch=(0,u.c)((async t=>{const e=await this.isLegacyNFTContract(),r=(await Promise.all(t.map((t=>e?this.mapLegacyPayloadToContractStruct(t.payload):this.mapPayloadToContractStruct(t.payload))))).map(((e,r)=>{const a=t[r],s=a.signature,i=a.payload.price;if(n.O$.from(i).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:s}})),a=new y.C(this.contractWrapper),s=r.map((t=>a.encode("mintWithSignature",[t.message,t.signature])));if((0,d.h)("multicall",this.contractWrapper))return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:t=>{const e=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===e.length)throw new Error("No MintWithSignature event found");return e.map((e=>({id:e.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not available on this contract!")}));async verify(t){const e=await this.isLegacyNFTContract(),r=t.payload,a=t.signature;let n,s;return e?(n=await this.mapLegacyPayloadToContractStruct(r),s=await this.contractWrapper.read("verify",[n,a])):(n=await this.mapPayloadToContractStruct(r),s=await this.contractWrapper.read("verify",[n,a])),s[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const e=await this.isLegacyNFTContract(),r=await Promise.all(t.map((t=>v.q.parseAsync(t)))),a=r.map((t=>t.metadata)),n=await(0,l.u)(a,this.storage),s=await this.contractWrapper.getChainID(),i=this.contractWrapper.getSigner();return(0,W.Z)(i,"No signer available"),await Promise.all(r.map((async(t,r)=>{const a=n[r],o=await v.r.parseAsync({...t,uri:a});let c;return c=e?await this.contractWrapper.signTypedData(i,{name:"TokenERC721",version:"1",chainId:s,verifyingContract:this.contractWrapper.address},{MintRequest:v.s},await this.mapLegacyPayloadToContractStruct(o)):await this.contractWrapper.signTypedData(i,{name:"SignatureMintERC721",version:"1",chainId:s,verifyingContract:await this.contractWrapper.address},{MintRequest:v.u},await this.mapPayloadToContractStruct(o)),{payload:o,signature:c.toString()}})))}async mapPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:e,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const e=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:e,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return(0,d.d)(this.contractWrapper,"ERC721SignatureMintV1")}}class z{featureName=p.d0.name;get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,r]=await Promise.all([this.ownerOf(t).catch((()=>s.d)),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...l.F})))]);return{owner:e,metadata:r,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await(0,p.aP)(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,e){const[r,a]=await Promise.all([(0,p.aP)(t),(0,p.aP)(e)]);return await this.contractWrapper.read("isApprovedForAll",[r,a])}transfer=(0,u.c)((async(t,e)=>{const[r,a]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,p.aP)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[r,a,e]})}));transferFrom=(0,u.c)((async(t,e,r)=>{const[a,n]=await Promise.all([(0,p.aP)(t),(0,p.aP)(e)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[a,n,r]})}));setApprovalForAll=(0,u.c)((async(t,e)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await(0,p.aP)(t),e]})));setApprovalForToken=(0,u.c)((async(t,e)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await(0,p.aP)(t),e]})));async getAll(t){return(0,h.a)(this.query,p.cU).all(t)}async getAllOwners(){return(0,h.a)(this.query,p.cU).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return(0,h.a)(this.query,p.cU).totalCirculatingSupply()}async getOwned(t,e){if(t&&(t=await(0,p.aP)(t)),this.query?.owned)return this.query.owned.all(t,e);{const[r,a]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);let n=(a||[]).filter((t=>r?.toLowerCase()===t.owner?.toLowerCase()));if(e){const t=e?.start||0,r=e?.count||l.D;n=n.slice(t,t+r)}return await Promise.all(n.map((async t=>this.get(t.tokenId))))}}async getOwnedTokenIds(t){if(t&&(t=await(0,p.aP)(t)),this.query?.owned)return this.query.owned.tokenIds(t);{const[e,r]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(r||[]).filter((t=>e?.toLowerCase()===t.owner?.toLowerCase())).map((t=>n.O$.from(t.tokenId)))}}mint=(0,u.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,u.c)((async(t,e)=>(0,h.a)(this.mintable,p.cR).to.prepare(t,e)));async getMintTransaction(t,e){return this.mintTo.prepare(t,e)}mintBatch=(0,u.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=(0,u.c)((async(t,e)=>(0,h.a)(this.mintable?.batch,p.cM).to.prepare(t,e)));burn=(0,u.c)((async t=>(0,h.a)(this.burnable,p.cW).token.prepare(t)));cancel=(0,u.c)((async t=>(0,h.a)(this.loyaltyCard,p.cY).cancel.prepare(t)));revoke=(0,u.c)((async t=>(0,h.a)(this.loyaltyCard,p.cY).revoke.prepare(t)));lazyMint=(0,u.c)((async(t,e)=>(0,h.a)(this.lazyMintable,p.cP).lazyMint.prepare(t,e)));update=(0,u.c)((async(t,e)=>(0,h.a)(this.updatableMetadata,p.cZ).update.prepare(t,e)));claim=(0,u.c)((async(t,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,e)));claimTo=(0,u.c)((async(t,e,r)=>{const a=this.claimWithConditions,n=this.claimCustom,s=this.claimZora;if(a)return a.to.prepare(t,e,r);if(n)return n.to.prepare(t,e,r);if(s)return s.to.prepare(t,e,r);throw new p.x(p.cO)}));async getClaimTransaction(t,e,r){const a=this.claimWithConditions,n=this.claimCustom;if(a)return a.conditions.getClaimTransaction(t,e,r);if(n)return n.getClaimTransaction(t,e,r);throw new p.x(p.cO)}async totalClaimedSupply(){const t=this.contractWrapper;if((0,d.h)("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if((0,d.h)("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,e]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(e)}get claimConditions(){return(0,h.a)(this.claimWithConditions,p.cN).conditions}get tieredDrop(){return(0,h.a)(this.tieredDropable,p.cV)}get signature(){return(0,h.a)(this.signatureMintable,p.c$)}get revealer(){return(0,h.a)(this.lazyMintable?.revealer,p.cQ)}get sharedMetadata(){return(0,h.a)(this.erc721SharedMetadata,p.c_)}async getTokenMetadata(t){const e=await this.contractWrapper.read("tokenURI",[t]);if(!e)throw new p.n;return(0,l.f)(t,e,this.storage)}async nextTokenIdToMint(){if((0,d.h)("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return(0,d.h)("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}if((0,d.h)("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if((0,d.d)(this.contractWrapper,"ERC721Supply")||(0,d.h)("nextTokenIdToMint",this.contractWrapper))return new E(this,this.contractWrapper)}detectErc721Mintable(){if((0,d.d)(this.contractWrapper,"ERC721Mintable"))return new I(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if((0,d.d)(this.contractWrapper,"ERC721Burnable"))return new B(this.contractWrapper)}detectErc721LazyMintable(){if((0,d.d)(this.contractWrapper,"ERC721LazyMintable"))return new k(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if((0,d.d)(this.contractWrapper,"ERC721TieredDrop"))return new R(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if((0,d.d)(this.contractWrapper,"ERC721SignatureMintV1")||(0,d.d)(this.contractWrapper,"ERC721SignatureMintV2"))return new U(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if((0,d.d)(this.contractWrapper,"ERC721ClaimConditionsV1")||(0,d.d)(this.contractWrapper,"ERC721ClaimConditionsV2")||(0,d.d)(this.contractWrapper,"ERC721ClaimPhasesV1")||(0,d.d)(this.contractWrapper,"ERC721ClaimPhasesV2"))return new P(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if((0,d.d)(this.contractWrapper,"ERC721ClaimCustom"))return new S(this,this.contractWrapper)}detectErc721ClaimableZora(){if((0,d.d)(this.contractWrapper,"ERC721ClaimZora"))return new O(this,this.contractWrapper)}detectErc721SharedMetadata(){if((0,d.d)(this.contractWrapper,"ERC721SharedMetadata"))return new F(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if((0,d.d)(this.contractWrapper,"ERC721LoyaltyCard"))return new L(this.contractWrapper)}detectErc721UpdatableMetadata(){if((0,d.d)(this.contractWrapper,"ERC721UpdatableMetadata"))return new D(this.contractWrapper,this.storage)}}},26655:(t,e,r)=>{"use strict";r.d(e,{S:()=>i});var a=r(7860),n=r(19578),s=r(15039);class i{get chainId(){return this._chainId}constructor(t,e,r){this.contractWrapper=t,this.storage=e,this.erc721=new s.h(this.contractWrapper,this.storage,r),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async getAll(t){return this.erc721.getAll(t)}async getOwned(t,e){return t&&(t=await(0,a.aP)(t)),this.erc721.getOwned(t,e)}async getOwnedTokenIds(t){return t&&(t=await(0,a.aP)(t)),this.erc721.getOwnedTokenIds(t)}async totalSupply(){return this.erc721.totalCirculatingSupply()}async get(t){return this.erc721.get(t)}async ownerOf(t){return this.erc721.ownerOf(t)}async balanceOf(t){return this.erc721.balanceOf(t)}async balance(){return this.erc721.balance()}async isApproved(t,e){return this.erc721.isApproved(t,e)}transfer=(0,n.c)((async(t,e)=>this.erc721.transfer.prepare(t,e)));setApprovalForAll=(0,n.c)((async(t,e)=>this.erc721.setApprovalForAll.prepare(t,e)));setApprovalForToken=(0,n.c)((async(t,e)=>n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await(0,a.aP)(t),e]})))}},96325:(t,e,r)=>{"use strict";r.r(e),r.d(e,{NFTCollection:()=>f});var a=r(9279),n=r(7860),s=r(19578),i=r(89536),o=r(68828),c=r(52153),l=r(83833),p=r(5995),h=r(74935),d=r(82714),u=r(26655),m=r(15039);r(13550),r(77191),r(54146),r(64063);class f extends u.S{static contractRoles=n.dz;constructor(t,e,r){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0,u=arguments.length>5?arguments[5]:void 0;super(arguments.length>6&&void 0!==arguments[6]?arguments[6]:new n.cu(t,e,s,a,r),r,u),this.abi=n.bn.parse(s||[]),this.metadata=new i.C(this.contractWrapper,n.ch,this.storage),this.app=new i.b(this.contractWrapper,this.metadata,this.storage),this.roles=new h.C(this.contractWrapper,f.contractRoles),this.royalties=new l.C(this.contractWrapper,this.metadata),this.sales=new d.C(this.contractWrapper),this.encoder=new o.C(this.contractWrapper),this.estimator=new i.G(this.contractWrapper),this.events=new i.a(this.contractWrapper),this.platformFees=new p.C(this.contractWrapper),this.interceptor=new c.C(this.contractWrapper),this.signature=new m.i(this.contractWrapper,this.storage),this.owner=new l.a(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async isTransferRestricted(){return!await this.contractWrapper.read("hasRole",[(0,n.H)("transfer"),a.d])}mint=(0,s.c)((async t=>this.erc721.mint.prepare(t)));mintTo=(0,s.c)((async(t,e)=>this.erc721.mintTo.prepare(t,e)));async getMintTransaction(t,e){return this.erc721.getMintTransaction(t,e)}mintBatch=(0,s.c)((async t=>this.erc721.mintBatch.prepare(t)));mintBatchTo=(0,s.c)((async(t,e)=>this.erc721.mintBatchTo.prepare(t,e)));burn=(0,s.c)((t=>this.erc721.burn.prepare(t)));async prepare(t,e,r){return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:e,overrides:r})}async call(t,e,r){return this.contractWrapper.call(t,e,r)}}},41518:(t,e,r)=>{"use strict";r.d(e,{B:()=>c,C:()=>h,N:()=>p,a:()=>l,s:()=>d});var a=r(7860),n=r(1604),s=r(68828);const i=(()=>n.z.object({}).catchall(n.z.union([a.cA,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(i),i]).optional().nullable())(),c=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cB.nullable().optional(),animation_url:a.cB.optional().nullable()}))(),l=(()=>c.extend({external_url:a.cB.nullable().optional(),background_color:a.cC.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cA,n.z.unknown()])))(),p=(()=>n.z.union([l,n.z.string()]))(),h=(()=>l.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function d(t,e,n,i){if(!(0,s.i)(n)){const s=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,o=t.getSigner(),c=t.getProvider(),l=new a.cu(o||c,n,s,t.options,t.storage),p=await t.getSignerAddress(),h=t.address;return(await l.read("allowance",[p,h])).lt(e)&&await l.sendTransaction("approve",[h,e]),i}i.value=e}},58179:(t,e,r)=>{"use strict";r.d(e,{A:()=>M,B:()=>X,C:()=>G,D:()=>V,E:()=>I,F:()=>A,H:()=>Y,I:()=>Q,M:()=>ct,S:()=>K,a:()=>L,f:()=>R,k:()=>tt,o:()=>nt,p:()=>st,q:()=>it,r:()=>ot,s:()=>lt,t:()=>pt,u:()=>ht,v:()=>J,w:()=>B,x:()=>O,y:()=>x,z:()=>D});var a=r(21046),n=r(61744),s=r(31886),i=r(9279),o=r(38197),c=r(2593),l=r(16441),p=r(29251),h=r(7860),d=r(68828),u=r(19824),m=r(48764),f=r(56351),y=r.n(f),g=r(99269);class w{print(){w.print(this)}bufferIndexOf(t,e){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(t,e,m.Buffer.compare);return this.linearSearch(t,e,((t,e)=>t.equals(e)))}static binarySearch(t,e,r){let a=0,n=t.length-1;for(;a<=n;){const s=Math.floor((a+n)/2),i=r(t[s],e);if(0===i){for(let a=s-1;a>=0;a--)if(0!==r(t[a],e))return a+1;return 0}i<0?a=s+1:n=s-1}return-1}binarySearch(t,e,r){return w.binarySearch(t,e,r)}static linearSearch(t,e,r){for(let a=0;a<t.length;a++)if(r(t[a],e))return a;return-1}linearSearch(t,e,r){return w.linearSearch(t,e,r)}static bufferify(t){if(!m.Buffer.isBuffer(t)){if("object"==typeof t&&t.words)return m.Buffer.from(t.toString(C),"hex");if(w.isHexString(t))return m.Buffer.from(t.replace(/^0x/,""),"hex");if("string"==typeof t)return m.Buffer.from(t);if("bigint"==typeof t)return m.Buffer.from(t.toString(16),"hex");if(t instanceof Uint8Array)return m.Buffer.from(t.buffer);if("number"==typeof t){let e=t.toString();return e.length%2&&(e=`0${e}`),m.Buffer.from(e,"hex")}if(ArrayBuffer.isView(t))return m.Buffer.from(t.buffer,t.byteOffset,t.byteLength)}return t}bigNumberify(t){return w.bigNumberify(t)}static bigNumberify(t){if("bigint"==typeof t)return t;if("string"==typeof t)return t.startsWith("0x")&&w.isHexString(t)?BigInt("0x"+t.replace("0x","").toString()):BigInt(t);if(m.Buffer.isBuffer(t))return BigInt("0x"+t.toString("hex"));if(t instanceof Uint8Array)return function(t){const e=Array.from(t).map((t=>t.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${e}`)}(t);if("number"==typeof t)return BigInt(t);throw new Error("cannot bigNumberify")}static isHexString(t){return"string"==typeof t&&/^(0x)?[0-9A-Fa-f]*$/.test(t)}static print(t){console.log(t.toString())}bufferToHex(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(t,e)}static bufferToHex(t){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(t||m.Buffer.alloc(0)).toString("hex")}`}bufferify(t){return w.bufferify(t)}bufferifyFn(t){return e=>{const r=t(e);if(m.Buffer.isBuffer(r))return r;if(this.isHexString(r))return m.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return m.Buffer.from(r);if("bigint"==typeof r)return m.Buffer.from(e.toString(16),"hex");if(ArrayBuffer.isView(r))return m.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(t){const e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=parseInt(t.substring(r,r+2),16);return e.buffer}(e.toString("hex")),n=function(t){const e=new Uint8Array(t);return Array.from(e).map((t=>t.toString(16).padStart(2,"0"))).join("")}(t(a));return m.Buffer.from(n,"hex")}}isHexString(t){return w.isHexString(t)}log2(t){return 1===t?0:1+this.log2(t/2|0)}zip(t,e){return t.map(((t,r)=>[t,e[r]]))}static hexZeroPad(t,e){return"0x"+t.replace("0x","").padStart(e,"0")}}var W=w;function C(t){const e=t.words,r=new ArrayBuffer(4*e.length),a=new Uint8Array(r);for(let t=0;t<e.length;t++)a[4*t]=e[t]>>24&255,a[4*t+1]=e[t]>>16&255,a[4*t+2]=e[t]>>8&255,a[4*t+3]=255&e[t];return r}class b extends W{duplicateOdd=!1;concatenator=m.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!m.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(t,e)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(e),this.processLeaves(t)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(t){if(this.hashLeaves&&(t=t.map(this.hashFn)),this.leaves=t.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(m.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(t){for(this.layers=[t];t.length>1;){const e=this.layers.length;this.layers.push([]);const r=this.complete&&1===e&&!Number.isInteger(Math.log2(t.length))?2*t.length-2**Math.ceil(Math.log2(t.length)):t.length;for(let a=0;a<t.length;a+=2){if(a>=r){this.layers[e].push(...t.slice(r));break}if(a+1===t.length&&t.length%2==1){const r=t[t.length-1];let n=r;if(this.isBitcoinTree){n=this.hashFn(this.concatenator([y()(r),y()(r)])),n=y()(this.hashFn(n)),this.layers[e].push(n);continue}if(!this.duplicateOdd){this.layers[e].push(t[a]);continue}}const n=t[a],s=a+1===t.length?n:t[a+1];let i=null;i=this.isBitcoinTree?[y()(n),y()(s)]:[n,s],this.sortPairs&&i.sort(m.Buffer.compare);let o=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(o=y()(this.hashFn(o))),this.layers[e].push(o)}t=this.layers[e]}}addLeaf(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=this.hashFn(t)),this.processLeaves(this.leaves.concat(t))}addLeaves(t){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(t=t.map(this.hashFn)),this.processLeaves(this.leaves.concat(t))}getLeaves(t){return Array.isArray(t)?(this.hashLeaves&&(t=t.map(this.hashFn),this.sortLeaves&&(t=t.sort(m.Buffer.compare))),this.leaves.filter((e=>-1!==this.bufferIndexOf(t,e,this.sortLeaves)))):this.leaves}getLeaf(t){return t<0||t>this.leaves.length-1?m.Buffer.from([]):this.leaves[t]}getLeafIndex(t){t=this.bufferify(t);const e=this.getLeaves();for(let r=0;r<e.length;r++){if(e[r].equals(t))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((t=>this.bufferToHex(t)))}static marshalLeaves(t){return JSON.stringify(t.map((t=>b.bufferToHex(t))),null,2)}static unmarshalLeaves(t){let e=null;if("string"==typeof t)e=JSON.parse(t);else{if(!(t instanceof Object))throw new Error("Expected type of string or object");e=t}if(!e)return[];if(!Array.isArray(e))throw new Error("Expected JSON string to be array");return e.map(b.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((t,e)=>(Array.isArray(e)?t.push(e.map((t=>this.bufferToHex(t)))):t.push(e),t)),[])}getLayersFlat(){const t=this.layers.reduce(((t,e)=>(Array.isArray(e)?t.unshift(...e):t.unshift(e),t)),[]);return t.unshift(m.Buffer.from([0])),t}getHexLayersFlat(){return this.getLayersFlat().map((t=>this.bufferToHex(t)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?m.Buffer.from([]):this.layers[this.layers.length-1][0]||m.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(t,e){if(void 0===t)throw new Error("leaf is required");t=this.bufferify(t);const r=[];if(!Number.isInteger(e)){e=-1;for(let r=0;r<this.leaves.length;r++)0===m.Buffer.compare(t,this.leaves[r])&&(e=r)}if(e<=-1)return[];for(let t=0;t<this.layers.length;t++){const a=this.layers[t],n=e%2,s=n?e-1:this.isBitcoinTree&&e===a.length-1&&t<this.layers.length-1?e:e+1;s<a.length&&r.push({position:n?"left":"right",data:a[s]}),e=e/2|0}return r}getHexProof(t,e){return this.getProof(t,e).map((t=>this.bufferToHex(t.data)))}getProofs(){const t=[];return this.getProofsDFS(this.layers.length-1,0,[],t),t}getProofsDFS(t,e,r,a){const n=e%2;if(-1===t)return void(n||a.push([...r].reverse()));if(e>=this.layers[t].length)return;const s=this.layers[t],i=n?e-1:e+1;let o=!1;i<s.length&&(o=!0,r.push({position:n?"left":"right",data:s[i]}));const c=2*e,l=2*e+1;this.getProofsDFS(t-1,c,r,a),this.getProofsDFS(t-1,l,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((t=>this.bufferToHex(t.data)))}getPositionalHexProof(t,e){return this.getProof(t,e).map((t=>["left"===t.position?0:1,this.bufferToHex(t.data)]))}getProofIndices(t,e){const r=2**e;let a=new Set;for(const e of t){let t=r+e;for(;t>1;)a.add(1^t),t=t/2|0}const n=t.map((t=>r+t)),s=Array.from(a).sort(((t,e)=>t-e)).reverse();a=n.concat(s);const i=new Set,o=[];for(let t of a)if(!i.has(t))for(o.push(t);t>1&&(i.add(t),i.has(1^t));)t=t/2|0;return o.filter((e=>!t.includes(e-r)))}getProofIndicesForUnevenTree(t,e){const r=Math.ceil(Math.log2(e)),a=[];for(let t=0;t<r;t++){e%2!=0&&a.push({index:t,leavesCount:e}),e=Math.ceil(e/2)}const n=[];let s=t;for(let t=0;t<r;t++){let e=s.map((t=>t%2==0?t+1:t-1)).filter((t=>!s.includes(t)));const r=a.find((e=>{let{index:r}=e;return r===t}));r&&s.includes(r.leavesCount-1)&&(e=e.slice(0,-1)),n.push(e),s=[...new Set(s.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))]}return n}getMultiProof(t,e){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),e||(e=t,t=this.getLayersFlat());if(this.isUnevenTree()&&e.every(Number.isInteger))return this.getMultiProofForUnevenTree(e);if(!e.every(Number.isInteger)){let t=e;this.sortPairs&&(t=t.sort(m.Buffer.compare));let r=t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1));if(!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=[],n=[];let s=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],o=this.getPairNode(e,i);a.push(e[i]),o&&n.push(o),s.push(i/2|0)}r=s.filter(((t,e,r)=>r.indexOf(t)===e)),s=[]}return n.filter((t=>!a.includes(t)))}return this.getProofIndices(e,Math.log2(t.length/2|0)).map((e=>t[e]))}getMultiProofForUnevenTree(t,e){e||(e=t,t=this.getLayers());let r=[],a=e;for(const e of t){const t=[];for(const r of a){if(r%2==0){const n=r+1;if(!a.includes(n)&&e[n]){t.push(e[n]);continue}}const n=r-1;a.includes(n)||!e[n]||t.push(e[n])}r=r.concat(t);const n=new Set;for(const t of a)t%2!=0?t%2!=0?n.add((t-1)/2):n.add((t+1)/2):n.add(t/2);a=Array.from(n)}return r}getHexMultiProof(t,e){return this.getMultiProof(t,e).map((t=>this.bufferToHex(t)))}getProofFlags(t,e){if(!Array.isArray(t)||t.length<=0)throw new Error("Invalid Inputs!");let r;if(r=t.every(Number.isInteger)?[...t].sort(((t,e)=>t===e?0:t>e?1:-1)):t.map((t=>this.bufferIndexOf(this.leaves,t,this.sortLeaves))).sort(((t,e)=>t===e?0:t>e?1:-1)),!r.every((t=>-1!==t)))throw new Error("Element does not exist in Merkle tree");const a=e.map((t=>this.bufferify(t))),n=[],s=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];r=r.reduce(((t,r)=>{if(!n.includes(e[r])){const t=this.getPairNode(e,r),i=a.includes(e[r])||a.includes(t);t&&s.push(!i),n.push(e[r]),n.push(t)}return t.push(r/2|0),t}),[])}return s}verify(t,e,r){let a=this.bufferify(e);if(r=this.bufferify(r),!Array.isArray(t)||!e||!r)return!1;for(let e=0;e<t.length;e++){const r=t[e];let n=null,s=null;if("string"==typeof r)n=this.bufferify(r),s=!0;else if(Array.isArray(r))s=0===r[0],n=this.bufferify(r[1]);else if(m.Buffer.isBuffer(r))n=r,s=!0;else{if(!(r instanceof Object))throw new Error("Expected node to be of type string or object");n=this.bufferify(r.data),s="left"===r.position}const i=[];this.isBitcoinTree?(i.push(y()(a)),i[s?"unshift":"push"](y()(n)),a=this.hashFn(this.concatenator(i)),a=y()(this.hashFn(a))):this.sortPairs?-1===m.Buffer.compare(a,n)?(i.push(a,n),a=this.hashFn(this.concatenator(i))):(i.push(n,a),a=this.hashFn(this.concatenator(i))):(i.push(a),i[s?"unshift":"push"](n),a=this.hashFn(this.concatenator(i)))}return 0===m.Buffer.compare(a,r)}verifyMultiProof(t,e,r,a,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(t,e,r,a,n);const s=Math.ceil(Math.log2(a));t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const i={};for(const[t,a]of this.zip(e,r))i[2**s+t]=a;for(const[t,r]of this.zip(this.getProofIndices(e,s),n))i[t]=r;let o=Object.keys(i).map((t=>Number(t))).sort(((t,e)=>t-e));o=o.slice(0,o.length-1);let c=0;for(;c<o.length;){const t=o[c];if(t>=2&&{}.hasOwnProperty.call(i,1^t)){let e=[i[t-t%2],i[t-t%2+1]];this.sortPairs&&(e=e.sort(m.Buffer.compare));const r=e[1]?this.hashFn(this.concatenator(e)):e[0];i[t/2|0]=r,o.push(t/2|0)}c+=1}return!e.length||{}.hasOwnProperty.call(i,1)&&i[1].equals(t)}verifyMultiProofWithFlags(t,e,r,a){t=this.bufferify(t),e=e.map(this.bufferify),r=r.map(this.bufferify);const n=e.length,s=a.length,i=[];let o=0,c=0,l=0;for(let t=0;t<s;t++){const s=[a[t]?o<n?e[o++]:i[c++]:r[l++],o<n?e[o++]:i[c++]].sort(m.Buffer.compare);i[t]=this.hashFn(this.concatenator(s))}return 0===m.Buffer.compare(i[s-1],t)}verifyMultiProofForUnevenTree(t,e,r,a,n){t=this.bufferify(t),r=r.map((t=>this.bufferify(t))),n=n.map((t=>this.bufferify(t)));const s=this.calculateRootForUnevenTree(e,r,a,n);return t.equals(s)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const t=this.getLayers().map((t=>t.map((t=>this.bufferToHex(t,!1))))),e=[];for(let r=0;r<t.length;r++){const a=[];for(let n=0;n<t[r].length;n++){const s={[t[r][n]]:null};if(e.length){s[t[r][n]]={};const a=e.shift(),i=Object.keys(a)[0];if(s[t[r][n]][i]=a[i],e.length){const a=e.shift(),i=Object.keys(a)[0];s[t[r][n]][i]=a[i]}}a.push(s)}e.push(...a)}return e[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(t,e){const r=e%2==0?e+1:e-1;return r<t.length?t[r]:null}toTreeString(){const t=this.getLayersAsObject();return(0,g.asTree)(t,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(t){const e=t?.length||this.getDepth();return!this.isPowOf2(e)}isPowOf2(t){return t&&!(t&t-1)}calculateRootForUnevenTree(t,e,r,a){const n=this.zip(t,e).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})),s=n.map((t=>{let[e]=t;return e})),i=this.getProofIndicesForUnevenTree(s,r);let o=0;const c=[];for(let t=0;t<i.length;t++){const e=i[t],r=o;o+=e.length,c[t]=this.zip(e,a.slice(r,o))}const l=[n];for(let t=0;t<c.length;t++){const e=c[t].concat(l[t]).sort(((t,e)=>{let[r]=t,[a]=e;return r-a})).map((t=>{let[,e]=t;return e})),r=l[t].map((t=>{let[e]=t;return e})),a=[...new Set(r.map((t=>t%2==0?t/2:t%2==0?(t+1)/2:(t-1)/2)))],n=[];for(let t=0;t<a.length;t++){const r=a[t],s=e[2*t],i=e[2*t+1],o=i?this.hashFn(this.concatenator([s,i])):s;n.push([r,o])}l.push(n)}return l[l.length-1][0][1]}}var v=r(89208),T=r(1604),P=r(41518),S=r(57632),k=r(48764).Buffer;function I(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerTransaction:t.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims||0}}function A(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot,pricePerToken:t.pricePerToken,currency:t.currency,quantityLimitPerWallet:t.maxClaimablePerWallet,metadata:t.metadata||""}}function x(t,e){return"unlimited"===t?a.Bz:n.parseUnits(t,e)}async function E(t){const e=25e3,r=Array.from({length:Math.ceil(t.length/e)},((r,a)=>t.slice(a*e,a*e+e))),a=[],n=await Promise.all(r.map((t=>h.bO.parseAsync(t))));for(const t of n)a.push(...t);return a}let M=function(t){return t[t.V1=1]="V1",t[t.V2=2]="V2",t}({});class N{constructor(t,e,r,a,n){this.storage=t,this.shardNybbles=a,this.baseUri=e,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(t,e){try{const r=await e.downloadJSON(t);if(r.isShardedMerkleTree)return N.fromShardedMerkleTreeInfo(r,e)}catch(t){return}}static async fromShardedMerkleTreeInfo(t,e){return new N(e,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,e,r,a){switch(a){case M.V1:return s.keccak256(["address","uint256"],[t.address,x(t.maxClaimable,e)]);case M.V2:return s.keccak256(["address","uint256","uint256","address"],[t.address,x(t.maxClaimable,e),x(t.price||"unlimited",r),t.currencyAddress||i.d])}}static async fetchAndCacheDecimals(t,e,r){if(!r)return 18;let a=t[r];if(void 0===a){a=(await(0,d.f)(e,r)).decimals,t[r]=a}return a}static async buildAndUpload(t,e,r,a,n){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const i=await E(t),c={};for(const t of i){const e=t.address.slice(2,2+s).toLowerCase();void 0===c[e]&&(c[e]=[]),c[e].push(t)}const l={},p=await Promise.all(Object.entries(c).map((async t=>{let[a,s]=t;return[a,new b(await Promise.all(s.map((async t=>{const a=await N.fetchAndCacheDecimals(l,r,t.currencyAddress);return N.hashEntry(t,e,a,n)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),h=Object.fromEntries(p),d=new b(Object.values(h),o.keccak256,{sort:!0}),u=[];for(const[t,e]of Object.entries(c)){const r={proofs:d.getProof(h[t]).map((t=>"0x"+t.data.toString("hex"))),entries:e};u.push({data:JSON.stringify(r),name:`${t}.json`})}const m=await a.uploadBatch(u),f=m[0].slice(0,m[0].lastIndexOf("/")),y=await a.upload(i),g={merkleRoot:d.getHexRoot(),baseUri:f,originalEntriesUri:y,shardNybbles:s,tokenDecimals:e,isShardedMerkleTree:!0};return{shardedMerkleInfo:g,uri:await a.upload(g)}}async getProof(t,e,r){const a=t.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[a];const s={};if(void 0===n)try{const t=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;n=this.shards[a]=await this.storage.downloadJSON(`${t}${a}.json`);const i=await Promise.all(n.entries.map((async t=>{const a=await N.fetchAndCacheDecimals(s,e,t.currencyAddress);return N.hashEntry(t,this.tokenDecimals,a,r)})));this.trees[a]=new b(i,o.keccak256,{sort:!0})}catch(t){return null}const i=n.entries.find((e=>e.address.toLowerCase()===t.toLowerCase()));if(!i)return null;const c=await N.fetchAndCacheDecimals(s,e,i.currencyAddress),l=N.hashEntry(i,this.tokenDecimals,c,r),p=this.trees[a].getProof(l).map((t=>"0x"+t.data.toString("hex")));return h.bP.parseAsync({...i,proof:p.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function R(t,e,r,a,n,s){if(!r)return null;const i=r[e];if(i){const r=await n.downloadJSON(i);if(r.isShardedMerkleTree&&r.merkleRoot===e){const e=await N.fromShardedMerkleTreeInfo(r,n);return await e.getProof(t,a,s)}const o=await h.bQ.parseAsync(r);if(e===o.merkleRoot)return o.claims.find((e=>e.address.toLowerCase()===t.toLowerCase()))||null}return null}function B(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:t.waitTimeInSecondsBetweenClaims}}function O(t){return{startTimestamp:t.startTimestamp,maxClaimableSupply:t.maxClaimableSupply,supplyClaimed:t.supplyClaimed,merkleRoot:t.merkleRoot.toString(),pricePerToken:t.pricePerToken,currency:t.currency,maxClaimablePerWallet:t.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:t.metadata}}async function L(t,e,a,s,i){const o=t.getSigner(),l=t.getProvider(),p=(await Promise.resolve().then(r.t.bind(r,49242,19))).default,d=new h.cu(o||l,e,p,t.options,t.storage),u=await t.getSignerAddress(),m=t.address,f=await d.read("allowance",[u,m]),y=c.O$.from(a).mul(c.O$.from(s)).div(n.parseUnits("1",i));f.lt(y)&&await d.sendTransaction("approve",[m,f.add(y)])}async function D(t,e,r,s,o,p,h,m,f){let y=x(r.maxClaimablePerWallet,o),g=[l.hexZeroPad([0],32)],w=r.price,W=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(i.d)){const e=await R(t,r.merkleRootHash.toString(),await s(),p.getProvider(),h,f);if(e)g=e.proof,y="unlimited"===e.maxClaimable?a.Bz:n.parseUnits(e.maxClaimable,o),w=void 0===e.price||"unlimited"===e.price?a.Bz:await(0,u.n)(p.getProvider(),e.price,e.currencyAddress||i.d),W=e.currencyAddress||i.d;else if(f===M.V1)throw new Error("No claim found for this address")}}catch(t){if("No claim found for this address"===t?.message)throw t;console.warn("failed to check claim condition merkle root hash, continuing anyways",t)}const C=await p.getCallOverrides()||{},b=w.toString()!==a.Bz.toString()?w:r.price,v=W!==i.d?W:r.currencyAddress;return b.gt(0)&&((0,d.i)(v)?C.value=c.O$.from(b).mul(e).div(n.parseUnits("1",o)):m&&await L(p,v,b,e,o)),{overrides:C,proofs:g,maxClaimable:y,price:b,currencyAddress:v,priceInProof:w,currencyAddressInProof:W}}const F=(()=>T.z.object({name:T.z.string(),symbol:T.z.string(),decimals:T.z.number()}))(),U=(()=>F.extend({value:h.b9,displayValue:T.z.string()}))(),z=(()=>T.z.object({name:T.z.string().optional()}).catchall(T.z.unknown()))(),H=(()=>T.z.object({startTime:v.S,currencyAddress:T.z.string().default(h.aZ),price:h.cz.default(0),maxClaimableSupply:h.cD,maxClaimablePerWallet:h.cD,waitInSeconds:h.ba.default(0),merkleRootHash:h.cE.default(l.hexZeroPad([0],32)),snapshot:T.z.optional(h.bO).nullable(),metadata:z.optional()}))(),$=(()=>T.z.array(H))(),q=(()=>H.extend({availableSupply:h.cD,currentMintSupply:h.cD,currencyMetadata:U.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h.b9,waitInSeconds:h.b9,startTime:h.b9.transform((t=>new Date(1e3*t.toNumber()))),snapshot:h.bO.optional().nullable()}))();async function _(t,e,r,a,n){const s=[],i=await Promise.all(t.map((async t=>{if(t.snapshot&&t.snapshot.length>0){const i=await async function(t,e,r,a,n){const s=await E(t),i=s.map((t=>t.address));if(new Set(i).size<i.length)throw new h.s;const o=await N.buildAndUpload(s,e,r,a,n);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(t.snapshot,e,r,a,n);s.push(i),t.merkleRootHash=i.merkleRoot}else t.merkleRootHash=l.hexZeroPad([0],32);return t})));return{inputsWithSnapshots:i,snapshotInfos:s}}async function V(t,e,r,a,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await _(t,e,r,a,n),l=await $.parseAsync(s),p=(await Promise.all(l.map((t=>async function(t,e,r,a){const n=t.currencyAddress===i.d?h.aZ:t.currencyAddress,s=x(t.maxClaimableSupply,e),o=x(t.maxClaimablePerWallet,e);let c;return t.metadata&&(c="string"==typeof t.metadata?t.metadata:await a.upload(t.metadata)),{startTimestamp:t.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,u.n)(r,t.price,n),currency:n,merkleRoot:t.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:t.waitInSeconds||0,metadata:c}}(t,e,r,a))))).sort(((t,e)=>function(t,e){const r=c.O$.from(t),a=c.O$.from(e);return r.eq(a)?0:r.gt(a)?1:-1}(t.startTimestamp,e.startTimestamp)));return{snapshotInfos:o,sortedConditions:p}}async function j(t,e,r){if(!e)return null;const a=e[t];if(a){const e=await r.downloadJSON(a);if(e.isShardedMerkleTree&&e.merkleRoot===t){const t=await N.fromUri(a,r);return t?.getAllEntries()||null}{const r=await h.bQ.parseAsync(e);if(t===r.merkleRoot)return r.claims.map((t=>({address:t.address,maxClaimable:t.maxClaimable,price:t.price,currencyAddress:t.currencyAddress})))}}return null}function Z(t,e){return t.toString()===a.Bz.toString()?"unlimited":n.formatUnits(t,e)}async function J(t,e,r,a,n,s){const i=await(0,d.a)(r,t.currency,t.pricePerToken),o=Z(t.maxClaimableSupply,e),l=Z(t.maxClaimablePerWallet,e),p=Z(c.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed),e),h=Z(t.supplyClaimed,e);let u;return t.metadata&&(u=await n.downloadJSON(t.metadata)),q.parseAsync({startTime:t.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:l,currentMintSupply:h,availableSupply:p,waitInSeconds:t.waitTimeInSecondsBetweenClaims?.toString(),price:c.O$.from(t.pricePerToken),currency:t.currency,currencyAddress:t.currency,currencyMetadata:i,merkleRootHash:t.merkleRoot,snapshot:s?await j(t.merkleRoot,a,n):void 0,metadata:u})}async function Y(t,e,r){if(t>=r.length)throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);const a=r[t].currencyMetadata.decimals,s=r[t].price,i=n.formatUnits(s,a),o=await H.parseAsync({...r[t],price:i,...e}),c=await q.parseAsync({...o,price:s});return r.map(((e,r)=>{let s;s=r===t?c:e;const i=n.formatUnits(s.price,a);return{...s,price:i}}))}let G=function(t){return t.NotEnoughSupply="There is not enough supply to claim.",t.AddressNotAllowed="This address is not on the allowlist.",t.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",t.ClaimPhaseNotStarted="Claim phase has not started yet.",t.AlreadyClaimed="You have already claimed the token.",t.WrongPriceOrCurrency="Incorrect price or currency.",t.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",t.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",t.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",t.NoClaimConditionSet="There is no claim condition set.",t.NoWallet="No wallet connected.",t.Unknown="No claim conditions found.",t}({});function Q(t){if(void 0===t){const t=k.alloc(16);return(0,S.Z)({},t),l.hexlify(p.Y0(t.toString("hex")))}return l.hexlify(t)}const X=(()=>T.z.object({to:h.bd.refine((t=>t.toLowerCase()!==i.d),{message:"Cannot create payload to mint to zero address"}),price:h.cz.default(0),currencyAddress:h.bc.default(h.aZ),mintStartTime:v.S,mintEndTime:v.E,uid:T.z.string().optional().transform((t=>Q(t))),primarySaleRecipient:h.bd.default(i.d)}))(),K=(()=>X.extend({quantity:h.cz}))(),tt=(()=>K.extend({mintStartTime:h.b9,mintEndTime:h.b9}))(),et=(()=>X.extend({metadata:P.N,royaltyRecipient:T.z.string().default(i.d),royaltyBps:h.cF.default(0)}))(),rt=(()=>et.extend({metadata:P.N.default(""),uri:T.z.string(),royaltyBps:h.b9,mintStartTime:h.b9,mintEndTime:h.b9}))(),at=(()=>et.extend({metadata:P.N.default(""),quantity:h.ba}))(),nt=(()=>at.extend({tokenId:h.ba}))(),st=(()=>rt.extend({tokenId:h.b9,quantity:h.b9}))(),it=(()=>et.extend({metadata:P.N.default(""),quantity:h.b9.default(1)}))(),ot=(()=>rt.extend({quantity:h.b9.default(1)}))(),ct=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],pt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ht=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},56351:(t,e,r)=>{var a=r(48764).Buffer;t.exports=function(t){for(var e=new a(t.length),r=0,n=t.length-1;r<=n;++r,--n)e[r]=t[n],e[n]=t[r];return e}},99269:function(t){t.exports=function(){function t(t,e){var r=e?"└":"├";return r+=t?"─ ":"──┐"}function e(t,e){var r=[];for(var a in t)t.hasOwnProperty(a)&&(e&&"function"==typeof t[a]||r.push(a));return r}function r(a,n,s,i,o,c,l){var p,h,d="",u=0,m=i.slice(0);if(m.push([n,s])&&i.length>0&&(i.forEach((function(t,e){e>0&&(d+=(t[1]?" ":"│")+"  "),h||t[0]!==n||(h=!0)})),d+=t(a,s)+a,o&&("object"!=typeof n||n instanceof Date)&&(d+=": "+n),h&&(d+=" (circular ref.)"),l(d)),!h&&"object"==typeof n){var f=e(n,c);f.forEach((function(t){p=++u===f.length,r(t,n[t],p,m,o,c,l)}))}}var a={asLines:function(t,e,a,n){r(".",t,!1,[],e,"function"!=typeof a&&a,n||a)},asTree:function(t,e,a){var n="";return r(".",t,!1,[],e,a,(function(t){n+=t+"\n"})),n}};return a}()}}]);
//# sourceMappingURL=6325.js.map